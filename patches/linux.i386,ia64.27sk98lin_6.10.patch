diff -ruN linux/Documentation/Configure.help linuxn/Documentation/Configure.help
--- linux/Documentation/Configure.help	Fri Nov 29 00:53:08 2002
+++ linuxn/Documentation/Configure.help	Tue May 20 12:17:45 2003
@@ -10875,31 +10875,182 @@
 
   The safe and default value for this is N.
 
-SysKonnect SK-98xx support
+Marvell Yukon / SysKonnect SK-98xx and SK-95xx Gigabit Ethernet Adapter family support
 CONFIG_SK98LIN
-  Say Y here if you have a SysKonnect SK-98xx Gigabit Ethernet Server
-  Adapter. The following adapters are supported by this driver:
-  - SK-9841 (single link 1000Base-LX)
-  - SK-9842 (dual link   1000Base-LX)
-  - SK-9843 (single link 1000Base-SX)
-  - SK-9844 (dual link   1000Base-SX)
-  - SK-9821 (single link 1000Base-T)
-  - SK-9822 (dual link   1000Base-T)
-  - SK-9861 (single link Volition connector)
-  - SK-9862 (dual link   Volition connector)
-  The driver also supports the following adapters from Allied Telesyn:
-  - AT2970...
+  Say Y here if you have a Marvell Yukon or SysKonnect SK-98xx/SK-95xx
+  compliant Gigabit Ethernet Adapter. The following adapters are supported
+  by this driver:
+  - 3Com 3C940 Gigabit LOM Ethernet Adapter
+  - 3Com 3C941 Gigabit LOM Ethernet Adapter
+  - SK-9821 Gigabit Ethernet Server Adapter (SK-NET GE-T)
+  - SK-9822 Gigabit Ethernet Server Adapter (SK-NET GE-T dual link)
+  - SK-9841 Gigabit Ethernet Server Adapter (SK-NET GE-LX)
+  - SK-9842 Gigabit Ethernet Server Adapter (SK-NET GE-LX dual link)
+  - SK-9843 Gigabit Ethernet Server Adapter (SK-NET GE-SX)
+  - SK-9844 Gigabit Ethernet Server Adapter (SK-NET GE-SX dual link)
+  - SK-9861 Gigabit Ethernet Server Adapter (SK-NET GE-SX Volition)
+  - SK-9862 Gigabit Ethernet Server Adapter (SK-NET GE-SX Volition dual link)
+  - SK-9871 Gigabit Ethernet Server Adapter (SK-NET GE-ZX)
+  - SK-9872 Gigabit Ethernet Server Adapter (SK-NET GE-ZX dual link)
+  - Allied Telesyn AT-2970SX Gigabit Ethernet Adapter
+  - Allied Telesyn AT-2970LX Gigabit Ethernet Adapter
+  - Allied Telesyn AT-2970TX Gigabit Ethernet Adapter
+  - Allied Telesyn AT-2971SX Gigabit Ethernet Adapter
+  - Allied Telesyn AT-2971T Gigabit Ethernet Adapter
+  - Allied Telesyn AT-2970SX/2SC Gigabit Ethernet Adapter
+  - Allied Telesyn AT-2970LX/2SC Gigabit Ethernet Adapter
+  - Allied Telesyn AT-2970TX/2TX Gigabit Ethernet Adapter
+  - Marvell RDK-8001 Adapter
+  - Marvell RDK-8002 Adapter
+  - Marvell RDK-8003 Adapter
+  - Marvell RDK-8004 Adapter
+  - Marvell RDK-8006 Adapter
+  - Marvell RDK-8007 Adapter
+  - Marvell RDK-8008 Adapter
+  - Marvell RDK-8009 Adapter
+  - Marvell RDK-8011 Adapter
+  - Marvell RDK-8012 Adapter
+  - SK-9821 V2.0 Gigabit Ethernet 10/100/1000Base-T Adapter
+  - SK-9841 V2.0 Gigabit Ethernet 1000Base-LX Adapter
+  - SK-9843 V2.0 Gigabit Ethernet 1000Base-SX Adapter
+  - SK-9851 V2.0 Gigabit Ethernet 1000Base-SX Adapter
+  - SK-9861 V2.0 Gigabit Ethernet 1000Base-SX Adapter
+  - SK-9871 V2.0 Gigabit Ethernet 1000Base-ZX Adapter
+  - SK-9521 10/100/1000Base-T Adapter
+  - DGE-530T Gigabit Ethernet Adapter
+  - Marvell Yukon Gigabit Ethernet 10/100/1000Base-T Adapter
+  - N-Way PCI-Bus Giga-Card 1000/100/10Mbps(L)
+  - EG1032 v2 Instant Gigabit Network Adapter
+  - EG1064 v2 Instant Gigabit Network Adapter
 
-  The dual link adapters support a link-failover feature.  Read
-  <file:Documentation/networking/sk98lin.txt> for information about
+  The adapters support Jumbo Frames.
+  The dual link adapters support link-failover and dual port features.
+  Both Marvell Yukon and SysKonnect SK-98xx/SK-95xx adapters support 
+  the scatter-gather functionality with sendfile(). Please refer to 
+  Documentation/networking/sk98lin.txt for more information about
   optional driver parameters.
   Questions concerning this driver may be addressed to:
     linux@syskonnect.de
 
   If you want to compile this driver as a module ( = code which can be
   inserted in and removed from the running kernel whenever you want),
-  say M here and read <file:Documentation/modules.txt>.  This is
-  recommended.  The module will be called sk98lin.o.
+  say M here and read Documentation/modules.txt. This is recommended.
+  The module will be called sk98lin.o.
+
+Marvell Yukon Chipset
+CONFIG_SK98LIN_T1
+  This driver supports:
+
+  - 3Com 3C940 Gigabit LOM Ethernet Adapter
+  - 3Com 3C941 Gigabit LOM Ethernet Adapter
+
+  Questions concerning this driver may be addressed to:
+    linux@syskonnect.de
+
+SysKonnect SK98xx Support
+CONFIG_SK98LIN_T2
+  This driver supports:
+
+  - SK-9821 Gigabit Ethernet Server Adapter (SK-NET GE-T)
+  - SK-9822 Gigabit Ethernet Server Adapter (SK-NET GE-T dual link)
+  - SK-9841 Gigabit Ethernet Server Adapter (SK-NET GE-LX)
+  - SK-9842 Gigabit Ethernet Server Adapter (SK-NET GE-LX dual link)
+  - SK-9843 Gigabit Ethernet Server Adapter (SK-NET GE-SX)
+  - SK-9844 Gigabit Ethernet Server Adapter (SK-NET GE-SX dual link)
+  - SK-9861 Gigabit Ethernet Server Adapter (SK-NET GE-SX Volition)
+  - SK-9862 Gigabit Ethernet Server Adapter (SK-NET GE-SX Volition dual link)
+  - SK-9871 Gigabit Ethernet Server Adapter (SK-NET GE-ZX)
+  - SK-9872 Gigabit Ethernet Server Adapter (SK-NET GE-ZX dual link)
+
+  Questions concerning this driver may be addressed to:
+    linux@syskonnect.de
+
+SysKonnect SK98xx Support
+CONFIG_SK98LIN_T3
+  This driver supports:
+
+  - Allied Telesyn AT-2970SX Gigabit Ethernet Adapter
+  - Allied Telesyn AT-2970LX Gigabit Ethernet Adapter
+  - Allied Telesyn AT-2970TX Gigabit Ethernet Adapter
+  - Allied Telesyn AT-2971SX Gigabit Ethernet Adapter
+  - Allied Telesyn AT-2971T Gigabit Ethernet Adapter
+  - Allied Telesyn AT-2970SX/2SC Gigabit Ethernet Adapter
+  - Allied Telesyn AT-2970LX/2SC Gigabit Ethernet Adapter
+  - Allied Telesyn AT-2970TX/2TX Gigabit Ethernet Adapter
+
+  Questions concerning this driver may be addressed to:
+    linux@syskonnect.de
+
+Marvell Yukon Chipset
+CONFIG_SK98LIN_T4
+  This driver supports:
+
+  - Marvell RDK-8001 Adapter
+  - Marvell RDK-8002 Adapter
+  - Marvell RDK-8003 Adapter
+  - Marvell RDK-8004 Adapter
+  - Marvell RDK-8006 Adapter
+  - Marvell RDK-8007 Adapter
+  - Marvell RDK-8008 Adapter
+  - Marvell RDK-8009 Adapter
+  - Marvell RDK-8011 Adapter
+  - Marvell RDK-8012 Adapter
+
+  Questions concerning this driver may be addressed to:
+    linux@syskonnect.de
+
+Marvell Yukon Chipset
+CONFIG_SK98LIN_T5
+  This driver supports:
+
+  - SK-9821 V2.0 Gigabit Ethernet 10/100/1000Base-T Adapter
+  - SK-9841 V2.0 Gigabit Ethernet 1000Base-LX Adapter
+  - SK-9843 V2.0 Gigabit Ethernet 1000Base-SX Adapter
+  - SK-9851 V2.0 Gigabit Ethernet 1000Base-SX Adapter
+  - SK-9861 V2.0 Gigabit Ethernet 1000Base-SX Adapter
+  - SK-9871 V2.0 Gigabit Ethernet 1000Base-ZX Adapter
+  - SK-9521 10/100/1000Base-T Adapter
+
+  Questions concerning this driver may be addressed to:
+    linux@syskonnect.de
+
+Marvell Yukon Chipset
+CONFIG_SK98LIN_T6
+  This driver supports:
+
+  - DGE-530T Gigabit Ethernet Adapter
+
+  Questions concerning this driver may be addressed to:
+    linux@syskonnect.de
+
+Marvell Yukon Chipset
+CONFIG_SK98LIN_T7
+  This driver supports:
+
+  - Marvell Yukon Gigabit Ethernet 10/100/1000Base-T Adapter
+
+  Questions concerning this driver may be addressed to:
+    linux@syskonnect.de
+
+Marvell Yukon Chipset
+CONFIG_SK98LIN_T8
+  This driver supports:
+
+  - N-Way PCI-Bus Giga-Card 1000/100/10Mbps(L)
+
+  Questions concerning this driver may be addressed to:
+    linux@syskonnect.de
+
+Marvell Yukon Chipset
+CONFIG_SK98LIN_T9
+  This driver supports:
+
+  - EG1032 v2 Instant Gigabit Network Adapter
+  - EG1064 v2 Instant Gigabit Network Adapter
+
+  Questions concerning this driver may be addressed to:
+    linux@syskonnect.de
+
 
 Sun GEM support
 CONFIG_SUNGEM
diff -ruN linux/Documentation/networking/00-INDEX linuxn/Documentation/networking/00-INDEX
--- linux/Documentation/networking/00-INDEX	Fri Nov 29 00:53:08 2002
+++ linuxn/Documentation/networking/00-INDEX	Tue May 20 12:17:45 2003
@@ -97,7 +97,8 @@
 sis900.txt
 	- SiS 900/7016 Fast Ethernet device driver info.
 sk98lin.txt
-	- SysKonnect SK-NET (SK-98xx) Gigabit Ethernet driver info.
+	- Marvell Yukon Chipset / SysKonnect SK-98xx compliant Gigabit
+	  Ethernet Adapter family driver info
 skfp.txt
 	- SysKonnect FDDI (SK-5xxx, Compaq Netelligent) driver info.
 smc9.txt
diff -ruN linux/Documentation/networking/sk98lin.txt linuxn/Documentation/networking/sk98lin.txt
--- linux/Documentation/networking/sk98lin.txt	Mon Jul  2 22:56:40 2001
+++ linuxn/Documentation/networking/sk98lin.txt	Tue May 20 12:17:41 2003
@@ -1,120 +1,160 @@
-(C)Copyright 1999-2001 SysKonnect GmbH.
+(C)Copyright 1999-2003 Marvell(R).
 All rights reserved
-===========================================================================
-
-sk98lin.txt created 28-May-2001
+#HLINE
+sk98lin.txt created 21-May-2003
 
-Readme File for sk98lin v4.06
-SK-NET Gigabit Ethernet PCI driver for LINUX
+Readme File for sk98lin v6.10
+Marvell Yukon/SysKonnect SK-98xx Gigabit Ethernet Adapter family driver for LINUX
 
 This file contains
-(1) OVERVIEW
-(2) REQUIRED FILES
-(3) INSTALLATION
-(4) INCLUSION OF ADAPTER AT SYSTEM START
-(5) DRIVER PARAMETERS
-(6) LARGE FRAME SUPPORT
-(7) TROUBLESHOOTING
-(8) HISTORY
+ 1  Overview
+ 2  Required Files
+ 3  Installation
+    3.1  Driver Installation
+    3.2  Inclusion of adapter at system start
+ 4  Driver Parameters
+    4.1  Per-Port Parameters
+    4.2  Adapter Parameters
+ 5  Large Frame Support
+ 6  VLAN and Link Aggregation Support (IEEE 802.1, 802.1q, 802.3ad)
+ 7  Troubleshooting
+ 8  History
 
 ===========================================================================
 
 
-(1) OVERVIEW
-============
+1  Overview
+===========
 
-The sk98lin driver supports the SysKonnect SK-NET Gigabit Ethernet
-Adapter SK-98xx family on Linux 2.2.x and above.
-It has been tested with Linux on Intel/x86 machines.
-From v3.02 on, the driver is integrated in the linux kernel source.
+The sk98lin driver supports the Marvell Yukon and SysKonnect 
+SK-98xx/SK-95xx compliant Gigabit Ethernet Adapter on Linux. It has 
+been tested with Linux on Intel/x86 machines.
 ***
 
 
-(2) REQUIRED FILES
-==================
+2  Required Files
+=================
 
 The linux kernel source.
 No additional files required.
 ***
 
 
-(3) INSTALLATION
-================
+3  Installation
+===============
+
+It is recommended to download the latest version of the driver from the 
+SysKonnect web site www.syskonnect.com. If you have downloaded the latest
+driver, the Linux kernel has to be patched before the driver can be 
+installed. For details on how to patch a Linux kernel, refer to the 
+patch.txt file.
+
+3.1  Driver Installation
+------------------------
 
 The following steps describe the actions that are required to install
 the driver and to start it manually. These steps should be carried
 out for the initial driver setup. Once confirmed to be ok, they can
-be included in the system start which is described in the next
-chapter.
+be included in the system start.
+
+NOTE 1: To perform the following tasks you need 'root' access.
+
+NOTE 2: In case of problems, please read the section "Troubleshooting" 
+        below.
 
-NOTE 1: You must have 'root' access to the system to perform
-        the following tasks.
-NOTE 2:	IMPORTANT: In case of problems, please read the section
-	"Troubleshooting" below.
-
-1) The driver can either be integrated into the kernel or it can
-   be compiled as a module.
-   Select the appropriate option during the kernel configuration.
-   For use as a module, your kernel must have
-   'loadable module support' enabled.
-   For automatic driver start, you also need 'Kernel module loader'
-   enabled.
-   Configure those options, build and install the new kernel. If you
-   choose to use the driver as a module, do "make modules" and
-   "make modules_install".
-   Reboot your system.
-
-2) Load the module manually by entering:
-       modprobe sk98lin
-   If the SysKonnect SK-98xx adapter is installed in your
-   computer and you have a /proc filesystem, running the command
-   'more /proc/net/dev' should produce an output containing a
-   line with the following format:
-       eth0:    0    0 ...
-   which means that your adapter has been found and initialized.
+The driver can either be integrated into the kernel or it can be compiled 
+as a module. Select the appropriate option during the kernel 
+configuration.
+
+Compile/use the driver as a module
+----------------------------------
+To compile the driver, go to the directory /usr/src/linux and
+execute the command "make menuconfig" or "make xconfig" and proceed as 
+follows:
+
+To integrate the driver permanently into the kernel, proceed as follows:
+
+1. Select the menu "Network device support" and then "Ethernet(1000Mbit)"
+2. Mark "Marvell Yukon/SysKonnect SK-98xx/SK-95xx Gigabit Ethernet Adapter 
+   support" with (*) 
+3. Build a new kernel when the configuration of the above options is 
+   finished.
+4. Install the new kernel.
+5. Reboot your system.
+
+To use the driver as a module, proceed as follows:
+
+1. Enable 'loadable module support' in the kernel.
+2. For automatic driver start, enable the 'Kernel module loader'.
+3. Select the menu "Network device support" and then "Ethernet(1000Mbit)"
+4. Mark "Marvell Yukon/SysKonnect SK-98xx/SK-95xx Gigabit Ethernet Adapter 
+   support" with (M)
+5. Execute the command "make modules".
+6. Execute the command "make modules_install".
+   The appropiate modules will be installed.
+7. Reboot your system.
+
+
+Load the module manually
+------------------------
+To load the module manually, proceed as follows:
+
+1. Enter "modprobe sk98lin".
+2. If a Marvell Yukon or SysKonnect SK-98xx adapter is installed in 
+   your computer and you have a /proc file system, execute the command:
+   "ls /proc/net/sk98lin/" 
+   This should produce an output containing a line with the following 
+   format:
+   eth0   eth1  ...
+   which indicates that your adapter has been found and initialized.
    
-   NOTE 1: If you have more than one SysKonnect SK-98xx adapter, the
-           adapters will be listed as 'eth0', 'eth1', 'eth2', etc.
-           For each adapter, repeat the steps 3) and 4).
-   NOTE 2: If you have other Ethernet adapters installed,
-           your SysKonnect SK-98xx adapter can be mapped to 'eth1' or
-	   'eth2' ...
-	   The module installation message (in system logfile or
-	   on console, depending on /etc/syslog.conf) prints a line
-	   for each adapter that is found, containing the
-	   corresponding 'ethX'.
+   NOTE 1: If you have more than one Marvell Yukon or SysKonnect SK-98xx 
+           adapter installed, the adapters will be listed as 'eth0', 
+                   'eth1', 'eth2', etc.
+                   For each adapter, repeat steps 3 and 4 below.
+
+   NOTE 2: If you have other Ethernet adapters installed, your Marvell
+           Yukon or SysKonnect SK-98xx adapter will be mapped to the 
+                   next available number, e.g. 'eth1'. The mapping is executed 
+                   automatically.
+           The module installation message (displayed either in a system
+           log file or on the console) prints a line for each adapter 
+           found containing the corresponding 'ethX'.
 
-3) Select an IP address and assign it to the respective adapter by
+3. Select an IP address and assign it to the respective adapter by 
    entering:
-       ifconfig eth0 <ip-address>
-   This causes the adapter to connect to the ethernet. The solitary
-   yellow LED at the adapter is now active, the link status LED of
-   the primary port is on and the link status LED of the secondary
-   port (on dual port adapters) is blinking (only if the laters are
-   connected to a switch or hub).
-   You will also get a status message on the console saying
-   "ethX: network connection up using port Y" and indicating
-   the selected connection parameters.
+   ifconfig eth0 <ip-address>
+   With this command, the adapter is connected to the Ethernet. 
    
+   SK-98xx Gigabit Ethernet Server Adapters: The yellow LED on the adapter 
+   is now active, the link status LED of the primary port is active and 
+   the link status LED of the secondary port (on dual port adapters) is 
+   blinking (if the ports are connected to a switch or hub).
+   SK-98xx V2.0 Gigabit Ethernet Adapters: The link status LED is active.
+   In addition, you will receive a status message on the console stating
+   "ethX: network connection up using port Y" and showing the selected 
+   connection parameters (x stands for the ethernet device number 
+   (0,1,2, etc), y stands for the port name (A or B)).
+
    NOTE: If you are in doubt about IP addresses, ask your network
          administrator for assistance.
+  
+4. Your adapter should now be fully operational.
+   Use 'ping <otherstation>' to verify the connection to other computers 
+   on your network.
+5. To check the adapter configuration view /proc/net/sk98lin/[devicename].
+   For example by executing:    
+   "cat /proc/net/sk98lin/eth0" 
+
+Unload the module
+-----------------
+To stop and unload the driver modules, proceed as follows:
 
-4) Your adapter should now be fully operational.
-   Use 'ping <otherstation>' to verify the connection to other
-   computers on your network.
-   By viewing /proc/net/sk98lin/[devicename], you can check some 
-   information regarding to the adapter configuration.
-
-
-5) The driver module can be stopped and unloaded using the following
-   commands:
-       ifconfig eth0 down
-       rmmod sk98lin
-***
-
+1. Execute the command "ifconfig eth0 down".
+2. Execute the command "rmmod sk98lin".
 
-(4) INCLUSION OF ADAPTER AT SYSTEM START
-========================================
+3.2  Inclusion of adapter at system start
+-----------------------------------------
 
 Since a large number of different Linux distributions are 
 available, we are unable to describe a general installation procedure
@@ -122,41 +162,45 @@
 Because the driver is now integrated in the kernel, installation should
 be easy, using the standard mechanism of your distribution.
 Refer to the distribution's manual for installation of ethernet adapters.
+
 ***
 
+4  Driver Parameters
+====================
 
-(5) DRIVER PARAMETERS
-=====================
+Parameters can be set at the command line after the module has been 
+loaded with the command 'modprobe'.
+In some distributions, the configuration tools are able to pass parameters
+to the driver module.
 
-Parameters can be set at the command line while loading the
-module with 'modprobe'. The configuration tools of some distributions
-can also give parameters to the driver module.
 If you use the kernel module loader, you can set driver parameters
 in the file /etc/modules.conf (or old name: /etc/conf.modules).
-Insert a line of the form:
+To set the driver parameters in this file, proceed as follows:
 
-options sk98lin ...
+1. Insert a line of the form :
+   options sk98lin ...
+   For "...", the same syntax is required as described for the command
+   line paramaters of modprobe below.
+2. To activate the new parameters, either reboot your computer
+   or 
+   unload and reload the driver.
+   The syntax of the driver parameters is:
+
+        modprobe sk98lin parameter=value1[,value2[,value3...]]
+
+   where value1 refers to the first adapter, value2 to the second etc.
+
+NOTE: All parameters are case sensitive. Write them exactly as shown 
+      below.
+
+Example:
+Suppose you have two adapters. You want to set auto-negotiation
+on the first adapter to ON and on the second adapter to OFF.
+You also want to set DuplexCapabilities on the first adapter
+to FULL, and on the second adapter to HALF.
+Then, you must enter:
 
-For "...", use the same syntax as described below for the command
-line paramaters of modprobe.
-You either have to reboot your computer or unload and reload
-the driver to activate the new parameters.
-The syntax of the driver parameters is:
-
-modprobe sk98lin parameter=value1[,value2[,value3...]]
-
-value1 is for the first adapter, value2 for the second one etc.
-All Parameters are case sensitive, so write them exactly as
-shown below.
-
-Sample: Suppose you have two adapters. You want to set AutoNegotiation
-	on Port A of the first adapter to ON and on Port A of the
-	second adapter to OFF.
-	You also want to set DuplexCapabilities on Port A of the first
-	adapter to FULL and on Port A of the second adapter to HALF.
-	You must enter:
-
-	modprobe sk98lin AutoNeg_A=On,Off DupCap_A=Full,Half
+        modprobe sk98lin AutoNeg=On,Off DupCap=Full,Half
 
 NOTE: The number of adapters that can be configured this way is
       limited in the driver (file skge.c, constant SK_MAX_CARD_PARAM).
@@ -164,357 +208,499 @@
       more adapters, adjust this and recompile.
 
 
-5.1 Per-Port Parameters
------------------------
-Those setting are available for each port on the adapter.
+4.1  Per-Port Parameters
+------------------------
+
+These settings are available for each port on the adapter.
 In the following description, '?' stands for the port for
 which you set the parameter (A or B).
 
-- Auto Negotiation
-  Parameter:	AutoNeg_?
-  Values:	On, Off, Sense
-  Default:	Sense
+Speed
+-----
+Parameter:    Speed_?
+Values:       10, 100, 1000, Auto
+Default:      Auto
+
+This parameter is used to set the speed capabilities. It is only valid 
+for the SK-98xx V2.0 copper adapters.
+Usually, the speed is negotiated between the two ports during link 
+establishment. If this fails, a port can be forced to a specific setting
+with this parameter.
+
+Auto-Negotiation
+----------------
+Parameter:    AutoNeg_?
+Values:       On, Off, Sense
+Default:      On
   
-  The "Sense"-mode finds out automatically whether the link
-  partner supports autonegotiation or not.
+The "Sense"-mode automatically detects whether the link partner supports
+auto-negotiation or not.
 
-- Duplex Capabilities
-  Parameter:	DupCap_?
-  Values:	Half, Full, Both
-  Default:	Both
-
-  This parameters is relevant only if autonegotiation for
-  this port is not "Sense". If autonegotiation is "On", all
-  three values are possible. If it is "Off", only "Full" and
-  "Half" are allowed.
-  It is usefull if your link partner does not support all
-  possible combinations.
-
-- Flow Control
-  Parameter:	FlowCtrl_?
-  Values:	Sym, SymOrRem, LocSend, None
-  Default:	SymOrRem
-
-  This parameter can be used to set the flow control capabilities
-  that the port reports during autonegotiation.
-  The meaning of the different modes is:
--- Sym = Symetric: both link partners are allowed to send PAUSE frames
--- SymOrRem = SymetricOrRemote: both or only remote partner are allowed
-   to send PAUSE frames
--- LocSend = LocalSend: only local link partner is allowed to send
-   PAUSE frames
--- None: no link partner is allowed to send PAUSE frames
+Duplex Capabilities
+-------------------
+Parameter:    DupCap_?
+Values:       Half, Full, Both
+Default:      Both
+
+This parameters is only relevant if auto-negotiation for this port is 
+not set to "Sense". If auto-negotiation is set to "On", all three values
+are possible. If it is set to "Off", only "Full" and "Half" are allowed.
+This parameter is usefull if your link partner does not support all
+possible combinations.
+
+Flow Control
+------------
+Parameter:    FlowCtrl_?
+Values:       Sym, SymOrRem, LocSend, None
+Default:      SymOrRem
+
+This parameter can be used to set the flow control capabilities the 
+port reports during auto-negotiation. It can be set for each port 
+individually.
+Possible modes:
+   -- Sym      = Symetric: both link partners are allowed to send 
+                  PAUSE frames
+   -- SymOrRem = SymetricOrRemote: both or only remote partner 
+                  are allowed to send PAUSE frames
+   -- LocSend  = LocalSend: only local link partner is allowed 
+                  to send PAUSE frames
+   -- None     = no link partner is allowed to send PAUSE frames
   
-  NOTE: This parameter is ignored if autonegotiation is set to "Off".
+NOTE: This parameter is ignored if auto-negotiation is set to "Off".
 
-- Role in Master-Slave-Negotiation (1000Base-T only).
-  Parameter:    Role_?
-  Values:       Auto, Master, Slave
-  Default:      Auto
-  
-  This parameter is only valid for the SK-9821 and SK-9822 adapters.
-  For two 1000Base-T ports to communicate, one must take the role as
-  master (providing timing information), while the other must be slave.
-  Normally, this is negotiated between the two ports during link 
-  establishment. If this should ever fail, you can force a port to a
-  specific setting with this parameter.
-  
+Role in Master-Slave-Negotiation (1000Base-T only)
+--------------------------------------------------
+Parameter:    Role_?
+Values:       Auto, Master, Slave
+Default:      Auto
+
+This parameter is only valid for the SK-9821 and SK-9822 adapters.
+For two 1000Base-T ports to communicate, one must take the role of the
+master (providing timing information), while the other must be the 
+slave. Usually, this is negotiated between the two ports during link 
+establishment. If this fails, a port can be forced to a specific setting
+with this parameter.
 
-5.2 Per-Adapter Parameters
---------------------------
 
-- Preferred Port
-  Parameter:	PrefPort
-  Values:	A, B
-  Default:	A
-
-  This is used to force the preferred port to A or B (on two-port NICs).
-  The preferred port is the one that is used if both are detected as
-  fully functional.
-
-- RLMT (Redundant Link Management Technology) Mode
-  Parameter:	RlmtMode
-  Values:	CheckLinkState,CheckLocalPort, CheckSeg, DualNet
-  Default:	CheckLinkState
-
-  RLMT (the driver part that decides which port to use) knows three
-  ways of checking if a port is available for use:
-
--- CheckLinkState = Check link state only: RLMT uses the link state
-   reported by the adapter hardware for each individual port to determine
-   whether a port can be used for all network traffic or not.
-
--- CheckLocalPort - Check other port on adapter: RLMT sends test frames
-   from each port to each other port and checks if they are received by
-   the other port, respectively. Thus, the ports must be connected to the
-   network such that LLC test frames can be exchanged between them
-   (i.e. there must be no routers between the ports).
-
--- CheckSeg - Check other port and segmentation: RLMT checks the other port
-   and in addition requests information from the Gigabit Ethernet
-   switch next to each port to see if the network is segmented between
-   the ports. Thus, this mode is only to be used if you have Gigabit
-   Ethernet switches installed in your network that have been configured
-   to use the Spanning Tree protocol.
-
--- DualNet - Both ports A and B are used as separate devices at the same
-   time. So if you have a dual port adapter, port A will show up as eth0
-   and port B as eth1. Both ports can be used independend with distinct
-   IP addresses.
-   The preferred port setting is not used. Rlmt is turned off.
-   
+4.2  Adapter Parameters
+-----------------------
 
-  NOTE: The modes CheckLocalPort and CheckSeg are meant to operate in
-        configurations where a network path between the ports on one
-        adapter exists. Especially, they are not designed to work where
-        adapters are connected back-to-back.
+Interrupt Moderation
+--------------------
+Parameter:    Moderation
+Values:       None, Static, Dynamic
+Default:      None
+
+Interrupt moderation is employed to limit the maxmimum number of interrupts
+the driver has to serve. That is, one or more interrupts (which indicate any
+transmit or receive packet to be processed) are queued until the driver 
+processes them. When queued interrupts are to be served, is determined by the
+'IntsPerSec' parameter, which is explained later below.
+
+Possible modes:
+
+   -- None - No interrupt moderation is applied on the adapter card. 
+      Therefore, each transmit or receive interrupt is served immediately
+      as soon as it appears on the interrupt line of the adapter card.
+
+   -- Static - Interrupt moderation is applied on the adapter card. 
+      All transmit and receive interrupts are queued until a complete
+      moderation interval ends. If such a moderation interval ends, all
+      queued interrupts are processed in one big bunch without any delay.
+      The term 'static' reflects the fact, that interrupt moderation is
+      always enabled, regardless how much network load is currently 
+      passing via a particular interface. In addition, the duration of
+      the moderation interval has a fixed length that never changes while
+      the driver is operational.
+
+   -- Dynamic - Interrupt moderation might be applied on the adapter card,
+      depending on the load of the system. If the driver detects that the
+      system load is too high, the driver tries to shield the system against 
+      too much network load by enabling interrupt moderation. If - at a later
+      time - the CPU utilizaton decreases again (or if the network load is 
+      negligible) the interrupt moderation will automatically be disabled.
+
+Interrupt moderation should be used when the driver has to handle one or more
+interfaces with a high network load, which - as a consequence - leads also to a
+high CPU utilization. When moderation is applied in such high network load 
+situations, CPU load might be reduced by 20-30%.
+
+NOTE: The drawback of using interrupt moderation is an increase of the round-
+trip-time (RTT), due to the queueing and serving of interrupts at dedicated
+moderation times.
+
+Interrupts per second
+---------------------
+Parameter:    IntsPerSec
+Values:       30...40000 (interrupts per second)
+Default:      2000
+
+This parameter is only used, if either static or dynamic interrupt moderation
+is used on a network adapter card. Using this paramter if no moderation is
+applied, will lead to no action performed.
+
+This parameter determines the length of any interrupt moderation interval. 
+Assuming that static interrupt moderation is to be used, an 'IntsPerSec' 
+parameter value of 2000 will lead to an interrupt moderation interval of
+500 microseconds. 
+
+NOTE: The duration of the moderation interval is to be chosen with care.
+At first glance, selecting a very long duration (e.g. only 100 interrupts per 
+second) seems to be meaningful, but the increase of packet-processing delay 
+is tremendous. On the other hand, selecting a very short moderation time might
+compensate the use of any moderation being applied.
+
+
+Preferred Port
+--------------
+Parameter:    PrefPort
+Values:       A, B
+Default:      A
+
+This is used to force the preferred port to A or B (on dual-port network 
+adapters). The preferred port is the one that is used if both are detected
+as fully functional.
+
+RLMT Mode (Redundant Link Management Technology)
+------------------------------------------------
+Parameter:    RlmtMode
+Values:       CheckLinkState,CheckLocalPort, CheckSeg, DualNet
+Default:      CheckLinkState
+
+RLMT monitors the status of the port. If the link of the active port 
+fails, RLMT switches immediately to the standby link. The virtual link is 
+maintained as long as at least one 'physical' link is up. 
+
+Possible modes:
+
+   -- CheckLinkState - Check link state only: RLMT uses the link state
+      reported by the adapter hardware for each individual port to 
+      determine whether a port can be used for all network traffic or 
+      not.
+
+   -- CheckLocalPort - In this mode, RLMT monitors the network path 
+      between the two ports of an adapter by regularly exchanging packets
+      between them. This mode requires a network configuration in which 
+      the two ports are able to "see" each other (i.e. there must not be 
+      any router between the ports).
+
+   -- CheckSeg - Check local port and segmentation: This mode supports the
+      same functions as the CheckLocalPort mode and additionally checks 
+      network segmentation between the ports. Therefore, this mode is only
+      to be used if Gigabit Ethernet switches are installed on the network
+      that have been configured to use the Spanning Tree protocol. 
+
+   -- DualNet - In this mode, ports A and B are used as separate devices. 
+      If you have a dual port adapter, port A will be configured as eth0 
+      and port B as eth1. Both ports can be used independently with 
+      distinct IP addresses. The preferred port setting is not used. 
+      RLMT is turned off.
+   
+NOTE: RLMT modes CLP and CLPSS are designed to operate in configurations 
+      where a network path between the ports on one adapter exists. 
+      Moreover, they are not designed to work where adapters are connected
+      back-to-back.
 ***
 
 
-(6) LARGE FRAME SUPPORT
-=======================
+5  Large Frame Support
+======================
 
-Large frames (also called jumbo frames) are now supported by the
-driver. This can result in a greatly improved throughput if
-transfering large amounts of data.
-To enable large frames, set the MTU (maximum transfer unit)
-of the interface to the value you wish (up to 9000). The command
-for this is:
-  ifconfig eth0 mtu 9000
+The driver supports large frames (also called jumbo frames). Using large 
+frames can result in an improved throughput if transferring large amounts 
+of data.
+To enable large frames, set the MTU (maximum transfer unit) of the 
+interface to the desired value (up to 9000), execute the following 
+command:
+      ifconfig eth0 mtu 9000
 This will only work if you have two adapters connected back-to-back
-or if you use a switch that supports large frames. When using a
-switch, it should be configured to allow large frames, without
-autonegotiating for them.
-The setting must be done on all adapters that can be reached by
-the large frames. If one adapter is not set to receive large frames,
-it will simply drop them.
-
-You can switch back to the standard ethernet frame size with:
-  ifconfig eth0 mtu 1500
+or if you use a switch that supports large frames. When using a switch, 
+it should be configured to allow large frames and auto-negotiation should  
+be set to OFF. The setting must be configured on all adapters that can be 
+reached by the large frames. If one adapter is not set to receive large 
+frames, it will simply drop them.
+
+You can switch back to the standard ethernet frame size by executing the 
+following command:
+      ifconfig eth0 mtu 1500
 
-To make this setting persitent, add a script with the 'ifconfig'
-line to the system startup sequence (named something like "S99sk98lin"
+To permanently configure this setting, add a script with the 'ifconfig' 
+line to the system startup sequence (named something like "S99sk98lin" 
 in /etc/rc.d/rc2.d).
 ***
 
 
-(7) TROUBLESHOOTING
-===================
+6  VLAN and Link Aggregation Support (IEEE 802.1, 802.1q, 802.3ad)
+==================================================================
+
+The Marvell Yukon/SysKonnect Linux drivers are able to support VLAN and 
+Link Aggregation according to IEEE standards 802.1, 802.1q, and 802.3ad. 
+These features are only available after installation of open source 
+modules available on the Internet:
+For VLAN go to: http://scry.wanfear.com/~greear/vlan.html
+For Link Aggregation go to: http://www.st.rim.or.jp/~yumo
+
+NOTE: SysKonnect GmbH does not offer any support for these open source 
+      modules and does not take the responsibility for any kind of 
+      failures or problems arising in connection with these modules.
+
+NOTE: Configuring Link Aggregation on a SysKonnect dual link adapter may 
+      cause problems when unloading the driver.
+
+
+7  Troubleshooting
+==================
+
+If any problems occur during the installation process, check the 
+following list:
 
-If you run into problems during installation, check those items:
 
 Problem:  The SK-98xx adapter can not be found by the driver.
-Reason:   Look in /proc/pci for the following entry:
+Solution: In /proc/pci search for the following entry:
              'Ethernet controller: SysKonnect SK-98xx ...'
-	  If this entry exists, then the SK-98xx adapter has been
-	  found by the system and should be able to be used.
-	  If this entry does not exist or if the file '/proc/pci'
-	  is not there, then you may have a hardware problem or PCI
-	  support may not be enabled in your kernel.
-	  The adapter can be checked using the diagnostic program
-	  which is available from the SysKonnect web site:
-	      www.syskonnect.de
-	  Some COMPAQ machines have a problem with PCI under
-	  Linux. This is described in the 'PCI howto' document
-	  (included in some distributions or available from the
-	  www, e.g. at 'www.linux.org'). This might be fixed in the
-	  2.2.x kernel series (I've not tested it).
-
-Problem:  Programs such as 'ifconfig' or 'route' can not be found or
-          you get an error message 'Operation not permitted'.
-Reason:   You are not logged in as user 'root'. Logout and 
-          login as root or change to root via 'su'.
-
-Problem:  Using the command 'ping <address>', you get a message
-          "ping: sendto: Network is unreachable".
-Reason:   Your route is not set up correct.
-	  If you are using RedHat, you probably forgot
-	  to set up the route in 'network configuration'.
-	  Check the existing routes with the 'route' command
-	  and check if there is an entry for 'eth0' and if
-	  it is correct.
-
-Problem:  The driver can be started, the adapter is connected
-          to the network, but you can not receive or transmit
-          any packet; e.g. 'ping' does not work.
-Reason:   You have an incorrect route in your routing table.
-          Check the routing table with the command 'route' and
-	  read the manual pages about route ('man route').
-NOTE:	  Although the 2.2.x kernel versions generate the routing
-	  entry automatically, you may have problems of this kind
-	  here, too. We found a case where the driver started correct
-	  at system boot, but after removing and reloading the driver,
-	  the route of the adapter's network pointed to the 'dummy0'
-	  device and had to be corrected manually.
-	  
-Problem:  You want to use your computer as a router between
-          multiple IP subnetworks (using multiple adapters), but
-	  you can not reach computers in other subnetworks.
-Reason:   Either the router's kernel is not configured for IP
-	  forwarding or there is a problem with the routing table
-	  and gateway configuration in at least one of the
-	  computers.
-
-Problem:  At the start of the driver, you get an error message:
-	  "eth0: -- ERROR --
-	   Class: internal Software error
-	   Nr: 0xcc
-	   Msg: SkGeInitPort() cannot init running ports"
-Reason:	  You are using a driver compiled for single processor
-	  machines on an multiprocessor machine with SMP (Symetric
-	  MultiProcessor) kernel.
-	  Configure your kernel appropriate and recompile the kernel or
-	  the modules.
+          If this entry exists, the SK-98xx or SK-98xx V2.0 adapter has 
+          been found by the system and should be operational.
+          If this entry does not exist or if the file '/proc/pci' is not 
+          found, there may be a hardware problem or the PCI support may 
+          not be enabled in your kernel.
+          The adapter can be checked using the diagnostics program which 
+          is available on the SysKonnect web site:
+          www.syskonnect.com
+          
+          Some COMPAQ machines have problems dealing with PCI under Linux.
+          Linux. This problem is described in the 'PCI howto' document
+          (included in some distributions or available from the
+          web, e.g. at 'www.linux.org'). 
+
+
+Problem:  Programs such as 'ifconfig' or 'route' can not be found or the 
+          error message 'Operation not permitted' is displayed.
+Reason:   You are not logged in as user 'root'.
+Solution: Logout and login as 'root' or change to 'root' via 'su'.
+
+
+Problem:  Upon use of the command 'ping <address>' the message
+          "ping: sendto: Network is unreachable" is displayed.
+Reason:   Your route is not set correctly.
+Solution: If you are using RedHat, you probably forgot to set up the 
+          route in the 'network configuration'.
+          Check the existing routes with the 'route' command and check 
+          if an entry for 'eth0' exists, and if so, if it is set correctly.
+
+
+Problem:  The driver can be started, the adapter is connected to the 
+          network, but you cannot receive or transmit any packets; 
+          e.g. 'ping' does not work.
+Reason:   There is an incorrect route in your routing table.
+Solution: Check the routing table with the command 'route' and read the 
+          manual help pages dealing with routes (enter 'man route').
+
+NOTE: Although the 2.2.x kernel versions generate the routing entry 
+      automatically, problems of this kind may occur here as well. We've 
+      come across a situation in which the driver started correctly at 
+      system start, but after the driver has been removed and reloaded,
+      the route of the adapter's network pointed to the 'dummy0'device 
+      and had to be corrected manually.
+
+
+Problem:  Your computer should act as a router between multiple 
+          IP subnetworks (using multiple adapters), but computers in 
+          other subnetworks cannot be reached.
+Reason:   Either the router's kernel is not configured for IP forwarding 
+          or the routing table and gateway configuration of at least one 
+          computer is not working.
+
+Problem:  Upon driver start, the following error message is displayed:
+          "eth0: -- ERROR --
+          Class: internal Software error
+          Nr:    0xcc
+          Msg:   SkGeInitPort() cannot init running ports"
+Reason:   You are using a driver compiled for single processor machines 
+          on a multiprocessor machine with SMP (Symetric MultiProcessor) 
+          kernel.
+Solution: Configure your kernel appropriately and recompile the kernel or
+          the modules.
+
+
 
 If your problem is not listed here, please contact SysKonnect's technical
 support for help (linux@syskonnect.de).
-When contacting our technical support, please ensure that the
-following information is available:
+When contacting our technical support, please ensure that the following 
+information is available:
 - System Manufacturer and Model
 - Boards in your system
 - Distribution
 - Kernel version
+- Driver version
 ***
 
+8  History
+==========
 
-(8) HISTORY
-===========
-
-VERSION 4.02 (In-Kernel version)
+VERSION 6.10
 New Features:
-- Add Kernel 2.4 changes
+- none
+Problems fixed:
+- Fix: Race condition with padded frames
 Known limitations:
 - None
 
-VERSION 4.01 (In-Kernel version)
+VERSION 6.09
+New Features:
+- Fix: Disabled HW Error IRQ on 32-bit Yukon if sensor IRQ occurs
+- Fix: Delay race condition with some server machines
 Problems fixed:
-- Full statistics support for DualNet mode
+- none
 Known limitations:
 - None
 
-VERSION 4.00 (In-Kernel version)
-Problems fixed:
-- Memory leak found 
+VERSION 6.08
 New Features:
-- Proc filesystem integration
-- DualNet functionality integrated
-- Rlmt networks added
+- Add: Dynamic Interrupt moderation
+- Add: Blink mode verification
+- Fix: CSUM changes
+Problems fixed:
+- none
 Known limitations:
-- statistics partially incorrect in DualNet mode
+- None
 
-VERSION 3.04 (In-Kernel version)
+VERSION 6.04 - 6.07
+New Features:
+- Common modules update
 Problems fixed:
-- Driver start failed on UltraSPARC
-- Rx checksum calculation for big endian machines did not work
-- Jumbo frames were counted as input-errors in netstat
+- none
+Known limitations:
+- None
 
-VERSION 3.03 (Standalone version)
+VERSION 6.03
+New Features:
+- Common modules update
 Problems fixed:
-- Compilation did not find script "printver.sh" if "." not in PATH
+- Remove useless init_module/cleanup_module forward declarations
 Known limitations:
 - None
 
-VERSION 3.02 (In-Kernel version)
+VERSION 6.02 (In-Kernel version)
+New Features:
+- Common modules update
 Problems fixed:
+- Boot message cleanup
+Known limitations:
 - None
+
+VERSION 6.00 (In-Kernel version)
 New Features:
-- Integration in Linux kernel source (2.2.14 and 2.3.29) 
+- Support for SK-98xx V2.0 adapters
+- Support for gmac
+- Support for kernel 2.4.x and kernel 2.2.x
+- Zerocopy support for kernel 2.4.x with sendfile()
+- Support for scatter-gather functionality with sendfile()
+- Speed support for SK-98xx V2.0 adapters
+- New ProcFs entries
+- New module parameters
+Problems fixed:
+- ProcFS initialization
+- csum packet error
+- Ierror/crc counter error (#10767)
+- rx_too_long counter error (#10751)
 Known limitations:
 - None
 
-VERSION 3.01
+VERSION 4.11
+New Features:
+- none
 Problems fixed:
+- Error statistic counter fix (#10620)
+- RLMT-Fixes (#10659, #10639, #10650)
+- LM80 sensor initialization fix (#10623)
+- SK-CSUM memory fixes (#10610).
+Known limitations:
 - None
+
+VERSION 4.10
 New Features:
-- Full source release
+- New ProcFs entries
+Problems fixed:
+- Corrected some printk's
 Known limitations:
 - None
 
-VERSION 3.00
+VERSION 4.09
+New Features:
+- IFF_RUNNING support (link status)
+- New ProcFs entries
 Problems fixed:
+- too long counters
+- too short counters
+- Kernel error compilation
+Known limitations:
 - None
+ 
+VERSION 4.06 (In-Kernel version)
+Problems fixed:
+- MTU init problems
+ 
+VERSION 4.04
+Problems fixed:
+- removed VLAN error messages
+
+VERSION 4.02 (In-Kernel version)
 New Features:
-- Support for 1000Base-T adapters (SK-9821 and SK-9822)
+- Add Kernel 2.4 changes
 Known limitations:
 - None
 
-VERSION 1.07
+VERSION 4.01 (In-Kernel version)
 Problems fixed:
-- RlmtMode parameter value strings were wrong (#10437)
-- Driver sent too many RLMT frames (#10439)
-- Driver did not recognize network segmentation (#10440)
-- RLMT switched too often on segmented network (#10441)
+- Full statistics support for DualNet mode
 Known limitations:
 - None
 
-VERSION 1.06
+VERSION 4.00 (In-Kernel version)
 Problems fixed:
-- System panic'ed after some time when running with 
-  RlmtMode=CheckOtherLink or RlmtMode=CheckSeg (#10421)
-  Panic message: "Kernel panic: skput: over ... dev: eth0"
-- Driver did not switch back to default port when connected
-  back-to-back (#10422).
-Changes:
-- RlmtMode parameter names have changed
-New features:
-- There is now a version for ALPHA processors
+- Memory leak found 
+New Features:
+- Proc filesystem integration
+- DualNet functionality integrated
+- Rlmt networks added
 Known limitations:
-- None
+- statistics partially incorrect in DualNet mode
+
+VERSION 3.04 (In-Kernel version)
+Problems fixed:
+- Driver start failed on UltraSPARC
+- Rx checksum calculation for big endian machines did not work
+- Jumbo frames were counted as input-errors in netstat
 
-VERSION 1.05
+VERSION 3.03 (Standalone version)
 Problems fixed:
-- Driver failed to load on kernels with version information
-  for module symbols enabled
+- Compilation did not find script "printver.sh" if "." not in PATH
 Known limitations:
 - None
 
-VERSION 1.04
+VERSION 3.02 (In-Kernel version)
 Problems fixed:
-- Large frame support does work now (no autonegotiation
-  support for large frames, just manually selectable)
+- None
 New Features:
-- Receive checksumming in hardware
-- Performance optimizations
-  Some numbers (on two PII-400 machines, back-to-back):
-  netpipe: 300 MBit/sec, with large frames: 470 MBit/sec
-  ttcp:  38 MByte/sec, with large frames: 60 MByte/sec
-  ttcp (UDP send): 66 MByte/sec, with large frames: 106 MByte/sec
+- Integration in Linux kernel source (2.2.14 and 2.3.29) 
 Known limitations:
 - None
 
-VERSION 1.03
+VERSION 3.01
 Problems fixed:
-- Unloading with "rmmod" caused segmentation fault (#10415)
-- The link LED flickered from time to time, if no link was
-  established (#10402)
-- Installation problems with RedHat 6.0 (#10409)
+- None
 New Features:
-- Connection state ouput at "network connection up"
+- Full source release
 Known limitations:
 - None
 
-VERSION 1.02
+VERSION 3.00
 Problems fixed:
-- Failed with multiple adapters
-- Failed with Single Port adapters
-- Startup string was only displayed if adapter found
-- No link could be established on certain switches when the switches were
-  rebooted. (#10377)
+- None
+New Features:
+- Support for 1000Base-T adapters (SK-9821 and SK-9822)
 Known limitations:
-- Segmentation fault at "rmmod" with kernel 2.2.3 on some machines
+- None
 
-VERSION 1.01
-Problems fixed:
-- Sensor status was not set back to 'ok' after 'warning/error'. (#10386)
-Changes:
-- improved parallelism in driver
-
-VERSION 1.00
-Known limitations:
-- not tested with all kernel versions (I don't have that much time :-)
-- only x86 version available (if you need others, ask for it)
-- source code not completely available
 
 ***End of Readme File***
-
-
diff -ruN linux/MAINTAINERS linuxn/MAINTAINERS
--- linux/MAINTAINERS	Fri Nov 29 00:53:08 2002
+++ linuxn/MAINTAINERS	Tue May 20 12:17:55 2003
@@ -1000,6 +1000,14 @@
 M:	zab@zabbo.net
 S:	Odd Fixes
 
+MARVELL YUKON / SYSKONNECT DRIVER
+P:	Mirko Lindner
+M: 	mlindner@syskonnect.de
+P:	Ralph Roesler
+M: 	rroesler@syskonnect.de
+W: 	http://www.syskonnect.com
+S: 	Supported
+
 MATROX FRAMEBUFFER DRIVER
 P:	Petr Vandrovec
 M:	vandrove@vc.cvut.cz
diff -ruN linux/drivers/net/Config.in linuxn/drivers/net/Config.in
--- linux/drivers/net/Config.in	Fri Nov 29 00:53:13 2002
+++ linuxn/drivers/net/Config.in	Tue May 20 12:17:45 2003
@@ -248,7 +248,18 @@
 dep_tristate 'National Semiconductor DP83820 support' CONFIG_NS83820 $CONFIG_PCI
 dep_tristate 'Packet Engines Hamachi GNIC-II support' CONFIG_HAMACHI $CONFIG_PCI
 dep_tristate 'Packet Engines Yellowfin Gigabit-NIC support (EXPERIMENTAL)' CONFIG_YELLOWFIN $CONFIG_PCI $CONFIG_EXPERIMENTAL
-dep_tristate 'SysKonnect SK-98xx support' CONFIG_SK98LIN $CONFIG_PCI
+dep_tristate 'Marvell Yukon Chipset / SysKonnect SK-98xx Support' CONFIG_SK98LIN $CONFIG_PCI
+if [ "$CONFIG_SK98LIN" != "n" ]; then
+   bool '  3Com 3C940/3C941 Gigabit Ethernet Adapter' CONFIG_SK98LIN_T1
+   bool '  Allied Telesyn AT-29xx Gigabit Ethernet Adapter' CONFIG_SK98LIN_T3
+   bool '  CNet N-Way Gigabit Ethernet Adapter' CONFIG_SK98LIN_T8
+   bool '  D-Link DGE-530T Gigabit Ethernet Adapter' CONFIG_SK98LIN_T6
+   bool '  Linksys EG10xx Ethernet Server Adapter' CONFIG_SK98LIN_T9
+   bool '  Marvell RDK-80xx Adapter' CONFIG_SK98LIN_T4
+   bool '  Marvell Yukon Gigabit Ethernet Adapter' CONFIG_SK98LIN_T7
+   bool '  SysKonnect SK-98xx Server Gigabit Adapter' CONFIG_SK98LIN_T2
+   bool '  SysKonnect SK-98xx V2.0 Gigabit Ethernet Adapter' CONFIG_SK98LIN_T5
+fi
 dep_tristate 'Broadcom Tigon3 support' CONFIG_TIGON3 $CONFIG_PCI
 
 endmenu
diff -ruN linux/drivers/net/sk98lin/Makefile linuxn/drivers/net/sk98lin/Makefile
--- linux/drivers/net/sk98lin/Makefile	Wed Jul  4 20:50:39 2001
+++ linuxn/drivers/net/sk98lin/Makefile	Tue May 20 12:17:55 2003
@@ -5,9 +5,23 @@
 
 O_TARGET := sk98lin.o
 
-obj-y :=     skge.o skaddr.o skgehwt.o skgeinit.o skgepnmi.o skgesirq.o \
-             ski2c.o sklm80.o skqueue.o skrlmt.o sktimer.o skvpd.o \
-             skxmac2.o skproc.o skcsum.o
+obj-y :=	\
+		skge.o		\
+		skdim.o		\
+		skaddr.o	\
+		skgehwt.o	\
+		skgeinit.o	\
+		skgepnmi.o	\
+		skgesirq.o	\
+		ski2c.o		\
+		sklm80.o	\
+		skqueue.o	\
+		skrlmt.o	\
+		sktimer.o	\
+		skvpd.o		\
+		skxmac2.o	\
+		skproc.o	\
+		skcsum.o
 obj-m := $(O_TARGET)
 
 # DBGDEF =  \
diff -ruN linux/drivers/net/sk98lin/h/lm80.h linuxn/drivers/net/sk98lin/h/lm80.h
--- linux/drivers/net/sk98lin/h/lm80.h	Wed Jul  4 20:50:39 2001
+++ linuxn/drivers/net/sk98lin/h/lm80.h	Tue May 20 12:17:40 2003
@@ -2,8 +2,8 @@
  *
  * Name:	lm80.h	
  * Project:	GEnesis, PCI Gigabit Ethernet Adapter
- * Version:	$Revision: 1.3 $
- * Date:	$Date: 1999/11/22 13:41:19 $
+ * Version:	$Revision: 1.5 $
+ * Date:	$Date: 2003/03/31 07:15:18 $
  * Purpose:	Contains all defines for the LM80 Chip
  *		(National Semiconductor).
  *
@@ -11,8 +11,8 @@
 
 /******************************************************************************
  *
- *	(C)Copyright 1998,1999 SysKonnect,
- *	a business unit of Schneider & Koch & Co. Datensysteme GmbH.
+ *	(C)Copyright 1998-2002 SysKonnect.
+ *	(C)Copyright 2002-2003 Marvell.
  *
  *	This program is free software; you can redistribute it and/or modify
  *	it under the terms of the GNU General Public License as published by
@@ -27,6 +27,13 @@
  *
  * History:
  *	$Log: lm80.h,v $
+ *	Revision 1.5  2003/03/31 07:15:18  mkarl
+ *	Corrected Copyright.
+ *	Editorial changes.
+ *	
+ *	Revision 1.4  2002/04/25 11:04:10  rschmidt
+ *	Editorial changes
+ *	
  *	Revision 1.3  1999/11/22 13:41:19  cgoos
  *	Changed license header to GPL.
  *	
@@ -53,23 +60,23 @@
  *
  * All registers are 8 bit wide
  */
-#define	LM80_CFG		0x00	/* Configuration Register */
-#define	LM80_ISRC_1		0x01	/* Interrupt Status Register 1 */
-#define LM80_ISRC_2		0x02	/* Interrupt Status Register 2 */
-#define LM80_IMSK_1		0x03	/* Interrupt Mask Register 1 */
-#define LM80_IMSK_2		0x04	/* Interrupt Mask Register 2 */
+#define LM80_CFG			0x00	/* Configuration Register */
+#define LM80_ISRC_1			0x01	/* Interrupt Status Register 1 */
+#define LM80_ISRC_2			0x02	/* Interrupt Status Register 2 */
+#define LM80_IMSK_1			0x03	/* Interrupt Mask Register 1 */
+#define LM80_IMSK_2			0x04	/* Interrupt Mask Register 2 */
 #define LM80_FAN_CTRL		0x05	/* Fan Devisor/RST#/OS# Register */
 #define LM80_TEMP_CTRL		0x06	/* OS# Config, Temp Res. Reg */
 	/* 0x07 - 0x1f reserved	*/
 	/* current values */
-#define LM80_VT0_IN		0x20	/* current Voltage 0 value */
-#define LM80_VT1_IN		0x21	/* current Voltage 1 value */
-#define LM80_VT2_IN		0x22	/* current Voltage 2 value */
-#define LM80_VT3_IN		0x23	/* current Voltage 3 value */
-#define LM80_VT4_IN		0x24	/* current Voltage 4 value */
-#define LM80_VT5_IN		0x25	/* current Voltage 5 value */
-#define LM80_VT6_IN		0x26	/* current Voltage 6 value */
-#define LM80_TEMP_IN		0x27	/* current temperature value */
+#define LM80_VT0_IN			0x20	/* current Voltage 0 value */
+#define LM80_VT1_IN			0x21	/* current Voltage 1 value */
+#define LM80_VT2_IN			0x22	/* current Voltage 2 value */
+#define LM80_VT3_IN			0x23	/* current Voltage 3 value */
+#define LM80_VT4_IN			0x24	/* current Voltage 4 value */
+#define LM80_VT5_IN			0x25	/* current Voltage 5 value */
+#define LM80_VT6_IN			0x26	/* current Voltage 6 value */
+#define LM80_TEMP_IN		0x27	/* current Temperature value */
 #define LM80_FAN1_IN		0x28	/* current Fan 1 count */
 #define LM80_FAN2_IN		0x29	/* current Fan 2 count */
 	/* limit values */
@@ -91,8 +98,8 @@
 #define LM80_THOT_LIM_LO	0x39	/* hot temperature limit (low) */
 #define LM80_TOS_LIM_UP		0x3a	/* OS temperature limit (high) */
 #define LM80_TOS_LIM_LO		0x3b	/* OS temperature limit (low) */
-#define	LM80_FAN1_COUNT_LIM	0x3c	/* Fan 1 count limit (high) */
-#define	LM80_FAN2_COUNT_LIM	0x3d	/* Fan 2 count limit (low) */
+#define LM80_FAN1_COUNT_LIM	0x3c	/* Fan 1 count limit (high) */
+#define LM80_FAN2_COUNT_LIM	0x3d	/* Fan 2 count limit (low) */
 	/* 0x3e - 0x3f reserved	*/
 
 /*
@@ -111,23 +118,23 @@
 
 /*	LM80_ISRC_1		Interrupt Status Register 1 */
 /*	LM80_IMSK_1		Interrupt Mask Register 1 */
-#define LM80_IS_VT0		(1<<0)	/* limit exceeded for Voltage 0 */
-#define LM80_IS_VT1		(1<<1)	/* limit exceeded for Voltage 1 */
-#define LM80_IS_VT2		(1<<2)	/* limit exceeded for Voltage 2 */
-#define LM80_IS_VT3		(1<<3)	/* limit exceeded for Voltage 3 */
-#define LM80_IS_VT4		(1<<4)	/* limit exceeded for Voltage 4 */
-#define LM80_IS_VT5		(1<<5)	/* limit exceeded for Voltage 5 */
-#define LM80_IS_VT6		(1<<6)	/* limit exceeded for Voltage 6 */
+#define LM80_IS_VT0			(1<<0)	/* limit exceeded for Voltage 0 */
+#define LM80_IS_VT1			(1<<1)	/* limit exceeded for Voltage 1 */
+#define LM80_IS_VT2			(1<<2)	/* limit exceeded for Voltage 2 */
+#define LM80_IS_VT3			(1<<3)	/* limit exceeded for Voltage 3 */
+#define LM80_IS_VT4			(1<<4)	/* limit exceeded for Voltage 4 */
+#define LM80_IS_VT5			(1<<5)	/* limit exceeded for Voltage 5 */
+#define LM80_IS_VT6			(1<<6)	/* limit exceeded for Voltage 6 */
 #define LM80_IS_INT_IN		(1<<7)	/* state of INT_IN# */
 
 /*	LM80_ISRC_2		Interrupt Status Register 2 */
 /*	LM80_IMSK_2		Interrupt Mask Register 2 */
-#define	LM80_IS_TEMP		(1<<0)	/* HOT temperature limit exceeded */
-#define LM80_IS_BTI		(1<<1)	/* state of BTI# pin */
+#define LM80_IS_TEMP		(1<<0)	/* HOT temperature limit exceeded */
+#define LM80_IS_BTI			(1<<1)	/* state of BTI# pin */
 #define LM80_IS_FAN1		(1<<2)	/* count limit exceeded for Fan 1 */
 #define LM80_IS_FAN2		(1<<3)	/* count limit exceeded for Fan 2 */
-#define LM80_IS_CI		(1<<4)	/* Chassis Intrusion occured */
-#define LM80_IS_OS		(1<<5)	/* OS temperature limit exceeded */
+#define LM80_IS_CI			(1<<4)	/* Chassis Intrusion occured */
+#define LM80_IS_OS			(1<<5)	/* OS temperature limit exceeded */
 	/* bit 6 and 7 are reserved in LM80_ISRC_2 */
 #define LM80_IS_HT_IRQ_MD	(1<<6)	/* Hot temperature interrupt mode */
 #define LM80_IS_OT_IRQ_MD	(1<<7)	/* OS temperature interrupt mode */
@@ -141,7 +148,7 @@
 #define LM80_FAN_RST_ENA	(1<<7)	/* sets RST_OUT#/OS# pins in RST mode */
 
 /*	LM80_TEMP_CTRL		OS# Config, Temp Res. Reg */
-#define	LM80_TEMP_OS_STAT	(1<<0)	/* mirrors the state of RST_OUT#/OS# */
+#define LM80_TEMP_OS_STAT	(1<<0)	/* mirrors the state of RST_OUT#/OS# */
 #define LM80_TEMP_OS_POL	(1<<1)	/* select OS# polarity */
 #define LM80_TEMP_OS_MODE	(1<<2)	/* selects Interrupt mode */
 #define LM80_TEMP_RES		(1<<3)	/* selects 9 or 11 bit temp resulution*/
@@ -181,7 +188,7 @@
 /*	LM80_FAN2_COUNT_LIM	Fan 2 count limit (low) */
 	/* 0x3e - 0x3f reserved	*/
 
-#define LM80_ADDR	0x28	/* LM80 default addr */
+#define LM80_ADDR		0x28	/* LM80 default addr */
 
 /* typedefs *******************************************************************/
 
diff -ruN linux/drivers/net/sk98lin/h/skaddr.h linuxn/drivers/net/sk98lin/h/skaddr.h
--- linux/drivers/net/sk98lin/h/skaddr.h	Wed Jul  4 20:50:39 2001
+++ linuxn/drivers/net/sk98lin/h/skaddr.h	Tue May 20 12:17:40 2003
@@ -2,15 +2,16 @@
  *
  * Name:	skaddr.h
  * Project:	GEnesis, PCI Gigabit Ethernet Adapter
- * Version:	$Revision: 1.24 $
- * Date:	$Date: 2001/01/22 13:41:34 $
+ * Version:	$Revision: 1.28 $
+ * Date:	$Date: 2003/04/15 09:33:22 $
  * Purpose:	Header file for Address Management (MC, UC, Prom).
  *
  ******************************************************************************/
 
 /******************************************************************************
  *
- *	(C)Copyright 1998-2001 SysKonnect GmbH.
+ *	(C)Copyright 1998-2002 SysKonnect GmbH.
+ *	(C)Copyright 2002-2003 Marvell.
  *
  *	This program is free software; you can redistribute it and/or modify
  *	it under the terms of the GNU General Public License as published by
@@ -26,6 +27,20 @@
  * History:
  *
  *	$Log: skaddr.h,v $
+ *	Revision 1.28  2003/04/15 09:33:22  tschilli
+ *	Copyright messages changed.
+ *	
+ *	Revision 1.27  2003/04/14 15:55:11  tschilli
+ *	"#error C++ is not yet supported." removed.
+ *	
+ *	Revision 1.26  2002/11/15 07:24:42  tschilli
+ *	SK_ADDR_EQUAL macro fixed.
+ *	
+ *	Revision 1.25  2002/06/10 13:55:18  tschilli
+ *	Changes for handling YUKON.
+ *	All changes are internally and not visible to the programmer
+ *	using this module.
+ *	
  *	Revision 1.24  2001/01/22 13:41:34  rassmann
  *	Supporting two nets on dual-port adapters.
  *	
@@ -132,7 +147,6 @@
 #define __INC_SKADDR_H
 
 #ifdef __cplusplus
-#error C++ is not yet supported.
 extern "C" {
 #endif	/* cplusplus */
 
@@ -144,7 +158,7 @@
 /* ----- Common return values ----- */
 
 #define SK_ADDR_SUCCESS				0	/* Function returned successfully. */
-#define SK_ADDR_ILLEGAL_PORT		100	/* Port number too high. */
+#define SK_ADDR_ILLEGAL_PORT			100	/* Port number too high. */
 #define SK_ADDR_TOO_EARLY			101	/* Function called too early. */
 
 /* ----- Clear/Add flag bits ----- */
@@ -198,6 +212,7 @@
 
 /* Macros */
 
+#if 0
 #ifndef SK_ADDR_EQUAL
 /*
  * "&" instead of "&&" allows better optimization on IA-64.
@@ -217,6 +232,23 @@
 	(*(SK_U32 *)&(((SK_U8 *)(A1))[0]) == *(SK_U32 *)&(((SK_U8 *)(A2))[0])))
 #endif	/* SK_ADDR_DWORD_COMPARE */
 #endif	/* SK_ADDR_EQUAL */
+#endif /* 0 */
+
+#ifndef SK_ADDR_EQUAL
+#ifndef SK_ADDR_DWORD_COMPARE
+#define SK_ADDR_EQUAL(A1,A2)	( \
+	(((SK_U8 *)(A1))[5] == ((SK_U8 *)(A2))[5]) & \
+	(((SK_U8 *)(A1))[4] == ((SK_U8 *)(A2))[4]) & \
+	(((SK_U8 *)(A1))[3] == ((SK_U8 *)(A2))[3]) & \
+	(((SK_U8 *)(A1))[2] == ((SK_U8 *)(A2))[2]) & \
+	(((SK_U8 *)(A1))[1] == ((SK_U8 *)(A2))[1]) & \
+	(((SK_U8 *)(A1))[0] == ((SK_U8 *)(A2))[0]))
+#else	/* SK_ADDR_DWORD_COMPARE */
+#define SK_ADDR_EQUAL(A1,A2)	( \
+	(*(SK_U16 *)&(((SK_U8 *)(A1))[4]) == *(SK_U16 *)&(((SK_U8 *)(A2))[4])) && \
+	(*(SK_U32 *)&(((SK_U8 *)(A1))[0]) == *(SK_U32 *)&(((SK_U8 *)(A2))[0])))
+#endif	/* SK_ADDR_DWORD_COMPARE */
+#endif	/* SK_ADDR_EQUAL */
 
 /* typedefs *******************************************************************/
 
@@ -239,13 +271,13 @@
 
 /* ----- Public part (read-only) ----- */
 
-	SK_MAC_ADDR	CurrentMacAddress;		/* Current physical MAC Address. */
+	SK_MAC_ADDR	CurrentMacAddress;	/* Current physical MAC Address. */
 	SK_MAC_ADDR	PermanentMacAddress;	/* Permanent physical MAC Address. */
-	int			PromMode;				/* Promiscuous Mode. */
+	int		PromMode;		/* Promiscuous Mode. */
 
 /* ----- Private part ----- */
 
-	SK_MAC_ADDR	PreviousMacAddress;		/* Prev. phys. MAC Address. */
+	SK_MAC_ADDR	PreviousMacAddress;	/* Prev. phys. MAC Address. */
 	SK_BOOL		CurrentMacAddressSet;	/* CurrentMacAddress is set. */
 	SK_U8		Align01;
 
@@ -255,18 +287,20 @@
 	SK_U32		NextExactMatchDrv;
 	SK_MAC_ADDR	Exact[SK_ADDR_EXACT_MATCHES];
 	SK_FILTER64	InexactFilter;			/* For 64-bit hash register. */
+	SK_FILTER64	InexactRlmtFilter;		/* For 64-bit hash register. */
+	SK_FILTER64	InexactDrvFilter;		/* For 64-bit hash register. */
 } SK_ADDR_PORT;
 
 
 struct s_AddrNet {
 /* ----- Public part (read-only) ----- */
 
-	SK_MAC_ADDR		CurrentMacAddress;		/* Logical MAC Address. */
+	SK_MAC_ADDR		CurrentMacAddress;	/* Logical MAC Address. */
 	SK_MAC_ADDR		PermanentMacAddress;	/* Logical MAC Address. */
 
 /* ----- Private part ----- */
 
-	SK_U32			ActivePort;				/* View of module ADDR. */
+	SK_U32			ActivePort;		/* View of module ADDR. */
 	SK_BOOL			CurrentMacAddressSet;	/* CurrentMacAddress is set. */
 	SK_U8			Align01;
 	SK_U16			Align02;
@@ -294,38 +328,86 @@
 extern	int	SkAddrInit(
 	SK_AC	*pAC,
 	SK_IOC	IoC,
-	int		Level);
+	int	Level);
 
 extern	int	SkAddrMcClear(
 	SK_AC	*pAC,
 	SK_IOC	IoC,
 	SK_U32	PortNumber,
-	int		Flags);
+	int	Flags);
+
+extern	int	SkAddrXmacMcClear(
+	SK_AC	*pAC,
+	SK_IOC	IoC,
+	SK_U32	PortNumber,
+	int	Flags);
+
+extern	int	SkAddrGmacMcClear(
+	SK_AC	*pAC,
+	SK_IOC	IoC,
+	SK_U32	PortNumber,
+	int	Flags);
 
 extern	int	SkAddrMcAdd(
 	SK_AC		*pAC,
 	SK_IOC		IoC,
 	SK_U32		PortNumber,
 	SK_MAC_ADDR	*pMc,
-	int			Flags);
+	int		Flags);
+
+extern	int	SkAddrXmacMcAdd(
+	SK_AC		*pAC,
+	SK_IOC		IoC,
+	SK_U32		PortNumber,
+	SK_MAC_ADDR	*pMc,
+	int		Flags);
+
+extern	int	SkAddrGmacMcAdd(
+	SK_AC		*pAC,
+	SK_IOC		IoC,
+	SK_U32		PortNumber,
+	SK_MAC_ADDR	*pMc,
+	int		Flags);
 
 extern	int	SkAddrMcUpdate(
 	SK_AC	*pAC,
 	SK_IOC	IoC,
 	SK_U32	PortNumber);
 
+extern	int	SkAddrXmacMcUpdate(
+	SK_AC	*pAC,
+	SK_IOC	IoC,
+	SK_U32	PortNumber);
+
+extern	int	SkAddrGmacMcUpdate(
+	SK_AC	*pAC,
+	SK_IOC	IoC,
+	SK_U32	PortNumber);
+
 extern	int	SkAddrOverride(
 	SK_AC		*pAC,
 	SK_IOC		IoC,
 	SK_U32		PortNumber,
 	SK_MAC_ADDR	*pNewAddr,
-	int			Flags);
+	int		Flags);
 
 extern	int	SkAddrPromiscuousChange(
 	SK_AC	*pAC,
 	SK_IOC	IoC,
 	SK_U32	PortNumber,
-	int		NewPromMode);
+	int	NewPromMode);
+
+extern	int	SkAddrXmacPromiscuousChange(
+	SK_AC	*pAC,
+	SK_IOC	IoC,
+	SK_U32	PortNumber,
+	int	NewPromMode);
+
+extern	int	SkAddrGmacPromiscuousChange(
+	SK_AC	*pAC,
+	SK_IOC	IoC,
+	SK_U32	PortNumber,
+	int	NewPromMode);	
 
 extern	int	SkAddrSwap(
 	SK_AC	*pAC,
diff -ruN linux/drivers/net/sk98lin/h/skdebug.h linuxn/drivers/net/sk98lin/h/skdebug.h
--- linux/drivers/net/sk98lin/h/skdebug.h	Fri Sep 15 23:34:19 2000
+++ linuxn/drivers/net/sk98lin/h/skdebug.h	Tue May 20 12:17:40 2003
@@ -2,16 +2,16 @@
  *
  * Name:	skdebug.h
  * Project:	GEnesis, PCI Gigabit Ethernet Adapter
- * Version:	$Revision: 1.10 $
- * Date:	$Date: 1999/11/22 13:47:40 $
+ * Version:	$Revision: 1.13 $
+ * Date:	$Date: 2003/03/31 07:16:39 $
  * Purpose:	SK specific DEBUG support
  *
  ******************************************************************************/
 
 /******************************************************************************
  *
- *	(C)Copyright 1998,1999 SysKonnect,
- *	a business unit of Schneider & Koch & Co. Datensysteme GmbH.
+ *	(C)Copyright 1998-2002 SysKonnect.
+ *	(C)Copyright 2002-2003 Marvell.
  *
  *	This program is free software; you can redistribute it and/or modify
  *	it under the terms of the GNU General Public License as published by
@@ -26,6 +26,16 @@
  *
  * History:
  *	$Log: skdebug.h,v $
+ *	Revision 1.13  2003/03/31 07:16:39  mkarl
+ *	Corrected Copyright.
+ *	
+ *	Revision 1.12  2002/07/15 15:37:13  rschmidt
+ *	Power Management support
+ *	Editorial changes
+ *	
+ *	Revision 1.11  2002/04/25 11:04:39  rschmidt
+ *	Editorial changes
+ *	
  *	Revision 1.10  1999/11/22 13:47:40  cgoos
  *	Changed license header to GPL.
  *	
@@ -89,26 +99,25 @@
 
 #define SK_DBGMOD_MERR	0x00000001L	/* general module error indication */
 #define SK_DBGMOD_HWM	0x00000002L	/* Hardware init module */
-#define	SK_DBGMOD_RLMT	0x00000004L	/* RLMT module */
-#define	SK_DBGMOD_VPD	0x00000008L	/* VPD module */
-#define	SK_DBGMOD_I2C	0x00000010L	/* I2C module */
-#define	SK_DBGMOD_PNMI	0x00000020L	/* PNMI module */
-#define	SK_DBGMOD_CSUM	0x00000040L	/* CSUM module */
-#define	SK_DBGMOD_ADDR	0x00000080L	/* ADDR module */
+#define SK_DBGMOD_RLMT	0x00000004L	/* RLMT module */
+#define SK_DBGMOD_VPD	0x00000008L	/* VPD module */
+#define SK_DBGMOD_I2C	0x00000010L	/* I2C module */
+#define SK_DBGMOD_PNMI	0x00000020L	/* PNMI module */
+#define SK_DBGMOD_CSUM	0x00000040L	/* CSUM module */
+#define SK_DBGMOD_ADDR	0x00000080L	/* ADDR module */
 #define SK_DBGMOD_PECP	0x00000100L	/* PECP module */
+#define SK_DBGMOD_POWM	0x00000200L	/* Power Management module */
 
 /* Debug events */
 
-#define	SK_DBGCAT_INIT	0x00000001L	/* module/driver initialization */
-#define	SK_DBGCAT_CTRL	0x00000002L	/* controlling: add/rmv MCA/MAC
-					 * and other controls (IOCTL)
-					 */
-#define	SK_DBGCAT_ERR	0x00000004L	/* error handling paths */
-#define	SK_DBGCAT_TX	0x00000008L	/* transmit path */
-#define	SK_DBGCAT_RX	0x00000010L	/* receive path */
-#define	SK_DBGCAT_IRQ	0x00000020L	/* general IRQ handling */
-#define	SK_DBGCAT_QUEUE	0x00000040L	/* any queue management */
-#define	SK_DBGCAT_DUMP	0x00000080L	/* large data output e.g. hex dump */
-#define	SK_DBGCAT_FATAL	0x00000100L	/* large data output e.g. hex dump */
+#define SK_DBGCAT_INIT	0x00000001L	/* module/driver initialization */
+#define SK_DBGCAT_CTRL	0x00000002L	/* controlling devices */
+#define SK_DBGCAT_ERR	0x00000004L	/* error handling paths */
+#define SK_DBGCAT_TX	0x00000008L	/* transmit path */
+#define SK_DBGCAT_RX	0x00000010L	/* receive path */
+#define SK_DBGCAT_IRQ	0x00000020L	/* general IRQ handling */
+#define SK_DBGCAT_QUEUE	0x00000040L	/* any queue management */
+#define SK_DBGCAT_DUMP	0x00000080L	/* large data output e.g. hex dump */
+#define SK_DBGCAT_FATAL	0x00000100L	/* fatal error */
 
 #endif	/* __INC_SKDEBUG_H */
diff -ruN linux/drivers/net/sk98lin/h/skdrv1st.h linuxn/drivers/net/sk98lin/h/skdrv1st.h
--- linux/drivers/net/sk98lin/h/skdrv1st.h	Sat Aug  3 02:39:44 2002
+++ linuxn/drivers/net/sk98lin/h/skdrv1st.h	Tue May 20 12:17:55 2003
@@ -2,16 +2,15 @@
  *
  * Name:	skdrv1st.h
  * Project:	GEnesis, PCI Gigabit Ethernet Adapter
- * Version:	$Revision: 1.9.2.1 $
- * Date:	$Date: 2001/03/12 16:50:59 $
+ * Version:	$Revision: 1.11 $
+ * Date:	$Date: 2003/02/25 14:16:40 $
  * Purpose:	First header file for driver and all other modules
  *
  ******************************************************************************/
 
 /******************************************************************************
  *
- *	(C)Copyright 1998-2001 SysKonnect,
- *	a business unit of Schneider & Koch & Co. Datensysteme GmbH.
+ *	(C)Copyright 1998-2003 SysKonnect GmbH.
  *
  *	This program is free software; you can redistribute it and/or modify
  *	it under the terms of the GNU General Public License as published by
@@ -27,6 +26,15 @@
  * History:
  *
  *	$Log: skdrv1st.h,v $
+ *	Revision 1.11  2003/02/25 14:16:40  mlindner
+ *	Fix: Copyright statement
+ *	
+ *	Revision 1.10  2002/10/02 12:46:02  mlindner
+ *	Add: Support for Yukon
+ *	
+ *	Revision 1.9.2.2  2001/12/07 12:06:42  mlindner
+ *	Fix: malloc -> slab changes
+ *	
  *	Revision 1.9.2.1  2001/03/12 16:50:59  mlindner
  *	chg: kernel 2.4 adaption
  *	
@@ -84,6 +92,10 @@
 #ifndef __INC_SKDRV1ST_H
 #define __INC_SKDRV1ST_H
 
+/* Check kernel version */
+#include <linux/version.h>
+#if (LINUX_VERSION_CODE > 0x020300)
+#endif
 
 typedef struct s_AC	SK_AC;
 
@@ -116,7 +128,6 @@
 #include <linux/slab.h>
 #include <linux/interrupt.h>
 #include <linux/pci.h>
-#include <linux/crc32.h>
 #include <asm/byteorder.h>
 #include <asm/bitops.h>
 #include <asm/io.h>
@@ -140,6 +151,8 @@
 #define SK_BIG_ENDIAN
 #endif
 
+#define SK_NET_DEVICE	net_device
+
 
 /* we use gethrtime(), return unit: nanoseconds */
 #define SK_TICKS_PER_SEC	HZ
@@ -161,17 +174,17 @@
 #define SK_MEMCPY(dest,src,size)	memcpy(dest,src,size)
 #define SK_MEMCMP(s1,s2,size)		memcmp(s1,s2,size)
 #define SK_MEMSET(dest,val,size)	memset(dest,val,size)
-#define SK_STRLEN(pStr)			strlen((char*)pStr)
-#define SK_STRNCPY(pDest,pSrc,size)	strncpy((char*)pDest,(char*)pSrc,size)
-#define SK_STRCMP(pStr1,pStr2)		strcmp((char*)pStr1,(char*)pStr2)
+#define SK_STRLEN(pStr)			strlen((char*)(pStr))
+#define SK_STRNCPY(pDest,pSrc,size)	strncpy((char*)(pDest),(char*)(pSrc),size)
+#define SK_STRCMP(pStr1,pStr2)		strcmp((char*)(pStr1),(char*)(pStr2))
 
 /* macros to access the adapter */
-#define SK_OUT8(b,a,v)		writeb(v, (b+a))	
-#define SK_OUT16(b,a,v)		writew(v, (b+a))	
-#define SK_OUT32(b,a,v)		writel(v, (b+a))	
-#define SK_IN8(b,a,pv)		(*(pv) = readb(b+a))
-#define SK_IN16(b,a,pv)		(*(pv) = readw(b+a))
-#define SK_IN32(b,a,pv)		(*(pv) = readl(b+a))
+#define SK_OUT8(b,a,v)		writeb((v), ((b)+(a)))	
+#define SK_OUT16(b,a,v)		writew((v), ((b)+(a)))	
+#define SK_OUT32(b,a,v)		writel((v), ((b)+(a)))	
+#define SK_IN8(b,a,pv)		(*(pv) = readb((b)+(a)))
+#define SK_IN16(b,a,pv)		(*(pv) = readw((b)+(a)))
+#define SK_IN32(b,a,pv)		(*(pv) = readl((b)+(a)))
 
 #define int8_t		char
 #define int16_t		short
@@ -222,11 +235,11 @@
 #define SK_DBGCAT_DRV_INT_SRC		0x04000000
 #define SK_DBGCAT_DRV_EVENT		0x08000000
 
-#endif /* DEBUG */
+#endif
 
 #define SK_ERR_LOG		SkErrorLog
 
 extern void SkErrorLog(SK_AC*, int, int, char*);
 
-#endif /* __INC_SKDRV1ST_H */
+#endif
 
diff -ruN linux/drivers/net/sk98lin/h/skdrv2nd.h linuxn/drivers/net/sk98lin/h/skdrv2nd.h
--- linux/drivers/net/sk98lin/h/skdrv2nd.h	Wed Jul  4 20:50:39 2001
+++ linuxn/drivers/net/sk98lin/h/skdrv2nd.h	Tue May 20 12:17:54 2003
@@ -2,16 +2,15 @@
  *
  * Name:	skdrv2nd.h
  * Project:	GEnesis, PCI Gigabit Ethernet Adapter
- * Version:	$Revision: 1.12.2.1 $
- * Date:	$Date: 2001/03/12 16:50:59 $
+ * Version:	$Revision: 1.16 $
+ * Date:	$Date: 2003/03/21 14:56:18 $
  * Purpose:	Second header file for driver and all other modules
  *
  ******************************************************************************/
 
 /******************************************************************************
  *
- *	(C)Copyright 1998-2001 SysKonnect,
- *	a business unit of Schneider & Koch & Co. Datensysteme GmbH.
+ *	(C)Copyright 1998-2003 SysKonnect GmbH.
  *
  *	This program is free software; you can redistribute it and/or modify
  *	it under the terms of the GNU General Public License as published by
@@ -27,6 +26,21 @@
  * History:
  *
  *	$Log: skdrv2nd.h,v $
+ *	Revision 1.16  2003/03/21 14:56:18  rroesler
+ *	Added code regarding interrupt moderation
+ *	
+ *	Revision 1.15  2003/02/25 14:16:40  mlindner
+ *	Fix: Copyright statement
+ *	
+ *	Revision 1.14  2003/02/25 13:26:26  mlindner
+ *	Add: Support for various vendors
+ *	
+ *	Revision 1.13  2002/10/02 12:46:02  mlindner
+ *	Add: Support for Yukon
+ *	
+ *	Revision 1.12.2.2  2001/09/05 12:14:50  mlindner
+ *	add: New hardware revision int
+ *	
  *	Revision 1.12.2.1  2001/03/12 16:50:59  mlindner
  *	chg: kernel 2.4 adaption
  *	
@@ -111,7 +125,54 @@
 #include "h/skrlmt.h"
 #include "h/skgedrv.h"
 
-/* global function prototypes ******************************************/
+#define SK_PCI_ISCOMPLIANT(result, pdev) {     \
+    result = SK_FALSE; /* default */     \
+    /* 3Com (0x10b7) */     \
+    if (pdev->vendor == 0x10b7) {     \
+        /* Gigabit Ethernet Adapter (0x1700) */     \
+        if ((pdev->device == 0x1700)) { \
+            result = SK_TRUE;     \
+        }     \
+    /* SysKonnect (0x1148) */     \
+    } else if (pdev->vendor == 0x1148) {     \
+        /* SK-98xx Gigabit Ethernet Server Adapter (0x4300) */     \
+        /* SK-98xx V2.0 Gigabit Ethernet Adapter (0x4320) */     \
+        if ((pdev->device == 0x4300) || \
+            (pdev->device == 0x4320)) { \
+            result = SK_TRUE;     \
+        }     \
+    /* D-Link (0x1186) */     \
+    } else if (pdev->vendor == 0x1186) {     \
+        /* Gigabit Ethernet Adapter (0x4c00) */     \
+        if ((pdev->device == 0x4c00)) { \
+            result = SK_TRUE;     \
+        }     \
+    /* Marvell (0x11ab) */     \
+    } else if (pdev->vendor == 0x11ab) {     \
+        /* Gigabit Ethernet Adapter (0x4320) */     \
+        if ((pdev->device == 0x4320)) { \
+            result = SK_TRUE;     \
+        }     \
+    /* CNet (0x1371) */     \
+    } else if (pdev->vendor == 0x1371) {     \
+        /* GigaCard Network Adapter (0x434e) */     \
+        if ((pdev->device == 0x434e)) { \
+            result = SK_TRUE;     \
+        }     \
+    /* Linksys (0x1737) */     \
+    } else if (pdev->vendor == 0x1737) {     \
+        /* Gigabit Network Adapter (0x1032) */     \
+        /* Gigabit Network Adapter (0x1064) */     \
+        if ((pdev->device == 0x1032) || \
+            (pdev->device == 0x1064)) { \
+            result = SK_TRUE;     \
+        }     \
+    } else {     \
+        result = SK_FALSE;     \
+    }     \
+}
+
+
 extern SK_MBUF		*SkDrvAllocRlmtMbuf(SK_AC*, SK_IOC, unsigned);
 extern void		SkDrvFreeRlmtMbuf(SK_AC*, SK_IOC, SK_MBUF*);
 extern SK_U64		SkOsGetTime(SK_AC*);
@@ -191,6 +252,15 @@
 #define SK_DRIVER_SET_MTU(pAc,IoC,i,v)	0
 #define SK_DRIVER_PRESET_MTU(pAc,IoC,i,v)	0
 
+/*
+** Interim definition of SK_DRV_TIMER placed in this file until 
+** common modules have boon finallized
+*/
+#define SK_DRV_TIMER                   11 
+#define	SK_DRV_MODERATION_TIMER		1
+#define SK_DRV_MODERATION_TIMER_LENGTH  1000000  /* 1 second */
+#define SK_DRV_RX_CLEANUP_TIMER		2
+#define SK_DRV_RX_CLEANUP_TIMER_LENGTH	1000000	 /* 100 millisecs */
 
 /* TX and RX descriptors *****************************************************/
 
@@ -202,7 +272,7 @@
 	SK_U32		VDataLow;	/* Receive buffer Addr, low dword */
 	SK_U32		VDataHigh;	/* Receive buffer Addr, high dword */
 	SK_U32		FrameStat;	/* Receive Frame Status word */
-	SK_U32		TimeStamp;	/* Time stamp from XMAX */
+	SK_U32		TimeStamp;	/* Time stamp from XMAC */
 	SK_U32		TcpSums;	/* TCP Sum 2 / TCP Sum 1 */
 	SK_U32		TcpSumStarts;	/* TCP Sum Start 2 / TCP Sum Start 1 */
 	RXD		*pNextRxd;	/* Pointer to next Rxd */
@@ -218,7 +288,8 @@
 	SK_U32		VDataHigh;	/* Transmit Buffer Addr, high dword */
 	SK_U32		FrameStat;	/* Transmit Frame Status Word */
 	SK_U32		TcpSumOfs;	/* Reserved / TCP Sum Offset */
-	SK_U32		TcpSumStWr;	/* TCP Sum Start / TCP Sum Write */
+	SK_U16		TcpSumSt;	/* TCP Sum Start */
+	SK_U16		TcpSumWr;	/* TCP Sum Write */
 	SK_U32		TcpReserved;	/* not used */
 	TXD		*pNextTxd;	/* Pointer to next Txd */
 	struct sk_buff	*pMBuf;		/* Pointer to Linux' socket buffer */
@@ -416,6 +487,53 @@
 	int		PortIndex;	/* index number of port (0 or 1) */
 };
 
+#define IRQ_EOF_AS_TX     ((IRQ_EOF_AS_TX1) | (IRQ_EOF_AS_TX2))
+#define IRQ_EOF_SY_TX     ((IRQ_EOF_SY_TX1) | (IRQ_EOF_SY_TX2))
+#define IRQ_MASK_TX_ONLY  ((IRQ_EOF_AS_TX)  | (IRQ_EOF_SY_TX))
+#define IRQ_MASK_RX_ONLY  ((IRQ_EOF_RX1)    | (IRQ_EOF_RX2))
+#define IRQ_MASK_SP_ONLY  (SPECIAL_IRQS)
+#define IRQ_MASK_TX_RX    ((IRQ_MASK_TX_ONLY) | (IRQ_MASK_RX_ONLY))
+#define IRQ_MASK_SP_RX    ((SPECIAL_IRQS)     | (IRQ_MASK_RX_ONLY))
+#define IRQ_MASK_SP_TX    ((SPECIAL_IRQS)     | (IRQ_MASK_TX_ONLY))
+#define IRQ_MASK_RX_TX_SP ((SPECIAL_IRQS)     | (IRQ_MASK_TX_RX))
+ 
+#define C_INT_MOD_NONE                 1
+#define C_INT_MOD_STATIC               2
+#define C_INT_MOD_DYNAMIC              4
+
+#define C_CLK_FREQ_GENESIS      53215000 /* shorter: 53.125 MHz  */
+#define C_CLK_FREQ_YUKON        78215000 /* shorter: 78.125 MHz  */
+
+#define C_INTS_PER_SEC_DEFAULT      2000 
+#define C_INT_MOD_ENABLE_PERCENTAGE   50 /* if higher 50% enable */
+#define C_INT_MOD_DISABLE_PERCENTAGE  50 /* if lower 50% disable */
+
+typedef struct s_DynIrqModInfo  DIM_INFO;
+struct s_DynIrqModInfo {
+	unsigned long   PrevTimeVal;
+	unsigned int    PrevSysLoad;
+	unsigned int    PrevUsedTime;
+	unsigned int    PrevTotalTime;
+	int             PrevUsedDescrRatio;
+	int             NbrProcessedDescr;
+        SK_U64          PrevPort0RxIntrCts;
+        SK_U64          PrevPort1RxIntrCts;
+        SK_U64          PrevPort0TxIntrCts;
+        SK_U64          PrevPort1TxIntrCts;
+	SK_BOOL         ModJustEnabled;     /* Moderation just enabled yes/no */
+
+	int             MaxModIntsPerSec;            /* Moderation Threshold */
+	int             MaxModIntsPerSecUpperLimit;  /* Upper limit for DIM  */
+	int             MaxModIntsPerSecLowerLimit;  /* Lower limit for DIM  */
+
+	long            MaskIrqModeration;   /* ModIrqType (eg. 'TxRx')      */
+	SK_BOOL         DisplayStats;        /* Stats yes/no                 */
+	SK_BOOL         AutoSizing;          /* Resize DIM-timer on/off      */
+	int             IntModTypeSelect;    /* EnableIntMod (eg. 'dynamic') */
+
+	SK_TIMER        ModTimer; /* just some timer */
+};
+
 typedef struct s_PerStrm	PER_STRM;
 
 #define SK_ALLOC_IRQ	0x00000001
@@ -445,11 +563,11 @@
 	int		BoardLevel;	/* level of active hw init (0-2) */
 	char		DeviceStr[80];	/* adapter string from vpd */
 	SK_U32		AllocFlag;	/* flag allocation of resources */
-	struct pci_dev	PciDev;		/* for access to pci config space */
+	struct pci_dev	*PciDev;	/* for access to pci config space */
 	SK_U32		PciDevId;	/* pci device id */
-	struct net_device	*dev[2];		/* pointer to device struct */
+	struct SK_NET_DEVICE	*dev[2];	/* pointer to device struct */
 	char		Name[30];	/* driver name */
-	struct net_device	*Next;		/* link all devices (for clearing) */
+	struct SK_NET_DEVICE	*Next;		/* link all devices (for clearing) */
 	int		RxBufSize;	/* length of receive buffers */
         struct net_device_stats stats;	/* linux 'netstat -i' statistics */
 	int		Index;		/* internal board index number */
@@ -465,12 +583,12 @@
 					/*  addresses for this board */
 					/*  (may be more than HW can)*/
 
+	int		HWRevision;	/* Hardware revision */
 	int		ActivePort;	/* the active XMAC port */
 	int		MaxPorts;		/* number of activated ports */
 	int		TxDescrPerRing;	/* # of descriptors per tx ring */
 	int		RxDescrPerRing;	/* # of descriptors per rx ring */
 
-	
 	caddr_t		pDescrMem;	/* Pointer to the descriptor area */
 	dma_addr_t	pDescrMemDMA;	/* PCI DMA address of area */
 
@@ -483,6 +601,12 @@
 	SK_U32		CsOfs;		/* for checksum calculation */
 
 	SK_BOOL		CheckQueue;	/* check event queue soon */
+	SK_TIMER        DrvCleanupTimer;/* to check for pending descriptors */
+	DIM_INFO        DynIrqModInfo;  /* all data related to DIM */
+
+	/* Only for tests */
+	int		PortUp;
+	int		PortDown;
 };
 
 
diff -ruN linux/drivers/net/sk98lin/h/skerror.h linuxn/drivers/net/sk98lin/h/skerror.h
--- linux/drivers/net/sk98lin/h/skerror.h	Fri Sep 15 23:34:19 2000
+++ linuxn/drivers/net/sk98lin/h/skerror.h	Tue May 20 12:17:40 2003
@@ -2,16 +2,16 @@
  *
  * Name:	skerror.h
  * Project:	GEnesis, PCI Gigabit Ethernet Adapter
- * Version:	$Revision: 1.4 $
- * Date:	$Date: 1999/11/22 13:51:59 $
+ * Version:	$Revision: 1.6 $
+ * Date:	$Date: 2003/03/31 07:17:48 $
  * Purpose:	SK specific Error log support
  *
  ******************************************************************************/
 
 /******************************************************************************
  *
- *	(C)Copyright 1998,1999 SysKonnect,
- *	a business unit of Schneider & Koch & Co. Datensysteme GmbH.
+ *	(C)Copyright 1998-2002 SysKonnect.
+ *	(C)Copyright 2002-2003 Marvell.
  *
  *	This program is free software; you can redistribute it and/or modify
  *	it under the terms of the GNU General Public License as published by
@@ -26,6 +26,12 @@
  *
  * History:
  *	$Log: skerror.h,v $
+ *	Revision 1.6  2003/03/31 07:17:48  mkarl
+ *	Corrected Copyright.
+ *	
+ *	Revision 1.5  2002/04/25 11:05:10  rschmidt
+ *	Editorial changes
+ *	
  *	Revision 1.4  1999/11/22 13:51:59  cgoos
  *	Changed license header to GPL.
  *	
@@ -49,29 +55,29 @@
 #define _INC_SKERROR_H_
 
 /*
- * Define the Error Classes
+ * Define Error Classes
  */
-#define	SK_ERRCL_OTHER		(0)	/* Other error */
+#define	SK_ERRCL_OTHER		(0)		/* Other error */
 #define	SK_ERRCL_CONFIG		(1L<<0)	/* Configuration error */
 #define	SK_ERRCL_INIT		(1L<<1)	/* Initialization error */
-#define	SK_ERRCL_NORES		(1L<<2)	/* Out of resources error */
-#define	SK_ERRCL_SW		(1L<<3)	/* internal Software error */
-#define	SK_ERRCL_HW		(1L<<4)	/* Hardware failure */
+#define	SK_ERRCL_NORES		(1L<<2)	/* Out of Resources error */
+#define	SK_ERRCL_SW			(1L<<3)	/* Internal Software error */
+#define	SK_ERRCL_HW			(1L<<4)	/* Hardware Failure */
 #define	SK_ERRCL_COMM		(1L<<5)	/* Communication error */
 
 
 /*
- * Define Error code bases
+ * Define Error Code Bases
  */
-#define	SK_ERRBASE_RLMT		100	/* Base Error number for RLMT */
-#define	SK_ERRBASE_HWINIT	200	/* Base Error number for HWInit */
-#define	SK_ERRBASE_VPD		300	/* Base Error number for VPD */
-#define	SK_ERRBASE_PNMI		400	/* Base Error number for PNMI */
-#define	SK_ERRBASE_CSUM		500	/* Base Error number for Checksum */
-#define	SK_ERRBASE_SIRQ		600	/* Base Error number for Special IRQ */
-#define	SK_ERRBASE_I2C		700	/* Base Error number for i2C module */
-#define	SK_ERRBASE_QUEUE	800	/* Base Error number for Scheduler */
-#define	SK_ERRBASE_ADDR		900	/* Base Error number for Address mod. */
+#define	SK_ERRBASE_RLMT		 100	/* Base Error number for RLMT */
+#define	SK_ERRBASE_HWINIT	 200	/* Base Error number for HWInit */
+#define	SK_ERRBASE_VPD		 300	/* Base Error number for VPD */
+#define	SK_ERRBASE_PNMI		 400	/* Base Error number for PNMI */
+#define	SK_ERRBASE_CSUM		 500	/* Base Error number for Checksum */
+#define	SK_ERRBASE_SIRQ		 600	/* Base Error number for Special IRQ */
+#define	SK_ERRBASE_I2C		 700	/* Base Error number for I2C module */
+#define	SK_ERRBASE_QUEUE	 800	/* Base Error number for Scheduler */
+#define	SK_ERRBASE_ADDR		 900	/* Base Error number for Address module */
 #define SK_ERRBASE_PECP		1000    /* Base Error number for PECP */
 #define	SK_ERRBASE_DRV		1100	/* Base Error number for Driver */
 
diff -ruN linux/drivers/net/sk98lin/h/skgedrv.h linuxn/drivers/net/sk98lin/h/skgedrv.h
--- linux/drivers/net/sk98lin/h/skgedrv.h	Fri Sep 15 23:34:19 2000
+++ linuxn/drivers/net/sk98lin/h/skgedrv.h	Tue May 20 12:17:40 2003
@@ -2,16 +2,16 @@
  *
  * Name:	skgedrv.h
  * Project:	GEnesis, PCI Gigabit Ethernet Adapter
- * Version:	$Revision: 1.4 $
- * Date:	$Date: 1999/11/22 13:52:46 $
+ * Version:	$Revision: 1.8 $
+ * Date:	$Date: 2003/03/31 07:18:54 $
  * Purpose:	Interface with the driver
  *
  ******************************************************************************/
 
 /******************************************************************************
  *
- *	(C)Copyright 1998,1999 SysKonnect,
- *	a business unit of Schneider & Koch & Co. Datensysteme GmbH.
+ *	(C)Copyright 1998-2002 SysKonnect.
+ *	(C)Copyright 2002-2003 Marvell.
  *
  *	This program is free software; you can redistribute it and/or modify
  *	it under the terms of the GNU General Public License as published by
@@ -27,6 +27,19 @@
  * History:
  *
  *	$Log: skgedrv.h,v $
+ *	Revision 1.8  2003/03/31 07:18:54  mkarl
+ *	Corrected Copyright.
+ *	
+ *	Revision 1.7  2003/03/18 09:43:47  rroesler
+ *	Added new event for timer
+ *	
+ *	Revision 1.6  2002/07/15 15:38:01  rschmidt
+ *	Power Management support
+ *	Editorial changes
+ *	
+ *	Revision 1.5  2002/04/25 11:05:47  rschmidt
+ *	Editorial changes
+ *	
  *	Revision 1.4  1999/11/22 13:52:46  cgoos
  *	Changed license header to GPL.
  *	
@@ -49,17 +62,19 @@
 
 /*
  * Define the driver events.
- * Usually the events are defined by the destination module. In case of the
- * driver we put the definition of the events here.
+ * Usually the events are defined by the destination module.
+ * In case of the driver we put the definition of the events here.
  */
-#define SK_DRV_PORT_RESET	1	/* The port needs to be reset */
-#define SK_DRV_NET_UP   	2	/* The net is now operational */
-#define SK_DRV_NET_DOWN		3	/* The net is now down */
-#define	SK_DRV_SWITCH_SOFT	4	/* Ports switch with both links conn */
-#define	SK_DRV_SWITCH_HARD	5	/* Port switch due to link failure */
-#define	SK_DRV_RLMT_SEND	6	/* Send a RLMT packet */
-#define	SK_DRV_ADAP_FAIL	7	/* The whole adapter fails */
-#define	SK_DRV_PORT_FAIL	8	/* One port fails */
-#define	SK_DRV_SWITCH_INTERN	9	/* Port switch from driver to itself */
+#define SK_DRV_PORT_RESET		 1	/* The port needs to be reset */
+#define SK_DRV_NET_UP   		 2	/* The net is operational */
+#define SK_DRV_NET_DOWN			 3	/* The net is down */
+#define SK_DRV_SWITCH_SOFT		 4	/* Ports switch with both links connected */
+#define SK_DRV_SWITCH_HARD		 5	/* Port switch due to link failure */
+#define SK_DRV_RLMT_SEND		 6	/* Send a RLMT packet */
+#define SK_DRV_ADAP_FAIL		 7	/* The whole adapter fails */
+#define SK_DRV_PORT_FAIL		 8	/* One port fails */
+#define SK_DRV_SWITCH_INTERN	 9	/* Port switch by the driver itself */
+#define SK_DRV_POWER_DOWN		10	/* Power down mode */
+#define SK_DRV_TIMER			11	/* Timer for free use */
 
 #endif	/* __INC_SKGEDRV_H_ */
diff -ruN linux/drivers/net/sk98lin/h/skgehw.h linuxn/drivers/net/sk98lin/h/skgehw.h
--- linux/drivers/net/sk98lin/h/skgehw.h	Wed Jul  4 20:50:39 2001
+++ linuxn/drivers/net/sk98lin/h/skgehw.h	Tue May 20 12:17:40 2003
@@ -2,16 +2,16 @@
  *
  * Name:	skgehw.h
  * Project:	GEnesis, PCI Gigabit Ethernet Adapter
- * Version:	$Revision: 1.36 $
- * Date:	$Date: 2000/11/09 12:32:49 $
- * Purpose:	Defines and Macros for the Gigabit Ethernet Adapter Product
- *		Family
+ * Version:	$Revision: 1.51 $
+ * Date:	$Date: 2003/04/08 16:31:50 $
+ * Purpose:	Defines and Macros for the Gigabit Ethernet Adapter Product Family
  *
  ******************************************************************************/
 
 /******************************************************************************
  *
- *	(C)Copyright 1998-2000 SysKonnect GmbH.
+ *	(C)Copyright 1998-2002 SysKonnect.
+ *	(C)Copyright 2002-2003 Marvell.
  *
  *	This program is free software; you can redistribute it and/or modify
  *	it under the terms of the GNU General Public License as published by
@@ -26,6 +26,74 @@
  *
  * History:
  * $Log: skgehw.h,v $
+ * Revision 1.51  2003/04/08 16:31:50  rschmidt
+ * Added defines for new Chip IDs (YUKON-Lite, YUKON-LP)
+ * Editorial changes
+ *
+ * Revision 1.50  2003/03/31 07:29:45  mkarl
+ * Corrected Copyright.
+ * Editorial changes.
+ *
+ * Revision 1.49  2003/01/28 09:43:49  rschmidt
+ * Added defines for PCI-Spec. 2.3 IRQ
+ * Added defines for CLK_RUN (YUKON-Lite)
+ * Editorial changes
+ *
+ * Revision 1.48  2002/12/05 10:25:11  rschmidt
+ * Added defines for Half Duplex Burst Mode On/Off
+ * Added defines for Rx GMAC FIFO Flush feature
+ * Editorial changes
+ *
+ * Revision 1.47  2002/11/12 17:01:31  rschmidt
+ * Added defines for WOL_CTL_DEFAULT
+ * Editorial changes
+ *
+ * Revision 1.46  2002/10/14 14:47:57  rschmidt
+ * Corrected bit mask for HW self test results
+ * Added defines for WOL Registers
+ * Editorial changes
+ *
+ * Revision 1.45  2002/10/11 09:25:22  mkarl
+ * Added bit mask for HW self test results.
+ *
+ * Revision 1.44  2002/08/16 14:44:36  rschmidt
+ * Added define GPC_HWCFG_GMII_FIB for YUKON Fiber
+ *
+ * Revision 1.43  2002/08/12 13:31:50  rschmidt
+ * Corrected macros for GMAC Address Registers: GM_INADDR(),
+ * GM_OUTADDR(), GM_INHASH, GM_OUTHASH.
+ * Editorial changes
+ *
+ * Revision 1.42  2002/08/08 15:37:56  rschmidt
+ * Added defines for Power Management Capabilities
+ * Editorial changes
+ *
+ * Revision 1.41  2002/07/23 16:02:25  rschmidt
+ * Added macro WOL_REG() to access WOL reg. (HW-Bug in YUKON 1st rev.)
+ *
+ * Revision 1.40  2002/07/15 15:41:37  rschmidt
+ * Added new defines for Power Management Cap. & Control
+ * Editorial changes
+ *
+ * Revision 1.39  2002/06/10 09:37:07  rschmidt
+ * Added macros for the ADDR-Modul
+ *
+ * Revision 1.38  2002/06/05 08:15:19  rschmidt
+ * Added defines for WOL Registers
+ * Editorial changes
+ *
+ * Revision 1.37  2002/04/25 11:39:23  rschmidt
+ * Added new defines for PCI Our Register 1
+ * Added new registers and defines for YUKON (Rx FIFO, Tx FIFO,
+ * Time Stamp Timer, GMAC Control, GPHY Control,Link Control,
+ * GMAC IRQ Source and Mask, Wake-up Frame Pattern Match);
+ * Added new defines for Control/Status (VAUX available)
+ * Added Chip ID for YUKON
+ * Added define for descriptors with UDP ext. for YUKON
+ * Added macros to access the GMAC
+ * Added new Phy Type for Marvell 88E1011S (GPHY)
+ * Editorial changes
+ *
  * Revision 1.36  2000/11/09 12:32:49  rassmann
  * Renamed variables.
  *
@@ -36,7 +104,7 @@
  * Changed license header to GPL.
  *
  * Revision 1.33  1999/08/27 11:17:10  malthoff
- * It's more savely to put bracket around marco parameters.
+ * It's more savely to put brackets around macro parameters.
  * Brackets added for PHY_READ and PHY_WRITE.
  *
  * Revision 1.32  1999/05/19 07:31:01  cgoos
@@ -50,7 +118,7 @@
  * Add PCI_ERRBITS.
  *
  * Revision 1.29  1999/01/26 08:55:48  malthoff
- * Bugfix: The 16 bit field releations inside the descriptor are
+ * Bugfix: The 16 bit field relations inside the descriptor are
  * 	endianess dependend if the descriptor reversal feature
  * 	(PCI_REV_DESC bit in PCI_OUR_REG_2) is enabled.
  * 	Drivers which use this feature has to set the define
@@ -91,7 +159,7 @@
  * fix: typo B0_XM_IMSK regs
  *
  * Revision 1.18  1998/10/16 09:46:54  malthoff
- * Remove temp defines for ML diag prototyp.
+ * Remove temp defines for ML diag prototype.
  * Fix register definition for B0_XM1_PHY_DATA, B0_XM1_PHY_DATA
  * B0_XM2_PHY_DATA, B0_XM2_PHY_ADDR, B0_XA1_CSR, B0_XS1_CSR,
  * B0_XS2_CSR, and B0_XA2_CSR.
@@ -133,7 +201,7 @@
  *
  * Revision 1.10  1998/09/02 11:16:39  malthoff
  * Temporary modify B2_I2C_SW to make tests with
- * the GE/ML prototyp.
+ * the GE/ML prototype.
  *
  * Revision 1.9  1998/08/19 09:11:49  gklug
  * fix: struct are removed from c-source (see CCC)
@@ -145,7 +213,7 @@
  *
  * Revision 1.7  1998/07/03 14:42:26  malthoff
  * bug fix: Correct macro XMA().
- * Add temporary workaround to access the PCI config space over IO
+ * Add temporary workaround to access the PCI config space over I/O
  *
  * Revision 1.6  1998/06/23 11:30:36  malthoff
  * Remove ';' with ',' in macors.
@@ -174,38 +242,120 @@
 
 /* defines ********************************************************************/
 
+#define BIT_31		(1UL << 31)
+#define BIT_30		(1L << 30)
+#define BIT_29		(1L << 29)
+#define BIT_28		(1L << 28)
+#define BIT_27		(1L << 27)
+#define BIT_26		(1L << 26)
+#define BIT_25		(1L << 25)
+#define BIT_24		(1L << 24)
+#define BIT_23		(1L << 23)
+#define BIT_22		(1L << 22)
+#define BIT_21		(1L << 21)
+#define BIT_20		(1L << 20)
+#define BIT_19		(1L << 19)
+#define BIT_18		(1L << 18)
+#define BIT_17		(1L << 17)
+#define BIT_16		(1L << 16)
+#define BIT_15		(1L << 15)
+#define BIT_14		(1L << 14)
+#define BIT_13		(1L << 13)
+#define BIT_12		(1L << 12)
+#define BIT_11		(1L << 11)
+#define BIT_10		(1L << 10)
+#define BIT_9		(1L << 9)
+#define BIT_8		(1L << 8)
+#define BIT_7		(1L << 7)
+#define BIT_6		(1L << 6)
+#define BIT_5		(1L << 5)
+#define BIT_4		(1L << 4)
+#define BIT_3		(1L << 3)
+#define BIT_2		(1L << 2)
+#define BIT_1		(1L << 1)
+#define BIT_0		1L
+
+#define BIT_15S		(1U << 15)
+#define BIT_14S		(1 << 14)
+#define BIT_13S		(1 << 13)
+#define BIT_12S		(1 << 12)
+#define BIT_11S		(1 << 11)
+#define BIT_10S		(1 << 10)
+#define BIT_9S		(1 << 9)
+#define BIT_8S		(1 << 8)
+#define BIT_7S 		(1 << 7)
+#define BIT_6S		(1 << 6)
+#define BIT_5S		(1 << 5)
+#define BIT_4S		(1 << 4)
+#define BIT_3S		(1 << 3)
+#define BIT_2S		(1 << 2)
+#define BIT_1S		(1 << 1)
+#define BIT_0S		1
+
+#define SHIFT31(x)	((x) << 31)
+#define SHIFT30(x)	((x) << 30)
+#define SHIFT29(x)	((x) << 29)
+#define SHIFT28(x)	((x) << 28)
+#define SHIFT27(x)	((x) << 27)
+#define SHIFT26(x)	((x) << 26)
+#define SHIFT25(x)	((x) << 25)
+#define SHIFT24(x)	((x) << 24)
+#define SHIFT23(x)	((x) << 23)
+#define SHIFT22(x)	((x) << 22)
+#define SHIFT21(x)	((x) << 21)
+#define SHIFT20(x)	((x) << 20)
+#define SHIFT19(x)	((x) << 19)
+#define SHIFT18(x)	((x) << 18)
+#define SHIFT17(x)	((x) << 17)
+#define SHIFT16(x)	((x) << 16)
+#define SHIFT15(x)	((x) << 15)
+#define SHIFT14(x)	((x) << 14)
+#define SHIFT13(x)	((x) << 13)
+#define SHIFT12(x)	((x) << 12)
+#define SHIFT11(x)	((x) << 11)
+#define SHIFT10(x)	((x) << 10)
+#define SHIFT9(x)	((x) << 9)
+#define SHIFT8(x)	((x) << 8)
+#define SHIFT7(x)	((x) << 7)
+#define SHIFT6(x)	((x) << 6)
+#define SHIFT5(x)	((x) << 5)
+#define SHIFT4(x)	((x) << 4)
+#define SHIFT3(x)	((x) << 3)
+#define SHIFT2(x)	((x) << 2)
+#define SHIFT1(x)	((x) << 1)
+#define SHIFT0(x)	((x) << 0)
+
 /*
  * Configuration Space header
  * Since this module is used for different OS', those may be
  * duplicate on some of them (e.g. Linux). But to keep the
  * common source, we have to live with this...
  */
-#define	PCI_VENDOR_ID	0x00	/* 16 bit	Vendor ID */
-#define	PCI_DEVICE_ID	0x02	/* 16 bit	Device ID */
-#define	PCI_COMMAND		0x04	/* 16 bit	Command */
-#define	PCI_STATUS		0x06	/* 16 bit	Status */
-#define	PCI_REV_ID		0x08	/*  8 bit	Revision ID */
-#define	PCI_CLASS_CODE	0x09	/* 24 bit	Class Code */
-#define	PCI_CACHE_LSZ	0x0c	/*  8 bit	Cache Line Size */
-#define	PCI_LAT_TIM		0x0d	/*  8 bit	Latency Timer */
-#define	PCI_HEADER_T	0x0e	/*  8 bit	Header Type */
-#define	PCI_BIST		0x0f	/*  8 bit	Built-in selftest */
-#define	PCI_BASE_1ST	0x10	/* 32 bit	1st Base address */
-#define	PCI_BASE_2ND	0x14	/* 32 bit	2nd Base address */
-	/* Byte 18..2b:	reserved */
-#define	PCI_SUB_VID		0x2c	/* 16 bit	Subsystem Vendor ID */
-#define	PCI_SUB_ID		0x2e	/* 16 bit	Subsystem ID */
-#define	PCI_BASE_ROM	0x30	/* 32 bit	Expansion ROM Base Address */
-	/* Byte 34..33:	reserved */
+#define PCI_VENDOR_ID	0x00	/* 16 bit	Vendor ID */
+#define PCI_DEVICE_ID	0x02	/* 16 bit	Device ID */
+#define PCI_COMMAND		0x04	/* 16 bit	Command */
+#define PCI_STATUS		0x06	/* 16 bit	Status */
+#define PCI_REV_ID		0x08	/*  8 bit	Revision ID */
+#define PCI_CLASS_CODE	0x09	/* 24 bit	Class Code */
+#define PCI_CACHE_LSZ	0x0c	/*  8 bit	Cache Line Size */
+#define PCI_LAT_TIM		0x0d	/*  8 bit	Latency Timer */
+#define PCI_HEADER_T	0x0e	/*  8 bit	Header Type */
+#define PCI_BIST		0x0f	/*  8 bit	Built-in selftest */
+#define PCI_BASE_1ST	0x10	/* 32 bit	1st Base address */
+#define PCI_BASE_2ND	0x14	/* 32 bit	2nd Base address */
+	/* Byte 0x18..0x2b:	reserved */
+#define PCI_SUB_VID		0x2c	/* 16 bit	Subsystem Vendor ID */
+#define PCI_SUB_ID		0x2e	/* 16 bit	Subsystem ID */
+#define PCI_BASE_ROM	0x30	/* 32 bit	Expansion ROM Base Address */
 #define PCI_CAP_PTR		0x34	/*  8 bit 	Capabilities Ptr */
-	/* Byte 35..3b:	reserved */
-#define	PCI_IRQ_LINE	0x3c	/*  8 bit	Interrupt Line */
-#define	PCI_IRQ_PIN		0x3d	/*  8 bit	Interrupt Pin */
-#define	PCI_MIN_GNT		0x3e	/*  8 bit	Min_Gnt */
-#define	PCI_MAX_LAT		0x3f	/*  8 bit	Max_Lat */
+	/* Byte 0x35..0x3b:	reserved */
+#define PCI_IRQ_LINE	0x3c	/*  8 bit	Interrupt Line */
+#define PCI_IRQ_PIN		0x3d	/*  8 bit	Interrupt Pin */
+#define PCI_MIN_GNT		0x3e	/*  8 bit	Min_Gnt */
+#define PCI_MAX_LAT		0x3f	/*  8 bit	Max_Lat */
 	/* Device Dependent Region */
-#define	PCI_OUR_REG_1	0x40	/* 32 bit 	Our Register 1 */
-#define	PCI_OUR_REG_2	0x44	/* 32 bit 	Our Register 2 */
+#define PCI_OUR_REG_1	0x40	/* 32 bit 	Our Register 1 */
+#define PCI_OUR_REG_2	0x44	/* 32 bit 	Our Register 2 */
 	/* Power Management Region */
 #define PCI_PM_CAP_ID	0x48	/*  8 bit 	Power Management Cap. ID */
 #define PCI_PM_NITEM	0x49	/*  8 bit 	Next Item Ptr */
@@ -214,11 +364,13 @@
 	/* Byte 0x4e:	reserved */
 #define PCI_PM_DAT_REG	0x4f	/*  8 bit 	Power Manag. Data Register */
 	/* VPD Region */
-#define	PCI_VPD_CAP_ID	0x50	/*  8 bit 	VPD Cap. ID */
+#define PCI_VPD_CAP_ID	0x50	/*  8 bit 	VPD Cap. ID */
 #define PCI_VPD_NITEM	0x51	/*  8 bit 	Next Item Ptr */
 #define PCI_VPD_ADR_REG	0x52	/* 16 bit 	VPD Address Register */
 #define PCI_VPD_DAT_REG	0x54	/* 32 bit 	VPD Data Register */
-	/* Byte 58..ff:	reserved */
+	/* Byte 0x58..0x59:	reserved */
+#define PCI_SER_LD_CTRL	0x5a	/* 16 bit 	SEEPROM Loader Ctrl (YUKON only) */
+	/* Byte 0x5c..0xff:	reserved */
 
 /*
  * I2C Address (PCI Config)
@@ -226,43 +378,45 @@
  * Note: The temperature and voltage sensors are relocated on a different
  *	 I2C bus.
  */
-#define I2C_ADDR_VPD	0xA0	/* I2C address for the VPD EEPROM */
+#define I2C_ADDR_VPD	0xa0	/* I2C address for the VPD EEPROM */
 
 /*
  * Define Bits and Values of the registers
  */
-/*	PCI_VENDOR_ID	16 bit	Vendor ID */
-/*	PCI_DEVICE_ID	16 bit	Device ID */
-/* Values for Vendor ID and Device ID shall be patched into the code */
 /*	PCI_COMMAND	16 bit	Command */
-								/* Bit 15..10:	reserved */
-#define	PCI_FBTEN		(1<<9)	/* Bit 9:	Fast Back-To-Back enable */
-#define	PCI_SERREN		(1<<8)	/* Bit 8:	SERR enable */
-#define	PCI_ADSTEP		(1<<7)	/* Bit 7:	Address Stepping */
-#define	PCI_PERREN		(1<<6)	/* Bit 6:	Parity Report Response enable */
-#define	PCI_VGA_SNOOP	(1<<5)	/* Bit 5:	VGA palette snoop */
-#define	PCI_MWIEN		(1<<4)	/* Bit 4:	Memory write an inv cycl ena */
-#define	PCI_SCYCEN		(1<<3)	/* Bit 3:	Special Cycle enable */
-#define	PCI_BMEN		(1<<2)	/* Bit 2:	Bus Master enable */
-#define	PCI_MEMEN		(1<<1)	/* Bit 1:	Memory Space Access enable */
-#define	PCI_IOEN		(1<<0)	/* Bit 0:	IO Space Access enable */
+								/* Bit 15..11:	reserved */
+#define PCI_INT_DIS		BIT_10S		/* Interrupt INTx# disable (PCI 2.3) */
+#define PCI_FBTEN		BIT_9S		/* Fast Back-To-Back enable */
+#define PCI_SERREN		BIT_8S		/* SERR enable */
+#define PCI_ADSTEP		BIT_7S		/* Address Stepping */
+#define PCI_PERREN		BIT_6S		/* Parity Report Response enable */
+#define PCI_VGA_SNOOP	BIT_5S		/* VGA palette snoop */
+#define PCI_MWIEN		BIT_4S		/* Memory write an inv cycl ena */
+#define PCI_SCYCEN		BIT_3S		/* Special Cycle enable */
+#define PCI_BMEN		BIT_2S		/* Bus Master enable */
+#define PCI_MEMEN		BIT_1S		/* Memory Space Access enable */
+#define PCI_IOEN		BIT_0S		/* I/O Space Access enable */
+
+#define PCI_COMMAND_VAL	(PCI_FBTEN | PCI_SERREN | PCI_PERREN | PCI_MWIEN |\
+						 PCI_BMEN | PCI_MEMEN | PCI_IOEN)
 
 /*	PCI_STATUS	16 bit	Status */
-#define	PCI_PERR		(1<<15)	/* Bit 15:	Parity Error */
-#define	PCI_SERR		(1<<14)	/* Bit 14:	Signaled SERR */
-#define	PCI_RMABORT		(1<<13)	/* Bit 13:	Received Master Abort */
-#define	PCI_RTABORT		(1<<12)	/* Bit 12:	Received Target Abort */
+#define PCI_PERR		BIT_15S		/* Parity Error */
+#define PCI_SERR		BIT_14S		/* Signaled SERR */
+#define PCI_RMABORT		BIT_13S		/* Received Master Abort */
+#define PCI_RTABORT		BIT_12S		/* Received Target Abort */
 								/* Bit 11:	reserved */
-#define	PCI_DEVSEL		(3<<9)	/* Bit 10..9:	DEVSEL Timing */
-#define	PCI_DEV_FAST	(0<<9)	/*		fast */
-#define	PCI_DEV_MEDIUM	(1<<9)	/*		medium */
-#define	PCI_DEV_SLOW	(2<<9)	/*		slow */
-#define	PCI_DATAPERR	(1<<8)	/* Bit 8:	DATA Parity error detected */
-#define	PCI_FB2BCAP		(1<<7)	/* Bit 7:	Fast Back-to-Back Capability */
-#define	PCI_UDF			(1<<6)	/* Bit 6:	User Defined Features */
-#define PCI_66MHZCAP	(1<<5)	/* Bit 5:	66 MHz PCI bus clock capable */
-#define PCI_NEWCAP		(1<<4)	/* Bit 4:	New cap. list implemented */
-								/* Bit 3..0:	reserved */
+#define PCI_DEVSEL		(3<<9)		/* Bit 10.. 9:	DEVSEL Timing */
+#define PCI_DEV_FAST	(0<<9)		/*		fast */
+#define PCI_DEV_MEDIUM	(1<<9)		/*		medium */
+#define PCI_DEV_SLOW	(2<<9)		/*		slow */
+#define PCI_DATAPERR	BIT_8S		/* DATA Parity error detected */
+#define PCI_FB2BCAP		BIT_7S		/* Fast Back-to-Back Capability */
+#define PCI_UDF			BIT_6S		/* User Defined Features */
+#define PCI_66MHZCAP	BIT_5S		/* 66 MHz PCI bus clock capable */
+#define PCI_NEWCAP		BIT_4S		/* New cap. list implemented */
+#define PCI_INT_STAT	BIT_3S		/* Interrupt INTx# Status (PCI 2.3) */
+								/* Bit  2.. 0:	reserved */
 
 #define PCI_ERRBITS	(PCI_PERR | PCI_SERR | PCI_RMABORT | PCI_RTABORT |\
 			PCI_DATAPERR)
@@ -276,160 +430,167 @@
 /*	Possible values: 0,2,4,8,16,32,64,128	*/
 
 /*	PCI_HEADER_T	8 bit	Header Type */
-#define	PCI_HD_MF_DEV	(1<<7)	/* Bit 7:	0= single, 1= multi-func dev */
-#define	PCI_HD_TYPE		0x7f	/* Bit 6..0:	Header Layout 0= normal */
+#define PCI_HD_MF_DEV	BIT_7S	/* 0= single, 1= multi-func dev */
+#define PCI_HD_TYPE		0x7f	/* Bit 6..0:	Header Layout 0= normal */
 
 /*	PCI_BIST	8 bit	Built-in selftest */
 /*	Built-in Self test not supported (optional) */
 
 /*	PCI_BASE_1ST	32 bit	1st Base address */
-#define	PCI_MEMSIZE		0x4000L		/* use 16 kB Memory Base */
-#define	PCI_MEMBASE_MSK 0xffffc000L	/* Bit 31..14:	Memory Base Address */
-#define	PCI_MEMSIZE_MSK 0x00003ff0L	/* Bit 13.. 4:	Memory Size Req. */
-#define	PCI_PREFEN		(1L<<3)		/* Bit	3:	Prefetchable */
-#define	PCI_MEM_TYP		(3L<<2)		/* Bit	2.. 1:	Memory Type */
-#define	PCI_MEM32BIT	(0L<<1)		/* Base addr anywhere in 32 Bit range */
-#define	PCI_MEM1M		(1L<<1)		/* Base addr below 1 MegaByte */
-#define	PCI_MEM64BIT	(2L<<1)		/* Base addr anywhere in 64 Bit range */
-#define	PCI_MEMSPACE	(1L<<0)		/* Bit	0:	Memory Space Indic. */
+#define PCI_MEMSIZE		0x4000L		/* use 16 kB Memory Base */
+#define PCI_MEMBASE_MSK 0xffffc000L	/* Bit 31..14:	Memory Base Address */
+#define PCI_MEMSIZE_MSK 0x00003ff0L	/* Bit 13.. 4:	Memory Size Req. */
+#define PCI_PREFEN		BIT_3		/* Prefetchable */
+#define PCI_MEM_TYP		(3L<<2)		/* Bit	2.. 1:	Memory Type */
+#define PCI_MEM32BIT	(0L<<1)		/* Base addr anywhere in 32 Bit range */
+#define PCI_MEM1M		(1L<<1)		/* Base addr below 1 MegaByte */
+#define PCI_MEM64BIT	(2L<<1)		/* Base addr anywhere in 64 Bit range */
+#define PCI_MEMSPACE	BIT_0		/* Memory Space Indic. */
 
 /*	PCI_BASE_2ND	32 bit	2nd Base address */
-#define	PCI_IOBASE		0xffffff00L	/* Bit 31..8:	I/O Base address */
-#define	PCI_IOSIZE		0x000000fcL	/* Bit	7..2:	I/O Size Requirements */
+#define PCI_IOBASE		0xffffff00L	/* Bit 31.. 8:	I/O Base address */
+#define PCI_IOSIZE		0x000000fcL	/* Bit	7.. 2:	I/O Size Requirements */
 									/* Bit	1:	reserved */
-#define	PCI_IOSPACE		(1L<<0)		/* Bit	0:	I/O Space Indicator */
+#define PCI_IOSPACE		BIT_0		/* I/O Space Indicator */
 
 /*	PCI_BASE_ROM	32 bit	Expansion ROM Base Address */
-#define	PCI_ROMBASE		(0xfffeL<<17)	/* Bit 31..17:	ROM BASE address (1st)*/
-#define	PCI_ROMBASZ		(0x1cL<<14)	/* Bit 16..14:	Treat as BASE or SIZE */
-#define	PCI_ROMSIZE		(0x38L<<11)	/* Bit 13..11:	ROM Size Requirements */
+#define PCI_ROMBASE		0xfffe0000L	/* Bit 31..17:	ROM BASE address (1st)*/
+#define PCI_ROMBASZ		(0x1cL<<14)	/* Bit 16..14:	Treat as BASE or SIZE */
+#define PCI_ROMSIZE		(0x38L<<11)	/* Bit 13..11:	ROM Size Requirements */
 									/* Bit 10.. 1:	reserved */
-#define	PCI_ROMEN		(0x1L<<0)	/* Bit 0:	Address Decode enable */
+#define PCI_ROMEN		BIT_0		/* Address Decode enable */
 
 /* Device Dependent Region */
 /*	PCI_OUR_REG_1		32 bit	Our Register 1 */
-									/* Bit 31..26:	reserved */
-#define PCI_VIO			(1L<<25)	/* Bit 25:	PCI IO Voltage, */
-									/*		0 = 3.3V / 1 = 5V */
-#define	PCI_EN_BOOT		(1L<<24)	/* Bit 24:	Enable BOOT via ROM */
-									/*		1 = Don't boot wth ROM*/
-									/*		0 = Boot with ROM */
-#define	PCI_EN_IO		(1L<<23)	/* Bit 23:	Mapping to IO space */
-#define	PCI_EN_FPROM	(1L<<22)	/* Bit 22:	FLASH mapped to mem? */
-									/*		1 = Map Flash to Mem */
-									/*		0 = Disable addr. dec*/
-#define	PCI_PAGESIZE	(3L<<20)	/* Bit 21..20:	FLASH Page Size	*/
-#define	PCI_PAGE_16		(0L<<20)	/*		16 k pages	*/
-#define	PCI_PAGE_32K	(1L<<20)	/*		32 k pages	*/
-#define	PCI_PAGE_64K	(2L<<20)	/*		64 k pages	*/
-#define	PCI_PAGE_128K	(3L<<20)	/*		128 k pages	*/
+									/* Bit 31..29:	reserved */
+#define PCI_PHY_COMA	BIT_28		/* Set PHY to Coma Mode */
+#define PCI_TEST_CAL	BIT_27		/* Test PCI buffer calib. (YUKON only) */
+#define PCI_EN_CAL		BIT_26		/* Enable PCI buffer calib. (YUKON only) */
+#define PCI_VIO			BIT_25		/* PCI I/O Voltage, 0 = 3.3V, 1 = 5V */
+#define PCI_DIS_BOOT	BIT_24		/* Disable BOOT via ROM */
+#define PCI_EN_IO		BIT_23		/* Mapping to I/O space */
+#define PCI_EN_FPROM	BIT_22		/* Enable FLASH mapping to memory */
+									/*		1 = Map Flash to memory */
+									/*		0 = Disable addr. dec */
+#define PCI_PAGESIZE	(3L<<20)	/* Bit 21..20:	FLASH Page Size	*/
+#define PCI_PAGE_16		(0L<<20)	/*		16 k pages	*/
+#define PCI_PAGE_32K	(1L<<20)	/*		32 k pages	*/
+#define PCI_PAGE_64K	(2L<<20)	/*		64 k pages	*/
+#define PCI_PAGE_128K	(3L<<20)	/*		128 k pages	*/
 									/* Bit 19:	reserved	*/
-#define	PCI_PAGEREG		(7L<<16)	/* Bit 18..16:	Page Register	*/
-#define PCI_NOTAR		(1L<<15)	/* Bit 15:	No turnaround cycle */
-#define	PCI_FORCE_BE	(1L<<14)	/* Bit 14:	Assert all BEs on MR */
-#define	PCI_DIS_MRL		(1L<<13)	/* Bit 13:	Disable Mem R Line */
-#define	PCI_DIS_MRM		(1L<<12)	/* Bit 12:	Disable Mem R multip */
-#define	PCI_DIS_MWI		(1L<<11)	/* Bit 11:	Disable Mem W & inv */
-#define	PCI_DISC_CLS	(1L<<10)	/* Bit 10:	Disc: cacheLsz bound */
-#define	PCI_BURST_DIS	(1L<<9)		/* Bit	9:	Burst Disable */
-#define	PCI_DIS_PCI_CLK	(1L<<8)		/* Bit	8:	Disable PCI clock driv*/
-#define	PCI_SKEW_DAS	(0xfL<<4)	/* Bit	7..4:	Skew Ctrl, DAS Ext */
-#define	PCI_SKEW_BASE	(0xfL<<0)	/* Bit	3..0:	Skew Ctrl, Base	*/
+#define PCI_PAGEREG		(7L<<16)	/* Bit 18..16:	Page Register	*/
+#define PCI_NOTAR		BIT_15		/* No turnaround cycle */
+#define PCI_FORCE_BE	BIT_14		/* Assert all BEs on MR */
+#define PCI_DIS_MRL		BIT_13		/* Disable Mem Read Line */
+#define PCI_DIS_MRM		BIT_12		/* Disable Mem Read Multiple */
+#define PCI_DIS_MWI		BIT_11		/* Disable Mem Write & Invalidate */
+#define PCI_DISC_CLS	BIT_10		/* Disc: cacheLsz bound */
+#define PCI_BURST_DIS	BIT_9		/* Burst Disable */
+#define PCI_DIS_PCI_CLK	BIT_8		/* Disable PCI clock driving */
+#define PCI_SKEW_DAS	(0xfL<<4)	/* Bit	7.. 4:	Skew Ctrl, DAS Ext */
+#define PCI_SKEW_BASE	0xfL		/* Bit	3.. 0:	Skew Ctrl, Base	*/
 
 
 /*	PCI_OUR_REG_2		32 bit	Our Register 2 */
 #define PCI_VPD_WR_THR	(0xffL<<24)	/* Bit 31..24:	VPD Write Threshold */
-#define	PCI_DEV_SEL		(0x7fL<<17)	/* Bit 23..17:	EEPROM Device Select */
-#define	PCI_VPD_ROM_SZ	(7L<<14)	/* Bit 16..14:	VPD ROM Size	*/
+#define PCI_DEV_SEL		(0x7fL<<17)	/* Bit 23..17:	EEPROM Device Select */
+#define PCI_VPD_ROM_SZ	(7L<<14)	/* Bit 16..14:	VPD ROM Size	*/
 									/* Bit 13..12:	reserved	*/
-#define	PCI_PATCH_DIR	(0xfL<<8)	/* Bit 11.. 8:	Ext Patchs dir 3..0 */
-#define	PCI_PATCH_DIR_0	(1L<<8)
-#define	PCI_PATCH_DIR_1	(1L<<9)
-#define	PCI_PATCH_DIR_2	(1L<<10)
-#define	PCI_PATCH_DIR_3	(1L<<11)
-#define PCI_EXT_PATCHS	(0xfL<<4)	/* Bit	7..4:	Extended Patches 3..0 */
-#define	PCI_EXT_PATCH_0	(1L<<4)
-#define	PCI_EXT_PATCH_1	(1L<<5)
-#define	PCI_EXT_PATCH_2	(1L<<6)
-#define	PCI_EXT_PATCH_3	(1L<<7)
-#define	PCI_EN_DUMMY_RD	(1L<<3)		/* Bit	3:	Enable Dummy Read */
-#define PCI_REV_DESC	(1L<<2)		/* Bit	2:	Reverse Desc. Bytes */
+#define PCI_PATCH_DIR	(0xfL<<8)	/* Bit 11.. 8:	Ext Patches dir 3..0 */
+#define PCI_PATCH_DIR_3	BIT_11
+#define PCI_PATCH_DIR_2	BIT_10
+#define PCI_PATCH_DIR_1	BIT_9
+#define PCI_PATCH_DIR_0	BIT_8
+#define PCI_EXT_PATCHS	(0xfL<<4)	/* Bit	7.. 4:	Extended Patches 3..0 */
+#define PCI_EXT_PATCH_3	BIT_7
+#define PCI_EXT_PATCH_2	BIT_6
+#define PCI_EXT_PATCH_1	BIT_5
+#define PCI_EXT_PATCH_0	BIT_4
+#define PCI_EN_DUMMY_RD	BIT_3		/* Enable Dummy Read */
+#define PCI_REV_DESC	BIT_2		/* Reverse Desc. Bytes */
 									/* Bit	1:	reserved */
-#define PCI_USEDATA64	(1L<<0)		/* Bit	0:	Use 64Bit Data bus ext*/
+#define PCI_USEDATA64	BIT_0		/* Use 64Bit Data bus ext */
 
 
 /* Power Management Region */
 /*	PCI_PM_CAP_REG		16 bit	Power Management Capabilities */
-#define	PCI_PME_SUP		(0x1f<<11)	/* Bit 15..11:	PM Manag. Event Sup */
-#define PCI_PM_D2_SUB	(1<<10)		/* Bit 10:	D2 Support Bit */
-#define PCI_PM_D1_SUB	(1<<9)		/* Bit	9:	D1 Support Bit */
-									/* Bit	8..6:	reserved */
-#define PCI_PM_DSI		(1<<5)		/* Bit	5:	Device Specific Init.*/
-#define PCI_PM_APS		(1<<4)		/* Bit	4:	Auxialiary Power Src */
-#define PCI_PME_CLOCK	(1<<3)		/* Bit	3:	PM Event Clock */
-#define PCI_PM_VER		(7<<0)		/* Bit	2..0:	PM PCI Spec. version */
-
-/*	PCI_PM_CTL_STS		16 bit	Power Manag. Control/Status */
-#define	PCI_PME_STATUS	(1<<15)		/* Bit 15: 	PGA doesn't sup. PME# */
-#define PCI_PM_DAT_SCL	(3<<13)		/* Bit 14..13:	dat reg Scaling factor*/
-#define PCI_PM_DAT_SEL	(0xf<<9)	/* Bit 12.. 9:	PM data selector field*/
-#define PCI_PME_EN		(1<<8)		/* Bit	8:	PGA doesn't sup. PME# */
+#define PCI_PME_SUP_MSK	(0x1f<<11)	/* Bit 15..11:	PM Event Support Mask */
+#define PCI_PME_D3C_SUP	BIT_15S		/* PME from D3cold Support (if Vaux) */
+#define PCI_PME_D3H_SUP	BIT_14S		/* PME from D3hot Support */
+#define PCI_PME_D2_SUP	BIT_13S		/* PME from D2 Support */
+#define PCI_PME_D1_SUP	BIT_12S		/* PME from D1 Support */
+#define PCI_PME_D0_SUP	BIT_11S		/* PME from D0 Support */
+#define PCI_PM_D2_SUP	BIT_10S		/* D2 Support in 33 MHz mode */
+#define PCI_PM_D1_SUP	BIT_9S		/* D1 Support */
+									/* Bit	8.. 6:	reserved */
+#define PCI_PM_DSI		BIT_5S		/* Device Specific Initialization */
+#define PCI_PM_APS		BIT_4S		/* Auxialiary Power Source */
+#define PCI_PME_CLOCK	BIT_3S		/* PM Event Clock */
+#define PCI_PM_VER_MSK		7		/* Bit	2.. 0:	PM PCI Spec. version */
+
+/*	PCI_PM_CTL_STS		16 bit	Power Management Control/Status */
+#define PCI_PME_STATUS	BIT_15S		/* PME Status (YUKON only) */
+#define PCI_PM_DAT_SCL	(3<<13)		/* Bit 14..13:	Data Reg. scaling factor */
+#define PCI_PM_DAT_SEL	(0xf<<9)	/* Bit 12.. 9:	PM data selector field */
+#define PCI_PME_EN		BIT_8S		/* Enable PME# generation (YUKON only) */
 									/* Bit	7.. 2:	reserved */
-#define PCI_PM_STATE	(3<<0)		/* Bit	1.. 0:	Power Management State*/
-#define PCI_PM_STATE_D0	(0<<0)		/* D0:	Operational (default) */
-#define	PCI_PM_STATE_D1	(1<<0)		/* D1:	not supported */
-#define PCI_PM_STATE_D2	(2<<0)		/* D2:	not supported */
-#define PCI_PM_STATE_D3 (3<<0)		/* D3:	HOT, Power Down and Reset */
+#define PCI_PM_STATE_MSK	3		/* Bit	1.. 0:	Power Management State */
+
+#define PCI_PM_STATE_D0		0		/* D0:	Operational (default) */
+#define PCI_PM_STATE_D1		1		/* D1:	(YUKON only) */
+#define PCI_PM_STATE_D2		2		/* D2:	(YUKON only) */
+#define PCI_PM_STATE_D3 	3		/* D3:	HOT, Power Down and Reset */
 
 /* VPD Region */
 /*	PCI_VPD_ADR_REG		16 bit	VPD Address Register */
-#define	PCI_VPD_FLAG	(1L<<15)	/* Bit 15:	starts VPD rd/wd cycle*/
-#define PCI_VPD_ADDR	(0x3fffL<<0)	/* Bit 14..0:	VPD address */
+#define PCI_VPD_FLAG	BIT_15S		/* starts VPD rd/wr cycle */
+#define PCI_VPD_ADR_MSK	0x7fffL		/* Bit 14.. 0:	VPD address mask */
+
+/*	Control Register File (Address Map) */
 
 /*
- *	Control Register File:
  *	Bank 0
  */
-#define	B0_RAP			0x0000	/*  8 bit	Register Address Port */
+#define B0_RAP			0x0000	/*  8 bit	Register Address Port */
 	/* 0x0001 - 0x0003:	reserved */
-#define	B0_CTST			0x0004	/* 16 bit	Control/Status register */
-#define	B0_LED			0x0006	/*  8 Bit	LED register */
-	/* 0x0007:		reserved */
-#define	B0_ISRC			0x0008	/* 32 bit	Interrupt Source Register */
-#define	B0_IMSK			0x000c	/* 32 bit	Interrupt Mask Register */
+#define B0_CTST			0x0004	/* 16 bit	Control/Status register */
+#define B0_LED			0x0006	/*  8 Bit	LED register */
+#define B0_POWER_CTRL	0x0007	/*  8 Bit	Power Control reg (YUKON only) */
+#define B0_ISRC			0x0008	/* 32 bit	Interrupt Source Register */
+#define B0_IMSK			0x000c	/* 32 bit	Interrupt Mask Register */
 #define B0_HWE_ISRC		0x0010	/* 32 bit	HW Error Interrupt Src Reg */
 #define B0_HWE_IMSK		0x0014	/* 32 bit	HW Error Interrupt Mask Reg */
 #define B0_SP_ISRC		0x0018	/* 32 bit	Special Interrupt Source Reg */
 	/* 0x001c:		reserved */
 
-/* B0 XMAC 1 registers */
-#define	B0_XM1_IMSK		0x0020	/* 16 bit r/w	XMAC 1 Interrupt Mask Register*/
-	/* 0x0022 - 0x0027	reserved */
+/* B0 XMAC 1 registers (GENESIS only) */
+#define B0_XM1_IMSK		0x0020	/* 16 bit r/w	XMAC 1 Interrupt Mask Register*/
+	/* 0x0022 - 0x0027:	reserved */
 #define B0_XM1_ISRC		0x0028	/* 16 bit ro	XMAC 1 Interrupt Status Reg */
-	/* 0x002a - 0x002f	reserved */
+	/* 0x002a - 0x002f:	reserved */
 #define B0_XM1_PHY_ADDR 0x0030	/* 16 bit r/w	XMAC 1 PHY Address Register */
-	/* 0x0032 - 0x0033	reserved */
+	/* 0x0032 - 0x0033:	reserved */
 #define B0_XM1_PHY_DATA 0x0034	/* 16 bit r/w	XMAC 1 PHY Data Register */
-	/* 0x0036 - 0x003f	reserved */
+	/* 0x0036 - 0x003f:	reserved */
 
-/* B0 XMAC 2 registers */
-#define	B0_XM2_IMSK		0x0040	/* 16 bit r/w	XMAC 2 Interrupt Mask Register*/
-	/* 0x0042 - 0x0047	reserved */
+/* B0 XMAC 2 registers (GENESIS only) */
+#define B0_XM2_IMSK		0x0040	/* 16 bit r/w	XMAC 2 Interrupt Mask Register*/
+	/* 0x0042 - 0x0047:	reserved */
 #define B0_XM2_ISRC		0x0048	/* 16 bit ro	XMAC 2 Interrupt Status Reg */
-	/* 0x004a - 0x004f	reserved */
+	/* 0x004a - 0x004f:	reserved */
 #define B0_XM2_PHY_ADDR 0x0050	/* 16 bit r/w	XMAC 2 PHY Address Register */
-	/* 0x0052 - 0x0053	reserved */
+	/* 0x0052 - 0x0053:	reserved */
 #define B0_XM2_PHY_DATA 0x0054	/* 16 bit r/w	XMAC 2 PHY Data Register */
-				/* 0x0056 - 0x005f	reserved */
+	/* 0x0056 - 0x005f:	reserved */
 
 /* BMU Control Status Registers */
-#define	B0_R1_CSR		0x0060	/* 32 bit	BMU Ctrl/Stat Rx Queue 1 */
-#define	B0_R2_CSR		0x0064	/* 32 bit	BMU Ctrl/Stat Rx Queue 2 */
-#define	B0_XS1_CSR		0x0068	/* 32 bit	BMU Ctrl/Stat Sync Tx Queue 1 */
-#define	B0_XA1_CSR		0x006c	/* 32 bit	BMU Ctrl/Stat Async Tx Queue 1*/
-#define	B0_XS2_CSR		0x0070	/* 32 bit	BMU Ctrl/Stat Sync Tx Queue 2 */
-#define	B0_XA2_CSR		0x0074	/* 32 bit	BMU Ctrl/Stat Async Tx Queue 2*/
-	/* x0078 - 0x007f	reserved */
+#define B0_R1_CSR		0x0060	/* 32 bit	BMU Ctrl/Stat Rx Queue 1 */
+#define B0_R2_CSR		0x0064	/* 32 bit	BMU Ctrl/Stat Rx Queue 2 */
+#define B0_XS1_CSR		0x0068	/* 32 bit	BMU Ctrl/Stat Sync Tx Queue 1 */
+#define B0_XA1_CSR		0x006c	/* 32 bit	BMU Ctrl/Stat Async Tx Queue 1*/
+#define B0_XS2_CSR		0x0070	/* 32 bit	BMU Ctrl/Stat Sync Tx Queue 2 */
+#define B0_XA2_CSR		0x0074	/* 32 bit	BMU Ctrl/Stat Async Tx Queue 2*/
+	/* 0x0078 - 0x007f:	reserved */
 
 /*
  *	Bank 1
@@ -441,20 +602,19 @@
  *	Bank 2
  */
 /* NA reg = 48 bit Network Address Register, 3x16 or 8x8 bit readable */
-
-#define	B2_MAC_1		0x0100	/* NA reg	 MAC Address 1 */
-	/* 0x0106 - 0x0107	reserved */
-#define	B2_MAC_2		0x0108	/* NA reg	 MAC Address 2 */
-	/* 0x010e - 0x010f	reserved */
-#define	B2_MAC_3		0x0110	/* NA reg	 MAC Address 3 */
-	/* 0x0116 - 0x0117	reserved */
+#define B2_MAC_1		0x0100	/* NA reg	 MAC Address 1 */
+	/* 0x0106 - 0x0107:	reserved */
+#define B2_MAC_2		0x0108	/* NA reg	 MAC Address 2 */
+	/* 0x010e - 0x010f:	reserved */
+#define B2_MAC_3		0x0110	/* NA reg	 MAC Address 3 */
+	/* 0x0116 - 0x0117:	reserved */
 #define B2_CONN_TYP		0x0118	/*  8 bit	Connector type */
 #define B2_PMD_TYP		0x0119	/*  8 bit	PMD type */
-#define B2_MAC_CFG		0x011a	/*  8 bit	MAC Configuration */
-#define B2_CHIP_REV		0x011b	/*  8 bit 	Queen Chip Revision Number */
+#define B2_MAC_CFG		0x011a	/*  8 bit	MAC Configuration / Chip Revision */
+#define B2_CHIP_ID		0x011b	/*  8 bit 	Chip Identification Number */
 	/* Eprom registers are currently of no use */
-#define B2_E_0			0x011c	/*  8 bit	EPROM Byte 0 */
-#define B2_E_1			0x011d	/*  8 bit	EPROM Byte 1 */
+#define B2_E_0			0x011c	/*  8 bit	EPROM Byte 0 (ext. SRAM size */
+#define B2_E_1			0x011d	/*  8 bit	EPROM Byte 1 (PHY type) */
 #define B2_E_2			0x011e	/*  8 bit	EPROM Byte 2 */
 #define B2_E_3			0x011f	/*  8 bit	EPROM Byte 3 */
 #define B2_FAR			0x0120	/* 32 bit	Flash-Prom Addr Reg/Cnt */
@@ -463,9 +623,9 @@
 #define B2_LD_CRTL		0x0128	/*  8 bit	EPROM loader control register */
 #define B2_LD_TEST		0x0129	/*  8 bit	EPROM loader test register */
 	/* 0x012a - 0x012f:	reserved */
-#define B2_TI_INI		0x0130	/* 32 bit	Timer init value */
-#define B2_TI_VAL		0x0134	/* 32 bit	Timer value */
-#define B2_TI_CRTL		0x0138	/*  8 bit	Timer control */
+#define B2_TI_INI		0x0130	/* 32 bit	Timer Init Value */
+#define B2_TI_VAL		0x0134	/* 32 bit	Timer Value */
+#define B2_TI_CRTL		0x0138	/*  8 bit	Timer Control */
 #define B2_TI_TEST		0x0139	/*  8 Bit	Timer Test */
 	/* 0x013a - 0x013f:	reserved */
 #define B2_IRQM_INI		0x0140	/* 32 bit	IRQ Moderation Timer Init Reg.*/
@@ -475,14 +635,16 @@
 #define B2_IRQM_MSK 	0x014c	/* 32 bit	IRQ Moderation Mask */
 #define B2_IRQM_HWE_MSK 0x0150	/* 32 bit	IRQ Moderation HW Error Mask */
 	/* 0x0154 - 0x0157:	reserved */
-#define	B2_TST_CTRL1	0x0158	/*  8 bit	Test Control Register 1 */
+#define B2_TST_CTRL1	0x0158	/*  8 bit	Test Control Register 1 */
 #define B2_TST_CTRL2	0x0159	/*  8 bit	Test Control Register 2 */
 	/* 0x015a - 0x015b:	reserved */
-#define B2_GP_IO		0x015c	/* 32 bit	General Purpose IO Register */
+#define B2_GP_IO		0x015c	/* 32 bit	General Purpose I/O Register */
 #define B2_I2C_CTRL		0x0160	/* 32 bit	I2C HW Control Register */
 #define B2_I2C_DATA		0x0164	/* 32 bit	I2C HW Data Register */
 #define B2_I2C_IRQ		0x0168	/* 32 bit	I2C HW IRQ Register */
 #define B2_I2C_SW		0x016c	/* 32 bit	I2C SW Port Register */
+
+/* Blink Source Counter (GENESIS only) */
 #define B2_BSC_INI		0x0170	/* 32 bit	Blink Source Counter Init Val */
 #define B2_BSC_VAL		0x0174	/* 32 bit	Blink Source Counter Value */
 #define B2_BSC_CTRL		0x0178	/*  8 bit	Blink Source Counter Control */
@@ -493,66 +655,70 @@
 /*
  *	Bank 3
  */
+/* RAM Random Registers */
 #define B3_RAM_ADDR		0x0180	/* 32 bit	RAM Address, to read or write */
 #define B3_RAM_DATA_LO	0x0184	/* 32 bit	RAM Data Word (low dWord) */
 #define B3_RAM_DATA_HI	0x0188	/* 32 bit	RAM Data Word (high dWord) */
 	/* 0x018c - 0x018f:	reserved */
+
 /* RAM Interface Registers */
 /*
- * The HW-Spec. call this registers Timeout Value 0..11. But this names are
+ * The HW-Spec. calls this registers Timeout Value 0..11. But this names are
  * not usable in SW. Please notice these are NOT real timeouts, these are
- * the number of qWords transfered continously.
+ * the number of qWords transferred continuously.
  */
-#define B3_RI_WTO_R1	0x0190	/* 8 bit RAM Iface WR Timeout Queue R1	(TO0) */
-#define B3_RI_WTO_XA1	0x0191	/* 8 bit RAM Iface WR Timeout Queue XA1	(TO1) */
-#define B3_RI_WTO_XS1	0x0192	/* 8 bit RAM Iface WR Timeout Queue XS1 (TO2) */
-#define B3_RI_RTO_R1	0x0193	/* 8 bit RAM Iface RD Timeout Queue R1	(TO3) */
-#define B3_RI_RTO_XA1	0x0194	/* 8 bit RAM Iface RD Timeout Queue XA1	(TO4) */
-#define B3_RI_RTO_XS1	0x0195	/* 8 bit RAM Iface RD Timeout Queue XS1	(TO5) */
-#define B3_RI_WTO_R2	0x0196	/* 8 bit RAM Iface WR Timeout Queue R2	(TO6) */
-#define B3_RI_WTO_XA2	0x0197	/* 8 bit RAM Iface WR Timeout Queue XA2	(TO7) */
-#define B3_RI_WTO_XS2	0x0198	/* 8 bit RAM Iface WR Timeout Queue XS2	(TO8) */
-#define B3_RI_RTO_R2	0x0199	/* 8 bit RAM Iface RD Timeout Queue R2	(TO9) */
-#define B3_RI_RTO_XA2	0x019a	/* 8 bit RAM Iface RD Timeout Queue XA2	(TO10)*/
-#define B3_RI_RTO_XS2	0x019b	/* 8 bit RAM Iface RD Timeout Queue XS2	(TO11)*/
-#define B3_RI_TO_VAL	0x019c	/* 8 bit RAM Iface Current Timeout Count Val */
-	/* 0x019d - 0x019f	reserved */
-#define B3_RI_CTRL		0x01a0	/* 16 bit	RAM Iface Control Register */
-#define B3_RI_TEST		0x01a2	/*  8 bit	RAM Iface Test Register */
-	/* 0x01a3 - 0x01af	reserved */
-/* MAC Arbiter Registers */
-/* Please notice these are the number of qWord tranfered continously and */
-/* NOT real timeouts */
-#define B3_MA_TOINI_RX1	0x01b0	/* 8 bit Timeout Init Value Rx Path MAC 1 */
-#define B3_MA_TOINI_RX2	0x01b1	/* 8 bit Timeout Init Value Rx Path MAC 2 */
-#define B3_MA_TOINI_TX1	0x01b2	/* 8 bit Timeout Init Value Tx Path MAC 1 */
-#define B3_MA_TOINI_TX2	0x01b3	/* 8 bit Timeout Init Value Tx Path MAC 2 */
-#define B3_MA_TOVAL_RX1	0x01b4	/* 8 bit Timeout Value Rx Path MAC 1 */
-#define B3_MA_TOVAL_RX2	0x01b5	/* 8 bit Timeout Value Rx Path MAC 1 */
-#define B3_MA_TOVAL_TX1	0x01b6	/* 8 bit Timeout Value Tx Path MAC 2 */
-#define B3_MA_TOVAL_TX2	0x01b7	/* 8 bit Timeout Value Tx Path MAC 2 */
+#define B3_RI_WTO_R1	0x0190	/*  8 bit	WR Timeout Queue R1		(TO0) */
+#define B3_RI_WTO_XA1	0x0191	/*  8 bit	WR Timeout Queue XA1	(TO1) */
+#define B3_RI_WTO_XS1	0x0192	/*  8 bit	WR Timeout Queue XS1	(TO2) */
+#define B3_RI_RTO_R1	0x0193	/*  8 bit	RD Timeout Queue R1		(TO3) */
+#define B3_RI_RTO_XA1	0x0194	/*  8 bit	RD Timeout Queue XA1	(TO4) */
+#define B3_RI_RTO_XS1	0x0195	/*  8 bit	RD Timeout Queue XS1	(TO5) */
+#define B3_RI_WTO_R2	0x0196	/*  8 bit	WR Timeout Queue R2		(TO6) */
+#define B3_RI_WTO_XA2	0x0197	/*  8 bit	WR Timeout Queue XA2	(TO7) */
+#define B3_RI_WTO_XS2	0x0198	/*  8 bit	WR Timeout Queue XS2	(TO8) */
+#define B3_RI_RTO_R2	0x0199	/*  8 bit	RD Timeout Queue R2		(TO9) */
+#define B3_RI_RTO_XA2	0x019a	/*  8 bit	RD Timeout Queue XA2	(TO10)*/
+#define B3_RI_RTO_XS2	0x019b	/*  8 bit	RD Timeout Queue XS2	(TO11)*/
+#define B3_RI_TO_VAL	0x019c	/*  8 bit	Current Timeout Count Val */
+	/* 0x019d - 0x019f:	reserved */
+#define B3_RI_CTRL		0x01a0	/* 16 bit	RAM Interface Control Register */
+#define B3_RI_TEST		0x01a2	/*  8 bit	RAM Interface Test Register */
+	/* 0x01a3 - 0x01af:	reserved */
+
+/* MAC Arbiter Registers (GENESIS only) */
+/* these are the no. of qWord transferred continuously and NOT real timeouts */
+#define B3_MA_TOINI_RX1	0x01b0	/*  8 bit	Timeout Init Val Rx Path MAC 1 */
+#define B3_MA_TOINI_RX2	0x01b1	/*  8 bit	Timeout Init Val Rx Path MAC 2 */
+#define B3_MA_TOINI_TX1	0x01b2	/*  8 bit	Timeout Init Val Tx Path MAC 1 */
+#define B3_MA_TOINI_TX2	0x01b3	/*  8 bit	Timeout Init Val Tx Path MAC 2 */
+#define B3_MA_TOVAL_RX1	0x01b4	/*  8 bit	Timeout Value Rx Path MAC 1 */
+#define B3_MA_TOVAL_RX2	0x01b5	/*  8 bit	Timeout Value Rx Path MAC 1 */
+#define B3_MA_TOVAL_TX1	0x01b6	/*  8 bit	Timeout Value Tx Path MAC 2 */
+#define B3_MA_TOVAL_TX2	0x01b7	/*  8 bit	Timeout Value Tx Path MAC 2 */
 #define B3_MA_TO_CTRL	0x01b8	/* 16 bit	MAC Arbiter Timeout Ctrl Reg */
 #define B3_MA_TO_TEST	0x01ba	/* 16 bit	MAC Arbiter Timeout Test Reg */
-	/* 0x01bc - 0x01bf	reserved */
-#define B3_MA_RCINI_RX1	0x01c0	/* 8 bit Recovery Init Value Rx Path MAC 1 */
-#define B3_MA_RCINI_RX2	0x01c1	/* 8 bit Recovery Init Value Rx Path MAC 2 */
-#define B3_MA_RCINI_TX1	0x01c2	/* 8 bit Recovery Init Value Tx Path MAC 1 */
-#define B3_MA_RCINI_TX2	0x01c3	/* 8 bit Recovery Init Value Tx Path MAC 2 */
-#define B3_MA_RCVAL_RX1	0x01c4	/* 8 bit Recovery Value Rx Path MAC 1 */
-#define B3_MA_RCVAL_RX2	0x01c5	/* 8 bit Recovery Value Rx Path MAC 1 */
-#define B3_MA_RCVAL_TX1	0x01c6	/* 8 bit Recovery Value Tx Path MAC 2 */
-#define B3_MA_RCVAL_TX2	0x01c7	/* 8 bit Recovery Value Tx Path MAC 2 */
+	/* 0x01bc - 0x01bf:	reserved */
+#define B3_MA_RCINI_RX1	0x01c0	/*  8 bit	Recovery Init Val Rx Path MAC 1 */
+#define B3_MA_RCINI_RX2	0x01c1	/*  8 bit	Recovery Init Val Rx Path MAC 2 */
+#define B3_MA_RCINI_TX1	0x01c2	/*  8 bit	Recovery Init Val Tx Path MAC 1 */
+#define B3_MA_RCINI_TX2	0x01c3	/*  8 bit	Recovery Init Val Tx Path MAC 2 */
+#define B3_MA_RCVAL_RX1	0x01c4	/*  8 bit	Recovery Value Rx Path MAC 1 */
+#define B3_MA_RCVAL_RX2	0x01c5	/*  8 bit	Recovery Value Rx Path MAC 1 */
+#define B3_MA_RCVAL_TX1	0x01c6	/*  8 bit	Recovery Value Tx Path MAC 2 */
+#define B3_MA_RCVAL_TX2	0x01c7	/*  8 bit	Recovery Value Tx Path MAC 2 */
 #define B3_MA_RC_CTRL	0x01c8	/* 16 bit	MAC Arbiter Recovery Ctrl Reg */
 #define B3_MA_RC_TEST	0x01ca	/* 16 bit	MAC Arbiter Recovery Test Reg */
-	/* 0x01cc - 0x01cf	reserved */
-/* Packet Arbiter Registers, This are real timeouts */
-#define B3_PA_TOINI_RX1	0x01d0	/* 16 bit	Timeout Init Val Rx Path MAC 1*/
+	/* 0x01cc - 0x01cf:	reserved */
+
+/* Packet Arbiter Registers (GENESIS only) */
+/* these are real timeouts */
+#define B3_PA_TOINI_RX1	0x01d0	/* 16 bit	Timeout Init Val Rx Path MAC 1 */
 	/* 0x01d2 - 0x01d3:	reserved */
-#define B3_PA_TOINI_RX2	0x01d4	/* 16 bit	Timeout Init Val Rx Path MAC 2*/
+#define B3_PA_TOINI_RX2	0x01d4	/* 16 bit	Timeout Init Val Rx Path MAC 2 */
 	/* 0x01d6 - 0x01d7:	reserved */
-#define B3_PA_TOINI_TX1	0x01d8	/* 16 bit	Timeout Init Val Tx Path MAC 1*/
+#define B3_PA_TOINI_TX1	0x01d8	/* 16 bit	Timeout Init Val Tx Path MAC 1 */
 	/* 0x01da - 0x01db:	reserved */
-#define B3_PA_TOINI_TX2	0x01dc	/* 16 bit	Timeout Init Val Tx Path MAC 2*/
+#define B3_PA_TOINI_TX2	0x01dc	/* 16 bit	Timeout Init Val Tx Path MAC 2 */
 	/* 0x01de - 0x01df:	reserved */
 #define B3_PA_TOVAL_RX1	0x01e0	/* 16 bit	Timeout Val Rx Path MAC 1 */
 	/* 0x01e2 - 0x01e3:	reserved */
@@ -569,8 +735,7 @@
 /*
  *	Bank 4 - 5
  */
-
-/* Transmit Arbiter Registers MAC 1 and 2, user MR_ADDR() to address */
+/* Transmit Arbiter Registers MAC 1 and 2, use MR_ADDR() to access */
 #define TXA_ITI_INI		0x0200	/* 32 bit	Tx Arb Interval Timer Init Val*/
 #define TXA_ITI_VAL		0x0204	/* 32 bit	Tx Arb Interval Timer Value */
 #define TXA_LIM_INI		0x0208	/* 32 bit	Tx Arb Limit Counter Init Val */
@@ -579,11 +744,13 @@
 #define TXA_TEST		0x0211	/*  8 bit	Tx Arbiter Test Register */
 #define TXA_STAT		0x0212	/*  8 bit	Tx Arbiter Status Register */
 	/* 0x0213 - 0x027f:	reserved */
+	/* 0x0280 - 0x0292:	MAC 2 */
+	/* 0x0213 - 0x027f:	reserved */
 
 /*
  *	Bank 6
  */
-/* External registers */
+/* External registers (GENESIS only) */
 #define B6_EXT_REG		0x0300
 
 /*
@@ -596,7 +763,7 @@
  *	Bank 8 - 15
  */
 /* Receive and Transmit Queue Registers, use Q_ADDR() to access */
-#define	B8_Q_REGS		0x0400
+#define B8_Q_REGS		0x0400
 
 /* Queue Register Offsets, use Q_ADDR() to access */
 #define Q_D		0x00	/* 8*32	bit	Current Descriptor */
@@ -620,254 +787,376 @@
  *	Bank 16 - 23
  */
 /* RAM Buffer Registers */
-#define	B16_RAM_REGS	0x0800
+#define B16_RAM_REGS	0x0800
 
-/* RAM Buffer Register Offsets */
-/* use RB_ADDR(Queue,Offs) to address */
-#define RB_START	0x00	/* 32 bit	RAM Buffer Start Address */
-#define RB_END		0x04	/* 32 bit	RAM Buffer End Address */
-#define RB_WP		0x08	/* 32 bit	RAM Buffer Write Pointer */
-#define RB_RP		0x0c	/* 32 bit	RAM Buffer Read Pointer */
-#define RB_RX_UTPP	0x10	/* 32 bit	Rx Upper Threshold, Pause Pack*/
-#define RB_RX_LTPP	0x14	/* 32 bit	Rx Lower Threshold, Pause Pack*/
-#define RB_RX_UTHP	0x18	/* 32 bit	Rx Upper Threshold, High Prio */
-#define RB_RX_LTHP	0x1c	/* 32 bit	Rx Lower Threshold, High Prio */
-	/* 0x10 - 0x1f:		reserved for Tx RAM Buffer Registers */
-#define RB_PC		0x20	/* 32 bit	RAM Buffer Packet Counter */
-#define RB_LEV		0x24	/* 32 bit	RAM Buffer Level Register */
-#define RB_CTRL		0x28	/*  8 bit	RAM Buffer Control Register */
-#define RB_TST1		0x29	/*  8 bit	RAM Buffer Test Register 1 */
-#define RB_TST2		0x2A	/*  8 bit	RAM Buffer Test Register 2 */
-	/* 0x2c - 0x7f:		reserved */
+/* RAM Buffer Register Offsets, use RB_ADDR() to access */
+#define RB_START		0x00	/* 32 bit	RAM Buffer Start Address */
+#define RB_END			0x04	/* 32 bit	RAM Buffer End Address */
+#define RB_WP			0x08	/* 32 bit	RAM Buffer Write Pointer */
+#define RB_RP			0x0c	/* 32 bit	RAM Buffer Read Pointer */
+#define RB_RX_UTPP		0x10	/* 32 bit	Rx Upper Threshold, Pause Pack */
+#define RB_RX_LTPP		0x14	/* 32 bit	Rx Lower Threshold, Pause Pack */
+#define RB_RX_UTHP		0x18	/* 32 bit	Rx Upper Threshold, High Prio */
+#define RB_RX_LTHP		0x1c	/* 32 bit	Rx Lower Threshold, High Prio */
+	/* 0x10 - 0x1f:	reserved at Tx RAM Buffer Registers */
+#define RB_PC			0x20	/* 32 bit	RAM Buffer Packet Counter */
+#define RB_LEV			0x24	/* 32 bit	RAM Buffer Level Register */
+#define RB_CTRL			0x28	/*  8 bit	RAM Buffer Control Register */
+#define RB_TST1			0x29	/*  8 bit	RAM Buffer Test Register 1 */
+#define RB_TST2			0x2A	/*  8 bit	RAM Buffer Test Register 2 */
+	/* 0x2c - 0x7f:	reserved */
 
 /*
- *	Bank 24 - 25
+ *	Bank 24
+ */
+/*
+ * Receive MAC FIFO, Receive LED, and Link_Sync regs (GENESIS only)
+ * use MR_ADDR() to access
  */
-/* Receive MAC FIFO, Receive LED, and Link Sync regs, use MR_ADDR() to address*/
 #define RX_MFF_EA		0x0c00	/* 32 bit	Receive MAC FIFO End Address */
-#define RX_MFF_WP		0x0c04	/* 32 bit 	Receive MAC FIFO Write Pointer*/
-	/* 0x0c08 - 0x0c0b	reserved */
+#define RX_MFF_WP		0x0c04	/* 32 bit 	Receive MAC FIFO Write Pointer */
+	/* 0x0c08 - 0x0c0b:	reserved */
 #define RX_MFF_RP		0x0c0c	/* 32 bit	Receive MAC FIFO Read Pointer */
 #define RX_MFF_PC		0x0c10	/* 32 bit	Receive MAC FIFO Packet Cnt */
 #define RX_MFF_LEV		0x0c14	/* 32 bit	Receive MAC FIFO Level */
 #define RX_MFF_CTRL1	0x0c18	/* 16 bit	Receive MAC FIFO Control Reg 1*/
 #define RX_MFF_STAT_TO	0x0c1a	/*  8 bit	Receive MAC Status Timeout */
-#define RX_MFF_TIST_TO	0x0c1b	/*  8 bit	Receive MAC Timestamp Timeout */
+#define RX_MFF_TIST_TO	0x0c1b	/*  8 bit	Receive MAC Time Stamp Timeout */
 #define RX_MFF_CTRL2	0x0c1c	/*  8 bit	Receive MAC FIFO Control Reg 2*/
 #define RX_MFF_TST1		0x0c1d	/*  8 bit	Receive MAC FIFO Test Reg 1 */
 #define RX_MFF_TST2		0x0c1e	/*  8 bit	Receive MAC FIFO Test Reg 2 */
-	/* 0x0c1f		reserved */
+	/* 0x0c1f:	reserved */
 #define RX_LED_INI		0x0c20	/* 32 bit	Receive LED Cnt Init Value */
 #define RX_LED_VAL		0x0c24	/* 32 bit	Receive LED Cnt Current Value */
 #define RX_LED_CTRL		0x0c28	/*  8 bit	Receive LED Cnt Control Reg */
 #define RX_LED_TST		0x0c29	/*  8 bit	Receive LED Cnt Test Register */
-	/* 0x0c2a - 0x0c2f	reserved */
+	/* 0x0c2a - 0x0c2f:	reserved */
 #define LNK_SYNC_INI	0x0c30	/* 32 bit	Link Sync Cnt Init Value */
 #define LNK_SYNC_VAL	0x0c34	/* 32 bit	Link Sync Cnt Current Value */
-#define LNK_SYNC_CTRL	0x0c38	/*  8 bit	Link Sync Cnt Control Register*/
+#define LNK_SYNC_CTRL	0x0c38	/*  8 bit	Link Sync Cnt Control Register */
 #define LNK_SYNC_TST	0x0c39	/*  8 bit	Link Sync Cnt Test Register */
-	/* 0x0c3a - 0x0c3b	reserved */
+	/* 0x0c3a - 0x0c3b:	reserved */
 #define LNK_LED_REG		0x0c3c	/*  8 bit	Link LED Register */
-	/* 0x0c3d - 0x0c7f	reserved */
+	/* 0x0c3d - 0x0c3f:	reserved */
+
+/* Receive GMAC FIFO (YUKON only), use MR_ADDR() to access */
+#define RX_GMF_EA		0x0c40	/* 32 bit	Rx GMAC FIFO End Address */
+#define RX_GMF_AF_THR	0x0c44	/* 32 bit	Rx GMAC FIFO Almost Full Thresh. */
+#define RX_GMF_CTRL_T	0x0c48	/* 32 bit	Rx GMAC FIFO Control/Test */
+#define RX_GMF_FL_MSK	0x0c4c	/* 32 bit	Rx GMAC FIFO Flush Mask */
+#define RX_GMF_FL_THR	0x0c50	/* 32 bit	Rx GMAC FIFO Flush Threshold */
+	/* 0x0c54 - 0x0c5f:	reserved */
+#define RX_GMF_WP		0x0c60	/* 32 bit 	Rx GMAC FIFO Write Pointer */
+	/* 0x0c64 - 0x0c67:	reserved */
+#define RX_GMF_WLEV		0x0c68	/* 32 bit 	Rx GMAC FIFO Write Level */
+	/* 0x0c6c - 0x0c6f:	reserved */
+#define RX_GMF_RP		0x0c70	/* 32 bit 	Rx GMAC FIFO Read Pointer */
+	/* 0x0c74 - 0x0c77:	reserved */
+#define RX_GMF_RLEV		0x0c78	/* 32 bit 	Rx GMAC FIFO Read Level */
+	/* 0x0c7c - 0x0c7f:	reserved */
 
 /*
- *	Bank 26 - 27
+ *	Bank 25
+ */
+	/* 0x0c80 - 0x0cbf:	MAC 2 */
+	/* 0x0cc0 - 0x0cff:	reserved */
+
+/*
+ *	Bank 26
+ */
+/*
+ * Transmit MAC FIFO and Transmit LED Registers (GENESIS only),
+ * use MR_ADDR() to access
  */
-/* Transmit MAC FIFO and Transmit LED Registers, use MR_ADDR() to address */
 #define TX_MFF_EA		0x0d00	/* 32 bit	Transmit MAC FIFO End Address */
 #define TX_MFF_WP		0x0d04	/* 32 bit 	Transmit MAC FIFO WR Pointer */
-#define TX_MFF_WSP		0x0d08	/* 32 bit	Transmit MAC FIFO WR Shadow Pt*/
+#define TX_MFF_WSP		0x0d08	/* 32 bit	Transmit MAC FIFO WR Shadow Ptr */
 #define TX_MFF_RP		0x0d0c	/* 32 bit	Transmit MAC FIFO RD Pointer */
 #define TX_MFF_PC		0x0d10	/* 32 bit	Transmit MAC FIFO Packet Cnt */
 #define TX_MFF_LEV		0x0d14	/* 32 bit	Transmit MAC FIFO Level */
 #define TX_MFF_CTRL1	0x0d18	/* 16 bit	Transmit MAC FIFO Ctrl Reg 1 */
-#define TX_MFF_WAF		0x0d1a	/*  8 bit	Transmit MAC Wait after flush*/
-	/* 0x0c1b		reserved */
+#define TX_MFF_WAF		0x0d1a	/*  8 bit	Transmit MAC Wait after flush */
+	/* 0x0c1b:	reserved */
 #define TX_MFF_CTRL2	0x0d1c	/*  8 bit	Transmit MAC FIFO Ctrl Reg 2 */
 #define TX_MFF_TST1		0x0d1d	/*  8 bit	Transmit MAC FIFO Test Reg 1 */
 #define TX_MFF_TST2		0x0d1e	/*  8 bit	Transmit MAC FIFO Test Reg 2 */
-	/* 0x0d1f		reserved */
+	/* 0x0d1f:	reserved */
 #define TX_LED_INI		0x0d20	/* 32 bit	Transmit LED Cnt Init Value */
 #define TX_LED_VAL		0x0d24	/* 32 bit	Transmit LED Cnt Current Val */
 #define TX_LED_CTRL		0x0d28	/*  8 bit	Transmit LED Cnt Control Reg */
-#define TX_LED_TST		0x0d29	/*  8 bit	Transmit LED Cnt Test Register*/
-	/* 0x0d2a - 0x0d7f	reserved */
+#define TX_LED_TST		0x0d29	/*  8 bit	Transmit LED Cnt Test Reg */
+	/* 0x0d2a - 0x0d3f:	reserved */
+
+/* Transmit GMAC FIFO (YUKON only), use MR_ADDR() to access */
+#define TX_GMF_EA		0x0d40	/* 32 bit	Tx GMAC FIFO End Address */
+#define TX_GMF_AE_THR	0x0d44	/* 32 bit	Tx GMAC FIFO Almost Empty Thresh.*/
+#define TX_GMF_CTRL_T	0x0d48	/* 32 bit	Tx GMAC FIFO Control/Test */
+	/* 0x0d4c - 0x0d5f:	reserved */
+#define TX_GMF_WP		0x0d60	/* 32 bit 	Tx GMAC FIFO Write Pointer */
+#define TX_GMF_WSP		0x0d64	/* 32 bit 	Tx GMAC FIFO Write Shadow Ptr. */
+#define TX_GMF_WLEV		0x0d68	/* 32 bit 	Tx GMAC FIFO Write Level */
+	/* 0x0d6c - 0x0d6f:	reserved */
+#define TX_GMF_RP		0x0d70	/* 32 bit 	Tx GMAC FIFO Read Pointer */
+#define TX_GMF_RSTP		0x0d74	/* 32 bit 	Tx GMAC FIFO Restart Pointer */
+#define TX_GMF_RLEV		0x0d78	/* 32 bit 	Tx GMAC FIFO Read Level */
+	/* 0x0d7c - 0x0d7f:	reserved */
+
+/*
+ *	Bank 27
+ */
+	/* 0x0d80 - 0x0dbf:	MAC 2 */
+	/* 0x0daa - 0x0dff:	reserved */
 
 /*
  *	Bank 28
  */
 /* Descriptor Poll Timer Registers */
-#define B28_DPT_INI		0x0e00	/* 32 bit	Descriptor Poll Timer Init Val*/
-#define B28_DPT_VAL		0x0e04	/* 32 bit	Descriptor Poll Timer Curr Val*/
-#define B28_DPT_CTRL	0x0e08	/*  8 bit	Descriptor Poll Timer Ctrl Reg*/
-	/* 0x0e09:		reserved */
-#define B28_DPT_TST		0x0e0a	/*  8 bit	Descriptor Poll Timer Test Reg*/
-	/* 0x0e0b - 0x0e8f:	reserved */
+#define B28_DPT_INI		0x0e00	/* 24 bit	Descriptor Poll Timer Init Val */
+#define B28_DPT_VAL		0x0e04	/* 24 bit	Descriptor Poll Timer Curr Val */
+#define B28_DPT_CTRL	0x0e08	/*  8 bit	Descriptor Poll Timer Ctrl Reg */
+	/* 0x0e09:	reserved */
+#define B28_DPT_TST		0x0e0a	/*  8 bit	Descriptor Poll Timer Test Reg */
+	/* 0x0e0b:	reserved */
+
+/* Time Stamp Timer Registers (YUKON only) */
+	/* 0x0e10:	reserved */
+#define GMAC_TI_ST_VAL	0x0e14	/* 32 bit	Time Stamp Timer Curr Val */
+#define GMAC_TI_ST_CTRL	0x0e18	/*  8 bit	Time Stamp Timer Ctrl Reg */
+	/* 0x0e19:	reserved */
+#define GMAC_TI_ST_TST	0x0e1a	/*  8 bit	Time Stamp Timer Test Reg */
+	/* 0x0e1b - 0x0e7f:	reserved */
 
 /*
- *	Bank 29 - 31
+ *	Bank 29
  */
-/* 0x0e90 - 0x0fff:	reserved */
+	/* 0x0e80 - 0x0efc:	reserved */
 
 /*
- *	Bank 0x20 - 0x3f
+ *	Bank 30
  */
-/* 0x1000 - 0x1fff:	reserved */
+/* GMAC and GPHY Control Registers (YUKON only) */
+#define GMAC_CTRL		0x0f00	/* 32 bit	GMAC Control Reg */
+#define GPHY_CTRL		0x0f04	/* 32 bit	GPHY Control Reg */
+#define GMAC_IRQ_SRC	0x0f08	/*  8 bit	GMAC Interrupt Source Reg */
+	/* 0x0f09 - 0x0f0b:	reserved */
+#define GMAC_IRQ_MSK	0x0f0c	/*  8 bit	GMAC Interrupt Mask Reg */
+	/* 0x0f0d - 0x0f0f:	reserved */
+#define GMAC_LINK_CTRL	0x0f10	/* 16 bit	Link Control Reg */
+	/* 0x0f14 - 0x0f1f:	reserved */
+
+/* Wake-up Frame Pattern Match Control Registers (YUKON only) */
+
+#define WOL_REG_OFFS	0x20	/* HW-Bug: Address is + 0x20 against spec. */
+
+#define WOL_CTRL_STAT	0x0f20	/* 16 bit	WOL Control/Status Reg */
+#define WOL_MATCH_CTL	0x0f22	/*  8 bit	WOL Match Control Reg */
+#define WOL_MATCH_RES	0x0f23	/*  8 bit	WOL Match Result Reg */
+#define WOL_MAC_ADDR_LO	0x0f24	/* 32 bit	WOL MAC Address Low */
+#define WOL_MAC_ADDR_HI	0x0f28	/* 16 bit	WOL MAC Address High */
+#define WOL_PATT_RPTR	0x0f2c	/*  8 bit	WOL Pattern Read Ptr */
+
+/* use this macro to access above registers */
+#define WOL_REG(Reg)	((Reg) + (pAC->GIni.GIWolOffs))
+
+
+/* WOL Pattern Length Registers (YUKON only) */
+
+#define WOL_PATT_LEN_LO	0x0f30		/* 32 bit	WOL Pattern Length 3..0 */
+#define WOL_PATT_LEN_HI	0x0f34		/* 24 bit	WOL Pattern Length 6..4 */
+
+/* WOL Pattern Counter Registers (YUKON only) */
+
+#define WOL_PATT_CNT_0	0x0f38		/* 32 bit	WOL Pattern Counter 3..0 */
+#define WOL_PATT_CNT_4	0x0f3c		/* 24 bit	WOL Pattern Counter 6..4 */
+	/* 0x0f40 - 0x0f7f:	reserved */
+
+/*
+ *	Bank 31
+ */
+/* 0x0f80 - 0x0fff:	reserved */
+
+/*
+ *	Bank 32	- 33
+ */
+#define WOL_PATT_RAM_1	0x1000	/*  WOL Pattern RAM Link 1 */
+
+/*
+ *	Bank 0x22 - 0x3f
+ */
+/* 0x1100 - 0x1fff:	reserved */
 
 /*
  *	Bank 0x40 - 0x4f
  */
-/* XMAC 1 registers */
-#define B40_XMAC1	0x2000
+#define BASE_XMAC_1		0x2000	/* XMAC 1 registers */
 
 /*
  *	Bank 0x50 - 0x5f
  */
-/* 0x2800 - 0x2fff:	reserved */
+
+#define BASE_GMAC_1		0x2800	/* GMAC 1 registers */
 
 /*
  *	Bank 0x60 - 0x6f
  */
-/* XMAC 2 registers */
-#define B40_XMAC2	0x3000
+#define BASE_XMAC_2		0x3000	/* XMAC 2 registers */
 
 /*
  *	Bank 0x70 - 0x7f
  */
-/* 0x3800 - 0x3fff:	reserved */
+#define BASE_GMAC_2		0x3800	/* GMAC 2 registers */
 
 /*
  *	Control Register Bit Definitions:
  */
 /*	B0_RAP		8 bit	Register Address Port */
-				/* Bit 7:	reserved */
-#define	RAP_RAP			0x3f	/* Bit 6..0:	0 = block 0, .., 6f = block 6f*/
+								/* Bit 7:	reserved */
+#define RAP_RAP			0x3f	/* Bit 6..0:	0 = block 0,..,6f = block 6f */
 
 /*	B0_CTST		16 bit	Control/Status register */
-				/* Bit 15..10:	reserved */
-#define CS_BUS_CLOCK	(1<<9)	/* Bit	9:	Bus Clock 0/1 = 33/66MHz */
-#define CS_BUS_SLOT_SZ	(1<<8)	/* Bit	8:	Slot Size 0/1 = 32/64 bit slot*/
-#define CS_ST_SW_IRQ	(1<<7)	/* Bit	7:	Set IRQ SW Request	*/
-#define CS_CL_SW_IRQ	(1<<6)	/* Bit	6:	Clear IRQ SW Request	*/
-#define CS_STOP_DONE	(1<<5)	/* Bit	5:	Stop Master is finished */
-#define	CS_STOP_MAST	(1<<4)	/* Bit	4:	Command Bit to stop the master*/
-#define	CS_MRST_CLR		(1<<3)	/* Bit	3:	Clear Master reset	*/
-#define	CS_MRST_SET		(1<<2)	/* Bit	2:	Set Master reset	*/
-#define	CS_RST_CLR		(1<<1)	/* Bit	1:	Clear Software reset	*/
-#define	CS_RST_SET		(1<<0)	/* Bit	0:	Set Software reset	*/
+								/* Bit 15..14:	reserved */
+#define CS_CLK_RUN_HOT	BIT_13S		/* CLK_RUN hot m. (YUKON-Lite only) */
+#define CS_CLK_RUN_RST	BIT_12S		/* CLK_RUN reset  (YUKON-Lite only) */
+#define CS_CLK_RUN_ENA	BIT_11S		/* CLK_RUN enable (YUKON-Lite only) */
+#define CS_VAUX_AVAIL	BIT_10S		/* VAUX available (YUKON only) */
+#define CS_BUS_CLOCK	BIT_9S		/* Bus Clock 0/1 = 33/66 MHz */
+#define CS_BUS_SLOT_SZ	BIT_8S		/* Slot Size 0/1 = 32/64 bit slot */
+#define CS_ST_SW_IRQ	BIT_7S		/* Set IRQ SW Request */
+#define CS_CL_SW_IRQ	BIT_6S		/* Clear IRQ SW Request */
+#define CS_STOP_DONE	BIT_5S		/* Stop Master is finished */
+#define CS_STOP_MAST	BIT_4S		/* Command Bit to stop the master */
+#define CS_MRST_CLR		BIT_3S		/* Clear Master reset	*/
+#define CS_MRST_SET		BIT_2S		/* Set Master reset	*/
+#define CS_RST_CLR		BIT_1S		/* Clear Software reset	*/
+#define CS_RST_SET		BIT_0S		/* Set   Software reset	*/
 
 /*	B0_LED		 8 Bit	LED register */
-				/* Bit 7..2:	reserved */
-#define LED_STAT_ON		(1<<1)	/* Bit 1:	Status LED on	*/
-#define LED_STAT_OFF	(1<<0)	/* Bit 0:	Status LED off	*/
+								/* Bit  7.. 2:	reserved */
+#define LED_STAT_ON		BIT_1S		/* Status LED on	*/
+#define LED_STAT_OFF	BIT_0S		/* Status LED off	*/
+
+/*	B0_POWER_CTRL	 8 Bit	Power Control reg (YUKON only) */
+#define PC_VAUX_ENA		BIT_7		/* Switch VAUX Enable  */
+#define PC_VAUX_DIS		BIT_6       /* Switch VAUX Disable */
+#define PC_VCC_ENA		BIT_5       /* Switch VCC Enable  */
+#define PC_VCC_DIS		BIT_4       /* Switch VCC Disable */
+#define PC_VAUX_ON		BIT_3       /* Switch VAUX On  */
+#define PC_VAUX_OFF		BIT_2       /* Switch VAUX Off */
+#define PC_VCC_ON		BIT_1       /* Switch VCC On  */
+#define PC_VCC_OFF		BIT_0       /* Switch VCC Off */
 
 /*	B0_ISRC		32 bit	Interrupt Source Register */
 /*	B0_IMSK		32 bit	Interrupt Mask Register */
 /*	B0_SP_ISRC	32 bit	Special Interrupt Source Reg */
 /*	B2_IRQM_MSK 	32 bit	IRQ Moderation Mask */
 #define IS_ALL_MSK		0xbfffffffL	/* 		All Interrupt bits */
-#define IS_HW_ERR		(1UL<<31)	/* Bit 31:	Interrupt HW Error */
-									/* Bit 30:	reserved */
-#define IS_PA_TO_RX1	(1L<<29)	/* Bit 29:	Packet Arb Timeout Rx1*/
-#define IS_PA_TO_RX2	(1L<<28)	/* Bit 28:	Packet Arb Timeout Rx2*/
-#define IS_PA_TO_TX1	(1L<<27)	/* Bit 27:	Packet Arb Timeout Tx1*/
-#define IS_PA_TO_TX2	(1L<<26)	/* Bit 26:	Packet Arb Timeout Tx2*/
-#define IS_I2C_READY	(1L<<25)	/* Bit 25:	IRQ on end of I2C tx */
-#define IS_IRQ_SW		(1L<<24)	/* Bit 24:	SW forced IRQ	*/
-#define IS_EXT_REG		(1L<<23)	/* Bit 23:	IRQ from external reg */
-#define	IS_TIMINT		(1L<<22)	/* Bit 22:	IRQ from Timer	*/
-#define IS_MAC1			(1L<<21)	/* Bit 21:	IRQ from MAC 1	*/
-#define IS_LNK_SYNC_M1	(1L<<20)	/* Bit 20:	Link Sync Cnt wrap M1 */
-#define IS_MAC2			(1L<<19)	/* Bit 19:	IRQ from MAC 2	*/
-#define IS_LNK_SYNC_M2	(1L<<18)	/* Bit 18:	Link Sync Cnt wrap M2 */
+#define IS_HW_ERR		BIT_31		/* Interrupt HW Error */
+								/* Bit 30:	reserved */
+#define IS_PA_TO_RX1	BIT_29		/* Packet Arb Timeout Rx1 */
+#define IS_PA_TO_RX2	BIT_28		/* Packet Arb Timeout Rx2 */
+#define IS_PA_TO_TX1	BIT_27		/* Packet Arb Timeout Tx1 */
+#define IS_PA_TO_TX2	BIT_26		/* Packet Arb Timeout Tx2 */
+#define IS_I2C_READY	BIT_25		/* IRQ on end of I2C Tx */
+#define IS_IRQ_SW		BIT_24		/* SW forced IRQ	*/
+#define IS_EXT_REG		BIT_23		/* IRQ from LM80 or PHY (GENESIS only) */
+									/* IRQ from PHY (YUKON only) */
+#define IS_TIMINT		BIT_22		/* IRQ from Timer	*/
+#define IS_MAC1			BIT_21		/* IRQ from MAC 1	*/
+#define IS_LNK_SYNC_M1	BIT_20		/* Link Sync Cnt wrap MAC 1 */
+#define IS_MAC2			BIT_19		/* IRQ from MAC 2	*/
+#define IS_LNK_SYNC_M2	BIT_18		/* Link Sync Cnt wrap MAC 2 */
 /* Receive Queue 1 */
-#define	IS_R1_B			(1L<<17)	/* Bit 17:	Q_R1 End of Buffer */
-#define	IS_R1_F			(1L<<16)	/* Bit 16:	Q_R1 End of Frame */
-#define	IS_R1_C			(1L<<15)	/* Bit 15:	Q_R1 Encoding Error */
+#define IS_R1_B			BIT_17		/* Q_R1 End of Buffer */
+#define IS_R1_F			BIT_16		/* Q_R1 End of Frame */
+#define IS_R1_C			BIT_15		/* Q_R1 Encoding Error */
 /* Receive Queue 2 */
-#define	IS_R2_B			(1L<<14)	/* Bit 14:	Q_R2 End of Buffer */
-#define	IS_R2_F			(1L<<13)	/* Bit 13:	Q_R2 End of Frame */
-#define	IS_R2_C			(1L<<12)	/* Bit 12:	Q_R2 Encoding Error */
+#define IS_R2_B			BIT_14		/* Q_R2 End of Buffer */
+#define IS_R2_F			BIT_13		/* Q_R2 End of Frame */
+#define IS_R2_C			BIT_12		/* Q_R2 Encoding Error */
 /* Synchronous Transmit Queue 1 */
-#define	IS_XS1_B		(1L<<11)	/* Bit 11:	Q_XS1 End of Buffer */
-#define	IS_XS1_F		(1L<<10)	/* Bit 10:	Q_XS1 End of Frame */
-#define	IS_XS1_C		(1L<<9)		/* Bit	9:	Q_XS1 Encoding Error */
+#define IS_XS1_B		BIT_11		/* Q_XS1 End of Buffer */
+#define IS_XS1_F		BIT_10		/* Q_XS1 End of Frame */
+#define IS_XS1_C		BIT_9		/* Q_XS1 Encoding Error */
 /* Asynchronous Transmit Queue 1 */
-#define	IS_XA1_B		(1L<<8)		/* Bit	8:	Q_XA1 End of Buffer */
-#define	IS_XA1_F		(1L<<7)		/* Bit	7:	Q_XA1 End of Frame */
-#define	IS_XA1_C		(1L<<6)		/* Bit	6:	Q_XA1 Encoding Error */
+#define IS_XA1_B		BIT_8		/* Q_XA1 End of Buffer */
+#define IS_XA1_F		BIT_7		/* Q_XA1 End of Frame */
+#define IS_XA1_C		BIT_6		/* Q_XA1 Encoding Error */
 /* Synchronous Transmit Queue 2 */
-#define	IS_XS2_B		(1L<<5)		/* Bit	5:	Q_XS2 End of Buffer */
-#define	IS_XS2_F		(1L<<4)		/* Bit	4:	Q_XS2 End of Frame */
-#define	IS_XS2_C		(1L<<3)		/* Bit	3:	Q_XS2 Encoding Error */
+#define IS_XS2_B		BIT_5		/* Q_XS2 End of Buffer */
+#define IS_XS2_F		BIT_4		/* Q_XS2 End of Frame */
+#define IS_XS2_C		BIT_3		/* Q_XS2 Encoding Error */
 /* Asynchronous Transmit Queue 2 */
-#define	IS_XA2_B		(1L<<2)		/* Bit	2:	Q_XA2 End of Buffer */
-#define	IS_XA2_F		(1L<<1)		/* Bit	1:	Q_XA2 End of Frame */
-#define	IS_XA2_C		(1L<<0)		/* Bit	0:	Q_XA2 Encoding Error */
+#define IS_XA2_B		BIT_2		/* Q_XA2 End of Buffer */
+#define IS_XA2_F		BIT_1		/* Q_XA2 End of Frame */
+#define IS_XA2_C		BIT_0		/* Q_XA2 Encoding Error */
 
 
 /*	B0_HWE_ISRC	32 bit	HW Error Interrupt Src Reg */
 /*	B0_HWE_IMSK	32 bit	HW Error Interrupt Mask Reg */
 /*	B2_IRQM_HWE_MSK 32 bit	IRQ Moderation HW Error Mask */
 #define IS_ERR_MSK		0x00000fffL	/* 		All Error bits */
-									/* Bit 31..12:	reserved */
-#define	IS_IRQ_MST_ERR	(1L<<11)	/* Bit 11:	IRQ master error */
-									/*	PERR,RMABORT,RTABORT,DATAPERR */
-#define	IS_IRQ_STAT		(1L<<10)	/* Bit 10:	IRQ status execption */
-									/*	RMABORT, RTABORT, DATAPERR */
-#define IS_NO_STAT_M1	(1L<<9)		/* Bit	9:	No Rx Status from MAC1*/
-#define IS_NO_STAT_M2	(1L<<8)		/* Bit	8:	No Rx Status from MAC2*/
-#define IS_NO_TIST_M1	(1L<<7)		/* Bit	7:	No Timestamp from MAC1*/
-#define IS_NO_TIST_M2	(1L<<6)		/* Bit	6:	No Timestamp from MAC2*/
-#define IS_RAM_RD_PAR	(1L<<5)		/* Bit	5:	RAM Read Parity Error */
-#define IS_RAM_WR_PAR	(1L<<4)		/* Bit	4:	RAM Write Parity Error*/
-#define IS_M1_PAR_ERR	(1L<<3)		/* Bit	3:	MAC 1 Parity Error */
-#define IS_M2_PAR_ERR	(1L<<2)		/* Bit	2:	MAC 2 Parity Error */
-#define IS_R1_PAR_ERR	(1L<<1)		/* Bit	1:	Queue R1 Parity Error */
-#define IS_R2_PAR_ERR	(1L<<0)		/* Bit	0:	Queue R2 Parity Error */
+								/* Bit 31..14:	reserved */
+#define IS_IRQ_TIST_OV	BIT_13	/* Time Stamp Timer Overflow (YUKON only) */
+#define IS_IRQ_SENSOR	BIT_12	/* IRQ from Sensor (YUKON only) */
+#define IS_IRQ_MST_ERR	BIT_11	/* IRQ master error detected */
+#define IS_IRQ_STAT		BIT_10	/* IRQ status exception */
+#define IS_NO_STAT_M1	BIT_9	/* No Rx Status from MAC 1 */
+#define IS_NO_STAT_M2	BIT_8	/* No Rx Status from MAC 2 */
+#define IS_NO_TIST_M1	BIT_7	/* No Time Stamp from MAC 1 */
+#define IS_NO_TIST_M2	BIT_6	/* No Time Stamp from MAC 2 */
+#define IS_RAM_RD_PAR	BIT_5	/* RAM Read  Parity Error */
+#define IS_RAM_WR_PAR	BIT_4	/* RAM Write Parity Error */
+#define IS_M1_PAR_ERR	BIT_3	/* MAC 1 Parity Error */
+#define IS_M2_PAR_ERR	BIT_2	/* MAC 2 Parity Error */
+#define IS_R1_PAR_ERR	BIT_1	/* Queue R1 Parity Error */
+#define IS_R2_PAR_ERR	BIT_0	/* Queue R2 Parity Error */
 
 /*	B2_CONN_TYP	 8 bit	Connector type */
 /*	B2_PMD_TYP	 8 bit	PMD type */
 /*	Values of connector and PMD type comply to SysKonnect internal std */
 
-/*	B2_MAC_CFG	 8 bit	MAC Configuration */
-								/* Bit 7..2:	reserved */
-#define	CFG_DIS_M2_CLK	(1<<1)	/* Bit 1:	Disable Clock for 2nd MAC */
-#define CFG_SNG_MAC		(1<<0)	/* Bit 0:	MAC Config: 1=2 MACs / 0=1 MAC*/
-
-/*	B2_CHIP_REV	 8 bit 	Queen Chip Revision Number */
-#define FIRST_CHIP_REV	0x0a	/* Initial Revision Value */
+/*	B2_MAC_CFG	 8 bit	MAC Configuration / Chip Revision */
+#define CFG_CHIP_R_MSK	(0xf<<4)	/* Bit 7.. 4: Chip Revision */
+									/* Bit 3.. 2:	reserved */
+#define CFG_DIS_M2_CLK	BIT_1S		/* Disable Clock for 2nd MAC */
+#define CFG_SNG_MAC		BIT_0S		/* MAC Config: 0=2 MACs / 1=1 MAC*/
+
+/*	B2_CHIP_ID	 8 bit 	Chip Identification Number */
+#define CHIP_ID_GENESIS		0x0a	/* Chip ID for GENESIS */
+#define CHIP_ID_YUKON		0xb0	/* Chip ID for YUKON */
+#define CHIP_ID_YUKON_LITE	0xb1	/* Chip ID for YUKON-Lite (Rev. A1) */
+#define CHIP_ID_YUKON_LP	0xb2	/* Chip ID for YUKON-LP */
 
 /*	B2_FAR		32 bit	Flash-Prom Addr Reg/Cnt */
-#define	FAR_ADDR		0x1ffffL	/* Bit 16..0:	FPROM Address mask */
+#define FAR_ADDR		0x1ffffL	/* Bit 16.. 0:	FPROM Address mask */
 
 /*	B2_LD_CRTL	 8 bit	EPROM loader control register */
 /*	Bits are currently reserved */
 
 /*	B2_LD_TEST	 8 bit	EPROM loader test register */
-								/* Bit 7..4:	reserved */
-#define	LD_T_ON			(1<<3)	/* Bit 3:	Loader Testmode on */
-#define	LD_T_OFF		(1<<2)	/* Bit 2:	Loader Testmode off */
-#define	LD_T_STEP		(1<<1)	/* Bit 1:	Decrement FPROM addr. Counter */
-#define	LD_START		(1<<0)	/* Bit 0:	Start loading FPROM */
+								/* Bit 7.. 4:	reserved */
+#define LD_T_ON			BIT_3S	/* Loader Test mode on */
+#define LD_T_OFF		BIT_2S	/* Loader Test mode off */
+#define LD_T_STEP		BIT_1S	/* Decrement FPROM addr. Counter */
+#define LD_START		BIT_0S	/* Start loading FPROM */
 
 /*
  *	Timer Section
  */
 /*	B2_TI_CRTL	 8 bit	Timer control */
 /*	B2_IRQM_CTRL	 8 bit	IRQ Moderation Timer Control */
-								/* Bit 7..3:	reserved */
-#define TIM_START		(1<<2)	/* Bit 2:	Start Timer */
-#define TIM_STOP		(1<<1)	/* Bit 1:	Stop Timer */
-#define TIM_CLR_IRQ		(1<<0)	/* Bit 0:	Clear Timer IRQ, (!IRQM) */
+								/* Bit 7.. 3:	reserved */
+#define TIM_START		BIT_2S	/* Start Timer */
+#define TIM_STOP		BIT_1S	/* Stop  Timer */
+#define TIM_CLR_IRQ		BIT_0S	/* Clear Timer IRQ (!IRQM) */
 
 /*	B2_TI_TEST	 8 Bit	Timer Test */
 /*	B2_IRQM_TEST	 8 bit	IRQ Moderation Timer Test */
 /*	B28_DPT_TST	 8 bit	Descriptor Poll Timer Test Reg */
-								/* Bit 7..3:	reserved */
-#define	TIM_T_ON		(1<<2)	/* Bit 2:	Test mode on */
-#define	TIM_T_OFF		(1<<1)	/* Bit 1:	Test mode off */
-#define	TIM_T_STEP		(1<<0)	/* Bit 0:	Test step */
+								/* Bit 7.. 3:	reserved */
+#define TIM_T_ON		BIT_2S	/* Test mode on */
+#define TIM_T_OFF		BIT_1S	/* Test mode off */
+#define TIM_T_STEP		BIT_0S	/* Test step */
 
 /*	B28_DPT_INI	32 bit	Descriptor Poll Timer Init Val */
 /*	B28_DPT_VAL	32 bit	Descriptor Poll Timer Curr Val */
@@ -875,100 +1164,101 @@
 #define DPT_MSK		0x00ffffffL	/* Bit 23.. 0:	Desc Poll Timer Bits */
 
 /*	B28_DPT_CTRL	 8 bit	Descriptor Poll Timer Ctrl Reg */
-								/* Bit 7..2:	reserved */
-#define DPT_START		(1<<1)	/* Bit 1:	Start Desciptor Poll Timer */
-#define DPT_STOP		(1<<0)	/* Bit 0:	Stop Desciptor Poll Timer */
+								/* Bit  7.. 2:	reserved */
+#define DPT_START		BIT_1S	/* Start Descriptor Poll Timer */
+#define DPT_STOP		BIT_0S	/* Stop  Descriptor Poll Timer */
 
+/*	B2_E_3			 8 bit 	lower 4 bits used for HW self test result */
+#define B2_E3_RES_MASK	0x0f
 
 /*	B2_TST_CTRL1	 8 bit	Test Control Register 1 */
-#define	TST_FRC_DPERR_MR	(1<<7)	/* Bit 7: force DATAPERR on MST RD */
-#define	TST_FRC_DPERR_MW	(1<<6)	/* Bit 6: force DATAPERR on MST WR */
-#define	TST_FRC_DPERR_TR	(1<<5)	/* Bit 5: force DATAPERR on TRG RD */
-#define	TST_FRC_DPERR_TW	(1<<4)	/* Bit 4: force DATAPERR on TRG WR */
-#define	TST_FRC_APERR_M		(1<<3)	/* Bit 3: force ADDRPERR on MST */
-#define	TST_FRC_APERR_T		(1<<2)	/* Bit 2: force ADDRPERR on TRG */
-#define	TST_CFG_WRITE_ON	(1<<1)	/* Bit 1: Enable Config Reg WR */
-#define	TST_CFG_WRITE_OFF	(1<<0)	/* Bit 0: Disable Config Reg WR */
+#define TST_FRC_DPERR_MR	BIT_7S	/* force DATAPERR on MST RD */
+#define TST_FRC_DPERR_MW	BIT_6S	/* force DATAPERR on MST WR */
+#define TST_FRC_DPERR_TR	BIT_5S	/* force DATAPERR on TRG RD */
+#define TST_FRC_DPERR_TW	BIT_4S	/* force DATAPERR on TRG WR */
+#define TST_FRC_APERR_M		BIT_3S	/* force ADDRPERR on MST */
+#define TST_FRC_APERR_T		BIT_2S	/* force ADDRPERR on TRG */
+#define TST_CFG_WRITE_ON	BIT_1S	/* Enable  Config Reg WR */
+#define TST_CFG_WRITE_OFF	BIT_0S	/* Disable Config Reg WR */
 
 /*	B2_TST_CTRL2	 8 bit	Test Control Register 2 */
-									/* Bit 7..4:	reserved */
-					/* force the following error on */
-					/* the next master read/write	*/
-#define TST_FRC_DPERR_MR64	(1<<3)	/* Bit 3:	DataPERR RD 64	*/
-#define TST_FRC_DPERR_MW64	(1<<2)	/* Bit 2:	DataPERR WR 64	*/
-#define TST_FRC_APERR_1M64	(1<<1)	/* Bit 1:	AddrPERR on 1. phase */
-#define TST_FRC_APERR_2M64	(1<<0)	/* Bit 0:	AddrPERR on 2. phase */
-
-/*	B2_GP_IO	32 bit	General Purpose IO Register */
-								/* Bit 31..26:	reserved */
-#define	GP_DIR_9	(1L<<25)	/* Bit 25:	IO_9 direct, 0=I/1=O */
-#define	GP_DIR_8	(1L<<24)	/* Bit 24:	IO_8 direct, 0=I/1=O */
-#define	GP_DIR_7	(1L<<23)	/* Bit 23:	IO_7 direct, 0=I/1=O */
-#define	GP_DIR_6	(1L<<22)	/* Bit 22:	IO_6 direct, 0=I/1=O */
-#define	GP_DIR_5	(1L<<21)	/* Bit 21:	IO_5 direct, 0=I/1=O */
-#define	GP_DIR_4	(1L<<20)	/* Bit 20:	IO_4 direct, 0=I/1=O */
-#define	GP_DIR_3	(1L<<19)	/* Bit 19:	IO_3 direct, 0=I/1=O */
-#define	GP_DIR_2	(1L<<18)	/* Bit 18:	IO_2 direct, 0=I/1=O */
-#define	GP_DIR_1	(1L<<17)	/* Bit 17:	IO_1 direct, 0=I/1=O */
-#define	GP_DIR_0	(1L<<16)	/* Bit 16:	IO_0 direct, 0=I/1=O */
-								/* Bit 15..10:	reserved */
-#define	GP_IO_9		(1L<<9)		/* Bit	9:	IO_9 pin */
-#define	GP_IO_8		(1L<<8)		/* Bit	8:	IO_8 pin */
-#define	GP_IO_7		(1L<<7)		/* Bit	7:	IO_7 pin */
-#define	GP_IO_6		(1L<<6)		/* Bit	6:	IO_6 pin */
-#define	GP_IO_5		(1L<<5)		/* Bit	5:	IO_5 pin */
-#define	GP_IO_4		(1L<<4)		/* Bit	4:	IO_4 pin */
-#define	GP_IO_3		(1L<<3)		/* Bit	3:	IO_3 pin */
-#define	GP_IO_2		(1L<<2)		/* Bit	2:	IO_2 pin */
-#define	GP_IO_1		(1L<<1)		/* Bit	1:	IO_1 pin */
-#define	GP_IO_0		(1L<<0)		/* Bit	0:	IO_0 pin */
+									/* Bit 7.. 4:	reserved */
+			/* force the following error on the next master read/write	*/
+#define TST_FRC_DPERR_MR64	BIT_3S	/* DataPERR RD 64	*/
+#define TST_FRC_DPERR_MW64	BIT_2S	/* DataPERR WR 64	*/
+#define TST_FRC_APERR_1M64	BIT_1S	/* AddrPERR on 1. phase */
+#define TST_FRC_APERR_2M64	BIT_0S	/* AddrPERR on 2. phase */
+
+/*	B2_GP_IO	32 bit	General Purpose I/O Register */
+							/* Bit 31..26:	reserved */
+#define GP_DIR_9	BIT_25	/* IO_9 direct, 0=I/1=O */
+#define GP_DIR_8	BIT_24	/* IO_8 direct, 0=I/1=O */
+#define GP_DIR_7	BIT_23	/* IO_7 direct, 0=I/1=O */
+#define GP_DIR_6	BIT_22	/* IO_6 direct, 0=I/1=O */
+#define GP_DIR_5	BIT_21	/* IO_5 direct, 0=I/1=O */
+#define GP_DIR_4	BIT_20	/* IO_4 direct, 0=I/1=O */
+#define GP_DIR_3	BIT_19	/* IO_3 direct, 0=I/1=O */
+#define GP_DIR_2	BIT_18	/* IO_2 direct, 0=I/1=O */
+#define GP_DIR_1	BIT_17	/* IO_1 direct, 0=I/1=O */
+#define GP_DIR_0	BIT_16	/* IO_0 direct, 0=I/1=O */
+						/* Bit 15..10:	reserved */
+#define GP_IO_9		BIT_9	/* IO_9 pin */
+#define GP_IO_8		BIT_8	/* IO_8 pin */
+#define GP_IO_7		BIT_7	/* IO_7 pin */
+#define GP_IO_6		BIT_6	/* IO_6 pin */
+#define GP_IO_5		BIT_5	/* IO_5 pin */
+#define GP_IO_4		BIT_4	/* IO_4 pin */
+#define GP_IO_3		BIT_3	/* IO_3 pin */
+#define GP_IO_2		BIT_2	/* IO_2 pin */
+#define GP_IO_1		BIT_1	/* IO_1 pin */
+#define GP_IO_0		BIT_0	/* IO_0 pin */
 
 /*	B2_I2C_CTRL	32 bit	I2C HW Control Register */
-#define	I2C_FLAG		(1UL<<31)	/* Bit 31:	Start read/write if WR*/
-#define I2C_ADDR	(0x7fffL<<16)	/* Bit 30..16:	Addr to be RD/WR */
-#define	I2C_DEV_SEL		(0x7fL<<9)	/* Bit 15.. 9:	I2C Device Select */
-									/* Bit	8.. 5:	reserved	*/
-#define I2C_BURST_LEN	(1L<<4)		/* Bit	4:	Burst Len, 1/4 bytes */
+#define I2C_FLAG		BIT_31		/* Start read/write if WR */
+#define I2C_ADDR		(0x7fffL<<16)	/* Bit 30..16:	Addr to be RD/WR */
+#define I2C_DEV_SEL		(0x7fL<<9)		/* Bit 15.. 9:	I2C Device Select */
+								/* Bit	8.. 5:	reserved	*/
+#define I2C_BURST_LEN	BIT_4		/* Burst Len, 1/4 bytes */
 #define I2C_DEV_SIZE	(7L<<1)		/* Bit	3.. 1:	I2C Device Size	*/
 #define I2C_025K_DEV	(0L<<1)		/*		0: 256 Bytes or smal. */
 #define I2C_05K_DEV		(1L<<1)		/* 		1: 512	Bytes	*/
-#define	I2C_1K_DEV		(2L<<1)		/*		2: 1024 Bytes	*/
+#define I2C_1K_DEV		(2L<<1)		/*		2: 1024 Bytes	*/
 #define I2C_2K_DEV		(3L<<1)		/*		3: 2048	Bytes	*/
-#define	I2C_4K_DEV		(4L<<1)		/*		4: 4096 Bytes	*/
-#define	I2C_8K_DEV		(5L<<1)		/*		5: 8192 Bytes	*/
-#define	I2C_16K_DEV		(6L<<1)		/*		6: 16384 Bytes	*/
-#define	I2C_32K_DEV		(7L<<1)		/*		7: 32768 Bytes	*/
-#define I2C_STOP		(1L<<0)		/* Bit	0:	Interrupt I2C transfer*/
+#define I2C_4K_DEV		(4L<<1)		/*		4: 4096 Bytes	*/
+#define I2C_8K_DEV		(5L<<1)		/*		5: 8192 Bytes	*/
+#define I2C_16K_DEV		(6L<<1)		/*		6: 16384 Bytes	*/
+#define I2C_32K_DEV		(7L<<1)		/*		7: 32768 Bytes	*/
+#define I2C_STOP		BIT_0		/* Interrupt I2C transfer */
 
 /*	B2_I2C_IRQ	32 bit	I2C HW IRQ Register */
-								/* Bit 31..1	reserved */
-#define I2C_CLR_IRQ		(1<<0)	/* Bit 0:	Clear I2C IRQ */
+								/* Bit 31.. 1	reserved */
+#define I2C_CLR_IRQ		BIT_0	/* Clear I2C IRQ */
 
-/*	B2_I2C_SW	32 bit	I2C HW SW Port Register */
-								/* Bit 7..3:	reserved */
-#define	I2C_DATA_DIR	(1<<2)	/* Bit 2:	direction of I2C_DATA */
-#define I2C_DATA		(1<<1)	/* Bit 1:	I2C Data Port	*/
-#define	I2C_CLK			(1<<0)	/* Bit 0:	I2C Clock Port	*/
+/*	B2_I2C_SW	32 bit (8 bit access)	I2C HW SW Port Register */
+								/* Bit  7.. 3:	reserved */
+#define I2C_DATA_DIR	BIT_2S		/* direction of I2C_DATA */
+#define I2C_DATA		BIT_1S		/* I2C Data Port	*/
+#define I2C_CLK			BIT_0S		/* I2C Clock Port	*/
 
 /*
  * I2C Address
  */
-#define	I2C_SENS_ADDR	LM80_ADDR	/* I2C Sensor Address, (Volt and Temp)*/
+#define I2C_SENS_ADDR	LM80_ADDR	/* I2C Sensor Address, (Volt and Temp)*/
 
 
 /*	B2_BSC_CTRL	 8 bit	Blink Source Counter Control */
-							/* Bit 7..2:	reserved */
-#define BSC_START	(1<<1)	/* Bit 1:	Start Blink Source Counter */
-#define BSC_STOP	(1<<0)	/* Bit 0:	Stop Blink Source Counter */
+							/* Bit  7.. 2:	reserved */
+#define BSC_START	BIT_1S		/* Start Blink Source Counter */
+#define BSC_STOP	BIT_0S		/* Stop  Blink Source Counter */
 
 /*	B2_BSC_STAT	 8 bit	Blink Source Counter Status */
-							/* Bit 7..1:	reserved */
-#define BSC_SRC		(1<<0)	/* Bit 0:	Blink Source, 0=Off / 1=On */
+							/* Bit  7.. 1:	reserved */
+#define BSC_SRC		BIT_0S		/* Blink Source, 0=Off / 1=On */
 
 /*	B2_BSC_TST	16 bit	Blink Source Counter Test Reg */
-#define	BSC_T_ON	(1<<2)	/* Bit 2:	Test mode on */
-#define	BSC_T_OFF	(1<<1)	/* Bit 1:	Test mode off */
-#define	BSC_T_STEP	(1<<0)	/* Bit 0:	Test step */
+#define BSC_T_ON	BIT_2S		/* Test mode on */
+#define BSC_T_OFF	BIT_1S		/* Test mode off */
+#define BSC_T_STEP	BIT_0S		/* Test step */
 
 
 /*	B3_RAM_ADDR	32 bit	RAM Address, to read or write */
@@ -978,55 +1268,55 @@
 /* RAM Interface Registers */
 /*	B3_RI_CTRL	16 bit	RAM Iface Control Register */
 								/* Bit 15..10:	reserved */
-#define RI_CLR_RD_PERR	(1<<9)	/* Bit	9:	Clear IRQ RAM Read Parity Err */
-#define RI_CLR_WR_PERR	(1<<8)	/* Bit	8:	Clear IRQ RAM Write Parity Err*/
-								/* Bit	7..2:	reserved */
-#define RI_RST_CLR		(1<<1)	/* Bit	1:	Clear RAM Interface Reset */
-#define RI_RST_SET		(1<<0)	/* Bit	0:	Set RAM Interface Reset */
+#define RI_CLR_RD_PERR	BIT_9S	/* Clear IRQ RAM Read Parity Err */
+#define RI_CLR_WR_PERR	BIT_8S	/* Clear IRQ RAM Write Parity Err*/
+								/* Bit	7.. 2:	reserved */
+#define RI_RST_CLR		BIT_1S	/* Clear RAM Interface Reset */
+#define RI_RST_SET		BIT_0S	/* Set   RAM Interface Reset */
 
 /*	B3_RI_TEST	 8 bit	RAM Iface Test Register */
-								/* Bit 15..4:	reserved */
-#define RI_T_EV			(1<<3)	/* Bit	3:	Timeout Event occured */
-#define RI_T_ON			(1<<2)	/* Bit	2:	Timeout Timer Test On */
-#define RI_T_OFF		(1<<1)	/* Bit	1:	Timeout Timer Test Off */
-#define RI_T_STEP		(1<<0)	/* Bit	0:	Timeout Timer Step */
+								/* Bit 15.. 4:	reserved */
+#define RI_T_EV			BIT_3S	/* Timeout Event occured */
+#define RI_T_ON			BIT_2S	/* Timeout Timer Test On */
+#define RI_T_OFF		BIT_1S	/* Timeout Timer Test Off */
+#define RI_T_STEP		BIT_0S	/* Timeout Timer Step */
 
 /* MAC Arbiter Registers */
 /*	B3_MA_TO_CTRL	16 bit	MAC Arbiter Timeout Ctrl Reg */
-								/* Bit 15..4:	reserved */
-#define MA_FOE_ON		(1<<3)	/* Bit	3:	XMAC Fast Output Enable ON */
-#define MA_FOE_OFF		(1<<2)	/* Bit	2:	XMAC Fast Output Enable OFF */
-#define MA_RST_CLR		(1<<1)	/* Bit	1:	Clear MAC Arbiter Reset */
-#define MA_RST_SET		(1<<0)	/* Bit	0:	Set MAC Arbiter Reset */
+								/* Bit 15.. 4:	reserved */
+#define MA_FOE_ON		BIT_3S	/* XMAC Fast Output Enable ON */
+#define MA_FOE_OFF		BIT_2S	/* XMAC Fast Output Enable OFF */
+#define MA_RST_CLR		BIT_1S	/* Clear MAC Arbiter Reset */
+#define MA_RST_SET		BIT_0S	/* Set   MAC Arbiter Reset */
 
 /*	B3_MA_RC_CTRL	16 bit	MAC Arbiter Recovery Ctrl Reg */
-								/* Bit 15..8:	reserved */
-#define MA_ENA_REC_TX2	(1<<7)	/* Bit	7:	Enable Recovery Timer TX2 */
-#define MA_DIS_REC_TX2	(1<<6)	/* Bit	6:	Disable Recovery Timer TX2 */
-#define MA_ENA_REC_TX1	(1<<5)	/* Bit	5:	Enable Recovery Timer TX1 */
-#define MA_DIS_REC_TX1	(1<<4)	/* Bit	4:	Disable Recovery Timer TX1 */
-#define MA_ENA_REC_RX2	(1<<3)	/* Bit	3:	Enable Recovery Timer RX2 */
-#define MA_DIS_REC_RX2	(1<<2)	/* Bit	2:	Disable Recovery Timer RX2 */
-#define MA_ENA_REC_RX1	(1<<1)	/* Bit	1:	Enable Recovery Timer RX1 */
-#define MA_DIS_REC_RX1	(1<<0)	/* Bit	0:	Disable Recovery Timer RX1 */
+								/* Bit 15.. 8:	reserved */
+#define MA_ENA_REC_TX2	BIT_7S	/* Enable  Recovery Timer TX2 */
+#define MA_DIS_REC_TX2	BIT_6S	/* Disable Recovery Timer TX2 */
+#define MA_ENA_REC_TX1	BIT_5S	/* Enable  Recovery Timer TX1 */
+#define MA_DIS_REC_TX1	BIT_4S	/* Disable Recovery Timer TX1 */
+#define MA_ENA_REC_RX2	BIT_3S	/* Enable  Recovery Timer RX2 */
+#define MA_DIS_REC_RX2	BIT_2S	/* Disable Recovery Timer RX2 */
+#define MA_ENA_REC_RX1	BIT_1S	/* Enable  Recovery Timer RX1 */
+#define MA_DIS_REC_RX1	BIT_0S	/* Disable Recovery Timer RX1 */
 
 /* Packet Arbiter Registers */
 /*	B3_PA_CTRL	16 bit	Packet Arbiter Ctrl Register */
 								/* Bit 15..14:	reserved */
-#define PA_CLR_TO_TX2	(1<<13)	/* Bit 13:	Clear IRQ Packet Timeout TX2 */
-#define PA_CLR_TO_TX1	(1<<12)	/* Bit 12:	Clear IRQ Packet Timeout TX1 */
-#define PA_CLR_TO_RX2	(1<<11)	/* Bit 11:	Clear IRQ Packet Timeout RX2 */
-#define PA_CLR_TO_RX1	(1<<10)	/* Bit 10:	Clear IRQ Packet Timeout RX1 */
-#define PA_ENA_TO_TX2	(1<<9)	/* Bit	9:	Enable Timeout Timer TX2 */
-#define PA_DIS_TO_TX2	(1<<8)	/* Bit	8:	Disable Timeout Timer TX2 */
-#define PA_ENA_TO_TX1	(1<<7)	/* Bit	7:	Enable Timeout Timer TX1 */
-#define PA_DIS_TO_TX1	(1<<6)	/* Bit	6:	Disable Timeout Timer TX1 */
-#define PA_ENA_TO_RX2	(1<<5)	/* Bit	5:	Enable Timeout Timer RX2 */
-#define PA_DIS_TO_RX2	(1<<4)	/* Bit	4:	Disable Timeout Timer RX2 */
-#define PA_ENA_TO_RX1	(1<<3)	/* Bit	3:	Enable Timeout Timer RX1 */
-#define PA_DIS_TO_RX1	(1<<2)	/* Bit	2:	Disable Timeout Timer RX1 */
-#define PA_RST_CLR		(1<<1)	/* Bit	1:	Clear MAC Arbiter Reset */
-#define PA_RST_SET		(1<<0)	/* Bit	0:	Set MAC Arbiter Reset */
+#define PA_CLR_TO_TX2	BIT_13S	/* Clear IRQ Packet Timeout TX2 */
+#define PA_CLR_TO_TX1	BIT_12S	/* Clear IRQ Packet Timeout TX1 */
+#define PA_CLR_TO_RX2	BIT_11S	/* Clear IRQ Packet Timeout RX2 */
+#define PA_CLR_TO_RX1	BIT_10S	/* Clear IRQ Packet Timeout RX1 */
+#define PA_ENA_TO_TX2	BIT_9S	/* Enable  Timeout Timer TX2 */
+#define PA_DIS_TO_TX2	BIT_8S	/* Disable Timeout Timer TX2 */
+#define PA_ENA_TO_TX1	BIT_7S	/* Enable  Timeout Timer TX1 */
+#define PA_DIS_TO_TX1	BIT_6S	/* Disable Timeout Timer TX1 */
+#define PA_ENA_TO_RX2	BIT_5S	/* Enable  Timeout Timer RX2 */
+#define PA_DIS_TO_RX2	BIT_4S	/* Disable Timeout Timer RX2 */
+#define PA_ENA_TO_RX1	BIT_3S	/* Enable  Timeout Timer RX1 */
+#define PA_DIS_TO_RX1	BIT_2S	/* Disable Timeout Timer RX1 */
+#define PA_RST_CLR		BIT_1S	/* Clear MAC Arbiter Reset */
+#define PA_RST_SET		BIT_0S	/* Set   MAC Arbiter Reset */
 
 #define PA_ENA_TO_ALL	(PA_ENA_TO_RX1 | PA_ENA_TO_RX2 |\
 						PA_ENA_TO_TX1 | PA_ENA_TO_TX2)
@@ -1036,57 +1326,57 @@
 /*	B3_MA_RC_TEST	16 bit	MAC Arbiter Recovery Test Reg */
 /*	B3_PA_TEST	16 bit	Packet Arbiter Test Register */
 /*			Bit 15, 11, 7, and 3 are reserved in B3_PA_TEST */
-#define TX2_T_EV	(1<<15)	/* Bit 15: 	TX2 Timeout/Recv Event occured*/
-#define TX2_T_ON	(1<<14)	/* Bit 14:	TX2 Timeout/Recv Timer Test On*/
-#define TX2_T_OFF	(1<<13)	/* Bit 13:	TX2 Timeout/Recv Timer Tst Off*/
-#define TX2_T_STEP	(1<<12)	/* Bit 12:	TX2 Timeout/Recv Timer Step */
-#define TX1_T_EV	(1<<11)	/* Bit 11:	TX1 Timeout/Recv Event occured*/
-#define TX1_T_ON	(1<<10)	/* Bit 10:	TX1 Timeout/Recv Timer Test On*/
-#define TX1_T_OFF	(1<<9)	/* Bit	9:	TX1 Timeout/Recv Timer Tst Off*/
-#define TX1_T_STEP	(1<<8)	/* Bit	8:	TX1 Timeout/Recv Timer Step */
-#define RX2_T_EV	(1<<7)	/* Bit	7:	RX2 Timeout/Recv Event occured*/
-#define RX2_T_ON	(1<<6)	/* Bit	6:	RX2 Timeout/Recv Timer Test On*/
-#define RX2_T_OFF	(1<<5)	/* Bit	5:	RX2 Timeout/Recv Timer Tst Off*/
-#define RX2_T_STEP	(1<<4)	/* Bit	4:	RX2 Timeout/Recv Timer Step */
-#define RX1_T_EV	(1<<3)	/* Bit	3:	RX1 Timeout/Recv Event occured*/
-#define RX1_T_ON	(1<<2)	/* Bit	2:	RX1 Timeout/Recv Timer Test On*/
-#define RX1_T_OFF	(1<<1)	/* Bit	1:	RX1 Timeout/Recv Timer Tst Off*/
-#define RX1_T_STEP	(1<<0)	/* Bit	0:	RX1 Timeout/Recv Timer Step */
+#define TX2_T_EV	BIT_15S		/* TX2 Timeout/Recv Event occured */
+#define TX2_T_ON	BIT_14S		/* TX2 Timeout/Recv Timer Test On */
+#define TX2_T_OFF	BIT_13S		/* TX2 Timeout/Recv Timer Tst Off */
+#define TX2_T_STEP	BIT_12S		/* TX2 Timeout/Recv Timer Step */
+#define TX1_T_EV	BIT_11S		/* TX1 Timeout/Recv Event occured */
+#define TX1_T_ON	BIT_10S		/* TX1 Timeout/Recv Timer Test On */
+#define TX1_T_OFF	BIT_9S		/* TX1 Timeout/Recv Timer Tst Off */
+#define TX1_T_STEP	BIT_8S		/* TX1 Timeout/Recv Timer Step */
+#define RX2_T_EV	BIT_7S		/* RX2 Timeout/Recv Event occured */
+#define RX2_T_ON	BIT_6S		/* RX2 Timeout/Recv Timer Test On */
+#define RX2_T_OFF	BIT_5S		/* RX2 Timeout/Recv Timer Tst Off */
+#define RX2_T_STEP	BIT_4S		/* RX2 Timeout/Recv Timer Step */
+#define RX1_T_EV	BIT_3S		/* RX1 Timeout/Recv Event occured */
+#define RX1_T_ON	BIT_2S		/* RX1 Timeout/Recv Timer Test On */
+#define RX1_T_OFF	BIT_1S		/* RX1 Timeout/Recv Timer Tst Off */
+#define RX1_T_STEP	BIT_0S		/* RX1 Timeout/Recv Timer Step */
 
 
-/* Transmit Arbiter Registers MAC 1 and 2, user MR_ADDR() to address */
+/* Transmit Arbiter Registers MAC 1 and 2, use MR_ADDR() to access */
 /*	TXA_ITI_INI	32 bit	Tx Arb Interval Timer Init Val */
 /*	TXA_ITI_VAL	32 bit	Tx Arb Interval Timer Value */
 /*	TXA_LIM_INI	32 bit	Tx Arb Limit Counter Init Val */
 /*	TXA_LIM_VAL	32 bit	Tx Arb Limit Counter Value */
 								/* Bit 31..24:	reserved */
-#define	TXA_MAX_VAL	0x00ffffffL	/* Bit 23.. 0:	Max TXA Timer/Cnt Val */
+#define TXA_MAX_VAL	0x00ffffffL	/* Bit 23.. 0:	Max TXA Timer/Cnt Val */
 
 /*	TXA_CTRL	 8 bit	Tx Arbiter Control Register */
-#define TXA_ENA_FSYNC	(1<<7)	/* Bit 7:	Enable force of sync tx queue */
-#define TXA_DIS_FSYNC	(1<<6)	/* Bit 6:	Disable force of sync tx queue*/
-#define TXA_ENA_ALLOC	(1<<5)	/* Bit 5:	Enable alloc of free bandwidth*/
-#define TXA_DIS_ALLOC	(1<<4)	/* Bit 4:	Disabl alloc of free bandwidth*/
-#define TXA_START_RC	(1<<3)	/* Bit 3:	Start sync Rate Control */
-#define TXA_STOP_RC		(1<<2)	/* Bit 2:	Stop sync Rate Control */
-#define TXA_ENA_ARB		(1<<1)	/* Bit 1:	Enable Tx Arbiter */
-#define TXA_DIS_ARB		(1<<0)	/* Bit 0:	Disable Tx Arbiter */
+#define TXA_ENA_FSYNC	BIT_7S	/* Enable  force of sync Tx queue */
+#define TXA_DIS_FSYNC	BIT_6S	/* Disable force of sync Tx queue */
+#define TXA_ENA_ALLOC	BIT_5S	/* Enable  alloc of free bandwidth */
+#define TXA_DIS_ALLOC	BIT_4S	/* Disable alloc of free bandwidth */
+#define TXA_START_RC	BIT_3S	/* Start sync Rate Control */
+#define TXA_STOP_RC		BIT_2S	/* Stop  sync Rate Control */
+#define TXA_ENA_ARB		BIT_1S	/* Enable  Tx Arbiter */
+#define TXA_DIS_ARB		BIT_0S	/* Disable Tx Arbiter */
 
 /*	TXA_TEST	 8 bit	Tx Arbiter Test Register */
-				/* Bit 7..6:	reserved */
-#define TXA_INT_T_ON	(1<<5)	/* Bit 5:	Tx Arb Interval Timer Test On */
-#define TXA_INT_T_OFF	(1<<4)	/* Bit 4:	Tx Arb Interval Timer Test Off*/
-#define TXA_INT_T_STEP	(1<<3)	/* Bit 3:	Tx Arb Interval Timer Step */
-#define TXA_LIM_T_ON	(1<<2)	/* Bit 2:	Tx Arb Limit Timer Test On */
-#define TXA_LIM_T_OFF	(1<<1)	/* Bit 1:	Tx Arb Limit Timer Test Off */
-#define TXA_LIM_T_STEP	(1<<0)	/* Bit 0:	Tx Arb Limit Timer Step */
+								/* Bit 7.. 6:	reserved */
+#define TXA_INT_T_ON	BIT_5S	/* Tx Arb Interval Timer Test On */
+#define TXA_INT_T_OFF	BIT_4S	/* Tx Arb Interval Timer Test Off */
+#define TXA_INT_T_STEP	BIT_3S	/* Tx Arb Interval Timer Step */
+#define TXA_LIM_T_ON	BIT_2S	/* Tx Arb Limit Timer Test On */
+#define TXA_LIM_T_OFF	BIT_1S	/* Tx Arb Limit Timer Test Off */
+#define TXA_LIM_T_STEP	BIT_0S	/* Tx Arb Limit Timer Step */
 
 /*	TXA_STAT	 8 bit	Tx Arbiter Status Register */
-								/* Bit 7..1:	reserved */
-#define	TXA_PRIO_XS		(1<<0)	/* Bit 0:	sync queue has prio to send */
+								/* Bit 7.. 1:	reserved */
+#define TXA_PRIO_XS		BIT_0S	/* sync queue has prio to send */
 
 /*	Q_BC	32 bit	Current Byte Counter */
-				/* Bit 31..16:	reserved */
+								/* Bit 31..16:	reserved */
 #define BC_MAX			0xffff	/* Bit 15.. 0:	Byte counter */
 
 /* BMU Control Status Registers */
@@ -1096,94 +1386,95 @@
 /*	B0_XS1_CSR	32 bit	BMU Ctrl/Stat Async Tx Queue 1 */
 /*	B0_XA2_CSR	32 bit	BMU Ctrl/Stat Sync Tx Queue 2 */
 /*	B0_XS2_CSR	32 bit	BMU Ctrl/Stat Async Tx Queue 2 */
-/*	Q_CSR	32 bit	BMU Control/Status Register */
-									/* Bit 31..25:	reserved */
-#define CSR_SV_IDLE		(1L<<24)	/* Bit 24: 	BMU SM Idle */
-									/* Bit 23..22:	reserved */
-#define	CSR_DESC_CLR	(1L<<21)	/* Bit 21:	Clear Reset for Descr */
-#define	CSR_DESC_SET	(1L<<20)	/* Bit 20:	Set Reset for Descr */
-#define	CSR_FIFO_CLR	(1L<<19)	/* Bit 19:	Clear Reset for FIFO */
-#define	CSR_FIFO_SET	(1L<<18)	/* Bit 18:	Set Reset for FIFO */
-#define	CSR_HPI_RUN		(1L<<17)	/* Bit 17:	Release HPI SM */
-#define	CSR_HPI_RST		(1L<<16)	/* Bit 16:	Reset HPI SM to Idle */
-#define	CSR_SV_RUN		(1L<<15)	/* Bit 15:	Release Supervisor SM */
-#define	CSR_SV_RST		(1L<<14)	/* Bit 14:	Reset Supervisor SM */
-#define	CSR_DREAD_RUN	(1L<<13)	/* Bit 13:	Release Descr Read SM */
-#define	CSR_DREAD_RST	(1L<<12)	/* Bit 12:	Reset Descr Read SM */
-#define	CSR_DWRITE_RUN	(1L<<11)	/* Bit 11:	Rel. Descr Write SM */
-#define	CSR_DWRITE_RST	(1L<<10)	/* Bit 10:	Reset Descr Write SM */
-#define	CSR_TRANS_RUN	(1L<<9)		/* Bit	9:	Release Transfer SM */
-#define	CSR_TRANS_RST	(1L<<8)		/* Bit	8:	Reset Transfer SM */
-#define CSR_ENA_POL		(1L<<7)		/* Bit	7:	Enable Descr Polling */
-#define CSR_DIS_POL		(1L<<6)		/* Bit	6:	Disable Descr Polling */
-#define CSR_STOP		(1L<<5)		/* Bit	5:	Stop Rx/Tx Queue */
-#define	CSR_START		(1L<<4)		/* Bit	4:	Start Rx/Tx Queue */
-#define	CSR_IRQ_CL_P	(1L<<3)		/* Bit	3: (Rx)	Clear Parity IRQ */
-#define	CSR_IRQ_CL_B	(1L<<2)		/* Bit	2:	Clear EOB IRQ */
-#define	CSR_IRQ_CL_F	(1L<<1)		/* Bit	1:	Clear EOF IRQ */
-#define	CSR_IRQ_CL_C	(1L<<0)		/* Bit	0:	Clear ERR IRQ */
-
-#define CSR_SET_RESET	(CSR_DESC_SET|CSR_FIFO_SET|CSR_HPI_RST|CSR_SV_RST|\
-						CSR_DREAD_RST|CSR_DWRITE_RST|CSR_TRANS_RST)
-#define CSR_CLR_RESET	(CSR_DESC_CLR|CSR_FIFO_CLR|CSR_HPI_RUN|CSR_SV_RUN|\
-						CSR_DREAD_RUN|CSR_DWRITE_RUN|CSR_TRANS_RUN)
-
+/*	Q_CSR		32 bit	BMU Control/Status Register */
+								/* Bit 31..25:	reserved */
+#define CSR_SV_IDLE		BIT_24		/* BMU SM Idle */
+								/* Bit 23..22:	reserved */
+#define CSR_DESC_CLR	BIT_21		/* Clear Reset for Descr */
+#define CSR_DESC_SET	BIT_20		/* Set   Reset for Descr */
+#define CSR_FIFO_CLR	BIT_19		/* Clear Reset for FIFO */
+#define CSR_FIFO_SET	BIT_18		/* Set   Reset for FIFO */
+#define CSR_HPI_RUN		BIT_17		/* Release HPI SM */
+#define CSR_HPI_RST		BIT_16		/* Reset   HPI SM to Idle */
+#define CSR_SV_RUN		BIT_15		/* Release Supervisor SM */
+#define CSR_SV_RST		BIT_14		/* Reset   Supervisor SM */
+#define CSR_DREAD_RUN	BIT_13		/* Release Descr Read SM */
+#define CSR_DREAD_RST	BIT_12		/* Reset   Descr Read SM */
+#define CSR_DWRITE_RUN	BIT_11		/* Release Descr Write SM */
+#define CSR_DWRITE_RST	BIT_10		/* Reset   Descr Write SM */
+#define CSR_TRANS_RUN	BIT_9		/* Release Transfer SM */
+#define CSR_TRANS_RST	BIT_8		/* Reset   Transfer SM */
+#define CSR_ENA_POL		BIT_7		/* Enable  Descr Polling */
+#define CSR_DIS_POL		BIT_6		/* Disable Descr Polling */
+#define CSR_STOP		BIT_5		/* Stop  Rx/Tx Queue */
+#define CSR_START		BIT_4		/* Start Rx/Tx Queue */
+#define CSR_IRQ_CL_P	BIT_3		/* (Rx)	Clear Parity IRQ */
+#define CSR_IRQ_CL_B	BIT_2		/* Clear EOB IRQ */
+#define CSR_IRQ_CL_F	BIT_1		/* Clear EOF IRQ */
+#define CSR_IRQ_CL_C	BIT_0		/* Clear ERR IRQ */
+
+#define CSR_SET_RESET	(CSR_DESC_SET | CSR_FIFO_SET | CSR_HPI_RST |\
+						CSR_SV_RST | CSR_DREAD_RST | CSR_DWRITE_RST |\
+						CSR_TRANS_RST)
+#define CSR_CLR_RESET	(CSR_DESC_CLR | CSR_FIFO_CLR | CSR_HPI_RUN |\
+						CSR_SV_RUN | CSR_DREAD_RUN | CSR_DWRITE_RUN |\
+						CSR_TRANS_RUN)
 
 /*	Q_F	32 bit	Flag Register */
-					/* Bit 28..31:	reserved */
-#define F_ALM_FULL		(1L<<27) (Rx)	/* Bit 27: (Rx)	FIFO almost full */
-#define F_EMPTY			(1L<<27) (Tx)	/* Bit 27: (Tx)	FIFO empty flag */
-#define F_FIFO_EOF		(1L<<26)	/* Bit 26: 	Fag bit in FIFO */
-#define F_WM_REACHED	(1L<<25)	/* Bit 25: 	Watermark reached */
-									/* Bit 24:	reserved */
+									/* Bit 31..28:	reserved */
+#define F_ALM_FULL		BIT_27		/* Rx FIFO: almost full */
+#define F_EMPTY			BIT_27		/* Tx FIFO: empty flag */
+#define F_FIFO_EOF		BIT_26		/* Tag (EOF Flag) bit in FIFO */
+#define F_WM_REACHED	BIT_25		/* Watermark reached */
+									/* reserved */
 #define F_FIFO_LEVEL	(0x1fL<<16)	/* Bit 23..16:	# of Qwords in FIFO */
 									/* Bit 15..11: 	reserved */
 #define F_WATER_MARK	0x0007ffL	/* Bit 10.. 0:	Watermark */
 
 /*	Q_T1	32 bit	Test Register 1 */
 /*		Holds four State Machine control Bytes */
-#define	SM_CRTL_SV	(0xffL<<24)	/* Bit 31..24:	Control Supervisor SM */
-#define	SM_CRTL_RD	(0xffL<<16)	/* Bit 23..16:	Control Read Desc SM */
-#define	SM_CRTL_WR	(0xffL<<8)	/* Bit 15.. 8:	Control Write Desc SM */
-#define	SM_CRTL_TR	(0xffL<<0)	/* Bit	7.. 0:	Control Transfer SM */
+#define SM_CRTL_SV_MSK	(0xffL<<24)	/* Bit 31..24:	Control Supervisor SM */
+#define SM_CRTL_RD_MSK	(0xffL<<16)	/* Bit 23..16:	Control Read Desc SM */
+#define SM_CRTL_WR_MSK	(0xffL<<8)	/* Bit 15.. 8:	Control Write Desc SM */
+#define SM_CRTL_TR_MSK	0xffL		/* Bit	7.. 0:	Control Transfer SM */
 
 /*	Q_T1_TR	 8 bit	Test Register 1 Transfer SM */
 /*	Q_T1_WR	 8 bit	Test Register 1 Write Descriptor SM */
 /*	Q_T1_RD	 8 bit	Test Register 1 Read Descriptor SM */
 /*	Q_T1_SV	 8 bit	Test Register 1 Supervisor SM */
+
 /* The control status byte of each machine looks like ... */
-#define	SM_STATE	0xf0	/* Bit 7..4:	State which shall be loaded */
-#define	SM_LOAD		(1<<3)	/* Bit 3:	Load the SM with SM_STATE */
-#define	SM_TEST_ON	(1<<2)	/* Bit 2:	Switch on SM Test Mode */
-#define	SM_TEST_OFF	(1<<1)	/* Bit 1:	Go off the Test Mode */
-#define	SM_STEP		(1<<0)	/* Bit 0:	Step the State Machine */
+#define SM_STATE		0xf0	/* Bit 7.. 4:	State which shall be loaded */
+#define SM_LOAD			BIT_3S	/* Load the SM with SM_STATE */
+#define SM_TEST_ON		BIT_2S	/* Switch on SM Test Mode */
+#define SM_TEST_OFF		BIT_1S	/* Go off the Test Mode */
+#define SM_STEP			BIT_0S	/* Step the State Machine */
 /* The encoding of the states is not supported by the Diagnostics Tool */
 
 /*	Q_T2	32 bit	Test Register 2	*/
-				/* Bit 31..8:	reserved */
-#define	T2_AC_T_ON	(1<<7)	/* Bit 7:	Address Counter Test Mode on */
-#define	T2_AC_T_OFF	(1<<6)	/* Bit 6:	Address Counter Test Mode off*/
-#define	T2_BC_T_ON	(1<<5)	/* Bit 5:	Byte Counter Test Mode on */
-#define	T2_BC_T_OFF	(1<<4)	/* Bit 4:	Byte Counter Test Mode off */
-#define	T2_STEP04	(1<<3)	/* Bit 3:	Inc AC/Dec BC by 4 */
-#define	T2_STEP03	(1<<2)	/* Bit 2:	Inc AC/Dec BC by 3 */
-#define	T2_STEP02	(1<<1)	/* Bit 1:	Inc AC/Dec BC by 2 */
-#define	T2_STEP01	(1<<0)	/* Bit 0:	Inc AC/Dec BC by 1 */
+								/* Bit 31.. 8:	reserved */
+#define T2_AC_T_ON		BIT_7	/* Address Counter Test Mode on */
+#define T2_AC_T_OFF		BIT_6	/* Address Counter Test Mode off */
+#define T2_BC_T_ON		BIT_5	/* Byte Counter Test Mode on */
+#define T2_BC_T_OFF		BIT_4	/* Byte Counter Test Mode off */
+#define T2_STEP04		BIT_3	/* Inc AC/Dec BC by 4 */
+#define T2_STEP03		BIT_2	/* Inc AC/Dec BC by 3 */
+#define T2_STEP02		BIT_1	/* Inc AC/Dec BC by 2 */
+#define T2_STEP01		BIT_0	/* Inc AC/Dec BC by 1 */
 
 /*	Q_T3	32 bit	Test Register 3	*/
-							/* Bit 31..7:	reserved */
-#define	T3_MUX		(7<<4)	/* Bit 6.. 4:	Mux Position */
-							/* Bit 3:	reserved */
-#define	T3_VRAM		(7<<0)	/* Bit 2.. 0:	Virtual RAM Buffer Address */
+								/* Bit 31.. 7:	reserved */
+#define T3_MUX_MSK		(7<<4)	/* Bit  6.. 4:	Mux Position */
+								/* Bit  3:	reserved */
+#define T3_VRAM_MSK		7		/* Bit  2.. 0:	Virtual RAM Buffer Address */
 
-/* RAM Buffer Register Offsets */
-/* use RB_ADDR(Queue,Offs) to address */
+/* RAM Buffer Register Offsets, use RB_ADDR(Queue, Offs) to access */
 /*	RB_START	32 bit	RAM Buffer Start Address */
 /*	RB_END		32 bit	RAM Buffer End Address */
 /*	RB_WP		32 bit	RAM Buffer Write Pointer */
 /*	RB_RP		32 bit	RAM Buffer Read Pointer */
 /*	RB_RX_UTPP	32 bit	Rx Upper Threshold, Pause Pack */
-/*	RB_RX_LTPP	32 bit	Rx Lower Threshold, Pasue Pack */
+/*	RB_RX_LTPP	32 bit	Rx Lower Threshold, Pause Pack */
 /*	RB_RX_UTHP	32 bit	Rx Upper Threshold, High Prio */
 /*	RB_RX_LTHP	32 bit	Rx Lower Threshold, High Prio */
 /*	RB_PC		32 bit	RAM Buffer Packet Counter */
@@ -1191,144 +1482,327 @@
 				/* Bit 31..19:	reserved */
 #define RB_MSK	0x0007ffff	/* Bit 18.. 0:	RAM Buffer Pointer Bits */
 
-/*	RB_TST2		8 bit	RAM Buffer Test Register 2 */
-							/* Bit 4..7:	reserved */
-#define	RB_PC_DEC	(1<<3)	/* Bit 3:	Packet Counter Decrem */
-#define RB_PC_T_ON	(1<<2)	/* Bit 2:	Packet Counter Test On */
-#define RB_PC_T_OFF	(1<<1)	/* Bit 1:	Packet Counter Tst Off */
-#define RB_PC_INC	(1<<0)	/* Bit 0:	Packet Counter Increm */
-
-/*	RB_TST1		8 bit	RAM Buffer Test Register 1 */
-				/* Bit 7:	reserved */
-#define RB_WP_T_ON	(1<<6)	/* Bit 6:	Write Pointer Test On */
-#define RB_WP_T_OFF	(1<<5)	/* Bit 5:	Write Pointer Test Off */
-#define RB_WP_INC	(1<<4)	/* Bit 4:	Write Pointer Increm */
-							/* Bit 3:	reserved */
-#define RB_RP_T_ON	(1<<2)	/* Bit 2:	Read Pointer Test On */
-#define RB_RP_T_OFF	(1<<1)	/* Bit 1:	Read Pointer Test Off */
-#define RB_RP_DEC	(1<<0)	/* Bit 0:	Read Pointer Decrement */
-
-/*	RB_CTRL		8 bit	RAM Buffer Control Register */
-								/* Bit	7..6:	reserved */
-#define RB_ENA_STFWD	(1<<5)	/* Bit	5:	Enable Store & Forward */
-#define RB_DIS_STFWD	(1<<4)	/* Bit	4:	Disab. Store & Forward */
-#define RB_ENA_OP_MD	(1<<3)	/* Bit	3:	Enable Operation Mode */
-#define RB_DIS_OP_MD	(1<<2)	/* Bit	2:	Disab. Operation Mode */
-#define RB_RST_CLR		(1<<1)	/* Bit	1:	Clr RAM Buf STM Reset */
-#define RB_RST_SET		(1<<0)	/* Bit	0:	Set RAM Buf STM Reset */
+/*	RB_TST2			 8 bit	RAM Buffer Test Register 2 */
+								/* Bit 7.. 4:	reserved */
+#define RB_PC_DEC		BIT_3S	/* Packet Counter Decrem */
+#define RB_PC_T_ON		BIT_2S	/* Packet Counter Test On */
+#define RB_PC_T_OFF		BIT_1S	/* Packet Counter Tst Off */
+#define RB_PC_INC		BIT_0S	/* Packet Counter Increm */
+
+/*	RB_TST1			 8 bit	RAM Buffer Test Register 1 */
+							/* Bit 7:	reserved */
+#define RB_WP_T_ON		BIT_6S	/* Write Pointer Test On */
+#define RB_WP_T_OFF		BIT_5S	/* Write Pointer Test Off */
+#define RB_WP_INC		BIT_4S	/* Write Pointer Increm */
+								/* Bit 3:	reserved */
+#define RB_RP_T_ON		BIT_2S	/* Read Pointer Test On */
+#define RB_RP_T_OFF		BIT_1S	/* Read Pointer Test Off */
+#define RB_RP_DEC		BIT_0S	/* Read Pointer Decrement */
+
+/*	RB_CTRL			 8 bit	RAM Buffer Control Register */
+								/* Bit 7.. 6:	reserved */
+#define RB_ENA_STFWD	BIT_5S	/* Enable  Store & Forward */
+#define RB_DIS_STFWD	BIT_4S	/* Disable Store & Forward */
+#define RB_ENA_OP_MD	BIT_3S	/* Enable  Operation Mode */
+#define RB_DIS_OP_MD	BIT_2S	/* Disable Operation Mode */
+#define RB_RST_CLR		BIT_1S	/* Clear RAM Buf STM Reset */
+#define RB_RST_SET		BIT_0S	/* Set   RAM Buf STM Reset */
 
 
-/* Receive and Transmit MAC FIFO Registers, use MR_ADDR() to address */
+/* Receive and Transmit MAC FIFO Registers (GENESIS only) */
+
 /*	RX_MFF_EA	32 bit	Receive MAC FIFO End Address */
 /*	RX_MFF_WP	32 bit 	Receive MAC FIFO Write Pointer */
 /*	RX_MFF_RP	32 bit	Receive MAC FIFO Read Pointer */
-/*	RX_MFF_PC	32 bit	Receive MAC FIFO Packet Counter*/
+/*	RX_MFF_PC	32 bit	Receive MAC FIFO Packet Counter */
 /*	RX_MFF_LEV	32 bit	Receive MAC FIFO Level */
 /*	TX_MFF_EA	32 bit	Transmit MAC FIFO End Address */
-/*	TX_MFF_WP	32 bit 	Transmit MAC FIFO Write Pointer*/
-/*	TX_MFF_WSP	32 bit	Transmit MAC FIFO WR Shadow Pt*/
+/*	TX_MFF_WP	32 bit 	Transmit MAC FIFO Write Pointer */
+/*	TX_MFF_WSP	32 bit	Transmit MAC FIFO WR Shadow Pointer */
 /*	TX_MFF_RP	32 bit	Transmit MAC FIFO Read Pointer */
 /*	TX_MFF_PC	32 bit	Transmit MAC FIFO Packet Cnt */
 /*	TX_MFF_LEV	32 bit	Transmit MAC FIFO Level */
-							/* Bit 31..6:	reserved */
-#define MFF_MSK		0x007fL	/* Bit	5..0:	MAC FIFO Address/Pointer Bits */
+								/* Bit 31.. 6:	reserved */
+#define MFF_MSK			0x007fL	/* Bit	5.. 0:	MAC FIFO Address/Ptr Bits */
 
 /*	RX_MFF_CTRL1	16 bit	Receive MAC FIFO Control Reg 1 */
-									/* Bit 15..14:	reserved */
-#define MFF_ENA_RDY_PAT	(1<<13)		/* Bit 13:	Enable Ready Patch */
-#define MFF_DIS_RDY_PAT	(1<<12)		/* Bit 12:	Disable Ready Patch */
-#define MFF_ENA_TIM_PAT	(1<<11)		/* Bit 11:	Enable Timing Patch */
-#define MFF_DIS_TIM_PAT	(1<<10)		/* Bit 10:	Disable Timing Patch */
-#define MFF_ENA_ALM_FUL	(1<<9)		/* Bit	9:	Enable AlmostFull Sign*/
-#define MFF_DIS_ALM_FUL	(1<<8)		/* Bit	8:	Disab. AlmostFull Sign*/
-#define MFF_ENA_PAUSE	(1<<7)		/* Bit	7:	Enable Pause Signaling*/
-#define MFF_DIS_PAUSE	(1<<6)		/* Bit	6:	Disab. Pause Signaling*/
-#define MFF_ENA_FLUSH	(1<<5)		/* Bit	5:	Enable Frame Flushing */
-#define MFF_DIS_FLUSH	(1<<4)		/* Bit	4:	Disab. Frame Flushing */
-#define MFF_ENA_TIST	(1<<3)		/* Bit	3:	Enable Timestamp Gener*/
-#define MFF_DIS_TIST	(1<<2)		/* Bit	2:	Disab. Timestamp Gener*/
-#define MFF_CLR_INTIST	(1<<1)		/* Bit	1:	Clear IRQ No Timestamp*/
-#define MFF_CLR_INSTAT	(1<<0)		/* Bit	0:	Clear IRQ No Status */
+								/* Bit 15..14:	reserved */
+#define MFF_ENA_RDY_PAT	BIT_13S		/* Enable  Ready Patch */
+#define MFF_DIS_RDY_PAT	BIT_12S		/* Disable Ready Patch */
+#define MFF_ENA_TIM_PAT	BIT_11S		/* Enable  Timing Patch */
+#define MFF_DIS_TIM_PAT	BIT_10S		/* Disable Timing Patch */
+#define MFF_ENA_ALM_FUL	BIT_9S		/* Enable  AlmostFull Sign */
+#define MFF_DIS_ALM_FUL	BIT_8S		/* Disable AlmostFull Sign */
+#define MFF_ENA_PAUSE	BIT_7S		/* Enable  Pause Signaling */
+#define MFF_DIS_PAUSE	BIT_6S		/* Disable Pause Signaling */
+#define MFF_ENA_FLUSH	BIT_5S		/* Enable  Frame Flushing */
+#define MFF_DIS_FLUSH	BIT_4S		/* Disable Frame Flushing */
+#define MFF_ENA_TIST	BIT_3S		/* Enable  Time Stamp Gener */
+#define MFF_DIS_TIST	BIT_2S		/* Disable Time Stamp Gener */
+#define MFF_CLR_INTIST	BIT_1S		/* Clear IRQ No Time Stamp */
+#define MFF_CLR_INSTAT	BIT_0S		/* Clear IRQ No Status */
 
 #define MFF_RX_CTRL_DEF MFF_ENA_TIM_PAT
 
 /*	TX_MFF_CTRL1	16 bit	Transmit MAC FIFO Control Reg 1 */
-#define MFF_CLR_PERR	(1<<15)		/* Bit 15:	Clear Parity Error IRQ*/
-									/* Bit 14:	reserved */
-#define MFF_ENA_PKT_REC	(1<<13)		/* Bit 13:	Enable Packet Recovery*/
-#define MFF_DIS_PKT_REC (1<<12)		/* Bit 12:	Disable Packet Recov. */
-/*	MFF_ENA_TIM_PAT	 (see RX_MFF_CTRL1)Bit 11:	Enable Timing Patch */
-/*	MFF_DIS_TIM_PAT	 (see RX_MFF_CTRL1)Bit 10:	Disable Timing Patch */
-/*	MFF_ENA_ALM_FUL	 (see RX_MFF_CTRL1)Bit	9:	Enable AlmostFull Sign*/
-/*	MFF_DIS_ALM_FUL	 (see RX_MFF_CTRL1)Bit	8:	Disab. AlmostFull Sign*/
-#define	MFF_ENA_W4E		(1<<7)		/* Bit	7:	Enable Wait for Empty */
-#define MFF_DIS_W4E		(1<<6)		/* Bit	6:	Disab. Wait for Empty */
-/*	MFF_ENA_FLUSH	 (see RX_MFF_CTRL1)Bit	5:	Enable Frame Flushing */
-/*	MFF_DIS_FLUSH	 (see RX_MFF_CTRL1)Bit	4:	Disab. Frame Flushing */
-#define MFF_ENA_LOOPB	(1<<3)		/* Bit	3:	Enable Loopback */
-#define MFF_DIS_LOOPB	(1<<2)		/* Bit	2:	Disable Loopback */
-#define MFF_CLR_MAC_RST	(1<<1)		/* Bit	1:	Clear XMAC Reset */
-#define MFF_SET_MAC_RST	(1<<0)		/* Bit	0:	Set XMAC Reset */
+#define MFF_CLR_PERR	BIT_15S		/* Clear Parity Error IRQ */
+								/* Bit 14:	reserved */
+#define MFF_ENA_PKT_REC	BIT_13S		/* Enable  Packet Recovery */
+#define MFF_DIS_PKT_REC BIT_12S		/* Disable Packet Recovery */
+/*	MFF_ENA_TIM_PAT	 (see RX_MFF_CTRL1) Bit 11:	Enable  Timing Patch */
+/*	MFF_DIS_TIM_PAT	 (see RX_MFF_CTRL1) Bit 10:	Disable Timing Patch */
+/*	MFF_ENA_ALM_FUL	 (see RX_MFF_CTRL1) Bit	 9:	Enable  Almost Full Sign */
+/*	MFF_DIS_ALM_FUL	 (see RX_MFF_CTRL1) Bit	 8:	Disable Almost Full Sign */
+#define MFF_ENA_W4E		BIT_7S		/* Enable  Wait for Empty */
+#define MFF_DIS_W4E		BIT_6S		/* Disable Wait for Empty */
+/*	MFF_ENA_FLUSH	 (see RX_MFF_CTRL1) Bit	 5:	Enable  Frame Flushing */
+/*	MFF_DIS_FLUSH	 (see RX_MFF_CTRL1) Bit	 4:	Disable Frame Flushing */
+#define MFF_ENA_LOOPB	BIT_3S		/* Enable  Loopback */
+#define MFF_DIS_LOOPB	BIT_2S		/* Disable Loopback */
+#define MFF_CLR_MAC_RST	BIT_1S		/* Clear XMAC Reset */
+#define MFF_SET_MAC_RST	BIT_0S		/* Set   XMAC Reset */
 
 #define MFF_TX_CTRL_DEF	(MFF_ENA_PKT_REC | MFF_ENA_TIM_PAT | MFF_ENA_FLUSH)
 
-/*	RX_MFF_TST2	 8 bit	Receive MAC FIFO Test Register 2 */
-/*	TX_MFF_TST2	 8 bit	Transmit MAC FIFO Test Register 2 */
+/*	RX_MFF_TST2	 	 8 bit	Receive MAC FIFO Test Register 2 */
+/*	TX_MFF_TST2	 	 8 bit	Transmit MAC FIFO Test Register 2 */
 								/* Bit 7:	reserved */
-#define MFF_WSP_T_ON	(1<<6)	/* Bit 6: (Tx)	Write Shadow Pt TestOn */
-#define MFF_WSP_T_OFF	(1<<5)	/* Bit 5: (Tx)	Write Shadow Pt TstOff */
-#define MFF_WSP_INC		(1<<4)	/* Bit 4: (Tx)	Write Shadow Pt Increm */
-#define	MFF_PC_DEC		(1<<3)	/* Bit 3:	Packet Counter Decrem  */
-#define MFF_PC_T_ON		(1<<2)	/* Bit 2:	Packet Counter Test On */
-#define MFF_PC_T_OFF	(1<<1)	/* Bit 1:	Packet Counter Tst Off */
-#define MFF_PC_INC		(1<<0)	/* Bit 0:	Packet Counter Increm  */
+#define MFF_WSP_T_ON	BIT_6S	/* Tx: Write Shadow Ptr TestOn */
+#define MFF_WSP_T_OFF	BIT_5S	/* Tx: Write Shadow Ptr TstOff */
+#define MFF_WSP_INC		BIT_4S	/* Tx: Write Shadow Ptr Increment */
+#define MFF_PC_DEC		BIT_3S	/* Packet Counter Decrement */
+#define MFF_PC_T_ON		BIT_2S	/* Packet Counter Test On */
+#define MFF_PC_T_OFF	BIT_1S	/* Packet Counter Test Off */
+#define MFF_PC_INC		BIT_0S	/* Packet Counter Increment */
 
-/*	RX_MFF_TST1	 8 bit	Receive MAC FIFO Test Register 1 */
-/*	TX_MFF_TST1	 8 bit	Transmit MAC FIFO Test Register 1 */
+/*	RX_MFF_TST1	 	 8 bit	Receive MAC FIFO Test Register 1 */
+/*	TX_MFF_TST1	 	 8 bit	Transmit MAC FIFO Test Register 1 */
 					/* Bit 7:	reserved */
-#define MFF_WP_T_ON		(1<<6)	/* Bit 6:	Write Pointer Test On */
-#define MFF_WP_T_OFF	(1<<5)	/* Bit 5:	Write Pointer Test Off */
-#define MFF_WP_INC		(1<<4)	/* Bit 4:	Write Pointer Increm */
-								/* Bit 3:	reserved */
-#define MFF_RP_T_ON		(1<<2)	/* Bit 2:	Read Pointer Test On */
-#define MFF_RP_T_OFF	(1<<1)	/* Bit 1:	Read Pointer Test Off */
-#define MFF_RP_DEC		(1<<0)	/* Bit 0:	Read Pointer Decrement */
+#define MFF_WP_T_ON		BIT_6S	/* Write Pointer Test On */
+#define MFF_WP_T_OFF	BIT_5S	/* Write Pointer Test Off */
+#define MFF_WP_INC		BIT_4S	/* Write Pointer Increm */
+							/* Bit 3:	reserved */
+#define MFF_RP_T_ON		BIT_2S	/* Read Pointer Test On */
+#define MFF_RP_T_OFF	BIT_1S	/* Read Pointer Test Off */
+#define MFF_RP_DEC		BIT_0S	/* Read Pointer Decrement */
 
 /*	RX_MFF_CTRL2	 8 bit	Receive MAC FIFO Control Reg 2 */
 /*	TX_MFF_CTRL2	 8 bit	Transmit MAC FIFO Control Reg 2 */
 								/* Bit 7..4:	reserved */
-#define MFF_ENA_OP_MD	(1<<3)	/* Bit 3:	Enable Operation Mode */
-#define MFF_DIS_OP_MD	(1<<2)	/* Bit 2:	Disab. Operation Mode */
-#define MFF_RST_CLR		(1<<1)	/* Bit 1:	Clear MAC FIFO Reset */
-#define MFF_RST_SET		(1<<0)	/* Bit 0:	Set MAC FIFO Reset */
-
-
-/* Receive, Transmit, and Link LED Counter Registers */
-/*	RX_LED_CTRL		8 bit	Receive LED Cnt Control Reg */
-/*	TX_LED_CTRL		8 bit	Transmit LED Cnt Control Reg */
-/*	LNK_SYNC_CTRL	8 bit	Link Sync Cnt Control Register */
-							/* Bit 7..3:	reserved */
-#define LED_START	(1<<2)	/* Bit 2:	Start Timer */
-#define LED_STOP	(1<<1)	/* Bit 1:	Stop Timer */
-#define LED_STATE	(1<<0)	/* Bit 0:(Rx/Tx)LED State, 1=LED on */
-#define LED_CLR_IRQ	(1<<0)	/* Bit 0:(Lnk) 	Clear Link IRQ */
-
-/*	RX_LED_TST		8 bit	Receive LED Cnt Test Register */
-/*	TX_LED_TST		8 bit	Transmit LED Cnt Test Register */
-/*	LNK_SYNC_TST	8 bit	Link Sync Cnt Test Register */
-							/* Bit 7..3:	reserved */
-#define LED_T_ON	(1<<2)	/* Bit 2:	LED Counter Testmode On */
-#define LED_T_OFF	(1<<1)	/* Bit 1:	LED Counter Testmode Off */
-#define LED_T_STEP	(1<<0)	/* Bit 0:	LED Counter Step */
-
-/*	LNK_LED_REG	 8 bit	Link LED Register */
-								/* Bit 7..6:	reserved */
-#define LED_BLK_ON		(1<<5)	/* Bit 5:	Link LED Blinking On */
-#define LED_BLK_OFF		(1<<4)	/* Bit 4:	Link LED Blinking Off */
-#define LED_SYNC_ON		(1<<3)	/* Bit 3:	Use Sync Wire to switch LED */
-#define LED_SYNC_OFF	(1<<2)	/* Bit 2:	Disable Sync Wire Input */
-#define LED_ON			(1<<1)	/* Bit 1:	switch LED on */
-#define LED_OFF			(1<<0)	/* Bit 0:	switch LED off */
+#define MFF_ENA_OP_MD	BIT_3S	/* Enable  Operation Mode */
+#define MFF_DIS_OP_MD	BIT_2S	/* Disable Operation Mode */
+#define MFF_RST_CLR		BIT_1S	/* Clear MAC FIFO Reset */
+#define MFF_RST_SET		BIT_0S	/* Set   MAC FIFO Reset */
+
+
+/*	Link LED Counter Registers (GENESIS only) */
+
+/*	RX_LED_CTRL		 8 bit	Receive LED Cnt Control Reg */
+/*	TX_LED_CTRL		 8 bit	Transmit LED Cnt Control Reg */
+/*	LNK_SYNC_CTRL	 8 bit	Link Sync Cnt Control Register */
+							/* Bit 7.. 3:	reserved */
+#define LED_START		BIT_2S	/* Start Timer */
+#define LED_STOP		BIT_1S	/* Stop Timer */
+#define LED_STATE		BIT_0S	/* Rx/Tx: LED State, 1=LED on */
+#define LED_CLR_IRQ		BIT_0S	/* Lnk: 	Clear Link IRQ */
+
+/*	RX_LED_TST		 8 bit	Receive LED Cnt Test Register */
+/*	TX_LED_TST		 8 bit	Transmit LED Cnt Test Register */
+/*	LNK_SYNC_TST	 8 bit	Link Sync Cnt Test Register */
+							/* Bit 7.. 3:	reserved */
+#define LED_T_ON		BIT_2S	/* LED Counter Test mode On */
+#define LED_T_OFF		BIT_1S	/* LED Counter Test mode Off */
+#define LED_T_STEP		BIT_0S	/* LED Counter Step */
+
+/*	LNK_LED_REG	 	 8 bit	Link LED Register */
+								/* Bit 7.. 6:	reserved */
+#define LED_BLK_ON		BIT_5S	/* Link LED Blinking On */
+#define LED_BLK_OFF		BIT_4S	/* Link LED Blinking Off */
+#define LED_SYNC_ON		BIT_3S	/* Use Sync Wire to switch LED */
+#define LED_SYNC_OFF	BIT_2S	/* Disable Sync Wire Input */
+#define LED_ON			BIT_1S	/* switch LED on */
+#define LED_OFF			BIT_0S	/* switch LED off */
+
+/*	Receive and Transmit GMAC FIFO Registers (YUKON only) */
+
+/*	RX_GMF_EA		32 bit	Rx GMAC FIFO End Address */
+/*	RX_GMF_AF_THR	32 bit	Rx GMAC FIFO Almost Full Thresh. */
+/*	RX_GMF_WP		32 bit 	Rx GMAC FIFO Write Pointer */
+/*	RX_GMF_WLEV		32 bit 	Rx GMAC FIFO Write Level */
+/*	RX_GMF_RP		32 bit 	Rx GMAC FIFO Read Pointer */
+/*	RX_GMF_RLEV		32 bit 	Rx GMAC FIFO Read Level */
+/*	TX_GMF_EA		32 bit	Tx GMAC FIFO End Address */
+/*	TX_GMF_AE_THR	32 bit	Tx GMAC FIFO Almost Empty Thresh.*/
+/*	TX_GMF_WP		32 bit 	Tx GMAC FIFO Write Pointer */
+/*	TX_GMF_WSP		32 bit 	Tx GMAC FIFO Write Shadow Ptr. */
+/*	TX_GMF_WLEV		32 bit 	Tx GMAC FIFO Write Level */
+/*	TX_GMF_RP		32 bit 	Tx GMAC FIFO Read Pointer */
+/*	TX_GMF_RSTP		32 bit 	Tx GMAC FIFO Restart Pointer */
+/*	TX_GMF_RLEV		32 bit 	Tx GMAC FIFO Read Level */
+
+/*	RX_GMF_CTRL_T	32 bit	Rx GMAC FIFO Control/Test */
+						/* Bits 31..15:	reserved */
+#define GMF_WP_TST_ON	BIT_14		/* Write Pointer Test On */
+#define GMF_WP_TST_OFF	BIT_13		/* Write Pointer Test Off */
+#define GMF_WP_STEP		BIT_12		/* Write Pointer Step/Increment */
+						/* Bit 11:	reserved */
+#define GMF_RP_TST_ON	BIT_10		/* Read Pointer Test On */
+#define GMF_RP_TST_OFF	BIT_9		/* Read Pointer Test Off */
+#define GMF_RP_STEP		BIT_8		/* Read Pointer Step/Increment */
+#define GMF_RX_F_FL_ON	BIT_7		/* Rx FIFO Flush Mode On */
+#define GMF_RX_F_FL_OFF	BIT_6		/* Rx FIFO Flush Mode Off */
+#define GMF_CLI_RX_FO	BIT_5		/* Clear IRQ Rx FIFO Overrun */
+#define GMF_CLI_RX_FC	BIT_4		/* Clear IRQ Rx Frame Complete */
+#define GMF_OPER_ON		BIT_3		/* Operational Mode On */
+#define GMF_OPER_OFF	BIT_2		/* Operational Mode Off */
+#define GMF_RST_CLR		BIT_1		/* Clear GMAC FIFO Reset */
+#define GMF_RST_SET		BIT_0		/* Set   GMAC FIFO Reset */
+
+/*	TX_GMF_CTRL_T	32 bit	Tx GMAC FIFO Control/Test */
+						/* Bits 31..19:	reserved */
+#define GMF_WSP_TST_ON	BIT_18		/* Write Shadow Pointer Test On */
+#define GMF_WSP_TST_OFF	BIT_17		/* Write Shadow Pointer Test Off */
+#define GMF_WSP_STEP	BIT_16		/* Write Shadow Pointer Step/Increment */
+						/* Bits 15..7: same as for RX_GMF_CTRL_T */
+#define GMF_CLI_TX_FU	BIT_6		/* Clear IRQ Tx FIFO Underrun */
+#define GMF_CLI_TX_FC	BIT_5		/* Clear IRQ Tx Frame Complete */
+#define GMF_CLI_TX_PE	BIT_4		/* Clear IRQ Tx Parity Error */
+						/* Bits 3..0: same as for RX_GMF_CTRL_T */
+
+#define GMF_RX_CTRL_DEF		(GMF_OPER_ON | GMF_RX_F_FL_ON)
+#define GMF_TX_CTRL_DEF		GMF_OPER_ON
+
+#define RX_GMF_FL_THR_DEF	0x0a	/* Rx GMAC FIFO Flush Threshold default */
+
+/*	GMAC_TI_ST_CTRL		  8 bit	Time Stamp Timer Ctrl Reg (YUKON only) */
+								/* Bit 7.. 3:	reserved */
+#define GMT_ST_START	BIT_2S		/* Start Time Stamp Timer */
+#define GMT_ST_STOP		BIT_1S		/* Stop  Time Stamp Timer */
+#define GMT_ST_CLR_IRQ	BIT_0S		/* Clear Time Stamp Timer IRQ */
+
+/*	GMAC_CTRL		32 bit	GMAC Control Reg (YUKON only) */
+						/* Bits 31.. 8:	reserved */
+#define GMC_H_BURST_ON	BIT_7		/* Half Duplex Burst Mode On */
+#define GMC_H_BURST_OFF	BIT_6		/* Half Duplex Burst Mode Off */
+#define GMC_F_LOOPB_ON	BIT_5		/* FIFO Loopback On */
+#define GMC_F_LOOPB_OFF	BIT_4		/* FIFO Loopback Off */
+#define GMC_PAUSE_ON	BIT_3		/* Pause On */
+#define GMC_PAUSE_OFF	BIT_2		/* Pause Off */
+#define GMC_RST_CLR		BIT_1		/* Clear GMAC Reset */
+#define GMC_RST_SET		BIT_0		/* Set   GMAC Reset */
+
+/*	GPHY_CTRL		32 bit	GPHY Control Reg (YUKON only) */
+						/* Bits 31..29:	reserved */
+#define GPC_SEL_BDT		BIT_28	/* Select Bi-Dir. Transfer for MDC/MDIO */
+#define GPC_INT_POL_HI	BIT_27	/* IRQ Polarity is Active HIGH */
+#define GPC_75_OHM		BIT_26	/* Use 75 Ohm Termination instead of 50 */
+#define GPC_DIS_FC		BIT_25	/* Disable Automatic Fiber/Copper Detection */
+#define GPC_DIS_SLEEP	BIT_24	/* Disable Energy Detect */
+#define GPC_HWCFG_M_3	BIT_23	/* HWCFG_MODE[3] */
+#define GPC_HWCFG_M_2	BIT_22	/* HWCFG_MODE[2] */
+#define GPC_HWCFG_M_1	BIT_21	/* HWCFG_MODE[1] */
+#define GPC_HWCFG_M_0	BIT_20	/* HWCFG_MODE[0] */
+#define GPC_ANEG_0		BIT_19	/* ANEG[0] */
+#define GPC_ENA_XC		BIT_18	/* Enable MDI crossover */
+#define GPC_DIS_125		BIT_17	/* Disable 125 MHz clock */
+#define GPC_ANEG_3		BIT_16	/* ANEG[3] */
+#define GPC_ANEG_2		BIT_15	/* ANEG[2] */
+#define GPC_ANEG_1		BIT_14	/* ANEG[1] */
+#define GPC_ENA_PAUSE	BIT_13	/* Enable Pause (SYM_OR_REM) */
+#define GPC_PHYADDR_4	BIT_12	/* Bit 4 of Phy Addr */
+#define GPC_PHYADDR_3	BIT_11	/* Bit 3 of Phy Addr */
+#define GPC_PHYADDR_2	BIT_10	/* Bit 2 of Phy Addr */
+#define GPC_PHYADDR_1	BIT_9	/* Bit 1 of Phy Addr */
+#define GPC_PHYADDR_0	BIT_8	/* Bit 0 of Phy Addr */
+						/* Bits  7..2:	reserved */
+#define GPC_RST_CLR		BIT_1	/* Clear GPHY Reset */
+#define GPC_RST_SET		BIT_0	/* Set   GPHY Reset */
+
+#define GPC_HWCFG_GMII_COP	(GPC_HWCFG_M_3 | GPC_HWCFG_M_2 | \
+							 GPC_HWCFG_M_1 | GPC_HWCFG_M_0)
+
+#define GPC_HWCFG_GMII_FIB	(				 GPC_HWCFG_M_2 | \
+							 GPC_HWCFG_M_1 | GPC_HWCFG_M_0)
+
+#define GPC_ANEG_ADV_ALL_M	(GPC_ANEG_3 | GPC_ANEG_2 | \
+							 GPC_ANEG_1 | GPC_ANEG_0)
+
+/* forced speed and duplex mode (don't mix with other ANEG bits) */
+#define GPC_FRC10MBIT_HALF	0
+#define GPC_FRC10MBIT_FULL	GPC_ANEG_0
+#define GPC_FRC100MBIT_HALF	GPC_ANEG_1
+#define GPC_FRC100MBIT_FULL	(GPC_ANEG_0 | GPC_ANEG_1)
+
+/* auto-negotiation with limited advertised speeds */
+/* mix only with master/slave settings (for copper) */
+#define GPC_ADV_1000_HALF	GPC_ANEG_2
+#define GPC_ADV_1000_FULL	GPC_ANEG_3
+#define GPC_ADV_ALL			(GPC_ANEG_2 | GPC_ANEG_3)
+
+/* master/slave settings */
+/* only for copper with 1000 Mbps */
+#define GPC_FORCE_MASTER	0
+#define GPC_FORCE_SLAVE		GPC_ANEG_0
+#define GPC_PREF_MASTER		GPC_ANEG_1
+#define GPC_PREF_SLAVE		(GPC_ANEG_1 | GPC_ANEG_0)
+
+/*	GMAC_IRQ_SRC	 8 bit	GMAC Interrupt Source Reg (YUKON only) */
+/*	GMAC_IRQ_MSK	 8 bit	GMAC Interrupt Mask   Reg (YUKON only) */
+#define GM_IS_TX_CO_OV	BIT_5		/* Transmit Counter Overflow IRQ */
+#define GM_IS_RX_CO_OV	BIT_4		/* Receive Counter Overflow IRQ */
+#define GM_IS_TX_FF_UR	BIT_3		/* Transmit FIFO Underrun */
+#define GM_IS_TX_COMPL	BIT_2		/* Frame Transmission Complete */
+#define GM_IS_RX_FF_OR	BIT_1		/* Receive FIFO Overrun */
+#define GM_IS_RX_COMPL	BIT_0		/* Frame Reception Complete */
+
+#define GMAC_DEF_MSK	(GM_IS_TX_CO_OV | GM_IS_RX_CO_OV | \
+						GM_IS_TX_FF_UR)
+
+/*	GMAC_LINK_CTRL		16 bit	GMAC Link Control Reg (YUKON only) */
+						/* Bits 15.. 2:	reserved */
+#define GMLC_RST_CLR	BIT_1S		/* Clear GMAC Link Reset */
+#define GMLC_RST_SET	BIT_0S		/* Set   GMAC Link Reset */
+
+
+/*	WOL_CTRL_STAT		16 bit	WOL Control/Status Reg */
+#define WOL_CTL_LINK_CHG_OCC			BIT_15S
+#define WOL_CTL_MAGIC_PKT_OCC			BIT_14S
+#define WOL_CTL_PATTERN_OCC				BIT_13S
+
+#define WOL_CTL_CLEAR_RESULT			BIT_12S
+
+#define WOL_CTL_ENA_PME_ON_LINK_CHG		BIT_11S
+#define WOL_CTL_DIS_PME_ON_LINK_CHG		BIT_10S
+#define WOL_CTL_ENA_PME_ON_MAGIC_PKT	BIT_9S
+#define WOL_CTL_DIS_PME_ON_MAGIC_PKT	BIT_8S
+#define WOL_CTL_ENA_PME_ON_PATTERN		BIT_7S
+#define WOL_CTL_DIS_PME_ON_PATTERN		BIT_6S
+
+#define WOL_CTL_ENA_LINK_CHG_UNIT		BIT_5S
+#define WOL_CTL_DIS_LINK_CHG_UNIT		BIT_4S
+#define WOL_CTL_ENA_MAGIC_PKT_UNIT		BIT_3S
+#define WOL_CTL_DIS_MAGIC_PKT_UNIT		BIT_2S
+#define WOL_CTL_ENA_PATTERN_UNIT		BIT_1S
+#define WOL_CTL_DIS_PATTERN_UNIT		BIT_0S
+
+#define WOL_CTL_DEFAULT				\
+	(WOL_CTL_DIS_PME_ON_LINK_CHG |	\
+	WOL_CTL_DIS_PME_ON_PATTERN |	\
+	WOL_CTL_DIS_PME_ON_MAGIC_PKT |	\
+	WOL_CTL_DIS_LINK_CHG_UNIT |		\
+	WOL_CTL_DIS_PATTERN_UNIT |		\
+	WOL_CTL_DIS_MAGIC_PKT_UNIT)
+	
+/*	WOL_MATCH_CTL		 8 bit	WOL Match Control Reg */
+#define WOL_CTL_PATT_ENA(x)				(BIT_0 << (x))
+
+#define SK_NUM_WOL_PATTERN		7
+#define SK_PATTERN_PER_WORD		4
+#define SK_BITMASK_PATTERN		7
+#define SK_POW_PATTERN_LENGTH	128
+
+#define WOL_LENGTH_MSK		0x7f
+#define WOL_LENGTH_SHIFT	8
 
 
 /* Receive and Transmit Descriptors ******************************************/
@@ -1357,55 +1831,56 @@
 /* Receive Descriptor struct */
 typedef	struct s_HwRxd {
 	SK_U32 volatile RxCtrl;	/* Receive Buffer Control Field */
-	SK_U32	RxNext;		/* Physical Address Pointer to the next TxD */
-	SK_U32	RxAdrLo;	/* Physical Receive Buffer Address lower dword*/
-	SK_U32	RxAdrHi;	/* Physical Receive Buffer Address upper dword*/
-	SK_U32	RxStat;		/* Receive Frame Status Word */
-	SK_U32	RxTiSt;		/* Receive Timestamp provided by the XMAC */
+	SK_U32	RxNext;			/* Physical Address Pointer to the next RxD */
+	SK_U32	RxAdrLo;		/* Physical Rx Buffer Address lower dword */
+	SK_U32	RxAdrHi;		/* Physical Rx Buffer Address upper dword */
+	SK_U32	RxStat;			/* Receive Frame Status Word */
+	SK_U32	RxTiSt;			/* Receive Time Stamp (from XMAC on GENESIS) */
 #ifndef	SK_USE_REV_DESC	
-	SK_U16	RxTcpSum1;	/* TCP Checksum 1 */
-	SK_U16	RxTcpSum2;	/* TCP Checksum 2 */
-	SK_U16	RxTcpSp1;	/* TCP Checksum Calculation Start Position 1 */
-	SK_U16	RxTcpSp2;	/* TCP Checksum Calculation Start Position 2 */
+	SK_U16	RxTcpSum1;		/* TCP Checksum 1 */
+	SK_U16	RxTcpSum2;		/* TCP Checksum 2 */
+	SK_U16	RxTcpSp1;		/* TCP Checksum Calculation Start Position 1 */
+	SK_U16	RxTcpSp2;		/* TCP Checksum Calculation Start Position 2 */
 #else	/* SK_USE_REV_DESC */
-	SK_U16	RxTcpSum2;	/* TCP Checksum 2 */
-	SK_U16	RxTcpSum1;	/* TCP Checksum 1 */
-	SK_U16	RxTcpSp2;	/* TCP Checksum Calculation Start Position 2 */
-	SK_U16	RxTcpSp1;	/* TCP Checksum Calculation Start Position 1 */
+	SK_U16	RxTcpSum2;		/* TCP Checksum 2 */
+	SK_U16	RxTcpSum1;		/* TCP Checksum 1 */
+	SK_U16	RxTcpSp2;		/* TCP Checksum Calculation Start Position 2 */
+	SK_U16	RxTcpSp1;		/* TCP Checksum Calculation Start Position 1 */
 #endif	/* SK_USE_REV_DESC */
 } SK_HWRXD;
 
 /*
  * Drivers which use the reverse descriptor feature (PCI_OUR_REG_2)
  * should set the define SK_USE_REV_DESC.
- * Structures are 'normaly' not endianess dependent. But in 
+ * Structures are 'normaly' not endianess dependent. But in
  * this case the SK_U16 fields are bound to bit positions inside the
  * descriptor. RxTcpSum1 e.g. must start at bit 0 within the 6.th DWord.
  * The bit positions inside a DWord are of course endianess dependent and
- * swaps if the DWord is swaped by the hardware.
+ * swaps if the DWord is swapped by the hardware.
  */
 
 
 /* Descriptor Bit Definition */
 /*	TxCtrl		Transmit Buffer Control Field */
-/*	RxCtrl		Receive Buffer Control Field */
-#define	BMU_OWN			(1UL<<31)	/* Bit 31:	OWN bit: 0=host/1=BMU */
-#define	BMU_STF			(1L<<30)	/* Bit 30:	Start of Frame ? */
-#define	BMU_EOF			(1L<<29)	/* Bit 29:	End of Frame ?	*/
-#define	BMU_IRQ_EOB		(1L<<28)	/* Bit 28:	Req "End of Buff" IRQ */
-#define	BMU_IRQ_EOF		(1L<<27)	/* Bit 27:	Req "End of Frame" IRQ*/
+/*	RxCtrl		Receive  Buffer Control Field */
+#define BMU_OWN			BIT_31	/* OWN bit: 0=host/1=BMU */
+#define BMU_STF			BIT_30	/* Start of Frame */
+#define BMU_EOF			BIT_29	/* End of Frame */
+#define BMU_IRQ_EOB		BIT_28	/* Req "End of Buffer" IRQ */
+#define BMU_IRQ_EOF		BIT_27	/* Req "End of Frame" IRQ */
 /* TxCtrl specific bits */
-#define BMU_STFWD		(1L<<26)	/* Bit 26: (Tx)	Store&Forward Frame */
-#define BMU_NO_FCS		(1L<<25)	/* Bit 25: (Tx) disable XMAC FCS gener*/
-#define BMU_SW			(1L<<24)	/* Bit 24: (Tx)	1 bit res. for SW use */
+#define BMU_STFWD		BIT_26	/* (Tx)	Store & Forward Frame */
+#define BMU_NO_FCS		BIT_25	/* (Tx) Disable MAC FCS (CRC) generation */
+#define BMU_SW			BIT_24	/* (Tx)	1 bit res. for SW use */
 /* RxCtrl specific bits */
-#define	BMU_DEV_0		(1L<<26)	/* Bit 26: (Rx)	transfer data to Dev0 */
-#define BMU_STAT_VAL	(1L<<25)	/* Bit 25: (Rx)	RxStat Valid */
-#define BMU_TIST_VAL	(1L<<24)	/* Bit 24: (Rx)	RxTiSt Valid */
-									/* Bit 23..16:	BMU Check Opcodes */
-#define	BMU_CHECK		0x00550000L	/* 		Default BMU check */
-#define	BMU_TCP_CHECK	0x00560000L	/* 		Descr with TCP ext */
-#define	BMU_BBC			0x0000FFFFL	/* Bit 15..0:	Buffer Byte Counter */
+#define BMU_DEV_0		BIT_26	/* (Rx)	Transfer data to Dev0 */
+#define BMU_STAT_VAL	BIT_25	/* (Rx)	Rx Status Valid */
+#define BMU_TIST_VAL	BIT_24	/* (Rx)	Rx TimeStamp Valid */
+								/* Bit 23..16:	BMU Check Opcodes */
+#define BMU_CHECK		(0x55L<<16)	/* Default BMU check */
+#define BMU_TCP_CHECK	(0x56L<<16)	/* Descr with TCP ext */
+#define BMU_UDP_CHECK	(0x57L<<16)	/* Descr with UDP ext (YUKON only) */
+#define BMU_BBC			0xffffL	/* Bit 15.. 0:	Buffer Byte Counter */
 
 /*	TxStat		Transmit Frame Status Word */
 /*	RxStat		Receive Frame Status Word */
@@ -1421,9 +1896,9 @@
 /*
  * FlashProm specification
  */
-#define	MAX_PAGES	0x20000L	/* Every byte has a single page */
-#define	MAX_FADDR	1			/* 1 byte per page */
-#define	SKFDDI_PSZ	8			/* address PROM size */
+#define MAX_PAGES	0x20000L	/* Every byte has a single page */
+#define MAX_FADDR	1			/* 1 byte per page */
+#define SKFDDI_PSZ	8			/* address PROM size */
 
 /* macros ********************************************************************/
 
@@ -1440,59 +1915,67 @@
 /*
  *	Macro Q_ADDR()
  *
- *	Use this macro to address the Receive and Transmit Queue Registers.
+ *	Use this macro to access the Receive and Transmit Queue Registers.
  *
- * para	Queue	Queue to address.
- *			Values: Q_R1, Q_R2, Q_XS1, Q_XA1, Q_XS2, and Q_XA2
+ * para:	
+ *	Queue	Queue to access.
+ *				Values: Q_R1, Q_R2, Q_XS1, Q_XA1, Q_XS2, and Q_XA2
  *	Offs	Queue register offset.
- *			Values: Q_D, Q_DA_L ... Q_T2, Q_T3
+ *				Values: Q_D, Q_DA_L ... Q_T2, Q_T3
  *
- * usage	SK_IN32(pAC,Q_ADDR(Q_R2,Q_BC),pVal)
+ * usage	SK_IN32(pAC, Q_ADDR(Q_R2, Q_BC), pVal)
  */
-#define Q_ADDR(Queue,Offs)	(B8_Q_REGS + (Queue) + (Offs))
+#define Q_ADDR(Queue, Offs)	(B8_Q_REGS + (Queue) + (Offs))
 
 /*
  *	Macro RB_ADDR()
  *
- *	Use this macro to address the RAM Buffer Registers.
+ *	Use this macro to access the RAM Buffer Registers.
  *
- * para	Queue	Queue to address.
- *			Values: Q_R1, Q_R2, Q_XS1, Q_XA1, Q_XS2, and Q_XA2
+ * para:	
+ *	Queue	Queue to access.
+ *				Values: Q_R1, Q_R2, Q_XS1, Q_XA1, Q_XS2, and Q_XA2
  *	Offs	Queue register offset.
- *			Values: RB_START, RB_END ... RB_LEV, RB_CTRL
+ *				Values: RB_START, RB_END ... RB_LEV, RB_CTRL
  *
- * usage	SK_IN32(pAC,RB_ADDR(Q_R2,RB_RP),pVal)
+ * usage	SK_IN32(pAC, RB_ADDR(Q_R2, RB_RP), pVal)
  */
-#define RB_ADDR(Queue,Offs)	(B16_RAM_REGS + (Queue) + (Offs))
+#define RB_ADDR(Queue, Offs)	(B16_RAM_REGS + (Queue) + (Offs))
 
 
 /*
  * MAC Related Registers
  */
-#define	MAC_1		0	/* belongs to the port near the slot */
+#define MAC_1		0	/* belongs to the port near the slot */
 #define MAC_2		1	/* belongs to the port far away from the slot */
 
 /*
  *	Macro MR_ADDR()
  *
- *	Use this macro to address a MAC Related Registers in side the ASIC.
+ *	Use this macro to access a MAC Related Registers inside the ASIC.
  *
- * para	Queue	Queue to address.
- *			Values:	TXA_ITI_INI	...	TXA_TEST,
- *				RX_MFF_EA	...	RX_LED_TST,
- *				LNK_SYNC_INI	...	LNK_LED_REG, and
- *				TX_MFF_EA	...	TX_LED_TST
- *	Mac	MAC to address.
- *			Values: MAC_1, MAC_2
+ * para:	
+ *	Mac		MAC to access.
+ *				Values: MAC_1, MAC_2
+ *	Offs	MAC register offset.
+ *				Values: RX_MFF_EA, RX_MFF_WP ... LNK_LED_REG,
+ *						TX_MFF_EA, TX_MFF_WP ... TX_LED_TST
  *
- * usage	SK_IN32(pAC,MR_ADDR(MAC_1,TX_MFF_EA),pVal)
+ * usage	SK_IN32(pAC, MR_ADDR(MAC_1, TX_MFF_EA), pVal)
  */
-#define MR_ADDR(Mac,Offs)	(((Mac) << 7) + (Offs))
+#define MR_ADDR(Mac, Offs)	(((Mac) << 7) + (Offs))
 
+#ifdef	SK_LITTLE_ENDIAN
+#define XM_WORD_LO	0
+#define XM_WORD_HI	1
+#else	/* !SK_LITTLE_ENDIAN */
+#define XM_WORD_LO	1
+#define XM_WORD_HI	0
+#endif	/* !SK_LITTLE_ENDIAN */
 
 
 /*
- * macros to access the XMAC
+ * macros to access the XMAC (GENESIS only)
  *
  * XM_IN16(),		to read a 16 bit register (e.g. XM_MMU_CMD)
  * XM_OUT16(),		to write a 16 bit register (e.g. XM_MMU_CMD)
@@ -1503,43 +1986,37 @@
  * XM_INHASH(),		to read the XM_HSM_CHK register
  * XM_OUTHASH()		to write the XM_HSM_CHK register
  *
- * para:	Mac	XMAC to address		values: MAC_1 or MAC_2
- *		IoC	I/O context needed for SK IO macros
- *		Reg	XMAC Register to read or write
- *		(p)Val	Value or pointer to the value which should be read or
- *			written.
+ * para:
+ *	Mac		XMAC to access		values: MAC_1 or MAC_2
+ *	IoC		I/O context needed for SK I/O macros
+ *	Reg		XMAC Register to read or write
+ *	(p)Val	Value or pointer to the value which should be read or written
  *
  * usage:	XM_OUT16(IoC, MAC_1, XM_MMU_CMD, Value);
  */
 
-#ifdef	SK_LITTLE_ENDIAN
-#define	XM_WORD_LO	0
-#define XM_WORD_HI	1
-#else	/* !SK_LITTLE_ENDIAN */
-#define	XM_WORD_LO	1
-#define XM_WORD_HI	0
-#endif	/* !SK_LITTLE_ENDIAN */
+#define XMA(Mac, Reg)									\
+	((BASE_XMAC_1 + (Mac) * (BASE_XMAC_2 - BASE_XMAC_1)) | ((Reg) << 1))
 
-#define	XMA(Mac,Reg)	(((0x1000 << (Mac)) + 0x1000) | ((Reg) << 1))
+#define XM_IN16(IoC, Mac, Reg, pVal)					\
+	SK_IN16((IoC), XMA((Mac), (Reg)), (pVal))
 
-#define XM_IN16(IoC,Mac,Reg,pVal)	SK_IN16((IoC), XMA((Mac), (Reg)), (pVal))
-#define XM_OUT16(IoC,Mac,Reg,Val)	SK_OUT16((IoC), XMA((Mac), (Reg)), (Val))
+#define XM_OUT16(IoC, Mac, Reg, Val)					\
+	SK_OUT16((IoC), XMA((Mac), (Reg)), (Val))
 
-#define XM_IN32(IoC,Mac,Reg,pVal) {						\
+#define XM_IN32(IoC, Mac, Reg, pVal) {					\
 	SK_IN16((IoC), XMA((Mac), (Reg)),					\
 		(SK_U16 *)&((SK_U16 *)(pVal))[XM_WORD_LO]);		\
 	SK_IN16((IoC), XMA((Mac), (Reg+2)),					\
 		(SK_U16 *)&((SK_U16 *)(pVal))[XM_WORD_HI]);		\
 }
 
-#define XM_OUT32(IoC,Mac,Reg,Val) {											\
-	SK_OUT16((IoC), XMA((Mac), (Reg)), (SK_U16)((Val) & 0x0000ffffL));		\
-	SK_OUT16((IoC), XMA((Mac), (Reg+2)),(SK_U16)(((Val)>>16) & 0x0000ffffL));	\
+#define XM_OUT32(IoC, Mac, Reg, Val) {										\
+	SK_OUT16((IoC), XMA((Mac), (Reg)), (SK_U16)((Val) & 0xffffL));			\
+	SK_OUT16((IoC), XMA((Mac), (Reg+2)), (SK_U16)(((Val) >> 16) & 0xffffL));\
 }
 
-/*
- * Remember: we are always writing to / reading from LITTLE ENDIAN memory
- */
+/* Remember: we are always writing to / reading from LITTLE ENDIAN memory */
 
 #define XM_INADDR(IoC, Mac, Reg, pVal) {				\
 	SK_U16	Word;										\
@@ -1606,32 +2083,150 @@
 }
 
 /*
+ * macros to access the GMAC (YUKON only)
+ *
+ * GM_IN16(),		to read  a 16 bit register (e.g. GM_GP_STAT)
+ * GM_OUT16(),		to write a 16 bit register (e.g. GM_GP_CTRL)
+ * GM_IN32(),		to read  a 32 bit register (e.g. GM_)
+ * GM_OUT32(),		to write a 32 bit register (e.g. GM_)
+ * GM_INADDR(),		to read  a network address register (e.g. GM_SRC_ADDR_1L)
+ * GM_OUTADDR(),	to write a network address register (e.g. GM_SRC_ADDR_2L)
+ * GM_INHASH(),		to read  the GM_MC_ADDR_H1 register
+ * GM_OUTHASH()		to write the GM_MC_ADDR_H1 register
+ *
+ * para:
+ *	Mac		GMAC to access		values: MAC_1 or MAC_2
+ *	IoC		I/O context needed for SK I/O macros
+ *	Reg		GMAC Register to read or write
+ *	(p)Val	Value or pointer to the value which should be read or written
+ *
+ * usage:	GM_OUT16(IoC, MAC_1, GM_GP_CTRL, Value);
+ */
+
+#define GMA(Mac, Reg)									\
+	((BASE_GMAC_1 + (Mac) * (BASE_GMAC_2 - BASE_GMAC_1)) | (Reg))
+
+#define GM_IN16(IoC, Mac, Reg, pVal)					\
+	SK_IN16((IoC), GMA((Mac), (Reg)), (pVal))
+
+#define GM_OUT16(IoC, Mac, Reg, Val)					\
+	SK_OUT16((IoC), GMA((Mac), (Reg)), (Val))
+
+#define GM_IN32(IoC, Mac, Reg, pVal) {					\
+	SK_IN16((IoC), GMA((Mac), (Reg)),					\
+		(SK_U16 *)&((SK_U16 *)(pVal))[XM_WORD_LO]);		\
+	SK_IN16((IoC), GMA((Mac), (Reg+4)),					\
+		(SK_U16 *)&((SK_U16 *)(pVal))[XM_WORD_HI]);		\
+}
+
+#define GM_OUT32(IoC, Mac, Reg, Val) {										\
+	SK_OUT16((IoC), GMA((Mac), (Reg)), (SK_U16)((Val) & 0xffffL));			\
+	SK_OUT16((IoC), GMA((Mac), (Reg+4)), (SK_U16)(((Val) >> 16) & 0xffffL));\
+}
+
+#define GM_INADDR(IoC, Mac, Reg, pVal) {				\
+	SK_U16	Word;										\
+	SK_U8	*pByte;										\
+	pByte = (SK_U8 *)&((SK_U8 *)(pVal))[0];				\
+	SK_IN16((IoC), GMA((Mac), (Reg)), &Word);			\
+	pByte[0] = (SK_U8)(Word  & 0x00ff);					\
+	pByte[1] = (SK_U8)((Word >> 8) & 0x00ff);			\
+	SK_IN16((IoC), GMA((Mac), (Reg+4)), &Word);			\
+	pByte[2] = (SK_U8)(Word  & 0x00ff);					\
+	pByte[3] = (SK_U8)((Word >> 8) & 0x00ff);			\
+	SK_IN16((IoC), GMA((Mac), (Reg+8)), &Word);			\
+	pByte[4] = (SK_U8)(Word  & 0x00ff);					\
+	pByte[5] = (SK_U8)((Word >> 8) & 0x00ff);			\
+}
+
+#define GM_OUTADDR(IoC, Mac, Reg, pVal) {				\
+	SK_U8	*pByte;										\
+	pByte = (SK_U8 *)&((SK_U8 *)(pVal))[0];				\
+	SK_OUT16((IoC), GMA((Mac), (Reg)), (SK_U16)			\
+		(((SK_U16)(pByte[0]) & 0x00ff) |				\
+		(((SK_U16)(pByte[1]) << 8) & 0xff00)));			\
+	SK_OUT16((IoC), GMA((Mac), (Reg+4)), (SK_U16)		\
+		(((SK_U16)(pByte[2]) & 0x00ff) |				\
+		(((SK_U16)(pByte[3]) << 8) & 0xff00)));			\
+	SK_OUT16((IoC), GMA((Mac), (Reg+8)), (SK_U16)		\
+		(((SK_U16)(pByte[4]) & 0x00ff) |				\
+		(((SK_U16)(pByte[5]) << 8) & 0xff00)));			\
+}
+
+#define GM_INHASH(IoC, Mac, Reg, pVal) {				\
+	SK_U16	Word;										\
+	SK_U8	*pByte;										\
+	pByte = (SK_U8 *)&((SK_U8 *)(pVal))[0];				\
+	SK_IN16((IoC), GMA((Mac), (Reg)), &Word);			\
+	pByte[0] = (SK_U8)(Word  & 0x00ff);					\
+	pByte[1] = (SK_U8)((Word >> 8) & 0x00ff);			\
+	SK_IN16((IoC), GMA((Mac), (Reg+4)), &Word);			\
+	pByte[2] = (SK_U8)(Word  & 0x00ff);					\
+	pByte[3] = (SK_U8)((Word >> 8) & 0x00ff);			\
+	SK_IN16((IoC), GMA((Mac), (Reg+8)), &Word);			\
+	pByte[4] = (SK_U8)(Word  & 0x00ff);					\
+	pByte[5] = (SK_U8)((Word >> 8) & 0x00ff);			\
+	SK_IN16((IoC), GMA((Mac), (Reg+12)), &Word);		\
+	pByte[6] = (SK_U8)(Word  & 0x00ff);					\
+	pByte[7] = (SK_U8)((Word >> 8) & 0x00ff);			\
+}
+
+#define GM_OUTHASH(IoC, Mac, Reg, pVal) {				\
+	SK_U8	*pByte;										\
+	pByte = (SK_U8 *)&((SK_U8 *)(pVal))[0];				\
+	SK_OUT16((IoC), GMA((Mac), (Reg)), (SK_U16)			\
+		(((SK_U16)(pByte[0]) & 0x00ff)|					\
+		(((SK_U16)(pByte[1]) << 8) & 0xff00)));			\
+	SK_OUT16((IoC), GMA((Mac), (Reg+4)), (SK_U16)		\
+		(((SK_U16)(pByte[2]) & 0x00ff)|					\
+		(((SK_U16)(pByte[3]) << 8) & 0xff00)));			\
+	SK_OUT16((IoC), GMA((Mac), (Reg+8)), (SK_U16)		\
+		(((SK_U16)(pByte[4]) & 0x00ff)|					\
+		(((SK_U16)(pByte[5]) << 8) & 0xff00)));			\
+	SK_OUT16((IoC), GMA((Mac), (Reg+12)), (SK_U16)		\
+		(((SK_U16)(pByte[6]) & 0x00ff)|					\
+		(((SK_U16)(pByte[7]) << 8) & 0xff00)));			\
+}
+
+/*
+ * Different MAC Types
+ */
+#define SK_MAC_XMAC		0	/* Xaqti XMAC II */
+#define SK_MAC_GMAC		1	/* Marvell GMAC */
+
+/*
  * Different PHY Types
  */
-#define SK_PHY_XMAC	0	/* integrated in Xmac II*/
-#define SK_PHY_BCOM	1	/* Broadcom BCM5400 */
-#define SK_PHY_LONE	2	/* Level One LXT1000 */
-#define SK_PHY_NAT	3	/* National DP83891 */ 
+#define SK_PHY_XMAC			0	/* integrated in XMAC II */
+#define SK_PHY_BCOM			1	/* Broadcom BCM5400 */
+#define SK_PHY_LONE			2	/* Level One LXT1000 */
+#define SK_PHY_NAT			3	/* National DP83891 */
+#define SK_PHY_MARV_COPPER	4	/* Marvell 88E1011S */
+#define SK_PHY_MARV_FIBER	5	/* Marvell 88E1011S working on fiber */
 
 /*
- * PHY addresses (bits 8..12 of PHY address reg)
+ * PHY addresses (bits 12..8 of PHY address reg)
  */
 #define PHY_ADDR_XMAC	(0<<8)
 #define PHY_ADDR_BCOM	(1<<8)
 #define PHY_ADDR_LONE	(3<<8)
 #define PHY_ADDR_NAT	(0<<8)
+		
+/* GPHY address (bits 15..11 of SMI control reg) */
+#define PHY_ADDR_MARV	0
 
 /*
  * macros to access the PHY
  *
  * PHY_READ()		read a 16 bit value from the PHY
- * PHY_WIRTE()		write a 16 bit value to the PHY
+ * PHY_WRITE()		write a 16 bit value to the PHY
  *
- * para:	IoC	I/O context needed for SK IO macros
- *		pPort	Pointer to port struct for PhyAddr
- * 		Mac	XMAC to address		values: MAC_1 or MAC_2
- *		PhyReg	PHY Register to read or write
- *		(p)Val	Value or pointer to the value which should be read or
+ * para:	
+ * 	IoC		I/O context needed for SK I/O macros
+ * 	pPort	Pointer to port struct for PhyAddr
+ * 	Mac		XMAC to access		values: MAC_1 or MAC_2
+ * 	PhyReg	PHY Register to read or write
+ * 	(p)Val	Value or pointer to the value which should be read or
  *			written.
  *
  * usage:	PHY_READ(IoC, pPort, MAC_1, PHY_CTRL, Value);
@@ -1672,7 +2267,7 @@
 		XM_IN16((IoC), (Mac), XM_PHY_DATA, (pVal));						\
 	}  																	\
 }
-#endif
+#endif /* DEBUG */
 
 #define PHY_WRITE(IoC, pPort, Mac, PhyReg, Val) {						\
 	SK_U16 Mmu;															\
@@ -1694,48 +2289,52 @@
 /*
  *	Macro PCI_C()
  *
- *	Use this macro to address PCI config register from the IO space.
+ *	Use this macro to access PCI config register from the I/O space.
  *
- * para	Addr	PCI configuration register to address.
- *			Values:	PCI_VENDOR_ID	...	PCI_VPD_ADDR,
+ * para:
+ *	Addr	PCI configuration register to access.
+ *			Values:	PCI_VENDOR_ID ... PCI_VPD_ADR_REG,
  *
- * usage	SK_IN16(pAC,PCI_C(PCI_VENDOR_ID),pVal);
+ * usage	SK_IN16(pAC, PCI_C(PCI_VENDOR_ID), pVal);
  */
 #define PCI_C(Addr)	(B7_CFG_SPC + (Addr))	/* PCI Config Space */
 
 /*
- *	Macro SK_ADDR(Base,Addr)
+ *	Macro SK_HW_ADDR(Base, Addr)
  *
  *	Calculates the effective HW address
  *
- * para Base	IO- or memory base address
+ * para:
+ *	Base	I/O or memory base address
  *	Addr	Address offset
  *
  * usage:	May be used in SK_INxx and SK_OUTxx macros
- *		#define SK_IN8(pAC,Addr,pVal) ...\
- *			*pVal = (SK_U8) inp(SK_ADDR(pAC->Hw.Iop,Addr)))
+ *		#define SK_IN8(pAC, Addr, pVal) ...\
+ *			*pVal = (SK_U8)inp(SK_HW_ADDR(pAC->Hw.Iop, Addr)))
  */
 #ifdef	SK_MEM_MAPPED_IO
-#define	SK_HW_ADDR(Base,Addr)	((Base)+(Addr))
+#define SK_HW_ADDR(Base, Addr)	((Base) + (Addr))
 #else	/* SK_MEM_MAPPED_IO */
-#define SK_HW_ADDR(Base,Addr)	((Base)+(((Addr)&0x7F)|((Addr)>>7 ? 0x80:0)))
+#define SK_HW_ADDR(Base, Addr)	\
+			((Base) + (((Addr) & 0x7f) | (((Addr) >> 7 > 0) ? 0x80 : 0)))
 #endif	/* SK_MEM_MAPPED_IO */
 
-#define	SZ_LONG	(sizeof(SK_U32))
+#define SZ_LONG	(sizeof(SK_U32))
 
 /*
  *	Macro SK_HWAC_LINK_LED()
  *
  *	Use this macro to set the link LED mode.
- * para pAC	Pointer to adapter context struct
- *	IoC	I/O context needed for SK IO macros
- *     	Port	Port number
+ * para:
+ *	pAC		Pointer to adapter context struct
+ *	IoC		I/O context needed for SK I/O macros
+ *  Port	Port number
  *	Mode	Mode to set for this LED
  */
 #define SK_HWAC_LINK_LED(pAC, IoC, Port, Mode) \
-	SK_OUT8(IoC, MR_ADDR(Port,LNK_LED_REG), Mode); 
+	SK_OUT8(IoC, MR_ADDR(Port, LNK_LED_REG), Mode);
+
 
- 
 /* typedefs *******************************************************************/
 
 
diff -ruN linux/drivers/net/sk98lin/h/skgehwt.h linuxn/drivers/net/sk98lin/h/skgehwt.h
--- linux/drivers/net/sk98lin/h/skgehwt.h	Wed Jul  4 20:50:39 2001
+++ linuxn/drivers/net/sk98lin/h/skgehwt.h	Tue May 20 12:17:40 2003
@@ -1,32 +1,23 @@
 /******************************************************************************
  *
  * Name:	skhwt.h
- * Project:	Genesis, PCI Gigabit Ethernet Adapter
- * Version:	$Revision: 1.4 $
- * Date:	$Date: 1998/08/19 09:50:58 $
+ * Project:	GEnesis, PCI Gigabit Ethernet Adapter
+ * Version:	$Revision: 1.5 $
+ * Date:	$Date: 1999/11/22 13:54:24 $
  * Purpose:	Defines for the hardware timer functions
  *
  ******************************************************************************/
 
 /******************************************************************************
  *
- *	(C)Copyright 1989-1998 SysKonnect,
+ *	(C)Copyright 1998,1999 SysKonnect,
  *	a business unit of Schneider & Koch & Co. Datensysteme GmbH.
- *	All Rights Reserved
  *
- *	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF SYSKONNECT
- *	The copyright notice above does not evidence any
- *	actual or intended publication of such source code.
- *
- *	This Module contains Proprietary Information of SysKonnect
- *	and should be treated as Confidential.
- *
- *	The information in this file is provided for the exclusive use of
- *	the licensees of SysKonnect.
- *	Such users have the right to use, modify, and incorporate this code
- *	into products for purposes authorized by the license agreement
- *	provided they include this notice and the associated copyright notice
- *	with any such product.
+ *	This program is free software; you can redistribute it and/or modify
+ *	it under the terms of the GNU General Public License as published by
+ *	the Free Software Foundation; either version 2 of the License, or
+ *	(at your option) any later version.
+ *
  *	The information in this file is provided "AS IS" without warranty.
  *
  ******************************************************************************/
@@ -36,6 +27,9 @@
  * History:
  *
  *	$Log: skgehwt.h,v $
+ *	Revision 1.5  1999/11/22 13:54:24  cgoos
+ *	Changed license header to GPL.
+ *	
  *	Revision 1.4  1998/08/19 09:50:58  gklug
  *	fix: remove struct keyword from c-code (see CCC) add typedefs
  *	
diff -ruN linux/drivers/net/sk98lin/h/skgei2c.h linuxn/drivers/net/sk98lin/h/skgei2c.h
--- linux/drivers/net/sk98lin/h/skgei2c.h	Fri Sep 15 23:34:19 2000
+++ linuxn/drivers/net/sk98lin/h/skgei2c.h	Tue May 20 12:17:41 2003
@@ -2,17 +2,15 @@
  *
  * Name:	skgei2c.h
  * Project:	GEnesis, PCI Gigabit Ethernet Adapter
- * Version:	$Revision: 1.17 $
- * Date:	$Date: 1999/11/22 13:55:25 $
- * Purpose:	Special genesis defines for I2C
- *		(taken from Monalisa (taken from Concentrator))
+ * Version:	$Revision: 1.23 $
+ * Date:	$Date: 2002/12/19 14:34:27 $
+ * Purpose:	Special GEnesis defines for TWSI
  *
  ******************************************************************************/
 
 /******************************************************************************
  *
- *	(C)Copyright 1998,1999 SysKonnect,
- *	a business unit of Schneider & Koch & Co. Datensysteme GmbH.
+ *	(C)Copyright 1998-2002 SysKonnect GmbH.
  *
  *	This program is free software; you can redistribute it and/or modify
  *	it under the terms of the GNU General Public License as published by
@@ -28,6 +26,28 @@
  * History:
  *
  *	$Log: skgei2c.h,v $
+ *	Revision 1.23  2002/12/19 14:34:27  rschmidt
+ *	Added cast in macros SK_I2C_SET_BIT() and SK_I2C_CLR_BIT()
+ *	Editorial changes (TWSI)
+ *	
+ *	Revision 1.22  2002/10/14 16:45:56  rschmidt
+ *	Editorial changes (TWSI)
+ *	
+ *	Revision 1.21  2002/08/13 08:42:24  rschmidt
+ *	Changed define for SK_MIN_SENSORS back to 5
+ *	Merged defines for PHY PLL 3V3 voltage (A and B)
+ *	Editorial changes
+ *	
+ *	Revision 1.20  2002/08/06 09:43:56  jschmalz
+ *	Extensions and changes for Yukon
+ *	
+ *	Revision 1.19  2002/08/02 12:00:08  rschmidt
+ *	Added defines for YUKON sensors
+ *	Editorial changes
+ *	
+ *	Revision 1.18  2001/08/16 12:44:33  afischer
+ *	LM80 sensor init values corrected
+ *	
  *	Revision 1.17  1999/11/22 13:55:25  cgoos
  *	Changed license header to GPL.
  *	
@@ -70,7 +90,7 @@
  *	
  *	Revision 1.5  1998/08/17 06:52:21  malthoff
  *	Remove unrequired macros.
- *	Add macros for accessing I2C SW register.
+ *	Add macros for accessing TWSI SW register.
  *	
  *	Revision 1.4  1998/08/13 08:30:18  gklug
  *	add: conversion factors for read values
@@ -81,8 +101,8 @@
  *
  *	Revision 1.2  1998/08/11 07:54:38  gklug
  *	add: sensor states for GE sensors
- *	add: Macro to access I2c hardware register
- *	chg: Error messages for I2c errors
+ *	add: Macro to access TWSI hardware register
+ *	chg: Error messages for TWSI errors
  *
  *	Revision 1.1  1998/07/17 11:27:56  gklug
  *	Created.
@@ -92,7 +112,7 @@
  ******************************************************************************/
 
 /*
- * SKGEI2C.H	contains all SK-98xx specific defines for the I2C handling
+ * SKGEI2C.H	contains all SK-98xx specific defines for the TWSI handling
  */
 
 #ifndef _INC_SKGEI2C_H_
@@ -101,12 +121,12 @@
 /*
  * Macros to access the B2_I2C_CTRL
  */
-#define SK_I2C_CTL(IoC,flag,dev,reg,burst) \
-	SK_OUT32(IoC,B2_I2C_CTRL,\
-		(flag ? 0x80000000UL : 0x0L ) | \
+#define SK_I2C_CTL(IoC, flag, dev, reg, burst) \
+	SK_OUT32(IoC, B2_I2C_CTRL,\
+		(flag ? 0x80000000UL : 0x0L) | \
 		(((SK_U32) reg << 16) & I2C_ADDR) | \
 		(((SK_U32) dev << 9) & I2C_DEV_SEL) | \
-		(( burst << 4) & I2C_BURST_LEN) )
+		(( burst << 4) & I2C_BURST_LEN))
 
 #define SK_I2C_STOP(IoC) {				\
 	SK_U32	I2cCtrl;				\
@@ -114,29 +134,29 @@
 	SK_OUT32(IoC, B2_I2C_CTRL, I2cCtrl | I2C_STOP);	\
 }
 
-#define SK_I2C_GET_CTL(Ioc,pI2cCtrl)	SK_IN32(Ioc,B2_I2C_CTRL,pI2cCtrl)
+#define SK_I2C_GET_CTL(IoC, pI2cCtrl)	SK_IN32(IoC, B2_I2C_CTRL, pI2cCtrl)
 
 /*
- * Macros to access the I2C SW Registers
+ * Macros to access the TWSI SW Registers
  */
 #define SK_I2C_SET_BIT(IoC, SetBits) {			\
 	SK_U8	OrgBits;				\
 	SK_IN8(IoC, B2_I2C_SW, &OrgBits);		\
-	SK_OUT8(IoC, B2_I2C_SW, OrgBits | (SetBits));	\
+	SK_OUT8(IoC, B2_I2C_SW, OrgBits | (SK_U8)(SetBits));	\
 }
 
-#define SK_I2C_CLR_BIT(IoC,ClrBits) {			\
+#define SK_I2C_CLR_BIT(IoC, ClrBits) {			\
 	SK_U8	OrgBits;				\
 	SK_IN8(IoC, B2_I2C_SW, &OrgBits);		\
-	SK_OUT8(IoC, B2_I2C_SW, OrgBits & ~(ClrBits));	\
+	SK_OUT8(IoC, B2_I2C_SW, OrgBits & ~((SK_U8)(ClrBits)));	\
 }
 
-#define SK_I2C_GET_SW(IoC,pI2cSw)	SK_IN8(IoC,B2_I2C_SW,pI2cSw)
+#define SK_I2C_GET_SW(IoC, pI2cSw)	SK_IN8(IoC, B2_I2C_SW, pI2cSw)
 
 /*
  * define the possible sensor states
  */
-#define	SK_SEN_IDLE	0	/* Idle: sensor not read */
+#define	SK_SEN_IDLE		0	/* Idle: sensor not read */
 #define	SK_SEN_VALUE	1	/* Value Read cycle */
 #define	SK_SEN_VALEXT	2	/* Extended Value Read cycle */
 
@@ -147,7 +167,7 @@
 #define	SK_LM80_VT_LSB		22	/* 22mV LSB resolution */
 #define	SK_LM80_TEMP_LSB	10	/* 1 degree LSB resolution */
 #define	SK_LM80_TEMPEXT_LSB	5	/* 0.5 degree LSB resolution for the
-					 * extension value 
+					 * extension value
 					 */
 #define SK_LM80_FAN_FAKTOR	((22500L*60)/(1*2))
 /* formula: counter = (22500*60)/(rpm * divisor * pulses/2)
@@ -163,20 +183,27 @@
 #define	SK_MIN_SENSORS	5	/* minimal no. of installed sensors */
 
 /*
+ * To watch the statemachine (JS) use the timer in two ways instead of one as hitherto
+ */
+#define	SK_TIMER_WATCH_STATEMACHINE	0	/* Watch the statemachine to finish in a specific time */
+#define	SK_TIMER_NEW_GAUGING    	1	/* Start a new gauging when timer expires */
+
+
+/*
  * Defines for the individual Thresholds
  */
 
 /* Temperature sensor */
-#define	SK_SEN_ERRHIGH0		800	/* Temperature High Err Threshold */
-#define	SK_SEN_WARNHIGH0	700	/* Temperature High Warn Threshold */
-#define	SK_SEN_WARNLOW0		100	/* Temperature Low Err Threshold */
-#define	SK_SEN_ERRLOW0		0	/* Temperature Low Warn Threshold */
+#define	SK_SEN_TEMP_HIGH_ERR    800	/* Temperature High Err  Threshold */
+#define	SK_SEN_TEMP_HIGH_WARN	700	/* Temperature High Warn Threshold */
+#define	SK_SEN_TEMP_LOW_WARN	100	/* Temperature Low  Warn Threshold */
+#define	SK_SEN_TEMP_LOW_ERR       0	/* Temperature Low  Err  Threshold */
 
 /* VCC which should be 5 V */
-#define	SK_SEN_ERRHIGH1		5588	/* Voltage PCI High Err Threshold */
-#define	SK_SEN_WARNHIGH1	5346	/* Voltage PCI High Warn Threshold */
-#define	SK_SEN_WARNLOW1		4664	/* Voltage PCI Low Err Threshold */
-#define	SK_SEN_ERRLOW1		4422	/* Voltage PCI Low Warn Threshold */
+#define	SK_SEN_PCI_5V_HIGH_ERR  	5588	/* Voltage PCI High Err  Threshold */
+#define	SK_SEN_PCI_5V_HIGH_WARN     5346	/* Voltage PCI High Warn Threshold */
+#define	SK_SEN_PCI_5V_LOW_WARN		4664	/* Voltage PCI Low  Warn Threshold */
+#define	SK_SEN_PCI_5V_LOW_ERR		4422	/* Voltage PCI Low  Err  Threshold */
 
 /*
  * VIO may be 5 V or 3.3 V. Initialization takes two parts:
@@ -187,49 +214,66 @@
  * Warning limits are +-5% of the exepected voltage.
  * Error limits are +-10% of the expected voltage.
  */
-#define	SK_SEN_ERRHIGH2		5588	/* Voltage PCI-IO High Err Threshold */
-#define	SK_SEN_WARNHIGH2	5346	/* Voltage PCI-IO High Warn Threshold */
-#define	SK_SEN_WARNLOW2		3146	/* Voltage PCI-IO Low Err Threshold */
-#define	SK_SEN_ERRLOW2		2970	/* Voltage PCI-IO Low Warn Threshold */
+
+/* Bug fix AF: 16.Aug.2001: Correct the init base of LM80 sensor */
+
+#define	SK_SEN_PCI_IO_5V_HIGH_ERR	5566	/* + 10% V PCI-IO High Err Threshold */
+#define	SK_SEN_PCI_IO_5V_HIGH_WARN	5324	/* +  5% V PCI-IO High Warn Threshold */
+					/*		5000	mVolt */
+#define	SK_SEN_PCI_IO_5V_LOW_WARN	4686	/* -  5% V PCI-IO Low Warn Threshold */
+#define	SK_SEN_PCI_IO_5V_LOW_ERR	4444	/* - 10% V PCI-IO Low Err Threshold */
+
+#define	SK_SEN_PCI_IO_RANGE_LIMITER	4000	/* 4000 mV range delimiter */
 
 /* correction values for the second pass */
-#define	SK_SEN_ERRHIGH2C	3630	/* Voltage PCI-IO High Err Threshold */
-#define	SK_SEN_WARNHIGH2C	3476	/* Voltage PCI-IO High Warn Threshold */
-#define	SK_SEN_WARNLOW2C	4664	/* Voltage PCI-IO Low Err Threshold */
-#define	SK_SEN_ERRLOW2C		4422	/* Voltage PCI-IO Low Warn Threshold */
+#define	SK_SEN_PCI_IO_3V3_HIGH_ERR	3850	/* + 15% V PCI-IO High Err Threshold */
+#define	SK_SEN_PCI_IO_3V3_HIGH_WARN	3674	/* + 10% V PCI-IO High Warn Threshold */
+					/*		3300	mVolt */
+#define	SK_SEN_PCI_IO_3V3_LOW_WARN  2926	/* - 10% V PCI-IO Low Warn Threshold */
+#define	SK_SEN_PCI_IO_3V3_LOW_ERR   2772	/* - 15% V PCI-IO Low Err  Threshold */
+
 
 /*
  * VDD voltage
  */
-#define	SK_SEN_ERRHIGH3		3630	/* Voltage ASIC High Err Threshold */
-#define	SK_SEN_WARNHIGH3	3476	/* Voltage ASIC High Warn Threshold */
-#define	SK_SEN_WARNLOW3		3146	/* Voltage ASIC Low Err Threshold */
-#define	SK_SEN_ERRLOW3		2970	/* Voltage ASIC Low Warn Threshold */
+#define	SK_SEN_VDD_HIGH_ERR	    3630	/* Voltage ASIC High Err  Threshold */
+#define	SK_SEN_VDD_HIGH_WARN    3476	/* Voltage ASIC High Warn Threshold */
+#define	SK_SEN_VDD_LOW_WARN     3146	/* Voltage ASIC Low  Warn Threshold */
+#define	SK_SEN_VDD_LOW_ERR      2970	/* Voltage ASIC Low  Err  Threshold */
+
+/*
+ * PHY PLL 3V3 voltage
+ */
+#define	SK_SEN_PLL_3V3_HIGH_ERR		3630	/* Voltage PMA High Err  Threshold */
+#define	SK_SEN_PLL_3V3_HIGH_WARN	3476	/* Voltage PMA High Warn Threshold */
+#define	SK_SEN_PLL_3V3_LOW_WARN		3146	/* Voltage PMA Low  Warn Threshold */
+#define	SK_SEN_PLL_3V3_LOW_ERR		2970	/* Voltage PMA Low  Err  Threshold */
 
 /*
- * PLC_3V3 voltage
- * PHY_PLL_A_3V3 voltage
+ * VAUX (YUKON only)
  */
-#define	SK_SEN_ERRHIGH4		3630	/* Voltage PMA High Err Threshold */
-#define	SK_SEN_WARNHIGH4	3476	/* Voltage PMA High Warn Threshold */
-#define	SK_SEN_WARNLOW4		3146	/* Voltage PMA Low Err Threshold */
-#define	SK_SEN_ERRLOW4		2970	/* Voltage PMA Low Warn Threshold */
+#define	SK_SEN_VAUX_3V3_HIGH_ERR	3630	/* Voltage VAUX High Err Threshold */
+#define	SK_SEN_VAUX_3V3_HIGH_WARN	3476	/* Voltage VAUX High Warn Threshold */
+#define	SK_SEN_VAUX_3V3_LOW_WARN	3146	/* Voltage VAUX Low Warn Threshold */
+#define	SK_SEN_VAUX_3V3_LOW_ERR	    2970	/* Voltage VAUX Low Err Threshold */
+#define	SK_SEN_VAUX_0V_WARN_ERR	       0	/* if VAUX not present */
+#define	SK_SEN_VAUX_RANGE_LIMITER	1000	/* 1000 mV range delimiter */
 
 /*
- * PHY_2V5 voltage
+ * PHY 2V5 voltage
  */
-#define	SK_SEN_ERRHIGH5		2750	/* Voltage PHY High Err Threshold */
-#define	SK_SEN_WARNHIGH5	2640	/* Voltage PHY High Warn Threshold */
-#define	SK_SEN_WARNLOW5		2376	/* Voltage PHY Low Err Threshold */
-#define	SK_SEN_ERRLOW5		2222	/* Voltage PHY Low Warn Threshold */
+#define	SK_SEN_PHY_2V5_HIGH_ERR		2750	/* Voltage PHY High Err Threshold */
+#define	SK_SEN_PHY_2V5_HIGH_WARN	2640	/* Voltage PHY High Warn Threshold */
+#define	SK_SEN_PHY_2V5_LOW_WARN		2376	/* Voltage PHY Low Warn Threshold */
+#define	SK_SEN_PHY_2V5_LOW_ERR		2222	/* Voltage PHY Low Err Threshold */
 
 /*
- * PHY_PLL_B_3V3 voltage
+ * ASIC Core 1V5 voltage (YUKON only)
  */
-#define	SK_SEN_ERRHIGH6		3630	/* Voltage PMA High Err Threshold */
-#define	SK_SEN_WARNHIGH6	3476	/* Voltage PMA High Warn Threshold */
-#define	SK_SEN_WARNLOW6		3146	/* Voltage PMA Low Err Threshold */
-#define	SK_SEN_ERRLOW6		2970	/* Voltage PMA Low Warn Threshold */
+#define	SK_SEN_CORE_1V5_HIGH_ERR    1650	/* Voltage ASIC Core High Err Threshold */
+#define	SK_SEN_CORE_1V5_HIGH_WARN	1575	/* Voltage ASIC Core High Warn Threshold */
+#define	SK_SEN_CORE_1V5_LOW_WARN	1425	/* Voltage ASIC Core Low Warn Threshold */
+#define	SK_SEN_CORE_1V5_LOW_ERR 	1350	/* Voltage ASIC Core Low Err Threshold */
 
 /*
  * FAN 1 speed
@@ -239,10 +283,17 @@
  * error at:	70 %
  * no upper limit
  */
-#define	SK_SEN_ERRHIGH		20000	/* FAN Speed High Err Threshold */
-#define	SK_SEN_WARNHIGH		20000	/* FAN Speed High Warn Threshold */
-#define	SK_SEN_WARNLOW		5200	/* FAN Speed Low Err Threshold */
-#define	SK_SEN_ERRLOW		4550	/* FAN Speed Low Warn Threshold */
+#define	SK_SEN_FAN_HIGH_ERR		20000	/* FAN Speed High Err Threshold */
+#define	SK_SEN_FAN_HIGH_WARN	20000	/* FAN Speed High Warn Threshold */
+#define	SK_SEN_FAN_LOW_WARN 	5200	/* FAN Speed Low Warn Threshold */
+#define	SK_SEN_FAN_LOW_ERR		4550	/* FAN Speed Low Err Threshold */
+
+/*
+ * Some Voltages need dynamic thresholds
+ */
+#define	SK_SEN_DYN_INIT_NONE		 0  /* No dynamic init of thresholds */
+#define	SK_SEN_DYN_INIT_PCI_IO		10  /* Init PCI-IO with new thresholds */
+#define	SK_SEN_DYN_INIT_VAUX		11  /* Init VAUX with new thresholds */
 
 extern	int SkLm80ReadSensor(SK_AC *pAC, SK_IOC IoC, SK_SENSOR *pSen);
 #endif	/* n_INC_SKGEI2C_H */
diff -ruN linux/drivers/net/sk98lin/h/skgeinit.h linuxn/drivers/net/sk98lin/h/skgeinit.h
--- linux/drivers/net/sk98lin/h/skgeinit.h	Wed Jul  4 20:50:39 2001
+++ linuxn/drivers/net/sk98lin/h/skgeinit.h	Tue May 20 12:17:41 2003
@@ -2,15 +2,16 @@
  *
  * Name:	skgeinit.h
  * Project:	GEnesis, PCI Gigabit Ethernet Adapter
- * Version:	$Revision: 1.51 $
- * Date:	$Date: 2001/02/09 12:26:38 $
+ * Version:	$Revision: 1.78 $
+ * Date:	$Date: 2003/04/28 08:59:57 $
  * Purpose:	Structures and prototypes for the GE Init Module
  *
  ******************************************************************************/
 
 /******************************************************************************
  *
- *	(C)Copyright 1998-2001 SysKonnect GmbH.
+ *	(C)Copyright 1998-2002 SysKonnect.
+ *	(C)Copyright 2002-2003 Marvell.
  *
  *	This program is free software; you can redistribute it and/or modify
  *	it under the terms of the GNU General Public License as published by
@@ -26,6 +27,134 @@
  * History:
  *
  *	$Log: skgeinit.h,v $
+ *	Revision 1.78  2003/04/28 08:59:57  rschmidt
+ *	Added entries GIValIrqMask and GITimeStampCnt in s_GeInit structure
+ *	
+ *	Revision 1.77  2003/04/08 16:27:02  rschmidt
+ *	Added entry GILedBlinkCtrl in s_GeInit structure
+ *	Added defines for LED Blink Control
+ *	
+ *	Revision 1.76  2003/03/31 07:21:01  mkarl
+ *	Added PGmANegAdv to SK_GEPORT.
+ *	Corrected Copyright.
+ *	
+ *	Revision 1.75  2003/02/05 13:36:39  rschmidt
+ *	Added define SK_FACT_78	for YUKON's Host Clock of 78.12 MHz
+ *	Editorial changes
+ *	
+ *	Revision 1.74  2003/01/28 09:39:16  rschmidt
+ *	Added entry GIYukonLite in s_GeInit structure
+ *	Editorial changes
+ *	
+ *	Revision 1.73  2002/11/15 12:47:25  rschmidt
+ *	Replaced error message SKERR_HWI_E024 for Cable Diagnostic with
+ *	Rx queue error in SkGeStopPort().
+ *	
+ *	Revision 1.72  2002/11/12 17:08:35  rschmidt
+ *	Added entries for Cable Diagnostic to Port structure
+ *	Added entries GIPciSlot64 and GIPciClock66 in s_GeInit structure
+ *	Added error message for Cable Diagnostic
+ *	Added prototypes for SkGmCableDiagStatus()
+ *	Editorial changes
+ *	
+ *	Revision 1.71  2002/10/21 11:26:10  mkarl
+ *	Changed interface of SkGeInitAssignRamToQueues().
+ *	
+ *	Revision 1.70  2002/10/14 08:21:32  rschmidt
+ *	Changed type of GICopperType, GIVauxAvail to SK_BOOL
+ *	Added entry PRxOverCnt to Port structure
+ *	Added entry GIYukon32Bit in s_GeInit structure
+ *	Editorial changes
+ *	
+ *	Revision 1.69  2002/10/09 16:57:15  mkarl
+ *	Added some constants and macros for SkGeInitAssignRamToQueues().
+ *	
+ *	Revision 1.68  2002/09/12 08:58:51  rwahl
+ *	Retrieve counters needed for XMAC errata workarounds directly because
+ *	PNMI returns corrected counter values (e.g. #10620).
+ *	
+ *	Revision 1.67  2002/08/16 14:40:30  rschmidt
+ *	Added entries GIGenesis and GICopperType in s_GeInit structure
+ *	Added prototypes for SkMacHashing()
+ *	Editorial changes
+ *	
+ *	Revision 1.66  2002/08/12 13:27:21  rschmidt
+ *	Added defines for Link speed capabilities
+ *	Added entry PLinkSpeedCap to Port structure
+ *	Added entry GIVauxAvail in s_GeInit structure
+ *	Added prototypes for SkMacPromiscMode()
+ *	Editorial changes
+ *	
+ *	Revision 1.65  2002/08/08 15:46:18  rschmidt
+ *	Added define SK_PHY_ACC_TO for PHY access timeout
+ *	Added define SK_XM_RX_HI_WM for XMAC Rx High Watermark
+ *	Added define SK_MIN_TXQ_SIZE for Min RAM Buffer Tx Queue Size
+ *	Added entry PhyId1 to Port structure
+ *	
+ *	Revision 1.64  2002/07/23 16:02:56  rschmidt
+ *	Added entry GIWolOffs in s_GeInit struct (HW-Bug in YUKON 1st rev.)
+ *	Added prototypes for: SkGePhyRead(), SkGePhyWrite()
+ *	
+ *	Revision 1.63  2002/07/18 08:17:38  rwahl
+ *	Corrected definitions for SK_LSPEED_xxx & SK_LSPEED_STAT_xxx.
+ *	
+ *	Revision 1.62  2002/07/17 18:21:55  rwahl
+ *	Added SK_LSPEED_INDETERMINATED define.
+ *	
+ *	Revision 1.61  2002/07/17 17:16:03  rwahl
+ *	- MacType now member of GIni struct.
+ *	- Struct alignment to 32bit.
+ *	- Editorial change.
+ *	
+ *	Revision 1.60  2002/07/15 18:23:39  rwahl
+ *	Added GeMacFunc to GE Init structure.
+ *	Added prototypes for SkXmUpdateStats(), SkGmUpdateStats(),
+ *	  SkXmMacStatistic(), SkGmMacStatistic(), SkXmResetCounter(),
+ *	  SkGmResetCounter(), SkXmOverflowStatus(), SkGmOverflowStatus().
+ *	Added defines for current link speed state.
+ *	Added ERRMSG defintions for MacUpdateStat() & MacStatistics().
+ *	
+ *	Revision 1.59  2002/07/15 15:40:22  rschmidt
+ *	Added entry PLinkSpeedUsed to Port structure
+ *	Editorial changes
+ *	
+ *	Revision 1.58  2002/06/10 09:36:30  rschmidt
+ *	Editorial changes.
+ *	
+ *	Revision 1.57  2002/06/05 08:18:00  rschmidt
+ *	Corrected alignment in Port Structure
+ *	Added new prototypes for GMAC
+ *	Editorial changes
+ *	
+ *	Revision 1.56  2002/04/25 11:38:12  rschmidt
+ *	Added defines for Link speed values
+ *	Added defines for Loopback parameters for MAC and PHY
+ *	Removed entry PRxCmd from Port structure
+ *	Added entry PLinkSpeed to Port structure
+ *	Added entries GIChipId and GIChipRev to GE Init structure
+ *	Removed entry GIAnyPortAct from GE Init structure
+ *	Added prototypes for: SkMacInit(), SkMacInitPhy(),
+ *	SkMacRxTxDisable(), SkMacSoftRst(), SkMacHardRst(), SkMacIrq(),
+ *	SkMacIrqDisable(), SkMacFlushTxFifo(), SkMacFlushRxFifo(),
+ *	SkMacAutoNegDone(), SkMacAutoNegLipaPhy(), SkMacSetRxTxEn(),
+ *	SkXmPhyRead(), SkXmPhyRead(), SkGmPhyWrite(), SkGmPhyWrite();
+ *	Removed prototypes for static functions in SkXmac2.c
+ *	Editorial changes
+ *	
+ *	Revision 1.55  2002/02/26 15:24:53  rwahl
+ *	Fix: no link with manual configuration (#10673). The previous fix for
+ *	#10639 was removed. So for RLMT mode = CLS the RLMT may switch to
+ *	misconfigured port. It should not occur for the other RLMT modes.
+ *	
+ *	Revision 1.54  2002/01/18 16:52:52  rwahl
+ *	Editorial corrections.
+ *	
+ *	Revision 1.53  2001/11/20 09:19:58  rwahl
+ *	Reworked bugfix #10639 (no dependency to RLMT mode).
+ *	
+ *	Revision 1.52  2001/10/26 07:52:23  afischer
+ *	Port switching bug in `check local link` mode
+ *	
  *	Revision 1.51  2001/02/09 12:26:38  cgoos
  *	Inserted #ifdef DIAG for half duplex workaround timer.
  *	
@@ -96,10 +225,10 @@
  *	ports are active but differently configured.
  *	
  *	Revision 1.31  1998/12/11 15:17:02  gklug
- *	add: Link partnet autoneg states : Unknown Manual and Autonegotiation
+ *	add: Link partnet autoneg states : Unknown Manual and Auto-negotiation
  *	
  *	Revision 1.30  1998/12/07 12:17:04  gklug
- *	add: Link Partner autonegotiation flag
+ *	add: Link Partner auto-negotiation flag
  *	
  *	Revision 1.29  1998/12/01 10:54:42  gklug
  *	add: variables for XMAC Errata
@@ -130,7 +259,7 @@
  *	Add GIRamOffs.
  *	
  *	Revision 1.20  1998/10/19 07:28:37  malthoff
- *	Add prototyp for SkGeInitRamIface().
+ *	Add prototype for SkGeInitRamIface().
  *	
  *	Revision 1.19  1998/10/14 14:47:48  malthoff
  *	SK_TIMER should not be defined for Diagnostics.
@@ -156,7 +285,7 @@
  *	Add some error log messages.
  *	
  *	Revision 1.13  1998/10/06 14:13:14  malthoff
- *	Add prototyp for SkGeLoadLnkSyncCnt().
+ *	Add prototype for SkGeLoadLnkSyncCnt().
  *
  *	Revision 1.12  1998/10/05 11:29:53  malthoff
  *	bug fix: A comment was not closed.
@@ -194,7 +323,7 @@
  *	Revision 1.4  1998/09/03 09:55:31  malthoff
  *	Add constants for parameters Dir and RstMode
  *	when calling SkGeStopPort().
- *	Rework the prototyp section.
+ *	Rework the prototype section.
  *	Add Queue Address offsets PRxQOff, PXsQOff, and PXaQOff.
  *	Remove Ioc with IoC.
  *
@@ -208,7 +337,6 @@
  *	Revision 1.1  1998/07/23 09:50:24  malthoff
  *	Created.
  *
- *
  ******************************************************************************/
 
 #ifndef __INC_SKGEINIT_H_
@@ -220,53 +348,52 @@
 
 /* defines ********************************************************************/
 
-/*
- * defines for modifying Link LED behaviour (has been used with SkGeLinkLED())
- */
-#define SK_LNK_OFF	LED_OFF
-#define SK_LNK_ON	(LED_ON | LED_BLK_OFF| LED_SYNC_OFF)	
-#define SK_LNK_BLINK	(LED_ON | LED_BLK_ON | LED_SYNC_ON)
-#define SK_LNK_PERM	(LED_ON | LED_BLK_OFF| LED_SYNC_ON)
-#define SK_LNK_TST	(LED_ON | LED_BLK_ON | LED_SYNC_OFF)
-
-/*
- * defines for parameter 'Mode' when calling SK_HWAC_LINK_LED()
- */
-#define SK_LED_OFF	LED_OFF
-#define SK_LED_ACTIVE	(LED_ON | LED_BLK_OFF| LED_SYNC_OFF)
-#define SK_LED_STANDBY	(LED_ON | LED_BLK_ON| LED_SYNC_OFF)
+/* modifying Link LED behaviour (used with SkGeLinkLED()) */
+#define SK_LNK_OFF		LED_OFF
+#define SK_LNK_ON		(LED_ON | LED_BLK_OFF | LED_SYNC_OFF)	
+#define SK_LNK_BLINK	(LED_ON | LED_BLK_ON  | LED_SYNC_ON)
+#define SK_LNK_PERM		(LED_ON | LED_BLK_OFF | LED_SYNC_ON)
+#define SK_LNK_TST		(LED_ON | LED_BLK_ON  | LED_SYNC_OFF)
+
+/* parameter 'Mode' when calling SK_HWAC_LINK_LED() */
+#define SK_LED_OFF		LED_OFF
+#define SK_LED_ACTIVE	(LED_ON | LED_BLK_OFF | LED_SYNC_OFF)
+#define SK_LED_STANDBY	(LED_ON | LED_BLK_ON  | LED_SYNC_OFF)
+
+/* addressing LED Registers in SkGeXmitLED() */
+#define XMIT_LED_INI	0
+#define XMIT_LED_CNT	(RX_LED_VAL - RX_LED_INI)
+#define XMIT_LED_CTRL	(RX_LED_CTRL- RX_LED_INI)
+#define XMIT_LED_TST	(RX_LED_TST - RX_LED_INI)
 
-/*
- * defines for parameter 'Mode' when calling SkGeXmitLED()
- */
+/* parameter 'Mode' when calling SkGeXmitLED() */
 #define SK_LED_DIS	0
 #define SK_LED_ENA	1
 #define SK_LED_TST	2
 
-/*
- * Counter and Timer constants, for a host clock of 62.5 MHz
- */
-#define SK_XMIT_DUR	0x002faf08L		/*  50 ms */
-#define SK_BLK_DUR	0x01dcd650L		/* 500 ms */
+/* Counter and Timer constants, for a host clock of 62.5 MHz */
+#define SK_XMIT_DUR		0x002faf08L		/*  50 ms */
+#define SK_BLK_DUR		0x01dcd650L		/* 500 ms */
 
-#define SK_DPOLL_DEF	0x00EE6B28L		/* 250 ms */
-#define SK_DPOLL_MAX	0x00FFFFFFL		/* ca. 268ms */
+#define SK_DPOLL_DEF	0x00ee6b28L		/* 250 ms at 62.5 MHz */
 
-#define SK_FACT_62	100			/* is given in percent */
-#define SK_FACT_53	 85
+#define SK_DPOLL_MAX	0x00ffffffL		/* 268 ms at 62.5 MHz */
+										/* 215 ms at 78.12 MHz */
 
-/*
- * Timeout values
- */
-#define SK_MAC_TO_53	72		/* MAC arbiter timeout */
+#define SK_FACT_62		100			/* is given in percent */
+#define SK_FACT_53		 85         /* on GENESIS:	53.12 MHz */
+#define SK_FACT_78		125			/* on YUKON:	78.12 MHz */
+
+/* Timeout values */
+#define SK_MAC_TO_53	72			/* MAC arbiter timeout */
 #define SK_PKT_TO_53	0x2000		/* Packet arbiter timeout */
 #define SK_PKT_TO_MAX	0xffff		/* Maximum value */
-#define SK_RI_TO_53	36		/* RAM interface timeout */
+#define SK_RI_TO_53		36			/* RAM interface timeout */
 
-/*
- * RAM Buffer High Pause Threshold values
- */
-#define SK_RB_ULPP	( 8 * 1024)	/* Upper Level in kB/8 */
+#define SK_PHY_ACC_TO	600000		/* PHY access timeout */
+
+/* RAM Buffer High Pause Threshold values */
+#define SK_RB_ULPP		( 8 * 1024)	/* Upper Level in kB/8 */
 #define SK_RB_LLPP_S	(10 * 1024)	/* Lower Level for small Queues */
 #define SK_RB_LLPP_B	(16 * 1024)	/* Lower Level for big Queues */
 
@@ -274,9 +401,12 @@
 #define SK_BMU_RX_WM	0x600		/* BMU Rx Watermark */
 #endif
 #ifndef SK_BMU_TX_WM
-#define SK_BMU_TX_WM	0x600		/* BMU Rx Watermark */
+#define SK_BMU_TX_WM	0x600		/* BMU Tx Watermark */
 #endif
 
+/* XMAC II Rx High Watermark */
+#define SK_XM_RX_HI_WM	0x05aa		/* 1450 */
+
 /* XMAC II Tx Threshold */
 #define SK_XM_THR_REDL	0x01fb		/* .. for redundant link usage */
 #define SK_XM_THR_SL	0x01fb		/* .. for single link adapters */
@@ -284,184 +414,203 @@
 #define SK_XM_THR_JUMBO	0x03fc		/* .. for jumbo frame usage */
 
 /* values for GIPortUsage */
-#define SK_RED_LINK	1		/* redundant link usage */
-#define SK_MUL_LINK	2		/* multiple link usage */
+#define SK_RED_LINK		1		/* redundant link usage */
+#define SK_MUL_LINK		2		/* multiple link usage */
 #define SK_JUMBO_LINK	3		/* driver uses jumbo frames */
 
-/* Minimum RAM Buffer Receive Queue Size */
-#define SK_MIN_RXQ_SIZE	16	/* 16 kB */
-/*
- * defines for parameter 'Dir' when calling SkGeStopPort()
- */
-#define	SK_STOP_TX	1	/* Stops the transmit path, resets the XMAC */
-#define SK_STOP_RX	2	/* Stops the receive path */
-#define SK_STOP_ALL	3	/* Stops rx and tx path, resets the XMAC */
-
-/*
- * defines for parameter 'RstMode' when calling SkGeStopPort()
- */
-#define SK_SOFT_RST	1	/* perform a software reset */
-#define SK_HARD_RST	2	/* perform a hardware reset */
-
-/*
- * Define Init Levels
- */
-#define	SK_INIT_DATA	0	/* Init level 0: init data structures */
-#define	SK_INIT_IO	1	/* Init level 1: init with IOs */
-#define	SK_INIT_RUN	2	/* Init level 2: init for run time */
-
-/*
- * Set Link Mode Parameter
- */
-#define	SK_LMODE_HALF		1	/* Half Duplex Mode */
-#define	SK_LMODE_FULL		2	/* Full Duplex Mode */
-#define	SK_LMODE_AUTOHALF	3	/* AutoHalf Duplex Mode */
-#define	SK_LMODE_AUTOFULL	4	/* AutoFull Duplex Mode */
-#define	SK_LMODE_AUTOBOTH	5	/* AutoBoth Duplex Mode */
-#define	SK_LMODE_AUTOSENSE	6	/* configured mode auto sensing */
-#define SK_LMODE_INDETERMINATED	7	/* Return value for virtual port if
-					 * multiple ports are differently
-					 * configured.
-					 */
-
-/*
- * Autonegotiation timeout in 100ms granularity.
- */
-#define	SK_AND_MAX_TO		6	/* Wait 600 msec before link comes up */
-
-/*
- * Define Autonegotiation error codes here
- */
-#define	SK_AND_OK		0	/* no error */
-#define	SK_AND_OTHER		1	/* other error than below */
-#define	SK_AND_DUP_CAP		2	/* Duplex capabilities error */
+/* Minimum RAM Buffer Rx Queue Size */
+#define SK_MIN_RXQ_SIZE	16		/* 16 kB */
 
-/*
- * Link Capability value
- */
-#define	SK_LMODE_CAP_HALF	(1<<0)	/* Half Duplex Mode */
-#define	SK_LMODE_CAP_FULL	(1<<1)	/* Full Duplex Mode */
-#define	SK_LMODE_CAP_AUTOHALF	(1<<2)	/* AutoHalf Duplex Mode */
-#define	SK_LMODE_CAP_AUTOFULL	(1<<3)	/* AutoFull Duplex Mode */
-#define SK_LMODE_CAP_INDETERMINATED (1<<4) /* Return value for virtual port if
-					 * multiple ports are differently
-					 * configured.
-					 */
+/* Minimum RAM Buffer Tx Queue Size */
+#define SK_MIN_TXQ_SIZE	16		/* 16 kB */
 
-/*
- * Link mode current state
- */
-#define	SK_LMODE_STAT_UNKNOWN	1	/* Unknown Duplex Mode */
-#define	SK_LMODE_STAT_HALF	2	/* Half Duplex Mode */
-#define	SK_LMODE_STAT_FULL	3	/* Full Duplex Mode */
-#define SK_LMODE_STAT_AUTOHALF	4	/* Half Duplex Mode obtained by AutoNeg */
-#define SK_LMODE_STAT_AUTOFULL	5	/* Half Duplex Mode obtained by AutoNeg */
-#define SK_LMODE_STAT_INDETERMINATED 6	/* Return value for virtual port if
-					 * multiple ports are differently
-					 * configured.
-					 */
-/*
- * Set Flow Control Mode Parameter (and capabilities)
- */
-#define	SK_FLOW_MODE_NONE	1	/* No Flow Control */
-#define	SK_FLOW_MODE_LOC_SEND	2	/* Local station sends PAUSE */
-#define	SK_FLOW_MODE_SYMMETRIC	3	/* Both station may send PAUSE */
-#define	SK_FLOW_MODE_SYM_OR_REM	4	/* Both station may send PAUSE or
-					 * just the remote station may send
-					 * PAUSE
-					 */
-#define SK_FLOW_MODE_INDETERMINATED 5	/* Return value for virtual port if
-					 * multiple ports are differently
-					 * configured.
-					 */
+/* Queue Size units */
+#define QZ_UNITS		0x7
+#define QZ_STEP			8
+
+/* Percentage of queue size from whole memory */
+/* 80 % for receive */
+#define RAM_QUOTA_RX	80L
+/* 0% for sync transfer */
+#define	RAM_QUOTA_SYNC	0L
+/* the rest (20%) is taken for async transfer */
+
+/* Get the rounded queue size in Bytes in 8k steps */
+#define ROUND_QUEUE_SIZE(SizeInBytes)					\
+	((((unsigned long) (SizeInBytes) + (QZ_STEP*1024L)-1) / 1024) &	\
+	~(QZ_STEP-1))
+
+/* Get the rounded queue size in KBytes in 8k steps */
+#define ROUND_QUEUE_SIZE_KB(Kilobytes) \
+	ROUND_QUEUE_SIZE((Kilobytes) * 1024L)
+
+/* Types of RAM Buffer Queues */
+#define SK_RX_SRAM_Q	1	/* small receive queue */
+#define SK_RX_BRAM_Q	2	/* big receive queue */
+#define SK_TX_RAM_Q		3	/* small or big transmit queue */
 
-/*
- * Flow Control Status Parameter
- */
-#define	SK_FLOW_STAT_NONE	1	/* No Flow Control */
-#define	SK_FLOW_STAT_REM_SEND	2	/* Remote Station sends PAUSE */
-#define	SK_FLOW_STAT_LOC_SEND	3	/* Local station sends PAUSE */
-#define	SK_FLOW_STAT_SYMMETRIC	4	/* Both station may send PAUSE */
-#define SK_FLOW_STAT_INDETERMINATED 5	/* Return value for virtual port if
-					 * multiple ports are differently
-					 * configured.
-					 */
-/*
- * Master/Slave Mode capabilities
- */
-#define	SK_MS_CAP_AUTO		(1<<0)	/* Automatic resolution */
-#define	SK_MS_CAP_MASTER	(1<<1)	/* This station is master */
-#define	SK_MS_CAP_SLAVE		(1<<2)	/* This station is slave */
-#define	SK_MS_CAP_INDETERMINATED (1<<3)	/* Return value for virtual port if
-					 * multiple ports are differently
-					 * configured.
-					 */
+/* parameter 'Dir' when calling SkGeStopPort() */
+#define SK_STOP_TX	1	/* Stops the transmit path, resets the XMAC */
+#define SK_STOP_RX	2	/* Stops the receive path */
+#define SK_STOP_ALL	3	/* Stops Rx and Tx path, resets the XMAC */
 
-/*
- * Set Master/Slave Mode Parameter (and capabilities)
- */
-#define	SK_MS_MODE_AUTO		1	/* Automatic resolution */
-#define	SK_MS_MODE_MASTER	2	/* This station is master */
-#define	SK_MS_MODE_SLAVE	3	/* This station is slave */
-#define SK_MS_MODE_INDETERMINATED 4	/* Return value for virtual port if 
-					 * multiple ports are differently
-					 */
+/* parameter 'RstMode' when calling SkGeStopPort() */
+#define SK_SOFT_RST	1	/* perform a software reset */
+#define SK_HARD_RST	2	/* perform a hardware reset */
 
-/*
- * Master/Slave Status Parameter
- */
-#define	SK_MS_STAT_UNSET	1	/* The MS status is never been determ*/
-#define	SK_MS_STAT_MASTER	2	/* This station is master */
-#define	SK_MS_STAT_SLAVE	3	/* This station is slave */
-#define	SK_MS_STAT_FAULT	4	/* MS resolution failed */
-#define SK_MS_STAT_INDETERMINATED 5	/* Return value for virtual port if
-					 * multiple ports are differently
+/* Init Levels */
+#define SK_INIT_DATA	0	/* Init level 0: init data structures */
+#define SK_INIT_IO		1	/* Init level 1: init with IOs */
+#define SK_INIT_RUN		2	/* Init level 2: init for run time */
+
+/* Link Mode Parameter */
+#define SK_LMODE_HALF		1	/* Half Duplex Mode */
+#define SK_LMODE_FULL		2	/* Full Duplex Mode */
+#define SK_LMODE_AUTOHALF	3	/* AutoHalf Duplex Mode */
+#define SK_LMODE_AUTOFULL	4	/* AutoFull Duplex Mode */
+#define SK_LMODE_AUTOBOTH	5	/* AutoBoth Duplex Mode */
+#define SK_LMODE_AUTOSENSE	6	/* configured mode auto sensing */
+#define SK_LMODE_INDETERMINATED	7	/* indeterminated */
+
+/* Auto-negotiation timeout in 100ms granularity */
+#define SK_AND_MAX_TO		6	/* Wait 600 msec before link comes up */
+
+/* Auto-negotiation error codes */
+#define SK_AND_OK			0	/* no error */
+#define SK_AND_OTHER		1	/* other error than below */
+#define SK_AND_DUP_CAP		2	/* Duplex capabilities error */
+
+
+/* Link Speed Capabilities */
+#define SK_LSPEED_CAP_AUTO			(1<<0)	/* Automatic resolution */
+#define SK_LSPEED_CAP_10MBPS		(1<<1)	/* 10 Mbps */
+#define SK_LSPEED_CAP_100MBPS		(1<<2)	/* 100 Mbps */
+#define SK_LSPEED_CAP_1000MBPS		(1<<3)	/* 1000 Mbps */
+#define SK_LSPEED_CAP_INDETERMINATED (1<<4) /* indeterminated */
+
+/* Link Speed Parameter */
+#define SK_LSPEED_AUTO				1	/* Automatic resolution */
+#define SK_LSPEED_10MBPS			2	/* 10 Mbps */
+#define SK_LSPEED_100MBPS			3	/* 100 Mbps */
+#define SK_LSPEED_1000MBPS			4	/* 1000 Mbps */
+#define SK_LSPEED_INDETERMINATED	5	/* indeterminated */
+
+/* Link Speed Current State */
+#define SK_LSPEED_STAT_UNKNOWN		1
+#define SK_LSPEED_STAT_10MBPS		2
+#define SK_LSPEED_STAT_100MBPS 		3
+#define SK_LSPEED_STAT_1000MBPS		4
+#define SK_LSPEED_STAT_INDETERMINATED 5
+
+
+/* Link Capability Parameter */
+#define SK_LMODE_CAP_HALF		(1<<0)	/* Half Duplex Mode */
+#define SK_LMODE_CAP_FULL		(1<<1)	/* Full Duplex Mode */
+#define SK_LMODE_CAP_AUTOHALF	(1<<2)	/* AutoHalf Duplex Mode */
+#define SK_LMODE_CAP_AUTOFULL	(1<<3)	/* AutoFull Duplex Mode */
+#define SK_LMODE_CAP_INDETERMINATED (1<<4) /* indeterminated */
+
+/* Link Mode Current State */
+#define SK_LMODE_STAT_UNKNOWN	1	/* Unknown Duplex Mode */
+#define SK_LMODE_STAT_HALF		2	/* Half Duplex Mode */
+#define SK_LMODE_STAT_FULL		3	/* Full Duplex Mode */
+#define SK_LMODE_STAT_AUTOHALF	4	/* Half Duplex Mode obtained by Auto-Neg */
+#define SK_LMODE_STAT_AUTOFULL	5	/* Full Duplex Mode obtained by Auto-Neg */
+#define SK_LMODE_STAT_INDETERMINATED 6	/* indeterminated */
+
+/* Flow Control Mode Parameter (and capabilities) */
+#define SK_FLOW_MODE_NONE		1	/* No Flow-Control */
+#define SK_FLOW_MODE_LOC_SEND	2	/* Local station sends PAUSE */
+#define SK_FLOW_MODE_SYMMETRIC	3	/* Both stations may send PAUSE */
+#define SK_FLOW_MODE_SYM_OR_REM	4	/* Both stations may send PAUSE or
+					 * just the remote station may send PAUSE
 					 */
+#define SK_FLOW_MODE_INDETERMINATED 5	/* indeterminated */
 
-/*
- * defines for parameter 'Mode' when calling SkXmSetRxCmd()
- */
-#define SK_STRIP_FCS_ON		(1<<0)	/* Enable FCS stripping of rx frames */
-#define SK_STRIP_FCS_OFF	(1<<1)	/* Disable FCS stripping of rx frames */
-#define SK_STRIP_PAD_ON		(1<<2)	/* Enable pad byte stripping of rx f */
-#define SK_STRIP_PAD_OFF	(1<<3)	/* Disable pad byte stripping of rx f */
-#define SK_LENERR_OK_ON		(1<<4)	/* Don't chk fr for in range len error*/
-#define SK_LENERR_OK_OFF	(1<<5)	/* Check frames for in range len error*/
-#define SK_BIG_PK_OK_ON		(1<<6)	/* Don't set rcvError bit for big fr */
-#define SK_BIG_PK_OK_OFF	(1<<7)	/* Set rcvError bit for big frames */	
+/* Flow Control Status Parameter */
+#define SK_FLOW_STAT_NONE		1	/* No Flow Control */
+#define SK_FLOW_STAT_REM_SEND	2	/* Remote Station sends PAUSE */
+#define SK_FLOW_STAT_LOC_SEND	3	/* Local station sends PAUSE */
+#define SK_FLOW_STAT_SYMMETRIC	4	/* Both station may send PAUSE */
+#define SK_FLOW_STAT_INDETERMINATED 5	/* indeterminated */
+
+/* Master/Slave Mode Capabilities */
+#define SK_MS_CAP_AUTO		(1<<0)	/* Automatic resolution */
+#define SK_MS_CAP_MASTER	(1<<1)	/* This station is master */
+#define SK_MS_CAP_SLAVE		(1<<2)	/* This station is slave */
+#define SK_MS_CAP_INDETERMINATED (1<<3)	/* indeterminated */
+
+/* Set Master/Slave Mode Parameter (and capabilities) */
+#define SK_MS_MODE_AUTO		1	/* Automatic resolution */
+#define SK_MS_MODE_MASTER	2	/* This station is master */
+#define SK_MS_MODE_SLAVE	3	/* This station is slave */
+#define SK_MS_MODE_INDETERMINATED 4	/* indeterminated */
+
+/* Master/Slave Status Parameter */
+#define SK_MS_STAT_UNSET	1	/* The M/S status is not set */
+#define SK_MS_STAT_MASTER	2	/* This station is Master */
+#define SK_MS_STAT_SLAVE	3	/* This station is Dlave */
+#define SK_MS_STAT_FAULT	4	/* M/S resolution failed */
+#define SK_MS_STAT_INDETERMINATED 5	/* indeterminated */
+
+/* parameter 'Mode' when calling SkXmSetRxCmd() */
+#define SK_STRIP_FCS_ON		(1<<0)	/* Enable  FCS stripping of Rx frames */
+#define SK_STRIP_FCS_OFF	(1<<1)	/* Disable FCS stripping of Rx frames */
+#define SK_STRIP_PAD_ON		(1<<2)	/* Enable  pad byte stripping of Rx fr */
+#define SK_STRIP_PAD_OFF	(1<<3)	/* Disable pad byte stripping of Rx fr */
+#define SK_LENERR_OK_ON		(1<<4)	/* Don't chk fr for in range len error */
+#define SK_LENERR_OK_OFF	(1<<5)	/* Check frames for in range len error */
+#define SK_BIG_PK_OK_ON		(1<<6)	/* Don't set Rx Error bit for big frames */
+#define SK_BIG_PK_OK_OFF	(1<<7)	/* Set Rx Error bit for big frames */	
+#define SK_SELF_RX_ON		(1<<8)	/* Enable  Rx of own packets */
+#define SK_SELF_RX_OFF		(1<<9)	/* Disable Rx of own packets */
+
+/* parameter 'Para' when calling SkMacSetRxTxEn() */
+#define SK_MAC_LOOPB_ON		(1<<0)	/* Enable  MAC Loopback Mode */
+#define SK_MAC_LOOPB_OFF	(1<<1)	/* Disable MAC Loopback Mode */
+#define SK_PHY_LOOPB_ON		(1<<2)	/* Enable  PHY Loopback Mode */
+#define SK_PHY_LOOPB_OFF	(1<<3)	/* Disable PHY Loopback Mode */
+#define SK_PHY_FULLD_ON		(1<<4)	/* Enable  GMII Full Duplex */
+#define SK_PHY_FULLD_OFF	(1<<5)	/* Disable GMII Full Duplex */
 
-/*
- * States of PState
- */
+/* States of PState */
 #define SK_PRT_RESET	0	/* the port is reset */
-#define SK_PRT_STOP	1	/* the port is stopped (similar to sw reset) */
-#define SK_PRT_INIT	2	/* the port is initialized */
-#define SK_PRT_RUN	3	/* the port has an active link */
+#define SK_PRT_STOP		1	/* the port is stopped (similar to SW reset) */
+#define SK_PRT_INIT		2	/* the port is initialized */
+#define SK_PRT_RUN		3	/* the port has an active link */
+
+/* Default receive frame limit for Workaround of XMAC Errata */
+#define SK_DEF_RX_WA_LIM	SK_CONSTU64(100)
+
+/* values for GILedBlinkCtrl (LED Blink Control) */
+#define SK_ACT_LED_BLINK	(1<<0)	/* Active LED blinking */
+#define SK_DUP_LED_NORMAL	(1<<1)	/* Duplex LED normal */
+#define SK_LED_LINK100_ON	(1<<2)	/* Link 100M LED on */
+
+/* Link Partner Status */
+#define SK_LIPA_UNKNOWN	0	/* Link partner is in unknown state */
+#define SK_LIPA_MANUAL	1	/* Link partner is in detected manual state */
+#define SK_LIPA_AUTO	2	/* Link partner is in auto-negotiation state */
 
-/*
- * Default receive frame limit for Workaround of XMAC Errata
- */
-#define	SK_DEF_RX_WA_LIM	SK_CONSTU64(100)
+/* Maximum Restarts before restart is ignored (3Com WA) */
+#define SK_MAX_LRESTART	3	/* Max. 3 times the link is restarted */
 
-/*
- * Define link partner Status
- */
-#define	SK_LIPA_UNKNOWN	0	/* Link partner is in unknown state */
-#define	SK_LIPA_MANUAL	1	/* Link partner is in detected manual state */
-#define	SK_LIPA_AUTO	2	/* Link partner is in autonegotiation state */
+/* Max. Auto-neg. timeouts before link detection in sense mode is reset */
+#define SK_MAX_ANEG_TO	10	/* Max. 10 times the sense mode is reset */
 
-/*
- * Define Maximum Restarts before restart is ignored (3com WA)
- */
-#define	SK_MAX_LRESTART	3	/* Max. 3 times the link is restarted */
+/* structures *****************************************************************/
 
 /*
- * define max. autonegotiation timeouts before link detection in sense mode is
- * reset.
+ * MAC specific functions
  */
-#define	SK_MAX_ANEG_TO	10	/* Max. 10 times the sense mode is reset */
-
-/* structures *****************************************************************/
+typedef struct s_GeMacFunc {
+	int  (*pFnMacUpdateStats)(SK_AC *pAC, SK_IOC IoC, unsigned int Port);
+	int  (*pFnMacStatistic)(SK_AC *pAC, SK_IOC IoC, unsigned int Port,
+							SK_U16 StatAddr, SK_U32 *pVal);
+	int  (*pFnMacResetCounter)(SK_AC *pAC, SK_IOC IoC, unsigned int Port);
+	int  (*pFnMacOverflow)(SK_AC *pAC, SK_IOC IoC, unsigned int Port,
+						   SK_U16 IStatus, SK_U64 *pVal);
+} SK_GEMACFUNC;
 
 /*
  * Port Structure
@@ -469,37 +618,36 @@
 typedef	struct s_GePort {
 #ifndef SK_DIAG
 	SK_TIMER	PWaTimer;	/* Workaround Timer */
-#endif
-	SK_U64	PPrevShorts;	/* Previous short Counter checking */
+	SK_TIMER	HalfDupChkTimer;
+#endif /* SK_DIAG */
+	SK_U32	PPrevShorts;	/* Previous short Counter checking */
+	SK_U32	PPrevFcs;		/* Previous FCS Error Counter checking */
 	SK_U64	PPrevRx;		/* Previous RxOk Counter checking */
-	SK_U64	PPrevFcs;		/* Previous FCS Error Counter checking */
 	SK_U64	PRxLim;			/* Previous RxOk Counter checking */
 	SK_U64	LastOctets;		/* For half duplex hang check */
-#ifndef SK_DIAG
-	SK_TIMER	HalfDupChkTimer;
-#endif
 	int		PLinkResCt;		/* Link Restart Counter */
-	int		PAutoNegTimeOut;/* AutoNegotiation timeout current value */
-	int		PAutoNegTOCt;	/* AutoNeg Timeout Counter */
+	int		PAutoNegTimeOut;/* Auto-negotiation timeout current value */
+	int		PAutoNegTOCt;	/* Auto-negotiation Timeout Counter */
 	int		PRxQSize;		/* Port Rx Queue Size in kB */
-	int		PXSQSize;		/* Port Synchronous Transmit Queue Size in kB */
-	int		PXAQSize;		/* Port Asynchronous Transmit Queue Size in kB*/
+	int		PXSQSize;		/* Port Synchronous  Transmit Queue Size in kB */
+	int		PXAQSize;		/* Port Asynchronous Transmit Queue Size in kB */
 	SK_U32	PRxQRamStart;	/* Receive Queue RAM Buffer Start Address */
 	SK_U32	PRxQRamEnd;		/* Receive Queue RAM Buffer End Address */
 	SK_U32	PXsQRamStart;	/* Sync Tx Queue RAM Buffer Start Address */
 	SK_U32	PXsQRamEnd;		/* Sync Tx Queue RAM Buffer End Address */
 	SK_U32	PXaQRamStart;	/* Async Tx Queue RAM Buffer Start Address */
 	SK_U32	PXaQRamEnd;		/* Async Tx Queue RAM Buffer End Address */
+	SK_U32	PRxOverCnt;		/* Receive Overflow Counter */
 	int		PRxQOff;		/* Rx Queue Address Offset */
 	int		PXsQOff;		/* Synchronous Tx Queue Address Offset */
 	int		PXaQOff;		/* Asynchronous Tx Queue Address Offset */
 	int		PhyType;		/* PHY used on this port */
+	SK_U16	PhyId1;			/* PHY Id1 on this port */
 	SK_U16	PhyAddr;		/* MDIO/MDC PHY address */
-	SK_U16	PRxCmd;			/* Port Receive Command Configuration Value */
 	SK_U16	PIsave;			/* Saved Interrupt status word */
 	SK_U16	PSsave;			/* Saved PHY status word */
-	SK_U16	Align01;
-	SK_BOOL	PHWLinkUp;		/* The hardware Link is up (wireing) */
+	SK_U16	PGmANegAdv;		/* Saved GPhy AutoNegAdvertisment register */
+	SK_BOOL	PHWLinkUp;		/* The hardware Link is up (wiring) */
 	SK_BOOL	PState;			/* Is port initialized ? */
 	SK_BOOL	PLinkBroken;	/* Is Link broken ? */
 	SK_BOOL	PCheckPar;		/* Do we check for parity errors ? */
@@ -508,77 +656,106 @@
 	SK_U8	PLinkModeConf;	/* Link Mode configured */
 	SK_U8	PLinkMode;		/* Link Mode currently used */
 	SK_U8	PLinkModeStatus;/* Link Mode Status */
+	SK_U8	PLinkSpeedCap;	/* Link Speed Capabilities(10/100/1000 Mbps) */
+	SK_U8	PLinkSpeed;		/* configured Link Speed (10/100/1000 Mbps) */
+	SK_U8	PLinkSpeedUsed;	/* current Link Speed (10/100/1000 Mbps) */
 	SK_U8	PFlowCtrlCap;	/* Flow Control Capabilities */
 	SK_U8	PFlowCtrlMode;	/* Flow Control Mode */
 	SK_U8	PFlowCtrlStatus;/* Flow Control Status */
 	SK_U8	PMSCap;			/* Master/Slave Capabilities */
 	SK_U8	PMSMode;		/* Master/Slave Mode */
 	SK_U8	PMSStatus;		/* Master/Slave Status */
-	SK_U8	PAutoNegFail;	/* Autonegotiation fail flag */
-	SK_U8	PLipaAutoNeg;	/* Autonegotiation possible with Link Partner */
-	SK_U8	Align02;
+	SK_U8	PAutoNegFail;	/* Auto-negotiation fail flag */
+	SK_U8	PLipaAutoNeg;	/* Auto-negotiation possible with Link Partner */
+	SK_U8	PCableLen;		/* Cable Length */
+	SK_U8	PMdiPairLen[4];	/* MDI[0..3] Pair Length */
+	SK_U8	PMdiPairSts[4];	/* MDI[0..3] Pair Diagnostic Status */
 } SK_GEPORT;
 
 /*
- * Gigabit Ethernet Initalization Struct
+ * Gigabit Ethernet Initialization Struct
  * (has to be included in the adapter context)
  */
 typedef	struct s_GeInit {
+	SK_U8		GIPciHwRev;		/* PCI HW Revision Number */
+	SK_U8		GIChipId;		/* Chip Identification Number */
+	SK_U8		GIChipRev;		/* Chip Revision Number */
+	SK_BOOL		GIGenesis;		/* Genesis adapter ? */
+	SK_BOOL		GICopperType;	/* Copper Type adapter ? */
+	SK_BOOL		GIPciSlot64;	/* 64-bit PCI Slot */
+	SK_BOOL		GIPciClock66;	/* 66 MHz PCI Clock */
+	SK_BOOL		GIVauxAvail;	/* VAUX available (YUKON) */
+	SK_BOOL		GIYukon32Bit;	/* 32-Bit YUKON adapter */
+	SK_BOOL		GIYukonLite;	/* YUKON-Lite chip */
+	SK_U16		GILedBlinkCtrl;	/* LED Blink Control */
 	int			GIMacsFound;	/* Number of MACs found on this adapter */
-	int			GIPciHwRev;		/* PCI HW Revision Number */
-	SK_U32		GIRamOffs;		/* RAM Address Offset for addr calculation */
-	int			GIRamSize;		/* The RAM size of the adapter in kB */
+	int			GIMacType;		/* MAC Type used on this adapter */
 	int			GIHstClkFact;	/* Host Clock Factor (62.5 / HstClk * 100) */
-	int			GIPortUsage;	/* driver port usage: SK_RED_LINK/SK_MUL_LINK */
-	SK_U32		GIPollTimerVal;	/* Descriptor Poll Timer Init Val in clk ticks*/
-	int			GILevel;		/* Initialization Level Completed */
+	int			GIPortUsage;	/* Driver Port Usage */
+	int			GILevel;		/* Initialization Level completed */
+	int			GIRamSize;		/* The RAM size of the adapter in kB */
+	int			GIWolOffs;		/* WOL Register Offset (HW-Bug in Rev. A) */
+	SK_U32		GIRamOffs;		/* RAM Address Offset for addr calculation */
+	SK_U32		GIPollTimerVal;	/* Descr. Poll Timer Init Val (HstClk ticks) */
+	SK_U32		GIValIrqMask;	/* Value for Interrupt Mask */
+	SK_U32		GITimeStampCnt;	/* Time Stamp High Counter (YUKON only) */
 	SK_GEPORT	GP[SK_MAX_MACS];/* Port Dependent Information */
-	SK_BOOL		GIAnyPortAct;	/* Is True if one or more port is initialized */
-	SK_U8		Align01;
-	SK_U16		Align02;
+	SK_GEMACFUNC GIFunc;		/* MAC depedent functions */
 } SK_GEINIT;
 
 /*
- * Define the error numbers and messages for xmac_ii.c and skgeinit.c
+ * Error numbers and messages for skxmac2.c and skgeinit.c
  */
-#define	SKERR_HWI_E001		(SK_ERRBASE_HWINIT)
-#define	SKERR_HWI_E001MSG	"SkXmClrExactAddr() has got illegal parameters"
-#define	SKERR_HWI_E002		(SKERR_HWI_E001+1)
-#define	SKERR_HWI_E002MSG	"SkGeInit() Level 1 call missing"
-#define	SKERR_HWI_E003		(SKERR_HWI_E002+1)
-#define	SKERR_HWI_E003MSG	"SkGeInit() called with illegal init Level"
-#define	SKERR_HWI_E004		(SKERR_HWI_E003+1)
-#define	SKERR_HWI_E004MSG	"SkGeInitPort() Queue size illegal configured"
-#define	SKERR_HWI_E005		(SKERR_HWI_E004+1)
-#define	SKERR_HWI_E005MSG	"SkGeInitPort() cannot init running ports"
-#define	SKERR_HWI_E006		(SKERR_HWI_E005+1)
-#define	SKERR_HWI_E006MSG	"SkGeXmInit(): PState does not match HW state"
-#define	SKERR_HWI_E007		(SKERR_HWI_E006+1)
-#define	SKERR_HWI_E007MSG	"SkXmInitDupMd() called with invalid Dup Mode"
-#define	SKERR_HWI_E008		(SKERR_HWI_E007+1)
-#define	SKERR_HWI_E008MSG	"SkXmSetRxCmd() called with invalid Mode"
-#define	SKERR_HWI_E009		(SKERR_HWI_E008+1)
-#define	SKERR_HWI_E009MSG	"SkGeCfgSync() called although PXSQSize zero"
-#define	SKERR_HWI_E010		(SKERR_HWI_E009+1)
-#define	SKERR_HWI_E010MSG	"SkGeCfgSync() called with invalid parameters"
-#define	SKERR_HWI_E011		(SKERR_HWI_E010+1)
-#define	SKERR_HWI_E011MSG	"SkGeInitPort() Receive Queue Size to small"
-#define	SKERR_HWI_E012		(SKERR_HWI_E011+1)
-#define	SKERR_HWI_E012MSG	"SkGeInitPort() invalid Queue Size specified"
-#define	SKERR_HWI_E013		(SKERR_HWI_E012+1)
-#define	SKERR_HWI_E013MSG	"SkGeInitPort() cfg changed for running queue"
-#define	SKERR_HWI_E014		(SKERR_HWI_E013+1)
-#define	SKERR_HWI_E014MSG	"SkGeInitPort() unknown GIPortUsage specified"
-#define	SKERR_HWI_E015		(SKERR_HWI_E014+1)
-#define	SKERR_HWI_E015MSG	"Illegal Link mode parameter"
-#define	SKERR_HWI_E016		(SKERR_HWI_E015+1)
-#define	SKERR_HWI_E016MSG	"Illegal Flow control mode parameter"
-#define	SKERR_HWI_E017		(SKERR_HWI_E016+1)
-#define	SKERR_HWI_E017MSG	"Illegal value specified for GIPollTimerVal"
-#define	SKERR_HWI_E018		(SKERR_HWI_E017+1)
-#define	SKERR_HWI_E018MSG	"FATAL: SkGeStopPort() does not terminate"
-#define	SKERR_HWI_E019		(SKERR_HWI_E018+1)
-#define	SKERR_HWI_E019MSG	""
+#define SKERR_HWI_E001		(SK_ERRBASE_HWINIT)
+#define SKERR_HWI_E001MSG	"SkXmClrExactAddr() has got illegal parameters"
+#define SKERR_HWI_E002		(SKERR_HWI_E001+1)
+#define SKERR_HWI_E002MSG	"SkGeInit(): Level 1 call missing"
+#define SKERR_HWI_E003		(SKERR_HWI_E002+1)
+#define SKERR_HWI_E003MSG	"SkGeInit() called with illegal init Level"
+#define SKERR_HWI_E004		(SKERR_HWI_E003+1)
+#define SKERR_HWI_E004MSG	"SkGeInitPort(): Queue Size illegal configured"
+#define SKERR_HWI_E005		(SKERR_HWI_E004+1)
+#define SKERR_HWI_E005MSG	"SkGeInitPort(): cannot init running ports"
+#define SKERR_HWI_E006		(SKERR_HWI_E005+1)
+#define SKERR_HWI_E006MSG	"SkGeMacInit(): PState does not match HW state"
+#define SKERR_HWI_E007		(SKERR_HWI_E006+1)
+#define SKERR_HWI_E007MSG	"SkXmInitDupMd() called with invalid Dup Mode"
+#define SKERR_HWI_E008		(SKERR_HWI_E007+1)
+#define SKERR_HWI_E008MSG	"SkXmSetRxCmd() called with invalid Mode"
+#define SKERR_HWI_E009		(SKERR_HWI_E008+1)
+#define SKERR_HWI_E009MSG	"SkGeCfgSync() called although PXSQSize zero"
+#define SKERR_HWI_E010		(SKERR_HWI_E009+1)
+#define SKERR_HWI_E010MSG	"SkGeCfgSync() called with invalid parameters"
+#define SKERR_HWI_E011		(SKERR_HWI_E010+1)
+#define SKERR_HWI_E011MSG	"SkGeInitPort(): Receive Queue Size too small"
+#define SKERR_HWI_E012		(SKERR_HWI_E011+1)
+#define SKERR_HWI_E012MSG	"SkGeInitPort(): invalid Queue Size specified"
+#define SKERR_HWI_E013		(SKERR_HWI_E012+1)
+#define SKERR_HWI_E013MSG	"SkGeInitPort(): cfg changed for running queue"
+#define SKERR_HWI_E014		(SKERR_HWI_E013+1)
+#define SKERR_HWI_E014MSG	"SkGeInitPort(): unknown GIPortUsage specified"
+#define SKERR_HWI_E015		(SKERR_HWI_E014+1)
+#define SKERR_HWI_E015MSG	"Illegal Link mode parameter"
+#define SKERR_HWI_E016		(SKERR_HWI_E015+1)
+#define SKERR_HWI_E016MSG	"Illegal Flow control mode parameter"
+#define SKERR_HWI_E017		(SKERR_HWI_E016+1)
+#define SKERR_HWI_E017MSG	"Illegal value specified for GIPollTimerVal"
+#define SKERR_HWI_E018		(SKERR_HWI_E017+1)
+#define SKERR_HWI_E018MSG	"FATAL: SkGeStopPort() does not terminate (Tx)"
+#define SKERR_HWI_E019		(SKERR_HWI_E018+1)
+#define SKERR_HWI_E019MSG	"Illegal Speed parameter"
+#define SKERR_HWI_E020		(SKERR_HWI_E019+1)
+#define SKERR_HWI_E020MSG	"Illegal Master/Slave parameter"
+#define SKERR_HWI_E021		(SKERR_HWI_E020+1)
+#define	SKERR_HWI_E021MSG	"MacUpdateStats(): cannot update statistic counter"
+#define	SKERR_HWI_E022		(SKERR_HWI_E021+1)
+#define	SKERR_HWI_E022MSG	"MacStatistic(): illegal statistic base address"
+#define SKERR_HWI_E023		(SKERR_HWI_E022+1)
+#define SKERR_HWI_E023MSG	"SkGeInitPort(): Transmit Queue Size too small"
+#define SKERR_HWI_E024		(SKERR_HWI_E023+1)
+#define SKERR_HWI_E024MSG	"FATAL: SkGeStopPort() does not terminate (Rx)"
+#define SKERR_HWI_E025		(SKERR_HWI_E024+1)
+#define SKERR_HWI_E025MSG	""
 
 /* function prototypes ********************************************************/
 
@@ -588,146 +765,301 @@
  * public functions in skgeinit.c
  */
 extern void	SkGePollRxD(
-	SK_AC		*pAC,
-	SK_IOC		IoC,
+	SK_AC	*pAC,
+	SK_IOC	IoC,
 	int		Port,
-	SK_BOOL		PollRxD);
+	SK_BOOL	PollRxD);
 
 extern void	SkGePollTxD(
-	SK_AC		*pAC,
-	SK_IOC		IoC,
+	SK_AC	*pAC,
+	SK_IOC	IoC,
 	int		Port,
-	SK_BOOL 	PollTxD);
+	SK_BOOL PollTxD);
 
 extern void	SkGeYellowLED(
-	SK_AC		*pAC,
-	SK_IOC		IoC,
+	SK_AC	*pAC,
+	SK_IOC	IoC,
 	int		State);
 
 extern int	SkGeCfgSync(
-	SK_AC		*pAC,
-	SK_IOC		IoC,
+	SK_AC	*pAC,
+	SK_IOC	IoC,
 	int		Port,
-	SK_U32		IntTime,
-	SK_U32		LimCount,
+	SK_U32	IntTime,
+	SK_U32	LimCount,
 	int		SyncMode);
 
 extern void	SkGeLoadLnkSyncCnt(
-	SK_AC		*pAC,
-	SK_IOC		IoC,
+	SK_AC	*pAC,
+	SK_IOC	IoC,
 	int		Port,
-	SK_U32		CntVal);
+	SK_U32	CntVal);
 
 extern void	SkGeStopPort(
-	SK_AC		*pAC,
-	SK_IOC		IoC,
+	SK_AC	*pAC,
+	SK_IOC	IoC,
 	int		Port,
 	int		Dir,
 	int		RstMode);
 
 extern int	SkGeInit(
-	SK_AC		*pAC,
-	SK_IOC		IoC,
+	SK_AC	*pAC,
+	SK_IOC	IoC,
 	int		Level);
 
 extern void	SkGeDeInit(
-	SK_AC		*pAC,
-	SK_IOC		IoC);
+	SK_AC	*pAC,
+	SK_IOC	IoC);
 
 extern int	SkGeInitPort(
-	SK_AC		*pAC,
-	SK_IOC		IoC,
+	SK_AC	*pAC,
+	SK_IOC	IoC,
 	int		Port);
 
 extern void	SkGeXmitLED(
-	SK_AC		*pAC,
-	SK_IOC		IoC,
+	SK_AC	*pAC,
+	SK_IOC	IoC,
 	int		Led,
 	int		Mode);
 
 extern void	SkGeInitRamIface(
-	SK_AC		*pAC,
-	SK_IOC		IoC);
+	SK_AC	*pAC,
+	SK_IOC	IoC);
+
+extern int	SkGeInitAssignRamToQueues(
+	SK_AC	*pAC,
+	int		ActivePort,
+	SK_BOOL	DualNet);
 
 /*
  * public functions in skxmac2.c
  */
-extern void	SkXmSetRxCmd(
-	SK_AC		*pAC,
-	SK_IOC		IoC,
-	int		Port,
-	int		Mode);
+extern void SkMacRxTxDisable(
+	SK_AC	*pAC,
+	SK_IOC	IoC,
+	int		Port);
 
-extern void	SkXmClrExactAddr(
-	SK_AC		*pAC,
-	SK_IOC		IoC,
+extern void	SkMacSoftRst(
+	SK_AC	*pAC,
+	SK_IOC	IoC,
+	int		Port);
+
+extern void	SkMacHardRst(
+	SK_AC	*pAC,
+	SK_IOC	IoC,
+	int		Port);
+
+extern void	SkXmInitMac(
+	SK_AC	*pAC,
+	SK_IOC	IoC,
+	int		Port);
+
+extern void	SkGmInitMac(
+	SK_AC	*pAC,
+	SK_IOC	IoC,
+	int		Port);
+
+extern void SkMacInitPhy(
+	SK_AC	*pAC,
+	SK_IOC	IoC,
 	int		Port,
-	int		StartNum,
-	int		StopNum);
+	SK_BOOL	DoLoop);
 
-extern void	SkXmFlushTxFifo(
-	SK_AC		*pAC,
-	SK_IOC		IoC,
+extern void SkMacIrqDisable(
+	SK_AC	*pAC,
+	SK_IOC	IoC,
 	int		Port);
 
-extern void	SkXmFlushRxFifo(
-	SK_AC		*pAC,
-	SK_IOC		IoC,
+extern void	SkMacFlushTxFifo(
+	SK_AC	*pAC,
+	SK_IOC	IoC,
 	int		Port);
 
-extern void	SkXmSoftRst(
-	SK_AC		*pAC,
-	SK_IOC		IoC,
+extern void	SkMacFlushRxFifo(
+	SK_AC	*pAC,
+	SK_IOC	IoC,
 	int		Port);
 
-extern void	SkXmHardRst(
-	SK_AC		*pAC,
-	SK_IOC		IoC,
+extern void	SkMacIrq(
+	SK_AC	*pAC,
+	SK_IOC	IoC,
 	int		Port);
 
-extern void	SkXmInitMac(
-	SK_AC		*pAC,
-	SK_IOC		IoC,
+extern int	SkMacAutoNegDone(
+	SK_AC	*pAC,
+	SK_IOC	IoC,
 	int		Port);
 
-extern void	SkXmInitDupMd(
-	SK_AC		*pAC,
-	SK_IOC		IoC,
+extern void	SkMacAutoNegLipaPhy(
+	SK_AC	*pAC,
+	SK_IOC	IoC,
+	int		Port,
+	SK_U16	IStatus);
+
+extern void  SkMacSetRxTxEn(
+	SK_AC	*pAC,
+	SK_IOC	IoC,
+	int		Port,
+	int		Para);
+
+extern int  SkMacRxTxEnable(
+	SK_AC	*pAC,
+	SK_IOC	IoC,
 	int		Port);
 
-extern void	SkXmInitPauseMd(
-	SK_AC		*pAC,
-	SK_IOC		IoC,
+extern void	SkMacPromiscMode(
+	SK_AC	*pAC,
+	SK_IOC	IoC,
+	int		Port,
+	SK_BOOL	Enable);
+
+extern void	SkMacHashing(
+	SK_AC	*pAC,
+	SK_IOC	IoC,
+	int		Port,
+	SK_BOOL	Enable);
+
+extern void	SkXmPhyRead(
+	SK_AC	*pAC,
+	SK_IOC	IoC,
+	int		Port,
+	int		Addr,
+	SK_U16	*pVal);
+
+extern void	SkXmPhyWrite(
+	SK_AC	*pAC,
+	SK_IOC	IoC,
+	int		Port,
+	int		Addr,
+	SK_U16	Val);
+
+extern void	SkGmPhyRead(
+	SK_AC	*pAC,
+	SK_IOC	IoC,
+	int		Port,
+	int		Addr,
+	SK_U16	*pVal);
+
+extern void	SkGmPhyWrite(
+	SK_AC	*pAC,
+	SK_IOC	IoC,
+	int		Port,
+	int		Addr,
+	SK_U16	Val);
+
+extern void	SkGePhyRead(
+	SK_AC	*pAC,
+	SK_IOC	IoC,
+	int		Port,
+	int		Addr,
+	SK_U16	*pVal);
+
+extern void	SkGePhyWrite(
+	SK_AC	*pAC,
+	SK_IOC	IoC,
+	int		Port,
+	int		Addr,
+	SK_U16	Val);
+
+extern void	SkXmClrExactAddr(
+	SK_AC	*pAC,
+	SK_IOC	IoC,
+	int		Port,
+	int		StartNum,
+	int		StopNum);
+
+extern void	SkXmInitDupMd(
+	SK_AC	*pAC,
+	SK_IOC	IoC,
 	int		Port);
 
-extern int	SkXmAutoNegDone(
-	SK_AC		*pAC,
-	SK_IOC		IoC,
+extern void	SkXmInitPauseMd(
+	SK_AC	*pAC,
+	SK_IOC	IoC,
 	int		Port);
 
 extern void	SkXmAutoNegLipaXmac(
-	SK_AC		*pAC,
-	SK_IOC		IoC,
+	SK_AC	*pAC,
+	SK_IOC	IoC,
 	int		Port,
-	SK_U16		IStatus);
+	SK_U16	IStatus);
 
-extern void	SkXmAutoNegLipaBcom(
-	SK_AC		*pAC,
-	SK_IOC		IoC,
+extern int SkXmUpdateStats(
+	SK_AC	*pAC,
+	SK_IOC	IoC,
+	unsigned int Port);
+
+extern int SkGmUpdateStats(
+	SK_AC	*pAC,
+	SK_IOC	IoC,
+	unsigned int Port);
+
+extern int SkXmMacStatistic(
+	SK_AC	*pAC,
+	SK_IOC	IoC,
+	unsigned int Port,
+	SK_U16	StatAddr,
+	SK_U32	*pVal);
+
+extern int SkGmMacStatistic(
+	SK_AC	*pAC,
+	SK_IOC	IoC,
+	unsigned int Port,
+	SK_U16	StatAddr,
+	SK_U32	*pVal);
+
+extern int SkXmResetCounter(
+	SK_AC	*pAC,
+	SK_IOC	IoC,
+	unsigned int Port);
+
+extern int SkGmResetCounter(
+	SK_AC	*pAC,
+	SK_IOC	IoC,
+	unsigned int Port);
+
+extern int SkXmOverflowStatus(
+	SK_AC	*pAC,
+	SK_IOC	IoC,
+	unsigned int Port,
+	SK_U16  IStatus,
+	SK_U64	*pStatus);
+
+extern int SkGmOverflowStatus(
+	SK_AC	*pAC,
+	SK_IOC	IoC,
+	unsigned int Port,
+	SK_U16	MacStatus,
+	SK_U64	*pStatus);
+
+extern int SkGmCableDiagStatus(
+	SK_AC	*pAC,
+	SK_IOC	IoC,
 	int		Port,
-	SK_U16		IStatus);
+	SK_BOOL	StartTest);
 
-extern void	SkXmAutoNegLipaLone(
-	SK_AC		*pAC,
-	SK_IOC		IoC,
+#ifdef SK_DIAG
+extern void	SkMacSetRxCmd(
+	SK_AC	*pAC,
+	SK_IOC	IoC,
 	int		Port,
-	SK_U16		IStatus);
-
-extern void	SkXmIrq(
-	SK_AC		*pAC,
-	SK_IOC		IoC,
+	int		Mode);
+extern void	SkMacCrcGener(
+	SK_AC	*pAC,
+	SK_IOC	IoC,
 	int		Port,
-	SK_U16		IStatus);
+	SK_BOOL	Enable);
+extern void	SkMacTimeStamp(
+	SK_AC	*pAC,
+	SK_IOC	IoC,
+	int		Port,
+	SK_BOOL	Enable);
+extern void	SkXmSendCont(
+	SK_AC	*pAC,
+	SK_IOC	IoC,
+	int		Port,
+	SK_BOOL	Enable);
+#endif /* SK_DIAG */
 
 #else	/* SK_KR_PROTO */
 
@@ -745,22 +1077,53 @@
 extern int	SkGeInitPort();
 extern void	SkGeXmitLED();
 extern void	SkGeInitRamIface();
+extern int	SkGeInitAssignRamToQueues();
 
 /*
  * public functions in skxmac2.c
  */
-extern void	SkXmSetRxCmd();
-extern void	SkXmClrExactAddr();
-extern void	SkXmFlushTxFifo();
-extern void	SkXmFlushRxFifo();
-extern void	SkXmSoftRst();
-extern void	SkXmHardRst();
+extern void SkMacRxTxDisable();
+extern void	SkMacSoftRst();
+extern void	SkMacHardRst();
+extern void SkMacInitPhy();
+extern int  SkMacRxTxEnable();
+extern void SkMacPromiscMode();
+extern void SkMacHashing();
+extern void SkMacIrqDisable();
+extern void	SkMacFlushTxFifo();
+extern void	SkMacFlushRxFifo();
+extern void	SkMacIrq();
+extern int	SkMacAutoNegDone();
+extern void	SkMacAutoNegLipaPhy();
+extern void SkMacSetRxTxEn();
+extern void	SkGePhyRead();
+extern void	SkGePhyWrite();
 extern void	SkXmInitMac();
+extern void	SkXmPhyRead();
+extern void	SkXmPhyWrite();
+extern void	SkGmInitMac();
+extern void	SkGmPhyRead();
+extern void	SkGmPhyWrite();
+extern void	SkXmClrExactAddr();
 extern void	SkXmInitDupMd();
 extern void	SkXmInitPauseMd();
-extern int	SkXmAutoNegDone();
-extern void	SkXmAutoNegLipa();
-extern void	SkXmIrq();
+extern void	SkXmAutoNegLipaXmac();
+extern int	SkXmUpdateStats();
+extern int	SkGmUpdateStats();
+extern int	SkXmMacStatistic();
+extern int	SkGmMacStatistic();
+extern int	SkXmResetCounter();
+extern int	SkGmResetCounter();
+extern int	SkXmOverflowStatus();
+extern int	SkGmOverflowStatus();
+extern int	SkGmCableDiagStatus();
+
+#ifdef SK_DIAG
+extern void	SkMacSetRxCmd();
+extern void	SkMacCrcGener();
+extern void	SkMacTimeStamp();
+extern void	SkXmSendCont();
+#endif /* SK_DIAG */
 
 #endif	/* SK_KR_PROTO */
 
diff -ruN linux/drivers/net/sk98lin/h/skgepnm2.h linuxn/drivers/net/sk98lin/h/skgepnm2.h
--- linux/drivers/net/sk98lin/h/skgepnm2.h	Wed Jul  4 20:50:39 2001
+++ linuxn/drivers/net/sk98lin/h/skgepnm2.h	Tue May 20 12:17:41 2003
@@ -2,15 +2,16 @@
  *
  * Name:	skgepnm2.h
  * Project:	GEnesis, PCI Gigabit Ethernet Adapter
- * Version:	$Revision: 1.30 $
- * Date:	$Date: 2001/02/06 10:03:41 $
+ * Version:	$Revision: 1.35 $
+ * Date:	$Date: 2003/03/27 11:27:48 $
  * Purpose:	Defines for Private Network Management Interface
  *
  ****************************************************************************/
 
 /******************************************************************************
  *
- *	(C)Copyright 1998-2001 SysKonnect GmbH.
+ *	(C)Copyright 1998-2002 SysKonnect GmbH.
+ *	(C)Copyright 2002-2003 Marvell.
  *
  *	This program is free software; you can redistribute it and/or modify
  *	it under the terms of the GNU General Public License as published by
@@ -26,6 +27,24 @@
  * History:
  *
  *	$Log: skgepnm2.h,v $
+ *	Revision 1.35  2003/03/27 11:27:48  tschilli
+ *	Copyright messages changed.
+ *	
+ *	Revision 1.34  2002/12/16 09:05:18  tschilli
+ *	Code for VCT handling added.
+ *	
+ *	Revision 1.33  2002/09/10 09:00:03  rwahl
+ *	Adapted boolean definitions according sktypes.
+ *	
+ *	Revision 1.32  2002/08/09 09:47:01  rwahl
+ *	Added write-only flag to oid access defines.
+ *	Editorial changes.
+ *	
+ *	Revision 1.31  2002/07/17 19:23:18  rwahl
+ *	- Replaced MAC counter definitions by enumeration.
+ *	- Added definition SK_PNMI_MAC_TYPES.
+ *	- Added chipset defnition for Yukon.
+ *	
  *	Revision 1.30  2001/02/06 10:03:41  mkunz
  *	- Pnmi V4 dual net support added. Interface functions and macros extended
  *	- Vpd bug fixed
@@ -140,26 +159,19 @@
 #ifndef _SKGEPNM2_H_
 #define _SKGEPNM2_H_
 
-#ifndef FALSE
-#define FALSE			0
-#endif
-
-#ifndef TRUE
-#define	TRUE			!(FALSE)
-#endif
-
 /*
  * General definitions
  */
-#define SK_PNMI_CHIPSET		1	/* XMAC11800FP */
+#define SK_PNMI_CHIPSET_XMAC	1	/* XMAC11800FP */
+#define SK_PNMI_CHIPSET_YUKON	2	/* YUKON */
 
 #define	SK_PNMI_BUS_PCI		1	/* PCI bus*/
 
 /*
  * Actions
  */
-#define SK_PNMI_ACT_IDLE	1
-#define SK_PNMI_ACT_RESET	2
+#define SK_PNMI_ACT_IDLE		1
+#define SK_PNMI_ACT_RESET		2
 #define SK_PNMI_ACT_SELFTEST	3
 #define SK_PNMI_ACT_RESETCNT	4
 
@@ -170,13 +182,13 @@
 #define SK_PNMI_VPD_RW		1
 #define SK_PNMI_VPD_RO		2
 
-#define SK_PNMI_VPD_OK		0
+#define SK_PNMI_VPD_OK			0
 #define SK_PNMI_VPD_NOTFOUND	1
-#define SK_PNMI_VPD_CUT		2
-#define SK_PNMI_VPD_TIMEOUT	3
-#define SK_PNMI_VPD_FULL	4
-#define SK_PNMI_VPD_NOWRITE	5
-#define SK_PNMI_VPD_FATAL	6
+#define SK_PNMI_VPD_CUT			2
+#define SK_PNMI_VPD_TIMEOUT		3
+#define SK_PNMI_VPD_FULL		4
+#define SK_PNMI_VPD_NOWRITE		5
+#define SK_PNMI_VPD_FATAL		6
 
 #define SK_PNMI_VPD_IGNORE	0
 #define SK_PNMI_VPD_CREATE	1
@@ -188,124 +200,137 @@
  */
 #define SK_PNMI_DEF_RLMT_CHG_THRES	240	/* 4 changes per minute */
 
+
+/*
+ * VCT internal status values
+ */
+#define SK_PNMI_VCT_PENDING	32
+#define SK_PNMI_VCT_TEST_DONE	64
+#define SK_PNMI_VCT_LINK	128
+
 /*
  * Internal table definitions
  */
 #define SK_PNMI_GET		0
-#define SK_PNMI_PRESET		1
+#define SK_PNMI_PRESET	1
 #define SK_PNMI_SET		2
 
 #define SK_PNMI_RO		0
 #define SK_PNMI_RW		1
+#define SK_PNMI_WO		2
 
 typedef struct s_OidTabEntry {
-	SK_U32		Id;
-	SK_U32		InstanceNo;
+	SK_U32			Id;
+	SK_U32			InstanceNo;
 	unsigned int	StructSize;
 	unsigned int	Offset;
-	int		Access;
-	int		(* Func)(SK_AC *pAc, SK_IOC pIo, int action,
-				SK_U32 Id, char* pBuf, unsigned int* pLen,
-				SK_U32 Instance, unsigned int TableIndex,
-                                SK_U32 NetNumber);
-	SK_U16		Param;
+	int				Access;
+	int				(* Func)(SK_AC *pAc, SK_IOC pIo, int action,
+							 SK_U32 Id, char* pBuf, unsigned int* pLen,
+							 SK_U32 Instance, unsigned int TableIndex,
+							 SK_U32 NetNumber);
+	SK_U16			Param;
 } SK_PNMI_TAB_ENTRY;
 
 
 /*
  * Trap lengths
  */
-#define SK_PNMI_TRAP_SIMPLE_LEN		17
+#define SK_PNMI_TRAP_SIMPLE_LEN			17
 #define SK_PNMI_TRAP_SENSOR_LEN_BASE	46
 #define SK_PNMI_TRAP_RLMT_CHANGE_LEN	23
-#define SK_PNMI_TRAP_RLMT_PORT_LEN	23
-
+#define SK_PNMI_TRAP_RLMT_PORT_LEN		23
 
 /*
- * MAC statistic data structures
- * Only for the first 64 counters: the number relates to the bit in the
- * XMAC overflow status register
+ * Number of MAC types supported
  */
-#define SK_PNMI_HTX			0
-#define SK_PNMI_HTX_OCTET		1
-#define SK_PNMI_HTX_OCTETHIGH		1
-#define SK_PNMI_HTX_OCTETLOW		2
-#define SK_PNMI_HTX_BROADCAST		3
-#define SK_PNMI_HTX_MULTICAST		4
-#define SK_PNMI_HTX_UNICAST		5
-#define SK_PNMI_HTX_LONGFRAMES		6
-#define SK_PNMI_HTX_BURST		7
-#define SK_PNMI_HTX_PMACC		8
-#define SK_PNMI_HTX_MACC		9
-#define SK_PNMI_HTX_SINGLE_COL		10
-#define SK_PNMI_HTX_MULTI_COL		11
-#define SK_PNMI_HTX_EXCESS_COL		12
-#define SK_PNMI_HTX_LATE_COL		13
-#define SK_PNMI_HTX_DEFFERAL		14
-#define SK_PNMI_HTX_EXCESS_DEF		15
-#define SK_PNMI_HTX_UNDERRUN		16
-#define SK_PNMI_HTX_CARRIER		17
-#define SK_PNMI_HTX_UTILUNDER		18
-#define SK_PNMI_HTX_UTILOVER		19
-#define SK_PNMI_HTX_64			20
-#define SK_PNMI_HTX_127			21
-#define SK_PNMI_HTX_255			22
-#define SK_PNMI_HTX_511			23
-#define SK_PNMI_HTX_1023		24
-#define SK_PNMI_HTX_MAX			25
-#define SK_PNMI_HTX_RESERVED26		26
-#define SK_PNMI_HTX_RESERVED27		27
-#define SK_PNMI_HTX_RESERVED28		28
-#define SK_PNMI_HTX_RESERVED29		29
-#define SK_PNMI_HTX_RESERVED30		30
-#define SK_PNMI_HTX_RESERVED31		31
-#define SK_PNMI_HRX			(32 + 0)
-#define SK_PNMI_HRX_OCTET		(32 + 1)
-#define SK_PNMI_HRX_OCTETHIGH		(32 + 1)
-#define SK_PNMI_HRX_OCTETLOW		(32 + 2)
-#define SK_PNMI_HRX_BROADCAST		(32 + 3)
-#define SK_PNMI_HRX_MULTICAST		(32 + 4)
-#define SK_PNMI_HRX_UNICAST		(32 + 5)
-#define SK_PNMI_HRX_PMACC		(32 + 6)
-#define SK_PNMI_HRX_MACC		(32 + 7)
-#define SK_PNMI_HRX_PMACC_ERR		(32 + 8)
-#define SK_PNMI_HRX_MACC_UNKWN		(32 + 9)
-#define SK_PNMI_HRX_BURST		(32 + 10)
-#define SK_PNMI_HRX_MISSED		(32 + 11)
-#define SK_PNMI_HRX_FRAMING		(32 + 12)
-#define SK_PNMI_HRX_OVERFLOW		(32 + 13)
-#define SK_PNMI_HRX_JABBER		(32 + 14)
-#define SK_PNMI_HRX_CARRIER		(32 + 15)
-#define SK_PNMI_HRX_IRLENGTH		(32 + 16)
-#define SK_PNMI_HRX_SYMBOL		(32 + 17)
-#define SK_PNMI_HRX_SHORTS		(32 + 18)
-#define SK_PNMI_HRX_RUNT		(32 + 19)
-#define SK_PNMI_HRX_TOO_LONG		(32 + 20)
-#define SK_PNMI_HRX_FCS			(32 + 21)
-#define SK_PNMI_HRX_RESERVED22		(32 + 22)
-#define SK_PNMI_HRX_CEXT		(32 + 23)
-#define SK_PNMI_HRX_UTILUNDER		(32 + 24)
-#define SK_PNMI_HRX_UTILOVER		(32 + 25)
-#define SK_PNMI_HRX_64			(32 + 26)
-#define SK_PNMI_HRX_127			(32 + 27)
-#define SK_PNMI_HRX_255			(32 + 28)
-#define SK_PNMI_HRX_511			(32 + 29)
-#define SK_PNMI_HRX_1023		(32 + 30)
-#define SK_PNMI_HRX_MAX			(32 + 31)
-
-#define SK_PNMI_HTX_SYNC		64
-#define SK_PNMI_HTX_SYNC_OCTET		65
+#define SK_PNMI_MAC_TYPES	(SK_MAC_GMAC + 1)
 
-#define SK_PNMI_HRX_LONGFRAMES		66
-
-#define SK_PNMI_MAX_IDX			(SK_PNMI_CNT_NO)
+/*
+ * MAC statistic data list (overall set for MAC types used)
+ */
+enum SK_MACSTATS {
+	SK_PNMI_HTX				= 0,
+	SK_PNMI_HTX_OCTET,
+	SK_PNMI_HTX_OCTETHIGH 	= SK_PNMI_HTX_OCTET,
+	SK_PNMI_HTX_OCTETLOW,
+	SK_PNMI_HTX_BROADCAST,
+	SK_PNMI_HTX_MULTICAST,
+	SK_PNMI_HTX_UNICAST,
+	SK_PNMI_HTX_BURST,
+	SK_PNMI_HTX_PMACC,
+	SK_PNMI_HTX_MACC,
+	SK_PNMI_HTX_COL,
+	SK_PNMI_HTX_SINGLE_COL,
+	SK_PNMI_HTX_MULTI_COL,
+	SK_PNMI_HTX_EXCESS_COL,
+	SK_PNMI_HTX_LATE_COL,
+	SK_PNMI_HTX_DEFFERAL,
+	SK_PNMI_HTX_EXCESS_DEF,
+	SK_PNMI_HTX_UNDERRUN,
+	SK_PNMI_HTX_CARRIER,
+	SK_PNMI_HTX_UTILUNDER,
+	SK_PNMI_HTX_UTILOVER,
+	SK_PNMI_HTX_64,
+	SK_PNMI_HTX_127,
+	SK_PNMI_HTX_255,
+	SK_PNMI_HTX_511,
+	SK_PNMI_HTX_1023,
+	SK_PNMI_HTX_MAX,
+	SK_PNMI_HTX_LONGFRAMES,
+	SK_PNMI_HTX_SYNC,
+	SK_PNMI_HTX_SYNC_OCTET,
+	SK_PNMI_HTX_RESERVED,
+	
+	SK_PNMI_HRX,
+	SK_PNMI_HRX_OCTET,
+	SK_PNMI_HRX_OCTETHIGH	= SK_PNMI_HRX_OCTET,
+	SK_PNMI_HRX_OCTETLOW,
+	SK_PNMI_HRX_BADOCTET,
+	SK_PNMI_HRX_BADOCTETHIGH = SK_PNMI_HRX_BADOCTET,
+	SK_PNMI_HRX_BADOCTETLOW,
+	SK_PNMI_HRX_BROADCAST,
+	SK_PNMI_HRX_MULTICAST,
+	SK_PNMI_HRX_UNICAST,
+	SK_PNMI_HRX_PMACC,
+	SK_PNMI_HRX_MACC,
+	SK_PNMI_HRX_PMACC_ERR,
+	SK_PNMI_HRX_MACC_UNKWN,
+	SK_PNMI_HRX_BURST,
+	SK_PNMI_HRX_MISSED,
+	SK_PNMI_HRX_FRAMING,
+	SK_PNMI_HRX_UNDERSIZE,
+	SK_PNMI_HRX_OVERFLOW,
+	SK_PNMI_HRX_JABBER,
+	SK_PNMI_HRX_CARRIER,
+	SK_PNMI_HRX_IRLENGTH,
+	SK_PNMI_HRX_SYMBOL,
+	SK_PNMI_HRX_SHORTS,
+	SK_PNMI_HRX_RUNT,
+	SK_PNMI_HRX_TOO_LONG,
+	SK_PNMI_HRX_FCS,
+	SK_PNMI_HRX_CEXT,
+	SK_PNMI_HRX_UTILUNDER,
+	SK_PNMI_HRX_UTILOVER,
+	SK_PNMI_HRX_64,
+	SK_PNMI_HRX_127,
+	SK_PNMI_HRX_255,
+	SK_PNMI_HRX_511,
+	SK_PNMI_HRX_1023,
+	SK_PNMI_HRX_MAX,
+	SK_PNMI_HRX_LONGFRAMES,
+	
+	SK_PNMI_HRX_RESERVED,
+	
+	SK_PNMI_MAX_IDX		/* NOTE: Ensure SK_PNMI_CNT_NO is set to this value */
+};
 
 /*
  * MAC specific data
  */
 typedef struct s_PnmiStatAddr {
-	SK_BOOL		GetOffset;	/* TRUE: Call GetStatVal function */
-	SK_U16		Param;		/* XMAC register containing value */
+	SK_U16		Reg;		/* MAC register containing the value */
+	SK_BOOL		GetOffset;	/* TRUE: Offset managed by PNMI (call GetStatVal())*/
 } SK_PNMI_STATADDR;
 
 
diff -ruN linux/drivers/net/sk98lin/h/skgepnmi.h linuxn/drivers/net/sk98lin/h/skgepnmi.h
--- linux/drivers/net/sk98lin/h/skgepnmi.h	Wed Jul  4 20:50:39 2001
+++ linuxn/drivers/net/sk98lin/h/skgepnmi.h	Tue May 20 12:17:41 2003
@@ -2,15 +2,16 @@
  *
  * Name:	skgepnmi.h
  * Project:	GEnesis, PCI Gigabit Ethernet Adapter
- * Version:	$Revision: 1.48 $
- * Date:	$Date: 2001/02/23 14:34:24 $
+ * Version:	$Revision: 1.60 $
+ * Date:	$Date: 2003/03/27 11:27:26 $
  * Purpose:	Defines for Private Network Management Interface
  *
  ****************************************************************************/
 
 /******************************************************************************
  *
- *	(C)Copyright 1998-2001 SysKonnect GmbH.
+ *	(C)Copyright 1998-2002 SysKonnect GmbH.
+ *	(C)Copyright 2002-2003 Marvell.
  *
  *	This program is free software; you can redistribute it and/or modify
  *	it under the terms of the GNU General Public License as published by
@@ -26,6 +27,46 @@
  * History:
  *
  *	$Log: skgepnmi.h,v $
+ *	Revision 1.60  2003/03/27 11:27:26  tschilli
+ *	Copyright messages changed.
+ *	
+ *	Revision 1.59  2002/12/16 14:03:50  tschilli
+ *	New defines for VCT added.
+ *	
+ *	Revision 1.58  2002/12/16 09:04:59  tschilli
+ *	Code for VCT handling added.
+ *	
+ *	Revision 1.57  2002/09/26 12:41:05  tschilli
+ *	SK_PNMI_PORT BufPort entry in struct SK_PNMI added.
+ *	
+ *	Revision 1.56  2002/08/16 11:10:41  rwahl
+ *	- Replaced c++ comment.
+ *	
+ *	Revision 1.55  2002/08/09 15:40:21  rwahl
+ *	Editorial change (renamed ConfSpeedCap).
+ *	
+ *	Revision 1.54  2002/08/09 11:06:07  rwahl
+ *	Added OID_SKGE_SPEED_CAP.
+ *	
+ *	Revision 1.53  2002/08/09 09:45:28  rwahl
+ *	Added support for NDIS OID_PNP_xxx.
+ *	Editorial changes.
+ *	
+ *	Revision 1.52  2002/08/06 17:54:07  rwahl
+ *	- Added speed cap to PNMI config struct.
+ *	
+ *	Revision 1.51  2002/07/17 19:19:26  rwahl
+ *	- Added OID_SKGE_SPEED_MODE and OID_SKGE_SPEED_STATUS.
+ *	- Added SK_PNMI_CNT_RX_PMACC_ERR() & SK_PNMI_CNT_RX_LONGFRAMES().
+ *	- Added speed mode & status to PNMI config struct.
+ *	- Editorial changes.
+ *	
+ *	Revision 1.50  2002/05/22 08:59:37  rwahl
+ *	Added string definitions for error msgs.
+ *	
+ *	Revision 1.49  2001/11/20 09:23:50  rwahl
+ *	- pnmi struct: reordered and aligned to 32bit.
+ *	
  *	Revision 1.48  2001/02/23 14:34:24  mkunz
  *	Changed macro PHYS2INST. Added pAC to Interface
  *	
@@ -233,12 +274,14 @@
 #define SK_PNMI_EVT_RLMT_ACTIVE_UP		15	/* Port came logically up */
 #define SK_PNMI_EVT_RLMT_SET_NETS		16	/* 1. Parameter is number of nets
 												1 = single net; 2 = dual net */
+#define SK_PNMI_EVT_VCT_RESET		17	/* VCT port reset timer event started with SET. */
+
 
 /*
  * Return values
  */
-#define SK_PNMI_ERR_OK			0
-#define SK_PNMI_ERR_GENERAL		1
+#define SK_PNMI_ERR_OK				0
+#define SK_PNMI_ERR_GENERAL			1
 #define SK_PNMI_ERR_TOO_SHORT		2
 #define SK_PNMI_ERR_BAD_VALUE		3
 #define SK_PNMI_ERR_READ_ONLY		4
@@ -290,11 +333,11 @@
  */
 #ifndef _NDIS_	/* Check, whether NDIS already included OIDs */
 
-#define OID_GEN_XMIT_OK			0x00020101
-#define OID_GEN_RCV_OK			0x00020102
-#define OID_GEN_XMIT_ERROR		0x00020103
-#define OID_GEN_RCV_ERROR		0x00020104
-#define OID_GEN_RCV_NO_BUFFER		0x00020105
+#define OID_GEN_XMIT_OK					0x00020101
+#define OID_GEN_RCV_OK					0x00020102
+#define OID_GEN_XMIT_ERROR				0x00020103
+#define OID_GEN_RCV_ERROR				0x00020104
+#define OID_GEN_RCV_NO_BUFFER			0x00020105
 
 /* #define OID_GEN_DIRECTED_BYTES_XMIT	0x00020201 */
 #define OID_GEN_DIRECTED_FRAMES_XMIT	0x00020202
@@ -303,211 +346,256 @@
 /* #define OID_GEN_BROADCAST_BYTES_XMIT	0x00020205 */
 #define OID_GEN_BROADCAST_FRAMES_XMIT	0x00020206
 /* #define OID_GEN_DIRECTED_BYTES_RCV	0x00020207 */
-#define OID_GEN_DIRECTED_FRAMES_RCV	0x00020208
+#define OID_GEN_DIRECTED_FRAMES_RCV		0x00020208
 /* #define OID_GEN_MULTICAST_BYTES_RCV	0x00020209 */
 #define OID_GEN_MULTICAST_FRAMES_RCV	0x0002020A
 /* #define OID_GEN_BROADCAST_BYTES_RCV	0x0002020B */
 #define OID_GEN_BROADCAST_FRAMES_RCV	0x0002020C
-#define OID_GEN_RCV_CRC_ERROR		0x0002020D
+#define OID_GEN_RCV_CRC_ERROR			0x0002020D
 #define OID_GEN_TRANSMIT_QUEUE_LENGTH	0x0002020E
 
-#define OID_802_3_PERMANENT_ADDRESS	0x01010101
-#define OID_802_3_CURRENT_ADDRESS	0x01010102
-/* #define OID_802_3_MULTICAST_LIST	0x01010103 */
+#define OID_802_3_PERMANENT_ADDRESS		0x01010101
+#define OID_802_3_CURRENT_ADDRESS		0x01010102
+/* #define OID_802_3_MULTICAST_LIST		0x01010103 */
 /* #define OID_802_3_MAXIMUM_LIST_SIZE	0x01010104 */
-/* #define OID_802_3_MAC_OPTIONS	0x01010105 */
+/* #define OID_802_3_MAC_OPTIONS		0x01010105 */
 			
 #define OID_802_3_RCV_ERROR_ALIGNMENT	0x01020101
 #define OID_802_3_XMIT_ONE_COLLISION	0x01020102
 #define OID_802_3_XMIT_MORE_COLLISIONS	0x01020103
-#define OID_802_3_XMIT_DEFERRED		0x01020201
+#define OID_802_3_XMIT_DEFERRED			0x01020201
 #define OID_802_3_XMIT_MAX_COLLISIONS	0x01020202
-#define OID_802_3_RCV_OVERRUN		0x01020203
-#define OID_802_3_XMIT_UNDERRUN		0x01020204
+#define OID_802_3_RCV_OVERRUN			0x01020203
+#define OID_802_3_XMIT_UNDERRUN			0x01020204
 #define OID_802_3_XMIT_TIMES_CRS_LOST	0x01020206
 #define OID_802_3_XMIT_LATE_COLLISIONS	0x01020207
 
+/*
+ * PnP and PM OIDs
+ */
+#ifdef SK_POWER_MGMT
+#define OID_PNP_CAPABILITIES			0xFD010100
+#define OID_PNP_SET_POWER				0xFD010101
+#define OID_PNP_QUERY_POWER				0xFD010102
+#define OID_PNP_ADD_WAKE_UP_PATTERN		0xFD010103
+#define OID_PNP_REMOVE_WAKE_UP_PATTERN	0xFD010104
+#define OID_PNP_ENABLE_WAKE_UP			0xFD010106
+#endif /* SK_POWER_MGMT */
+
 #endif /* _NDIS_ */
 
-#define OID_SKGE_MDB_VERSION		0xFF010100
-#define OID_SKGE_SUPPORTED_LIST		0xFF010101
-#define OID_SKGE_VPD_FREE_BYTES		0xFF010102
-#define OID_SKGE_VPD_ENTRIES_LIST	0xFF010103
-#define OID_SKGE_VPD_ENTRIES_NUMBER	0xFF010104
-#define OID_SKGE_VPD_KEY		0xFF010105
-#define OID_SKGE_VPD_VALUE		0xFF010106
-#define OID_SKGE_VPD_ACCESS		0xFF010107
-#define OID_SKGE_VPD_ACTION		0xFF010108
+#define OID_SKGE_MDB_VERSION			0xFF010100
+#define OID_SKGE_SUPPORTED_LIST			0xFF010101
+#define OID_SKGE_VPD_FREE_BYTES			0xFF010102
+#define OID_SKGE_VPD_ENTRIES_LIST		0xFF010103
+#define OID_SKGE_VPD_ENTRIES_NUMBER		0xFF010104
+#define OID_SKGE_VPD_KEY				0xFF010105
+#define OID_SKGE_VPD_VALUE				0xFF010106
+#define OID_SKGE_VPD_ACCESS				0xFF010107
+#define OID_SKGE_VPD_ACTION				0xFF010108
 			
-#define OID_SKGE_PORT_NUMBER		0xFF010110
-#define OID_SKGE_DEVICE_TYPE		0xFF010111
-#define OID_SKGE_DRIVER_DESCR		0xFF010112
-#define OID_SKGE_DRIVER_VERSION		0xFF010113
-#define OID_SKGE_HW_DESCR		0xFF010114
-#define OID_SKGE_HW_VERSION		0xFF010115
-#define OID_SKGE_CHIPSET		0xFF010116
-#define OID_SKGE_ACTION			0xFF010117
-#define OID_SKGE_RESULT			0xFF010118
-#define OID_SKGE_BUS_TYPE		0xFF010119
-#define OID_SKGE_BUS_SPEED		0xFF01011A
-#define OID_SKGE_BUS_WIDTH		0xFF01011B
-
-/*#define OID_SKGE_MULTICAST_LIST		0xFF01011C*/
-
-#define OID_SKGE_SENSOR_NUMBER		0xFF020100			
-#define OID_SKGE_SENSOR_INDEX		0xFF020101
-#define OID_SKGE_SENSOR_DESCR		0xFF020102
-#define OID_SKGE_SENSOR_TYPE		0xFF020103
-#define OID_SKGE_SENSOR_VALUE		0xFF020104
+#define OID_SKGE_PORT_NUMBER			0xFF010110
+#define OID_SKGE_DEVICE_TYPE			0xFF010111
+#define OID_SKGE_DRIVER_DESCR			0xFF010112
+#define OID_SKGE_DRIVER_VERSION			0xFF010113
+#define OID_SKGE_HW_DESCR				0xFF010114
+#define OID_SKGE_HW_VERSION				0xFF010115
+#define OID_SKGE_CHIPSET				0xFF010116
+#define OID_SKGE_ACTION					0xFF010117
+#define OID_SKGE_RESULT					0xFF010118
+#define OID_SKGE_BUS_TYPE				0xFF010119
+#define OID_SKGE_BUS_SPEED				0xFF01011A
+#define OID_SKGE_BUS_WIDTH				0xFF01011B
+/* 0xFF01011C unused */
+#define OID_SKGE_DIAG_ACTION			0xFF01011D
+#define OID_SKGE_DIAG_RESULT			0xFF01011E
+#define OID_SKGE_MTU					0xFF01011F
+#define OID_SKGE_PHYS_CUR_ADDR			0xFF010120
+#define OID_SKGE_PHYS_FAC_ADDR			0xFF010121
+#define OID_SKGE_PMD					0xFF010122
+#define OID_SKGE_CONNECTOR				0xFF010123
+#define OID_SKGE_LINK_CAP				0xFF010124
+#define OID_SKGE_LINK_MODE				0xFF010125
+#define OID_SKGE_LINK_MODE_STATUS		0xFF010126
+#define OID_SKGE_LINK_STATUS			0xFF010127
+#define OID_SKGE_FLOWCTRL_CAP			0xFF010128
+#define OID_SKGE_FLOWCTRL_MODE			0xFF010129
+#define OID_SKGE_FLOWCTRL_STATUS		0xFF01012A
+#define OID_SKGE_PHY_OPERATION_CAP		0xFF01012B
+#define OID_SKGE_PHY_OPERATION_MODE		0xFF01012C
+#define OID_SKGE_PHY_OPERATION_STATUS	0xFF01012D
+#define OID_SKGE_MULTICAST_LIST			0xFF01012E
+#define OID_SKGE_CURRENT_PACKET_FILTER	0xFF01012F
+
+#define OID_SKGE_TRAP					0xFF010130
+#define OID_SKGE_TRAP_NUMBER			0xFF010131
+
+#define OID_SKGE_RLMT_MODE				0xFF010140
+#define OID_SKGE_RLMT_PORT_NUMBER		0xFF010141
+#define OID_SKGE_RLMT_PORT_ACTIVE		0xFF010142
+#define OID_SKGE_RLMT_PORT_PREFERRED	0xFF010143
+#define OID_SKGE_INTERMEDIATE_SUPPORT	0xFF010160
+
+#define OID_SKGE_SPEED_CAP				0xFF010170
+#define OID_SKGE_SPEED_MODE				0xFF010171
+#define OID_SKGE_SPEED_STATUS			0xFF010172
+
+#define OID_SKGE_SENSOR_NUMBER			0xFF020100			
+#define OID_SKGE_SENSOR_INDEX			0xFF020101
+#define OID_SKGE_SENSOR_DESCR			0xFF020102
+#define OID_SKGE_SENSOR_TYPE			0xFF020103
+#define OID_SKGE_SENSOR_VALUE			0xFF020104
 #define OID_SKGE_SENSOR_WAR_THRES_LOW	0xFF020105
 #define OID_SKGE_SENSOR_WAR_THRES_UPP	0xFF020106
 #define OID_SKGE_SENSOR_ERR_THRES_LOW	0xFF020107
 #define OID_SKGE_SENSOR_ERR_THRES_UPP	0xFF020108
-#define OID_SKGE_SENSOR_STATUS		0xFF020109
-#define OID_SKGE_SENSOR_WAR_CTS		0xFF02010A
-#define OID_SKGE_SENSOR_ERR_CTS		0xFF02010B
-#define OID_SKGE_SENSOR_WAR_TIME	0xFF02010C
-#define OID_SKGE_SENSOR_ERR_TIME	0xFF02010D
+#define OID_SKGE_SENSOR_STATUS			0xFF020109
+#define OID_SKGE_SENSOR_WAR_CTS			0xFF02010A
+#define OID_SKGE_SENSOR_ERR_CTS			0xFF02010B
+#define OID_SKGE_SENSOR_WAR_TIME		0xFF02010C
+#define OID_SKGE_SENSOR_ERR_TIME		0xFF02010D
 
-#define OID_SKGE_CHKSM_NUMBER		0xFF020110
-#define OID_SKGE_CHKSM_RX_OK_CTS	0xFF020111
+#define OID_SKGE_CHKSM_NUMBER			0xFF020110
+#define OID_SKGE_CHKSM_RX_OK_CTS		0xFF020111
 #define OID_SKGE_CHKSM_RX_UNABLE_CTS	0xFF020112
-#define OID_SKGE_CHKSM_RX_ERR_CTS	0xFF020113
-#define OID_SKGE_CHKSM_TX_OK_CTS	0xFF020114
+#define OID_SKGE_CHKSM_RX_ERR_CTS		0xFF020113
+#define OID_SKGE_CHKSM_TX_OK_CTS		0xFF020114
 #define OID_SKGE_CHKSM_TX_UNABLE_CTS	0xFF020115
 
-#define OID_SKGE_STAT_TX		0xFF020120
-#define OID_SKGE_STAT_TX_OCTETS		0xFF020121
-#define OID_SKGE_STAT_TX_BROADCAST	0xFF020122
-#define OID_SKGE_STAT_TX_MULTICAST	0xFF020123
-#define OID_SKGE_STAT_TX_UNICAST	0xFF020124
-#define OID_SKGE_STAT_TX_LONGFRAMES	0xFF020125
-#define OID_SKGE_STAT_TX_BURST		0xFF020126
-#define OID_SKGE_STAT_TX_PFLOWC		0xFF020127
-#define OID_SKGE_STAT_TX_FLOWC		0xFF020128
-#define OID_SKGE_STAT_TX_SINGLE_COL	0xFF020129
-#define OID_SKGE_STAT_TX_MULTI_COL	0xFF02012A
-#define OID_SKGE_STAT_TX_EXCESS_COL	0xFF02012B
-#define OID_SKGE_STAT_TX_LATE_COL	0xFF02012C
-#define OID_SKGE_STAT_TX_DEFFERAL	0xFF02012D
-#define OID_SKGE_STAT_TX_EXCESS_DEF	0xFF02012E
-#define OID_SKGE_STAT_TX_UNDERRUN	0xFF02012F
-#define OID_SKGE_STAT_TX_CARRIER	0xFF020130
+#define OID_SKGE_STAT_TX				0xFF020120
+#define OID_SKGE_STAT_TX_OCTETS			0xFF020121
+#define OID_SKGE_STAT_TX_BROADCAST		0xFF020122
+#define OID_SKGE_STAT_TX_MULTICAST		0xFF020123
+#define OID_SKGE_STAT_TX_UNICAST		0xFF020124
+#define OID_SKGE_STAT_TX_LONGFRAMES		0xFF020125
+#define OID_SKGE_STAT_TX_BURST			0xFF020126
+#define OID_SKGE_STAT_TX_PFLOWC			0xFF020127
+#define OID_SKGE_STAT_TX_FLOWC			0xFF020128
+#define OID_SKGE_STAT_TX_SINGLE_COL		0xFF020129
+#define OID_SKGE_STAT_TX_MULTI_COL		0xFF02012A
+#define OID_SKGE_STAT_TX_EXCESS_COL		0xFF02012B
+#define OID_SKGE_STAT_TX_LATE_COL		0xFF02012C
+#define OID_SKGE_STAT_TX_DEFFERAL		0xFF02012D
+#define OID_SKGE_STAT_TX_EXCESS_DEF		0xFF02012E
+#define OID_SKGE_STAT_TX_UNDERRUN		0xFF02012F
+#define OID_SKGE_STAT_TX_CARRIER		0xFF020130
 /* #define OID_SKGE_STAT_TX_UTIL		0xFF020131 */
-#define OID_SKGE_STAT_TX_64		0xFF020132
-#define OID_SKGE_STAT_TX_127		0xFF020133
-#define OID_SKGE_STAT_TX_255		0xFF020134
-#define OID_SKGE_STAT_TX_511		0xFF020135
-#define OID_SKGE_STAT_TX_1023		0xFF020136
-#define OID_SKGE_STAT_TX_MAX		0xFF020137
-#define OID_SKGE_STAT_TX_SYNC		0xFF020138
+#define OID_SKGE_STAT_TX_64				0xFF020132
+#define OID_SKGE_STAT_TX_127			0xFF020133
+#define OID_SKGE_STAT_TX_255			0xFF020134
+#define OID_SKGE_STAT_TX_511			0xFF020135
+#define OID_SKGE_STAT_TX_1023			0xFF020136
+#define OID_SKGE_STAT_TX_MAX			0xFF020137
+#define OID_SKGE_STAT_TX_SYNC			0xFF020138
 #define OID_SKGE_STAT_TX_SYNC_OCTETS	0xFF020139
-#define OID_SKGE_STAT_RX		0xFF02013A
-#define OID_SKGE_STAT_RX_OCTETS		0xFF02013B
-#define OID_SKGE_STAT_RX_BROADCAST	0xFF02013C
-#define OID_SKGE_STAT_RX_MULTICAST	0xFF02013D
-#define OID_SKGE_STAT_RX_UNICAST	0xFF02013E
-#define OID_SKGE_STAT_RX_PFLOWC		0xFF02013F
-#define OID_SKGE_STAT_RX_FLOWC		0xFF020140
-#define OID_SKGE_STAT_RX_PFLOWC_ERR	0xFF020141
+#define OID_SKGE_STAT_RX				0xFF02013A
+#define OID_SKGE_STAT_RX_OCTETS			0xFF02013B
+#define OID_SKGE_STAT_RX_BROADCAST		0xFF02013C
+#define OID_SKGE_STAT_RX_MULTICAST		0xFF02013D
+#define OID_SKGE_STAT_RX_UNICAST		0xFF02013E
+#define OID_SKGE_STAT_RX_PFLOWC			0xFF02013F
+#define OID_SKGE_STAT_RX_FLOWC			0xFF020140
+#define OID_SKGE_STAT_RX_PFLOWC_ERR		0xFF020141
 #define OID_SKGE_STAT_RX_FLOWC_UNKWN	0xFF020142
-#define OID_SKGE_STAT_RX_BURST		0xFF020143
-#define OID_SKGE_STAT_RX_MISSED		0xFF020144
-#define OID_SKGE_STAT_RX_FRAMING	0xFF020145
-#define OID_SKGE_STAT_RX_OVERFLOW	0xFF020146
-#define OID_SKGE_STAT_RX_JABBER		0xFF020147
-#define OID_SKGE_STAT_RX_CARRIER	0xFF020148
-#define OID_SKGE_STAT_RX_IR_LENGTH	0xFF020149
-#define OID_SKGE_STAT_RX_SYMBOL		0xFF02014A
-#define OID_SKGE_STAT_RX_SHORTS		0xFF02014B
-#define OID_SKGE_STAT_RX_RUNT		0xFF02014C
-#define OID_SKGE_STAT_RX_CEXT		0xFF02014D
-#define OID_SKGE_STAT_RX_TOO_LONG	0xFF02014E
-#define OID_SKGE_STAT_RX_FCS		0xFF02014F
+#define OID_SKGE_STAT_RX_BURST			0xFF020143
+#define OID_SKGE_STAT_RX_MISSED			0xFF020144
+#define OID_SKGE_STAT_RX_FRAMING		0xFF020145
+#define OID_SKGE_STAT_RX_OVERFLOW		0xFF020146
+#define OID_SKGE_STAT_RX_JABBER			0xFF020147
+#define OID_SKGE_STAT_RX_CARRIER		0xFF020148
+#define OID_SKGE_STAT_RX_IR_LENGTH		0xFF020149
+#define OID_SKGE_STAT_RX_SYMBOL			0xFF02014A
+#define OID_SKGE_STAT_RX_SHORTS			0xFF02014B
+#define OID_SKGE_STAT_RX_RUNT			0xFF02014C
+#define OID_SKGE_STAT_RX_CEXT			0xFF02014D
+#define OID_SKGE_STAT_RX_TOO_LONG		0xFF02014E
+#define OID_SKGE_STAT_RX_FCS			0xFF02014F
 /* #define OID_SKGE_STAT_RX_UTIL		0xFF020150 */
-#define OID_SKGE_STAT_RX_64		0xFF020151
-#define OID_SKGE_STAT_RX_127		0xFF020152
-#define OID_SKGE_STAT_RX_255		0xFF020153
-#define OID_SKGE_STAT_RX_511		0xFF020154
-#define OID_SKGE_STAT_RX_1023		0xFF020155
-#define OID_SKGE_STAT_RX_MAX		0xFF020156
-#define OID_SKGE_STAT_RX_LONGFRAMES	0xFF020157
-
-#define OID_SKGE_DIAG_ACTION		0xFF01011D
-#define OID_SKGE_DIAG_RESULT		0xFF01011E
-#define OID_SKGE_MTU		0xFF01011F
-#define OID_SKGE_PHYS_CUR_ADDR		0xFF010120
-#define OID_SKGE_PHYS_FAC_ADDR		0xFF010121
-#define OID_SKGE_PMD			0xFF010122
-#define OID_SKGE_CONNECTOR		0xFF010123
-#define OID_SKGE_LINK_CAP		0xFF010124
-#define OID_SKGE_LINK_MODE		0xFF010125
-#define OID_SKGE_LINK_MODE_STATUS	0xFF010126
-#define OID_SKGE_LINK_STATUS		0xFF010127
-#define OID_SKGE_FLOWCTRL_CAP		0xFF010128
-#define OID_SKGE_FLOWCTRL_MODE		0xFF010129
-#define OID_SKGE_FLOWCTRL_STATUS	0xFF01012A
-#define OID_SKGE_PHY_OPERATION_CAP	0xFF01012B
-#define OID_SKGE_PHY_OPERATION_MODE	0xFF01012C
-#define OID_SKGE_PHY_OPERATION_STATUS	0xFF01012D
-#define OID_SKGE_MULTICAST_LIST		0xFF01012E
-#define OID_SKGE_CURRENT_PACKET_FILTER		0xFF01012F
-
-#define OID_SKGE_TRAP			0xFF010130
-#define OID_SKGE_TRAP_NUMBER		0xFF010131
-
-#define OID_SKGE_RLMT_MODE		0xFF010140
-#define OID_SKGE_RLMT_PORT_NUMBER	0xFF010141
-#define OID_SKGE_RLMT_PORT_ACTIVE	0xFF010142
-#define OID_SKGE_RLMT_PORT_PREFERRED	0xFF010143
-#define OID_SKGE_INTERMEDIATE_SUPPORT		0xFF010160
-#define OID_SKGE_RLMT_CHANGE_CTS	0xFF020160
-#define OID_SKGE_RLMT_CHANGE_TIME	0xFF020161
-#define OID_SKGE_RLMT_CHANGE_ESTIM	0xFF020162
-#define OID_SKGE_RLMT_CHANGE_THRES	0xFF020163
-
-#define OID_SKGE_RLMT_PORT_INDEX	0xFF020164
-#define OID_SKGE_RLMT_STATUS		0xFF020165
-#define OID_SKGE_RLMT_TX_HELLO_CTS	0xFF020166
-#define OID_SKGE_RLMT_RX_HELLO_CTS	0xFF020167
-#define OID_SKGE_RLMT_TX_SP_REQ_CTS	0xFF020168
-#define OID_SKGE_RLMT_RX_SP_CTS		0xFF020169
+#define OID_SKGE_STAT_RX_64				0xFF020151
+#define OID_SKGE_STAT_RX_127			0xFF020152
+#define OID_SKGE_STAT_RX_255			0xFF020153
+#define OID_SKGE_STAT_RX_511			0xFF020154
+#define OID_SKGE_STAT_RX_1023			0xFF020155
+#define OID_SKGE_STAT_RX_MAX			0xFF020156
+#define OID_SKGE_STAT_RX_LONGFRAMES		0xFF020157
+
+#define OID_SKGE_RLMT_CHANGE_CTS		0xFF020160
+#define OID_SKGE_RLMT_CHANGE_TIME		0xFF020161
+#define OID_SKGE_RLMT_CHANGE_ESTIM		0xFF020162
+#define OID_SKGE_RLMT_CHANGE_THRES		0xFF020163
+
+#define OID_SKGE_RLMT_PORT_INDEX		0xFF020164
+#define OID_SKGE_RLMT_STATUS			0xFF020165
+#define OID_SKGE_RLMT_TX_HELLO_CTS		0xFF020166
+#define OID_SKGE_RLMT_RX_HELLO_CTS		0xFF020167
+#define OID_SKGE_RLMT_TX_SP_REQ_CTS		0xFF020168
+#define OID_SKGE_RLMT_RX_SP_CTS			0xFF020169
 
 #define OID_SKGE_RLMT_MONITOR_NUMBER	0xFF010150
-#define OID_SKGE_RLMT_MONITOR_INDEX	0xFF010151
-#define OID_SKGE_RLMT_MONITOR_ADDR	0xFF010152
-#define OID_SKGE_RLMT_MONITOR_ERRS	0xFF010153
+#define OID_SKGE_RLMT_MONITOR_INDEX		0xFF010151
+#define OID_SKGE_RLMT_MONITOR_ADDR		0xFF010152
+#define OID_SKGE_RLMT_MONITOR_ERRS		0xFF010153
 #define OID_SKGE_RLMT_MONITOR_TIMESTAMP	0xFF010154
-#define OID_SKGE_RLMT_MONITOR_ADMIN	0xFF010155
+#define OID_SKGE_RLMT_MONITOR_ADMIN		0xFF010155
 
-#define OID_SKGE_TX_SW_QUEUE_LEN	0xFF020170
-#define OID_SKGE_TX_SW_QUEUE_MAX	0xFF020171
-#define OID_SKGE_TX_RETRY		0xFF020172
-#define OID_SKGE_RX_INTR_CTS		0xFF020173
-#define OID_SKGE_TX_INTR_CTS		0xFF020174
-#define OID_SKGE_RX_NO_BUF_CTS		0xFF020175
-#define OID_SKGE_TX_NO_BUF_CTS		0xFF020176
-#define OID_SKGE_TX_USED_DESCR_NO	0xFF020177
-#define OID_SKGE_RX_DELIVERED_CTS	0xFF020178
+#define OID_SKGE_TX_SW_QUEUE_LEN		0xFF020170
+#define OID_SKGE_TX_SW_QUEUE_MAX		0xFF020171
+#define OID_SKGE_TX_RETRY				0xFF020172
+#define OID_SKGE_RX_INTR_CTS			0xFF020173
+#define OID_SKGE_TX_INTR_CTS			0xFF020174
+#define OID_SKGE_RX_NO_BUF_CTS			0xFF020175
+#define OID_SKGE_TX_NO_BUF_CTS			0xFF020176
+#define OID_SKGE_TX_USED_DESCR_NO		0xFF020177
+#define OID_SKGE_RX_DELIVERED_CTS		0xFF020178
 #define OID_SKGE_RX_OCTETS_DELIV_CTS	0xFF020179
-#define OID_SKGE_RX_HW_ERROR_CTS	0xFF02017A
-#define OID_SKGE_TX_HW_ERROR_CTS	0xFF02017B
-#define OID_SKGE_IN_ERRORS_CTS		0xFF02017C
-#define OID_SKGE_OUT_ERROR_CTS		0xFF02017D
-#define OID_SKGE_ERR_RECOVERY_CTS	0xFF02017E
-#define OID_SKGE_SYSUPTIME		0xFF02017F
-
-#define OID_SKGE_ALL_DATA		0xFF020190
-
-
-#define	OID_SKGE_TRAP_SEN_WAR_LOW	500
-#define OID_SKGE_TRAP_SEN_WAR_UPP	501
-#define	OID_SKGE_TRAP_SEN_ERR_LOW	502
-#define OID_SKGE_TRAP_SEN_ERR_UPP	503
+#define OID_SKGE_RX_HW_ERROR_CTS		0xFF02017A
+#define OID_SKGE_TX_HW_ERROR_CTS		0xFF02017B
+#define OID_SKGE_IN_ERRORS_CTS			0xFF02017C
+#define OID_SKGE_OUT_ERROR_CTS			0xFF02017D
+#define OID_SKGE_ERR_RECOVERY_CTS		0xFF02017E
+#define OID_SKGE_SYSUPTIME				0xFF02017F
+
+#define OID_SKGE_ALL_DATA				0xFF020190
+
+/* Defines for VCT. */
+#define OID_SKGE_VCT_GET			0xFF020200
+#define OID_SKGE_VCT_SET			0xFF020201
+#define OID_SKGE_VCT_STATUS			0xFF020202
+
+
+/* VCT struct to store a backup copy of VCT data after a port reset. */
+typedef struct s_PnmiVct {
+	SK_U8			VctStatus;
+	SK_U8			PCableLen;
+	SK_U32			PMdiPairLen[4];
+	SK_U8			PMdiPairSts[4];
+} SK_PNMI_VCT;
+
+
+/* VCT status values (to be given to CPA via OID_SKGE_VCT_STATUS). */
+#define SK_PNMI_VCT_NONE		0
+#define SK_PNMI_VCT_OLD_VCT_DATA	1
+#define SK_PNMI_VCT_NEW_VCT_DATA	2
+#define SK_PNMI_VCT_OLD_DSP_DATA	4
+#define SK_PNMI_VCT_NEW_DSP_DATA	8
+#define SK_PNMI_VCT_RUNNING		16
+
+
+/* VCT cable test status. */
+#define SK_PNMI_VCT_NORMAL_CABLE		0
+#define SK_PNMI_VCT_SHORT_CABLE			1
+#define SK_PNMI_VCT_OPEN_CABLE			2
+#define SK_PNMI_VCT_TEST_FAIL			3
+#define SK_PNMI_VCT_IMPEDANCE_MISMATCH		4
+
+#define	OID_SKGE_TRAP_SEN_WAR_LOW		500
+#define OID_SKGE_TRAP_SEN_WAR_UPP		501
+#define	OID_SKGE_TRAP_SEN_ERR_LOW		502
+#define OID_SKGE_TRAP_SEN_ERR_UPP		503
 #define OID_SKGE_TRAP_RLMT_CHANGE_THRES	520
 #define OID_SKGE_TRAP_RLMT_CHANGE_PORT	521
 #define OID_SKGE_TRAP_RLMT_PORT_DOWN	522
-#define OID_SKGE_TRAP_RLMT_PORT_UP	523
+#define OID_SKGE_TRAP_RLMT_PORT_UP		523
 #define OID_SKGE_TRAP_RLMT_SEGMENTATION	524
 
 
@@ -539,7 +627,7 @@
 #define SK_PNMI_ERR012		(SK_ERRBASE_PNMI + 12)
 #define SK_PNMI_ERR012MSG	"SensorStat: Unknown OID"
 #define SK_PNMI_ERR013		(SK_ERRBASE_PNMI + 13)
-#define SK_PNMI_ERR013MSG	"SensorStat: Unknown OID should be errored before"
+#define SK_PNMI_ERR013MSG	""
 #define SK_PNMI_ERR014		(SK_ERRBASE_PNMI + 14)
 #define SK_PNMI_ERR014MSG	"Vpd: Cannot read VPD keys"
 #define SK_PNMI_ERR015		(SK_ERRBASE_PNMI + 15)
@@ -583,7 +671,7 @@
 #define SK_PNMI_ERR035		(SK_ERRBASE_PNMI + 35)
 #define SK_PNMI_ERR035MSG	"Rlmt: Unknown OID"
 #define SK_PNMI_ERR036		(SK_ERRBASE_PNMI + 36)
-#define SK_PNMI_ERR036MSG	"Rlmt: Unknown OID should be errored before"
+#define SK_PNMI_ERR036MSG	""
 #define SK_PNMI_ERR037		(SK_ERRBASE_PNMI + 37)
 #define SK_PNMI_ERR037MSG	"Rlmt: SK_RLMT_MODE_CHANGE event return not 0"
 #define SK_PNMI_ERR038		(SK_ERRBASE_PNMI + 38)
@@ -591,17 +679,17 @@
 #define SK_PNMI_ERR039		(SK_ERRBASE_PNMI + 39)
 #define SK_PNMI_ERR039MSG	"RlmtStat: Unknown OID"
 #define SK_PNMI_ERR040		(SK_ERRBASE_PNMI + 40)
-#define SK_PNMI_ERR040MSG	"RlmtStat: Unknown OID should be errored before"
+#define SK_PNMI_ERR040MSG	"PowerManagement: Unknown OID"
 #define SK_PNMI_ERR041		(SK_ERRBASE_PNMI + 41)
 #define SK_PNMI_ERR041MSG	"MacPrivateConf: Unknown OID"
 #define SK_PNMI_ERR042		(SK_ERRBASE_PNMI + 42)
-#define SK_PNMI_ERR042MSG	"MacPrivateConf: Unknown OID should be errored before"
+#define SK_PNMI_ERR042MSG	"MacPrivateConf: SK_HWEV_SET_ROLE returned not 0"
 #define SK_PNMI_ERR043		(SK_ERRBASE_PNMI + 43)
 #define SK_PNMI_ERR043MSG	"MacPrivateConf: SK_HWEV_SET_LMODE returned not 0"
 #define SK_PNMI_ERR044		(SK_ERRBASE_PNMI + 44)
 #define SK_PNMI_ERR044MSG	"MacPrivateConf: SK_HWEV_SET_FLOWMODE returned not 0"
 #define SK_PNMI_ERR045		(SK_ERRBASE_PNMI + 45)
-#define SK_PNMI_ERR045MSG	"MacPrivateConf: Unknown OID in set action"
+#define SK_PNMI_ERR045MSG	"MacPrivateConf: SK_HWEV_SET_SPEED returned not 0"
 #define SK_PNMI_ERR046		(SK_ERRBASE_PNMI + 46)
 #define SK_PNMI_ERR046MSG	"Monitor: Unknown OID"
 #define SK_PNMI_ERR047		(SK_ERRBASE_PNMI + 47)
@@ -609,13 +697,13 @@
 #define SK_PNMI_ERR048		(SK_ERRBASE_PNMI + 48)
 #define SK_PNMI_ERR048MSG	"RlmtUpdate: Event function returns not 0"
 #define SK_PNMI_ERR049		(SK_ERRBASE_PNMI + 49)
-#define SK_PNMI_ERR049MSG	""
+#define SK_PNMI_ERR049MSG	"SkPnmiInit: Invalid size of 'CounterOffset' struct!!"
 #define SK_PNMI_ERR050		(SK_ERRBASE_PNMI + 50)
-#define SK_PNMI_ERR050MSG	"MacUpdate: Cannot update statistic counter"
+#define SK_PNMI_ERR050MSG	"SkPnmiInit: Invalid size of 'StatAddr' table!!"
 #define SK_PNMI_ERR051		(SK_ERRBASE_PNMI + 51)
 #define SK_PNMI_ERR051MSG	"SkPnmiEvent: Port switch suspicious"
 #define SK_PNMI_ERR052		(SK_ERRBASE_PNMI + 52)
-#define SK_PNMI_ERR052MSG	"MacPrivateConf: SK_HWEV_SET_ROLE returned not 0"
+#define SK_PNMI_ERR052MSG	""
 
 /*
  * Management counter macros called by the driver
@@ -659,7 +747,21 @@
 #define SK_PNMI_CNT_RX_LONGFRAMES(pAC,p) \
 	{ \
 		if ((p) < SK_MAX_MACS) { \
-			((pAC)->Pnmi.Port[p].StatRxLongFrameCts)++; \
+			((pAC)->Pnmi.Port[p].StatRxLongFrameCts++); \
+		} \
+	}
+
+#define SK_PNMI_CNT_RX_FRAMETOOLONG(pAC,p) \
+	{ \
+		if ((p) < SK_MAX_MACS) { \
+			((pAC)->Pnmi.Port[p].StatRxFrameTooLongCts++); \
+		} \
+	}
+
+#define SK_PNMI_CNT_RX_PMACC_ERR(pAC,p) \
+	{ \
+		if ((p) < SK_MAX_MACS) { \
+			((pAC)->Pnmi.Port[p].StatRxPMaccErr++); \
 		} \
 	}
 
@@ -685,12 +787,12 @@
 #define SK_PNMI_MULTICAST_LISTLEN	64
 #define SK_PNMI_SENSOR_ENTRIES		(SK_MAX_SENSORS)
 #define SK_PNMI_CHECKSUM_ENTRIES	3
-#define SK_PNMI_MAC_ENTRIES		(SK_MAX_MACS + 1)
+#define SK_PNMI_MAC_ENTRIES			(SK_MAX_MACS + 1)
 #define SK_PNMI_MONITOR_ENTRIES		20
 #define SK_PNMI_TRAP_ENTRIES		10
-#define SK_PNMI_TRAPLEN			128
-#define SK_PNMI_STRINGLEN1		80
-#define SK_PNMI_STRINGLEN2		25
+#define SK_PNMI_TRAPLEN				128
+#define SK_PNMI_STRINGLEN1			80
+#define SK_PNMI_STRINGLEN2			25
 #define SK_PNMI_TRAP_QUEUE_LEN		512
 
 typedef struct s_PnmiVpd {
@@ -798,6 +900,9 @@
 	SK_U8			ConfPhyOperationCapability;
 	SK_U8			ConfPhyOperationMode;
 	SK_U8			ConfPhyOperationStatus;
+	SK_U8			ConfSpeedCapability;
+	SK_U8			ConfSpeedMode;
+	SK_U8			ConfSpeedStatus;
 } SK_PNMI_CONF;
 
 typedef struct s_PnmiRlmt {
@@ -843,11 +948,11 @@
 	SK_U8			BusSpeed;
 	SK_U8			BusWidth;
 	SK_U8			SensorNumber;
-	SK_PNMI_SENSOR		Sensor[SK_PNMI_SENSOR_ENTRIES];
+	SK_PNMI_SENSOR	Sensor[SK_PNMI_SENSOR_ENTRIES];
 	SK_U8			ChecksumNumber;
 	SK_PNMI_CHECKSUM	Checksum[SK_PNMI_CHECKSUM_ENTRIES];
-	SK_PNMI_STAT		Stat[SK_PNMI_MAC_ENTRIES];
-	SK_PNMI_CONF		Conf[SK_PNMI_MAC_ENTRIES];
+	SK_PNMI_STAT	Stat[SK_PNMI_MAC_ENTRIES];
+	SK_PNMI_CONF	Conf[SK_PNMI_MAC_ENTRIES];
 	SK_U8			RlmtMode;
 	SK_U32			RlmtPortNumber;
 	SK_U8			RlmtPortActive;
@@ -856,7 +961,7 @@
 	SK_U64			RlmtChangeTime;
 	SK_U64			RlmtChangeEstimate;
 	SK_U64			RlmtChangeThreshold;
-	SK_PNMI_RLMT		Rlmt[SK_MAX_MACS];
+	SK_PNMI_RLMT	Rlmt[SK_MAX_MACS];
 	SK_U32			RlmtMonitorNumber;
 	SK_PNMI_RLMT_MONITOR	RlmtMonitor[SK_PNMI_MONITOR_ENTRIES];
 	SK_U32			TrapNumber;
@@ -882,25 +987,27 @@
 #define SK_PNMI_STRUCT_SIZE	(sizeof(SK_PNMI_STRUCT_DATA))
 #define SK_PNMI_MIN_STRUCT_SIZE	((unsigned int)(SK_UPTR)\
 				 &(((SK_PNMI_STRUCT_DATA *)0)->VpdFreeBytes))
-							/*
-							 * ReturnStatus field
-							 * must be located
-							 * before VpdFreeBytes
-							 */
+														/*
+														 * ReturnStatus field
+														 * must be located
+														 * before VpdFreeBytes
+														 */
 
 /*
  * Various definitions
  */
 #define SK_PNMI_MAX_PROTOS		3
 
-#define SK_PNMI_SCNT_NOT		64
-#define SK_PNMI_CNT_NO			67
+#define SK_PNMI_CNT_NO			66	/* Must have the value of the enum
+									 * SK_PNMI_MAX_IDX. Define SK_PNMI_CHECK
+									 * for check while init phase 1
+									 */
 
 /*
  * Estimate data structure
  */
 typedef struct s_PnmiEstimate {
-	unsigned int		EstValueIndex;
+	unsigned int	EstValueIndex;
 	SK_U64			EstValue[7];
 	SK_U64			Estimate;
 	SK_TIMER		EstTimer;
@@ -908,15 +1015,22 @@
 
 
 /*
- * PNMI specific adatper context structure
+ * VCT timer data structure
+ */
+typedef struct s_VctTimer {
+	SK_TIMER		VctTimer;
+} SK_PNMI_VCT_TIMER;
+
+
+/*
+ * PNMI specific adapter context structure
  */
 typedef struct s_PnmiPort {
-	SK_U32			CounterHigh[SK_PNMI_SCNT_NOT];
-	SK_U64			CounterOffset[SK_PNMI_CNT_NO];
 	SK_U64			StatSyncCts;
 	SK_U64			StatSyncOctetsCts;
 	SK_U64			StatRxLongFrameCts;
-	SK_BOOL			ActiveFlag;
+	SK_U64			StatRxFrameTooLongCts;
+	SK_U64			StatRxPMaccErr;
 	SK_U64			TxSwQueueLen;
 	SK_U64			TxSwQueueMax;
 	SK_U64			TxRetryCts;
@@ -932,41 +1046,53 @@
 	SK_U64			InErrorsCts;
 	SK_U64			OutErrorsCts;
 	SK_U64			ErrRecoveryCts;
+	SK_U64			RxShortZeroMark;
+	SK_U64			CounterOffset[SK_PNMI_CNT_NO];
+	SK_U32			CounterHigh[SK_PNMI_CNT_NO];
+	SK_BOOL			ActiveFlag;
+	SK_U8			Align[3];
 } SK_PNMI_PORT;
 
 
 typedef struct s_PnmiData {
-	SK_PNMI_PORT		Port[SK_MAX_MACS];
+	SK_PNMI_PORT	Port	[SK_MAX_MACS];
+	SK_PNMI_PORT	BufPort	[SK_MAX_MACS]; /* 2002-09-13 pweber  */
 	SK_U64			VirtualCounterOffset[SK_PNMI_CNT_NO];
 	SK_U32			TestResult;
 	char			HwVersion[10];
+	SK_U16			Align01;
 
 	char			*pDriverDescription;
 	char			*pDriverVersion;
 
-	char			TrapBuf[SK_PNMI_TRAP_QUEUE_LEN];
-	unsigned int		TrapBufFree;
-	unsigned int		TrapQueueBeg;
-	unsigned int		TrapQueueEnd;
-	unsigned int		TrapBufPad;
-	unsigned int		TrapUnique;
-
-	int			MacUpdatedFlag;
-	int			RlmtUpdatedFlag;
-	int			SirqUpdatedFlag;
+	int				MacUpdatedFlag;
+	int				RlmtUpdatedFlag;
+	int				SirqUpdatedFlag;
 
 	SK_U64			RlmtChangeCts;
 	SK_U64			RlmtChangeTime;
 	SK_PNMI_ESTIMATE	RlmtChangeEstimate;
 	SK_U64			RlmtChangeThreshold;
 
+	SK_U64			StartUpTime;
 	SK_U32			DeviceType;
 	char			PciBusSpeed;
 	char			PciBusWidth;
+	char			Chipset;
 	char			PMD;
 	char			Connector;
-	SK_U64			StartUpTime;
 	SK_BOOL			DualNetActiveFlag;
+	SK_U16			Align02;
+
+	char			TrapBuf[SK_PNMI_TRAP_QUEUE_LEN];
+	unsigned int	TrapBufFree;
+	unsigned int	TrapQueueBeg;
+	unsigned int	TrapQueueEnd;
+	unsigned int	TrapBufPad;
+	unsigned int	TrapUnique;
+	SK_U8		VctStatus[SK_MAX_MACS];
+	SK_PNMI_VCT	VctBackup[SK_MAX_MACS];
+	SK_PNMI_VCT_TIMER VctTimeout[SK_MAX_MACS];
 } SK_PNMI;
 
 
diff -ruN linux/drivers/net/sk98lin/h/skgesirq.h linuxn/drivers/net/sk98lin/h/skgesirq.h
--- linux/drivers/net/sk98lin/h/skgesirq.h	Wed Jul  4 20:50:39 2001
+++ linuxn/drivers/net/sk98lin/h/skgesirq.h	Tue May 20 12:17:41 2003
@@ -2,15 +2,16 @@
  *
  * Name:	skgesirq.h
  * Project:	GEnesis, PCI Gigabit Ethernet Adapter
- * Version:	$Revision: 1.22 $
- * Date:	$Date: 2000/11/09 11:30:10 $
+ * Version:	$Revision: 1.27 $
+ * Date:	$Date: 2003/03/31 07:32:34 $
  * Purpose:	SK specific Gigabit Ethernet special IRQ functions
  *
  ******************************************************************************/
 
 /******************************************************************************
  *
- *	(C)Copyright 1998-2000 SysKonnect GmbH.
+ *	(C)Copyright 1998-2002 SysKonnect.
+ *	(C)Copyright 2002-2003 Marvell.
  *
  *	This program is free software; you can redistribute it and/or modify
  *	it under the terms of the GNU General Public License as published by
@@ -25,6 +26,25 @@
  *
  * History:
  *	$Log: skgesirq.h,v $
+ *	Revision 1.27  2003/03/31 07:32:34  mkarl
+ *	Corrected Copyright.
+ *	Editorial changes.
+ *	
+ *	Revision 1.26  2002/10/14 09:52:36  rschmidt
+ *	Added SKERR_SIRQ_E023 and SKERR_SIRQ_E024 for GPHY (Yukon)
+ *	Editorial changes
+ *	
+ *	Revision 1.25  2002/07/15 18:15:52  rwahl
+ *	Editorial changes.
+ *	
+ *	Revision 1.24  2002/07/15 15:39:21  rschmidt
+ *	Corrected define for SKERR_SIRQ_E022
+ *	Editorial changes
+ *	
+ *	Revision 1.23  2002/04/25 11:09:45  rschmidt
+ *	Removed declarations for SkXmInitPhy(), SkXmRxTxEnable()
+ *	Editorial changes
+ *	
  *	Revision 1.22  2000/11/09 11:30:10  rassmann
  *	WA: Waiting after releasing reset until BCom chip is accessible.
  *	
@@ -66,7 +86,7 @@
  *	defined in skgeinit.h now.
  *
  *	Revision 1.9  1998/10/14 14:00:39  gklug
- *	add: eroor logs for init phys
+ *	add: error logs for init phys
  *	
  *	Revision 1.8  1998/10/14 05:44:05  gklug
  *	add: E020
@@ -103,73 +123,76 @@
 /*
  * Define the Event the special IRQ/INI module can handle
  */
-#define SK_HWEV_WATIM		1	/* Timeout for WA errata #2 XMAC */
-#define SK_HWEV_PORT_START	2	/* Port Start Event by RLMT */
-#define SK_HWEV_PORT_STOP	3	/* Port Stop Event by RLMT */
-#define SK_HWEV_CLEAR_STAT	4	/* Clear Statistics by PNMI */
-#define SK_HWEV_UPDATE_STAT	5	/* Update Statistics by PNMI */
-#define SK_HWEV_SET_LMODE	6	/* Set Link Mode by PNMI */
+#define SK_HWEV_WATIM			1	/* Timeout for WA Errata #2 XMAC */
+#define SK_HWEV_PORT_START		2	/* Port Start Event by RLMT */
+#define SK_HWEV_PORT_STOP		3	/* Port Stop Event by RLMT */
+#define SK_HWEV_CLEAR_STAT		4	/* Clear Statistics by PNMI */
+#define SK_HWEV_UPDATE_STAT		5	/* Update Statistics by PNMI */
+#define SK_HWEV_SET_LMODE		6	/* Set Link Mode by PNMI */
 #define SK_HWEV_SET_FLOWMODE	7	/* Set Flow Control Mode by PNMI */
-#define SK_HWEV_SET_ROLE	8	/* Set Master/Slave (Role) by PNMI */
-#define SK_HWEV_HALFDUP_CHK	9	/* Set Master/Slave (Role) by PNMI */
+#define SK_HWEV_SET_ROLE		8	/* Set Master/Slave (Role) by PNMI */
+#define SK_HWEV_SET_SPEED		9	/* Set Link Speed by PNMI */
+#define SK_HWEV_HALFDUP_CHK		10	/* Half Duplex Hangup Workaround */
 
-#define	SK_WA_ACT_TIME		(5000000L)	/* 5 sec */
-#define	SK_WA_INA_TIME		(100000L)	/* 100 msec */
+#define SK_WA_ACT_TIME		(5000000L)	/* 5 sec */
+#define SK_WA_INA_TIME		(100000L)	/* 100 msec */
 
-#define	SK_HALFDUP_CHK_TIME	(10000L)	/* 10 msec */
+#define SK_HALFDUP_CHK_TIME	(10000L)	/* 10 msec */
 
 /*
  * Define the error numbers and messages
  */
-#define	SKERR_SIRQ_E001		(SK_ERRBASE_SIRQ+0)
-#define	SKERR_SIRQ_E001MSG	"Unknown event"
-#define	SKERR_SIRQ_E002		(SKERR_SIRQ_E001+1)
-#define	SKERR_SIRQ_E002MSG	"Packet timeout RX1"
-#define	SKERR_SIRQ_E003		(SKERR_SIRQ_E002+1)
-#define	SKERR_SIRQ_E003MSG	"Packet timeout RX2"
-#define	SKERR_SIRQ_E004		(SKERR_SIRQ_E003+1)
-#define	SKERR_SIRQ_E004MSG	"XMAC 1 not correctly initialized"
-#define	SKERR_SIRQ_E005		(SKERR_SIRQ_E004+1)
-#define	SKERR_SIRQ_E005MSG	"XMAC 2 not correctly initialized"
-#define	SKERR_SIRQ_E006		(SKERR_SIRQ_E005+1)
-#define	SKERR_SIRQ_E006MSG	"CHECK failure R1"
-#define	SKERR_SIRQ_E007		(SKERR_SIRQ_E006+1)
-#define	SKERR_SIRQ_E007MSG	"CHECK failure R2"
-#define	SKERR_SIRQ_E008		(SKERR_SIRQ_E007+1)
-#define	SKERR_SIRQ_E008MSG	"CHECK failure XS1"
-#define	SKERR_SIRQ_E009		(SKERR_SIRQ_E008+1)
-#define	SKERR_SIRQ_E009MSG	"CHECK failure XA1"
-#define	SKERR_SIRQ_E010		(SKERR_SIRQ_E009+1)
-#define	SKERR_SIRQ_E010MSG	"CHECK failure XS2"
-#define	SKERR_SIRQ_E011		(SKERR_SIRQ_E010+1)
-#define	SKERR_SIRQ_E011MSG	"CHECK failure XA2"
-#define	SKERR_SIRQ_E012		(SKERR_SIRQ_E011+1)
-#define	SKERR_SIRQ_E012MSG	"unexpected IRQ Master error"
-#define	SKERR_SIRQ_E013		(SKERR_SIRQ_E012+1)
-#define	SKERR_SIRQ_E013MSG	"unexpected IRQ Status error"
-#define	SKERR_SIRQ_E014		(SKERR_SIRQ_E013+1)
-#define	SKERR_SIRQ_E014MSG	"Parity error on RAM (read)"
-#define	SKERR_SIRQ_E015		(SKERR_SIRQ_E014+1)
-#define	SKERR_SIRQ_E015MSG	"Parity error on RAM (write)"
-#define	SKERR_SIRQ_E016		(SKERR_SIRQ_E015+1)
-#define	SKERR_SIRQ_E016MSG	"Parity error MAC 1"
-#define	SKERR_SIRQ_E017		(SKERR_SIRQ_E016+1)
-#define	SKERR_SIRQ_E017MSG	"Parity error MAC 2"
-#define	SKERR_SIRQ_E018		(SKERR_SIRQ_E017+1)
-#define	SKERR_SIRQ_E018MSG	"Parity error RX 1"
-#define	SKERR_SIRQ_E019		(SKERR_SIRQ_E018+1)
-#define	SKERR_SIRQ_E019MSG	"Parity error RX 2"
-#define	SKERR_SIRQ_E020		(SKERR_SIRQ_E019+1)
-#define	SKERR_SIRQ_E020MSG	"XMAC transmit FIFO underrun"
-#define	SKERR_SIRQ_E021		(SKERR_SIRQ_E020+1)
-#define	SKERR_SIRQ_E021MSG	"Spurious I2C interrupt"
-#define	SKERR_SIRQ_E022		(SKERR_SIRQ_E020+1)
-#define	SKERR_SIRQ_E022MSG	"Cable pair swap error"
+#define SKERR_SIRQ_E001		(SK_ERRBASE_SIRQ+0)
+#define SKERR_SIRQ_E001MSG	"Unknown event"
+#define SKERR_SIRQ_E002		(SKERR_SIRQ_E001+1)
+#define SKERR_SIRQ_E002MSG	"Packet timeout RX1"
+#define SKERR_SIRQ_E003		(SKERR_SIRQ_E002+1)
+#define SKERR_SIRQ_E003MSG	"Packet timeout RX2"
+#define SKERR_SIRQ_E004		(SKERR_SIRQ_E003+1)
+#define SKERR_SIRQ_E004MSG	"MAC 1 not correctly initialized"
+#define SKERR_SIRQ_E005		(SKERR_SIRQ_E004+1)
+#define SKERR_SIRQ_E005MSG	"MAC 2 not correctly initialized"
+#define SKERR_SIRQ_E006		(SKERR_SIRQ_E005+1)
+#define SKERR_SIRQ_E006MSG	"CHECK failure R1"
+#define SKERR_SIRQ_E007		(SKERR_SIRQ_E006+1)
+#define SKERR_SIRQ_E007MSG	"CHECK failure R2"
+#define SKERR_SIRQ_E008		(SKERR_SIRQ_E007+1)
+#define SKERR_SIRQ_E008MSG	"CHECK failure XS1"
+#define SKERR_SIRQ_E009		(SKERR_SIRQ_E008+1)
+#define SKERR_SIRQ_E009MSG	"CHECK failure XA1"
+#define SKERR_SIRQ_E010		(SKERR_SIRQ_E009+1)
+#define SKERR_SIRQ_E010MSG	"CHECK failure XS2"
+#define SKERR_SIRQ_E011		(SKERR_SIRQ_E010+1)
+#define SKERR_SIRQ_E011MSG	"CHECK failure XA2"
+#define SKERR_SIRQ_E012		(SKERR_SIRQ_E011+1)
+#define SKERR_SIRQ_E012MSG	"unexpected IRQ Master error"
+#define SKERR_SIRQ_E013		(SKERR_SIRQ_E012+1)
+#define SKERR_SIRQ_E013MSG	"unexpected IRQ Status error"
+#define SKERR_SIRQ_E014		(SKERR_SIRQ_E013+1)
+#define SKERR_SIRQ_E014MSG	"Parity error on RAM (read)"
+#define SKERR_SIRQ_E015		(SKERR_SIRQ_E014+1)
+#define SKERR_SIRQ_E015MSG	"Parity error on RAM (write)"
+#define SKERR_SIRQ_E016		(SKERR_SIRQ_E015+1)
+#define SKERR_SIRQ_E016MSG	"Parity error MAC 1"
+#define SKERR_SIRQ_E017		(SKERR_SIRQ_E016+1)
+#define SKERR_SIRQ_E017MSG	"Parity error MAC 2"
+#define SKERR_SIRQ_E018		(SKERR_SIRQ_E017+1)
+#define SKERR_SIRQ_E018MSG	"Parity error RX 1"
+#define SKERR_SIRQ_E019		(SKERR_SIRQ_E018+1)
+#define SKERR_SIRQ_E019MSG	"Parity error RX 2"
+#define SKERR_SIRQ_E020		(SKERR_SIRQ_E019+1)
+#define SKERR_SIRQ_E020MSG	"MAC transmit FIFO underrun"
+#define SKERR_SIRQ_E021		(SKERR_SIRQ_E020+1)
+#define SKERR_SIRQ_E021MSG	"Spurious TWSI interrupt"
+#define SKERR_SIRQ_E022		(SKERR_SIRQ_E021+1)
+#define SKERR_SIRQ_E022MSG	"Cable pair swap error"
+#define SKERR_SIRQ_E023		(SKERR_SIRQ_E022+1)
+#define SKERR_SIRQ_E023MSG	"Auto-negotiation error"
+#define SKERR_SIRQ_E024		(SKERR_SIRQ_E023+1)
+#define SKERR_SIRQ_E024MSG	"FIFO overflow error"
 
 extern void SkGeSirqIsr(SK_AC *pAC, SK_IOC IoC, SK_U32 Istatus);
 extern int  SkGeSirqEvent(SK_AC *pAC, SK_IOC IoC, SK_U32 Event, SK_EVPARA Para);
-extern void SkXmInitPhy( SK_AC *pAC, SK_IOC IoC, int Port, SK_BOOL DoLoop);
-extern int  SkXmRxTxEnable(SK_AC *pAC, SK_IOC IoC, int Port);
 extern void SkHWLinkUp(SK_AC *pAC, SK_IOC IoC, int Port);
 extern void SkHWLinkDown(SK_AC *pAC, SK_IOC IoC, int Port);
 
diff -ruN linux/drivers/net/sk98lin/h/ski2c.h linuxn/drivers/net/sk98lin/h/ski2c.h
--- linux/drivers/net/sk98lin/h/ski2c.h	Wed Jul  4 20:50:39 2001
+++ linuxn/drivers/net/sk98lin/h/ski2c.h	Tue May 20 12:17:41 2003
@@ -2,17 +2,15 @@
  *
  * Name:	ski2c.h
  * Project:	GEnesis, PCI Gigabit Ethernet Adapter
- * Version:	$Revision: 1.30 $
- * Date:	$Date: 2001/04/05 11:38:09 $
+ * Version:	$Revision: 1.34 $
+ * Date:	$Date: 2003/01/28 09:11:21 $
  * Purpose:	Defines to access Voltage and Temperature Sensor
- *		(taken from Monalisa (taken from Concentrator))
  *
  ******************************************************************************/
 
 /******************************************************************************
  *
- *	(C)Copyright 1998,1999 SysKonnect,
- *	a business unit of Schneider & Koch & Co. Datensysteme GmbH.
+ *	(C)Copyright 1998-2003 SysKonnect GmbH.
  *
  *	This program is free software; you can redistribute it and/or modify
  *	it under the terms of the GNU General Public License as published by
@@ -28,6 +26,18 @@
  * History:
  *
  *	$Log: ski2c.h,v $
+ *	Revision 1.34  2003/01/28 09:11:21  rschmidt
+ *	Editorial changes
+ *	
+ *	Revision 1.33  2002/10/14 16:40:50  rschmidt
+ *	Editorial changes (TWSI)
+ *	
+ *	Revision 1.32  2002/08/13 08:55:07  rschmidt
+ *	Editorial changes
+ *	
+ *	Revision 1.31  2002/08/06 09:44:22  jschmalz
+ *	Extensions and changes for Yukon
+ *	
  *	Revision 1.30  2001/04/05 11:38:09  rassmann
  *	Set SenState to idle in SkI2cWaitIrq().
  *	Changed error message in SkI2cWaitIrq().
@@ -142,127 +152,131 @@
 #include "h/skgei2c.h"
 
 /*
- * Define the I2c events.
+ * Define the I2C events.
  */
 #define SK_I2CEV_IRQ	1	/* IRQ happened Event */
 #define SK_I2CEV_TIM	2	/* Timeout event */
-#define SK_I2CEV_CLEAR	3	/* Clear Mib Values */
+#define SK_I2CEV_CLEAR	3	/* Clear MIB Values */
 
 /*
  * Define READ and WRITE Constants.
  */
-#define	I2C_READ	0
-#define	I2C_WRITE	1
+#define I2C_READ	0
+#define I2C_WRITE	1
 #define I2C_BURST	1
-#define I2C_SIGLE	0
+#define I2C_SINGLE	0
 
-#define	SKERR_I2C_E001		(SK_ERRBASE_I2C+0)
-#define	SKERR_I2C_E001MSG	"Sensor index unknown"
-#define	SKERR_I2C_E002		(SKERR_I2C_E001+1)
-#define	SKERR_I2C_E002MSG	"I2C: transfer does not complete.\n"
-#define	SKERR_I2C_E003		(SKERR_I2C_E002+1)
-#define	SKERR_I2C_E003MSG	"lm80: NAK on device send.\n"
-#define	SKERR_I2C_E004		(SKERR_I2C_E003+1)
-#define	SKERR_I2C_E004MSG	"lm80: NAK on register send.\n"
-#define	SKERR_I2C_E005		(SKERR_I2C_E004+1)
-#define	SKERR_I2C_E005MSG	"lm80: NAK on device (2) send.\n"
-#define	SKERR_I2C_E006		(SKERR_I2C_E005+1)
-#define	SKERR_I2C_E006MSG	"Unknown event"
-#define	SKERR_I2C_E007		(SKERR_I2C_E006+1)
-#define	SKERR_I2C_E007MSG	"LM80 read out of state"
-#define	SKERR_I2C_E008		(SKERR_I2C_E007+1)
-#define	SKERR_I2C_E008MSG	"unexpected sensor read completed"
-#define	SKERR_I2C_E009		(SKERR_I2C_E008+1)
-#define	SKERR_I2C_E009MSG	"WARNING: temperature sensor out of range"
-#define	SKERR_I2C_E010		(SKERR_I2C_E009+1)
-#define	SKERR_I2C_E010MSG	"WARNING: voltage sensor out of range"
-#define	SKERR_I2C_E011		(SKERR_I2C_E010+1)
-#define	SKERR_I2C_E011MSG	"ERROR: temperature sensor out of range"
-#define	SKERR_I2C_E012		(SKERR_I2C_E011+1)
-#define	SKERR_I2C_E012MSG	"ERROR: voltage sensor out of range"
-#define	SKERR_I2C_E013		(SKERR_I2C_E012+1)
-#define	SKERR_I2C_E013MSG	"ERROR: couldn't init sensor"
-#define	SKERR_I2C_E014		(SKERR_I2C_E013+1)
-#define	SKERR_I2C_E014MSG	"WARNING: fan sensor out of range"
-#define	SKERR_I2C_E015		(SKERR_I2C_E014+1)
-#define	SKERR_I2C_E015MSG	"ERROR: fan sensor out of range"
-#define	SKERR_I2C_E016		(SKERR_I2C_E015+1)
-#define	SKERR_I2C_E016MSG	"I2C: active transfer does not complete.\n"
+#define SKERR_I2C_E001		(SK_ERRBASE_I2C+0)
+#define SKERR_I2C_E001MSG	"Sensor index unknown"
+#define SKERR_I2C_E002		(SKERR_I2C_E001+1)
+#define SKERR_I2C_E002MSG	"TWSI: transfer does not complete"
+#define SKERR_I2C_E003		(SKERR_I2C_E002+1)
+#define SKERR_I2C_E003MSG	"LM80: NAK on device send"
+#define SKERR_I2C_E004		(SKERR_I2C_E003+1)
+#define SKERR_I2C_E004MSG	"LM80: NAK on register send"
+#define SKERR_I2C_E005		(SKERR_I2C_E004+1)
+#define SKERR_I2C_E005MSG	"LM80: NAK on device (2) send"
+#define SKERR_I2C_E006		(SKERR_I2C_E005+1)
+#define SKERR_I2C_E006MSG	"Unknown event"
+#define SKERR_I2C_E007		(SKERR_I2C_E006+1)
+#define SKERR_I2C_E007MSG	"LM80 read out of state"
+#define SKERR_I2C_E008		(SKERR_I2C_E007+1)
+#define SKERR_I2C_E008MSG	"Unexpected sensor read completed"
+#define SKERR_I2C_E009		(SKERR_I2C_E008+1)
+#define SKERR_I2C_E009MSG	"WARNING: temperature sensor out of range"
+#define SKERR_I2C_E010		(SKERR_I2C_E009+1)
+#define SKERR_I2C_E010MSG	"WARNING: voltage sensor out of range"
+#define SKERR_I2C_E011		(SKERR_I2C_E010+1)
+#define SKERR_I2C_E011MSG	"ERROR: temperature sensor out of range"
+#define SKERR_I2C_E012		(SKERR_I2C_E011+1)
+#define SKERR_I2C_E012MSG	"ERROR: voltage sensor out of range"
+#define SKERR_I2C_E013		(SKERR_I2C_E012+1)
+#define SKERR_I2C_E013MSG	"ERROR: couldn't init sensor"
+#define SKERR_I2C_E014		(SKERR_I2C_E013+1)
+#define SKERR_I2C_E014MSG	"WARNING: fan sensor out of range"
+#define SKERR_I2C_E015		(SKERR_I2C_E014+1)
+#define SKERR_I2C_E015MSG	"ERROR: fan sensor out of range"
+#define SKERR_I2C_E016		(SKERR_I2C_E015+1)
+#define SKERR_I2C_E016MSG	"TWSI: active transfer does not complete"
 
 /*
  * Define Timeout values
  */
-#define	SK_I2C_TIM_LONG		2000000L	/* 2 seconds */
-#define	SK_I2C_TIM_SHORT	 100000L	/* 100 milliseconds */
+#define SK_I2C_TIM_LONG		2000000L	/* 2 seconds */
+#define SK_I2C_TIM_SHORT	 100000L	/* 100 milliseconds */
+#define SK_I2C_TIM_WATCH	1000000L	/* 1 second */
 
 /*
  * Define trap and error log hold times
  */
 #ifndef	SK_SEN_ERR_TR_HOLD
-#define	SK_SEN_ERR_TR_HOLD		(4*SK_TICKS_PER_SEC)
+#define SK_SEN_ERR_TR_HOLD		(4*SK_TICKS_PER_SEC)
 #endif
 #ifndef	SK_SEN_ERR_LOG_HOLD
-#define	SK_SEN_ERR_LOG_HOLD		(60*SK_TICKS_PER_SEC)
+#define SK_SEN_ERR_LOG_HOLD		(60*SK_TICKS_PER_SEC)
 #endif
 #ifndef	SK_SEN_WARN_TR_HOLD
-#define	SK_SEN_WARN_TR_HOLD		(15*SK_TICKS_PER_SEC)
+#define SK_SEN_WARN_TR_HOLD		(15*SK_TICKS_PER_SEC)
 #endif
 #ifndef	SK_SEN_WARN_LOG_HOLD
-#define	SK_SEN_WARN_LOG_HOLD	(15*60*SK_TICKS_PER_SEC)
+#define SK_SEN_WARN_LOG_HOLD	(15*60*SK_TICKS_PER_SEC)
 #endif
 
 /*
  * Defines for SenType
  */
-#define	SK_SEN_TEMP	1
-#define	SK_SEN_VOLT	2
-#define	SK_SEN_FAN	3
+#define SK_SEN_UNKNOWN	0
+#define SK_SEN_TEMP		1
+#define SK_SEN_VOLT		2
+#define SK_SEN_FAN		3
 
 /*
- * Define for the ErrorFlag
+ * Define for the SenErrorFlag
  */
-#define	SK_SEN_ERR_OK	1	/* Error Flag: O.K. */
-#define	SK_SEN_ERR_WARN	2	/* Error Flag: Warning */
-#define	SK_SEN_ERR_ERR	3	/* Error Flag: Error */
+#define SK_SEN_ERR_NOT_PRESENT	0	/* Error Flag: Sensor not present */
+#define SK_SEN_ERR_OK			1	/* Error Flag: O.K. */
+#define SK_SEN_ERR_WARN			2	/* Error Flag: Warning */
+#define SK_SEN_ERR_ERR			3	/* Error Flag: Error */
+#define SK_SEN_ERR_FAULTY		4	/* Error Flag: Faulty */
 
 /*
  * Define the Sensor struct
  */
 struct	s_Sensor {
-	char	*SenDesc;	/* Description */
-	int	SenType;	/* Voltage or Temperature */
-	SK_I32	SenValue;	/* Current value of the sensor */
-	SK_I32	SenThreErrHigh;	/* High error Threshhold of this sensor */
-	SK_I32	SenThreWarnHigh;/* High warning Threshhold of this sensor */
-	SK_I32	SenThreErrLow;	/* Lower error Threshold of the sensor */
-	SK_I32	SenThreWarnLow;	/* Lower warning Threshold of the sensor */
-	int	SenErrFlag;	/* Sensor indicated an error */
-	SK_BOOL	SenInit;	/* Is sensor initialized? */
-	SK_U64	SenErrCts;	/* Error  trap counter */
-	SK_U64	SenWarnCts;	/* Warning trap  counter */
-	SK_U64	SenBegErrTS;	/* Begin error timestamp */
-	SK_U64	SenBegWarnTS;	/* Begin warning timestamp */
+	char	*SenDesc;			/* Description */
+	int		SenType;			/* Voltage or Temperature */
+	SK_I32	SenValue;			/* Current value of the sensor */
+	SK_I32	SenThreErrHigh;		/* High error Threshhold of this sensor */
+	SK_I32	SenThreWarnHigh;	/* High warning Threshhold of this sensor */
+	SK_I32	SenThreErrLow;		/* Lower error Threshold of the sensor */
+	SK_I32	SenThreWarnLow;		/* Lower warning Threshold of the sensor */
+	int		SenErrFlag;			/* Sensor indicated an error */
+	SK_BOOL	SenInit;			/* Is sensor initialized ? */
+	SK_U64	SenErrCts;			/* Error  trap counter */
+	SK_U64	SenWarnCts;			/* Warning trap counter */
+	SK_U64	SenBegErrTS;		/* Begin error timestamp */
+	SK_U64	SenBegWarnTS;		/* Begin warning timestamp */
 	SK_U64	SenLastErrTrapTS;	/* Last error trap timestamp */
 	SK_U64	SenLastErrLogTS;	/* Last error log timestamp */
 	SK_U64	SenLastWarnTrapTS;	/* Last warning trap timestamp */
 	SK_U64	SenLastWarnLogTS;	/* Last warning log timestamp */
-	int	SenState;	/* Sensor State (see HW specific include) */
-	int	(*SenRead)(SK_AC *pAC, SK_IOC IoC,struct s_Sensor *pSen) ;
-				/* Sensors read function */
-	SK_U16	SenReg;		/* Register Address for this sensor */
-	SK_U8	SenDev;		/* DeviceSelection for this sensor */
-} ;
-
+	int		SenState;			/* Sensor State (see HW specific include) */
+	int		(*SenRead)(SK_AC *pAC, SK_IOC IoC, struct s_Sensor *pSen);
+								/* Sensors read function */
+	SK_U16	SenReg;				/* Register Address for this sensor */
+	SK_U8	SenDev;				/* Device Selection for this sensor */
+};
 
 typedef	struct	s_I2c {
 	SK_SENSOR	SenTable[SK_MAX_SENSORS];	/* Sensor Table */
-	int		CurrSens;	/* Which sensor is currently queried */
-	int		MaxSens;	/* Max. number of sensors */
-	int		InitLevel;	/* Initialized Level */
+	int			CurrSens;	/* Which sensor is currently queried */
+	int			MaxSens;	/* Max. number of sensors */
+	int			TimerMode;	/* Use the timer also to watch the state machine */
+	int			InitLevel;	/* Initialized Level */
 #ifndef SK_DIAG
-	int		DummyReads;	/* Number of non-checked dummy reads */
+	int			DummyReads;	/* Number of non-checked dummy reads */
 	SK_TIMER	SenTimer;	/* Sensors timer */
-#endif	/* !SK_DIAG */
+#endif /* !SK_DIAG */
 } SK_I2C;
 
 extern int SkI2cReadSensor(SK_AC *pAC, SK_IOC IoC, SK_SENSOR *pSen);
@@ -273,5 +287,5 @@
 extern void SkI2cIsr(SK_AC *pAC, SK_IOC IoC);
 
 #endif
-#endif	/* n_SKI2C_H */
+#endif /* n_SKI2C_H */
 
diff -ruN linux/drivers/net/sk98lin/h/skqueue.h linuxn/drivers/net/sk98lin/h/skqueue.h
--- linux/drivers/net/sk98lin/h/skqueue.h	Wed Jul  4 20:50:39 2001
+++ linuxn/drivers/net/sk98lin/h/skqueue.h	Tue May 20 12:17:41 2003
@@ -1,32 +1,23 @@
 /******************************************************************************
  *
  * Name:	skqueue.h
- * Project:	Genesis, PCI Gigabit Ethernet Adapter
- * Version:	$Revision: 1.12 $
- * Date:	$Date: 1998/09/08 08:48:01 $
+ * Project:	GEnesis, PCI Gigabit Ethernet Adapter
+ * Version:	$Revision: 1.14 $
+ * Date:	$Date: 2002/03/15 10:52:13 $
  * Purpose:	Defines for the Event queue
  *
  ******************************************************************************/
 
 /******************************************************************************
  *
- *	(C)Copyright 1989-1998 SysKonnect,
+ *	(C)Copyright 1998,1999 SysKonnect,
  *	a business unit of Schneider & Koch & Co. Datensysteme GmbH.
- *	All Rights Reserved
  *
- *	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF SYSKONNECT
- *	The copyright notice above does not evidence any
- *	actual or intended publication of such source code.
- *
- *	This Module contains Proprietary Information of SysKonnect
- *	and should be treated as Confidential.
- *
- *	The information in this file is provided for the exclusive use of
- *	the licensees of SysKonnect.
- *	Such users have the right to use, modify, and incorporate this code
- *	into products for purposes authorized by the license agreement
- *	provided they include this notice and the associated copyright notice
- *	with any such product.
+ *	This program is free software; you can redistribute it and/or modify
+ *	it under the terms of the GNU General Public License as published by
+ *	the Free Software Foundation; either version 2 of the License, or
+ *	(at your option) any later version.
+ *
  *	The information in this file is provided "AS IS" without warranty.
  *
  ******************************************************************************/
@@ -36,6 +27,12 @@
  * History:
  *
  *	$Log: skqueue.h,v $
+ *	Revision 1.14  2002/03/15 10:52:13  mkunz
+ *	Added event classes for link aggregation
+ *	
+ *	Revision 1.13  1999/11/22 13:59:05  cgoos
+ *	Changed license header to GPL.
+ *	
  *	Revision 1.12  1998/09/08 08:48:01  gklug
  *	add: init level handling
  *	
@@ -97,6 +94,12 @@
 #define	SKGE_CSUM	5	/* Checksum Event Class */
 #define	SKGE_HWAC	6	/* Hardware Access Event Class */
 
+#define	SKGE_SWT	9	/* Software Timer Event Class */
+#define	SKGE_LACP	10	/* LACP Aggregation Event Class */
+#define	SKGE_RSF	11	/* RSF Aggregation Event Class */
+#define	SKGE_MARKER	12	/* MARKER Aggregation Event Class */
+#define	SKGE_FD		13	/* FD Distributor Event Class */
+
 /*
  * define event queue as circular buffer
  */
diff -ruN linux/drivers/net/sk98lin/h/skrlmt.h linuxn/drivers/net/sk98lin/h/skrlmt.h
--- linux/drivers/net/sk98lin/h/skrlmt.h	Wed Jul  4 20:50:39 2001
+++ linuxn/drivers/net/sk98lin/h/skrlmt.h	Tue May 20 12:17:41 2003
@@ -2,15 +2,16 @@
  *
  * Name:	skrlmt.h
  * Project:	GEnesis, PCI Gigabit Ethernet Adapter
- * Version:	$Revision: 1.32 $
- * Date:	$Date: 2001/02/14 14:06:31 $
+ * Version:	$Revision: 1.37 $
+ * Date:	$Date: 2003/04/15 09:43:43 $
  * Purpose:	Header file for Redundant Link ManagemenT.
  *
  ******************************************************************************/
 
 /******************************************************************************
  *
- *	(C)Copyright 1998-2001 SysKonnect GmbH.
+ *	(C)Copyright 1998-2002 SysKonnect GmbH.
+ *	(C)Copyright 2002-2003 Marvell.
  *
  *	This program is free software; you can redistribute it and/or modify
  *	it under the terms of the GNU General Public License as published by
@@ -26,6 +27,21 @@
  * History:
  *
  *	$Log: skrlmt.h,v $
+ *	Revision 1.37  2003/04/15 09:43:43  tschilli
+ *	Copyright messages changed.
+ *	
+ *	Revision 1.36  2003/04/14 15:56:22  tschilli
+ *	"#error C++ is not yet supported." removed.
+ *	
+ *	Revision 1.35  2003/01/31 14:12:41  mkunz
+ *	single port adapter runs now with two identical MAC addresses
+ *	
+ *	Revision 1.34  2002/09/23 15:13:41  rwahl
+ *	Editorial changes.
+ *	
+ *	Revision 1.33  2001/07/03 12:16:48  mkunz
+ *	New Flag ChgBcPrio (Change priority of last broadcast received)
+ *	
  *	Revision 1.32  2001/02/14 14:06:31  rassmann
  *	Editorial changes.
  *	
@@ -160,7 +176,6 @@
 #define __INC_SKRLMT_H
 
 #ifdef __cplusplus
-#error C++ is not yet supported.
 extern "C" {
 #endif	/* cplusplus */
 
@@ -283,28 +298,33 @@
 	_PortNum = (SK_U32)(PortNum); \
 	/* _pAC->Rlmt.Port[_PortNum].PacketsRx++; */ \
 	_pAC->Rlmt.Port[_PortNum].PacketsPerTimeSlot++; \
-	if ((_pAC->Rlmt.Port[_PortNum].Net->RlmtMode & SK_RLMT_TRANSPARENT) != 0) { \
+    if (_pAC->Rlmt.RlmtOff) { \
 		*(pNumBytes) = 0; \
-	} \
-	else if (IsBc) { \
-		if (_pAC->Rlmt.Port[_PortNum].Net->RlmtMode != SK_RLMT_MODE_CLS) { \
-			*(pNumBytes) = 6; \
-			*(pOffset) = 6; \
-		} \
-		else { \
-			*(pNumBytes) = 0; \
-		} \
-	} \
-	else { \
-		if ((PktLen) > SK_RLMT_MAX_TX_BUF_SIZE) { \
-			/* _pAC->Rlmt.Port[_PortNum].DataPacketsPerTimeSlot++; */ \
-			*(pNumBytes) = 0; \
-		} \
-		else { \
-			*(pNumBytes) = 6; \
-			*(pOffset) = 0; \
-		} \
-	} \
+    } \
+    else {\
+        if ((_pAC->Rlmt.Port[_PortNum].Net->RlmtMode & SK_RLMT_TRANSPARENT) != 0) { \
+    		*(pNumBytes) = 0; \
+    	} \
+    	else if (IsBc) { \
+    		if (_pAC->Rlmt.Port[_PortNum].Net->RlmtMode != SK_RLMT_MODE_CLS) { \
+    			*(pNumBytes) = 6; \
+    			*(pOffset) = 6; \
+    		} \
+    		else { \
+    			*(pNumBytes) = 0; \
+    		} \
+    	} \
+    	else { \
+    		if ((PktLen) > SK_RLMT_MAX_TX_BUF_SIZE) { \
+    			/* _pAC->Rlmt.Port[_PortNum].DataPacketsPerTimeSlot++; */ \
+    			*(pNumBytes) = 0; \
+    		} \
+    		else { \
+    			*(pNumBytes) = 6; \
+    			*(pOffset) = 0; \
+    		} \
+    	} \
+    } \
 }
 
 #if 0
@@ -468,6 +488,7 @@
 
 	/* For PNMI */
 
+	SK_U32			ChgBcPrio;			/* Change Priority of last broadcast received */
 	SK_U32			RlmtMode;			/* Check ... */
 	SK_U32			ActivePort;			/* Active port. */
 	SK_U32			Preference;		/* 0xFFFFFFFF: Automatic. */
@@ -501,8 +522,10 @@
 
 /* ----- Private part ----- */
 	SK_BOOL			CheckSwitch;
-	SK_U8			Align01;
-	SK_U16			Align02;
+	SK_BOOL			RlmtOff;            /* set to zero if the Mac addresses 
+                                           are equal or the second one 
+                                           is zero */
+	SK_U16			Align01;
 
 } SK_RLMT;
 
diff -ruN linux/drivers/net/sk98lin/h/sktimer.h linuxn/drivers/net/sk98lin/h/sktimer.h
--- linux/drivers/net/sk98lin/h/sktimer.h	Wed Jul  4 20:50:39 2001
+++ linuxn/drivers/net/sk98lin/h/sktimer.h	Tue May 20 12:17:41 2003
@@ -1,32 +1,23 @@
 /******************************************************************************
  *
  * Name:	sktimer.h
- * Project:	Genesis, PCI Gigabit Ethernet Adapter
- * Version:	$Revision: 1.8 $
- * Date:	$Date: 1998/09/08 08:48:02 $
+ * Project:	GEnesis, PCI Gigabit Ethernet Adapter
+ * Version:	$Revision: 1.9 $
+ * Date:	$Date: 1999/11/22 14:00:29 $
  * Purpose:	Defines for the timer functions
  *
  ******************************************************************************/
 
 /******************************************************************************
  *
- *	(C)Copyright 1989-1998 SysKonnect,
+ *	(C)Copyright 1998,1999 SysKonnect,
  *	a business unit of Schneider & Koch & Co. Datensysteme GmbH.
- *	All Rights Reserved
  *
- *	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF SYSKONNECT
- *	The copyright notice above does not evidence any
- *	actual or intended publication of such source code.
- *
- *	This Module contains Proprietary Information of SysKonnect
- *	and should be treated as Confidential.
- *
- *	The information in this file is provided for the exclusive use of
- *	the licensees of SysKonnect.
- *	Such users have the right to use, modify, and incorporate this code
- *	into products for purposes authorized by the license agreement
- *	provided they include this notice and the associated copyright notice
- *	with any such product.
+ *	This program is free software; you can redistribute it and/or modify
+ *	it under the terms of the GNU General Public License as published by
+ *	the Free Software Foundation; either version 2 of the License, or
+ *	(at your option) any later version.
+ *
  *	The information in this file is provided "AS IS" without warranty.
  *
  ******************************************************************************/
@@ -36,6 +27,9 @@
  * History:
  *
  *	$Log: sktimer.h,v $
+ *	Revision 1.9  1999/11/22 14:00:29  cgoos
+ *	Changed license header to GPL.
+ *	
  *	Revision 1.8  1998/09/08 08:48:02  gklug
  *	add: init level handling
  *	
diff -ruN linux/drivers/net/sk98lin/h/sktypes.h linuxn/drivers/net/sk98lin/h/sktypes.h
--- linux/drivers/net/sk98lin/h/sktypes.h	Fri Sep 15 23:34:19 2000
+++ linuxn/drivers/net/sk98lin/h/sktypes.h	Tue May 20 12:17:41 2003
@@ -2,16 +2,15 @@
  *
  * Name:	sktypes.h
  * Project:	GEnesis, PCI Gigabit Ethernet Adapter
- * Version:	$Revision: 1.2 $
- * Date:	$Date: 1999/11/22 14:01:58 $
+ * Version:	$Revision: 1.3 $
+ * Date:	$Date: 2003/02/25 14:16:40 $
  * Purpose:	Define data types for Linux
  *
  ******************************************************************************/
 
 /******************************************************************************
  *
- *	(C)Copyright 1998,1999 SysKonnect,
- *	a business unit of Schneider & Koch & Co. Datensysteme GmbH.
+ *	(C)Copyright 1998-2003 SysKonnect GmbH.
  *
  *	This program is free software; you can redistribute it and/or modify
  *	it under the terms of the GNU General Public License as published by
@@ -27,6 +26,9 @@
  * History:
  *
  *	$Log: sktypes.h,v $
+ *	Revision 1.3  2003/02/25 14:16:40  mlindner
+ *	Fix: Copyright statement
+ *	
  *	Revision 1.2  1999/11/22 14:01:58  cgoos
  *	Changed license header to GPL.
  *	Now using Linux' fixed size types instead of standard types.
diff -ruN linux/drivers/net/sk98lin/h/skversion.h linuxn/drivers/net/sk98lin/h/skversion.h
--- linux/drivers/net/sk98lin/h/skversion.h	Wed Jul  4 20:50:39 2001
+++ linuxn/drivers/net/sk98lin/h/skversion.h	Tue May 20 12:17:41 2003
@@ -2,16 +2,15 @@
  *
  * Name:	version.h
  * Project:	GEnesis, PCI Gigabit Ethernet Adapter
- * Version:	$Revision: 1.1 $
- * Date:	$Date: 2001/03/06 09:25:00 $
+ * Version:	$Revision: 1.4 $
+ * Date:	$Date: 2003/02/25 14:16:40 $
  * Purpose:	SK specific Error log support
  *
  ******************************************************************************/
 
 /******************************************************************************
  *
- *	(C)Copyright 1998,1999 SysKonnect,
- *	a business unit of Schneider & Koch & Co. Datensysteme GmbH.
+ *	(C)Copyright 1998-2003 SysKonnect GmbH.
  *
  *	This program is free software; you can redistribute it and/or modify
  *	it under the terms of the GNU General Public License as published by
@@ -26,6 +25,15 @@
  *
  * History:
  *	$Log: skversion.h,v $
+ *	Revision 1.4  2003/02/25 14:16:40  mlindner
+ *	Fix: Copyright statement
+ *	
+ *	Revision 1.3  2003/02/25 13:30:18  mlindner
+ *	Add: Support for various vendors
+ *	
+ *	Revision 1.1.2.1  2001/09/05 13:38:30  mlindner
+ *	Removed FILE description
+ *	
  *	Revision 1.1  2001/03/06 09:25:00  mlindner
  *	first version
  *	
@@ -34,13 +42,13 @@
  ******************************************************************************/
  
  
-static const char SysKonnectFileId[] = "@(#)" __FILE__ " (C) SysKonnect GmbH.";
+static const char SysKonnectFileId[] = "@(#) (C) SysKonnect GmbH.";
 static const char SysKonnectBuildNumber[] =
-	"@(#)SK-BUILD: 4.06 PL: 01"; 
+	"@(#)SK-BUILD: 6.10 PL: 01"; 
 
-#define BOOT_STRING	"sk98lin: Network Device Driver v4.06\n" \
-			"Copyright (C) 2000-2001 SysKonnect GmbH."
+#define BOOT_STRING	"sk98lin: Network Device Driver v6.10\n" \
+			"(C)Copyright 1999-2003 Marvell(R)."
 
-#define VER_STRING	"4.06"
+#define VER_STRING	"6.10"
 
 
diff -ruN linux/drivers/net/sk98lin/h/skvpd.h linuxn/drivers/net/sk98lin/h/skvpd.h
--- linux/drivers/net/sk98lin/h/skvpd.h	Wed Jul  4 20:50:39 2001
+++ linuxn/drivers/net/sk98lin/h/skvpd.h	Tue May 20 12:17:41 2003
@@ -2,16 +2,15 @@
  *
  * Name:	skvpd.h
  * Project:	GEnesis, PCI Gigabit Ethernet Adapter
- * Version:	$Revision: 1.9 $
- * Date:	$Date: 1999/11/22 14:02:27 $
+ * Version:	$Revision: 1.15 $
+ * Date:	$Date: 2003/01/13 10:39:38 $
  * Purpose:	Defines and Macros for VPD handling
  *
  ******************************************************************************/
 
 /******************************************************************************
  *
- *	(C)Copyright 1998,1999 SysKonnect,
- *	a business unit of Schneider & Koch & Co. Datensysteme GmbH.
+ *	(C)Copyright 1998-2003 SysKonnect GmbH.
  *
  *	This program is free software; you can redistribute it and/or modify
  *	it under the terms of the GNU General Public License as published by
@@ -27,6 +26,33 @@
  * History:
  *
  *	$Log: skvpd.h,v $
+ *	Revision 1.15  2003/01/13 10:39:38  rschmidt
+ *	Replaced define for PCI device Id for YUKON with GENESIS
+ *	Editorial changes
+ *	
+ *	Revision 1.14  2002/11/14 15:18:10  gheinig
+ *	Added const specifier to key and buf parameters for VpdPara,VpdRead
+ *	and VpdWrite. This is necessary for the Diag 7 GUI API
+ *	
+ *	Revision 1.13  2002/10/14 15:58:18  rschmidt
+ *	Added entry in rom_size struct s_vpd
+ *	Editorial changes
+ *	
+ *	Revision 1.12  2002/09/09 14:43:51  mkarl
+ *	added PCI Id of Yukon for reading VPD in diag before the adapter has
+ *	been initialized
+ *	editorial changes
+ *	
+ *	Revision 1.11  2002/07/26 13:19:16  mkarl
+ *	added support for Yukon
+ *	added vpd_size to VPD struct
+ *	
+ *	Revision 1.10  2000/08/10 11:29:07  rassmann
+ *	Editorial changes.
+ *	Preserving 32-bit alignment in structs for the adapter context.
+ *	Removed unused function VpdWriteDword() (#if 0).
+ *	Made VpdReadKeyword() available for SKDIAG only.
+ *	
  *	Revision 1.9  1999/11/22 14:02:27  cgoos
  *	Changed license header to GPL.
  *	
@@ -45,7 +71,7 @@
  *	Changed constants in SK_SWAP_32 to UL.
  *	
  *	Revision 1.4  1998/08/19 08:14:09  gklug
- *	fix: remove struct keyword as much as possible from the c-code (see CCC)
+ *	fix: remove struct keyword as much as possible from the C-code (see CCC)
  *	
  *	Revision 1.3  1998/08/18 08:18:56  malthoff
  *	Modify VPD in and out macros for SK_DIAG
@@ -99,7 +125,12 @@
 /*
  * Define READ and WRITE Constants.
  */
-#define	VPD_SIZE	512
+
+#define VPD_DEV_ID_GENESIS 	0x4300
+
+#define	VPD_SIZE_YUKON		256
+#define	VPD_SIZE_GENESIS	512
+#define	VPD_SIZE			512
 #define VPD_READ	0x0000
 #define VPD_WRITE	0x8000
 
@@ -115,40 +146,44 @@
 
 /* VPD status */
 	/* bit 7..1 reserved */
-#define VPD_VALID	(1<<0)		/* VPD data buffer, vpd_free_ro, */
-					/* and vpd_free_rw valid	 */
+#define VPD_VALID	(1<<0)	/* VPD data buffer, vpd_free_ro, */
+							/* and vpd_free_rw valid	 */
 
 /*
  * VPD structs
  */
 typedef	struct s_vpd_status {
-	unsigned short	vpd_status ;	/* VPD status, description see above */
-	int		vpd_free_ro ;	/* unused bytes in read only area */
-	int		vpd_free_rw ;	/* bytes available in read/write area */
+	unsigned short	Align01;			/* Alignment */
+	unsigned short	vpd_status;			/* VPD status, description see above */
+	int				vpd_free_ro;		/* unused bytes in read only area */
+	int				vpd_free_rw;		/* bytes available in read/write area */
 } SK_VPD_STATUS;
 
 typedef	struct s_vpd {
-	SK_VPD_STATUS	v ;			/* VPD status structure */
-	char		vpd_buf[VPD_SIZE] ;	/* VPD buffer */
+	SK_VPD_STATUS	v;					/* VPD status structure */
+	char			vpd_buf[VPD_SIZE];	/* VPD buffer */
+	int				rom_size;			/* VPD ROM Size from PCI_OUR_REG_2 */
+	int				vpd_size;			/* saved VPD-size */
 } SK_VPD;
 
 typedef	struct s_vpd_para {
-	unsigned int	p_len ;		/* parameter length */
-	char		*p_val ;	/* points to the value */
+	unsigned int	p_len;	/* parameter length */
+	char			*p_val;	/* points to the value */
 } SK_VPD_PARA;
 
 /*
  * structure of Large Resource Type Identifiers
  */
-/* was removed, because of alignment problems */
+
+/* was removed because of alignment problems */
 
 /*
- * sturcture of VPD keywords
+ * structure of VPD keywords
  */
 typedef	struct s_vpd_key {
-	char		p_key[2] ;	/* 2 bytes ID string */
-	unsigned char	p_len ;		/* 1 byte length */
-	char		p_val ;		/* start of the value string */
+	char			p_key[2];	/* 2 bytes ID string */
+	unsigned char	p_len;		/* 1 byte length */
+	char			p_val;		/* start of the value string */
 } SK_VPD_KEY;
 
 
@@ -172,39 +207,39 @@
 #define VPD_IN32(pAC,IoC,Addr,pVal)	SK_IN32(IoC,PCI_C(Addr),pVal)
 #endif	/* VPD_DO_IO */
 #else	/* SKDIAG */
-#define VPD_OUT8(pAC,Ioc,Addr,Val) {				\
+#define VPD_OUT8(pAC,Ioc,Addr,Val) {			\
 		if ((pAC)->DgT.DgUseCfgCycle)			\
-			SkPciWriteCfgByte(pAC,Addr,Val) ;	\
-		else						\
+			SkPciWriteCfgByte(pAC,Addr,Val);	\
+		else									\
 			SK_OUT8(pAC,PCI_C(Addr),Val);		\
 		}
-#define VPD_OUT16(pAC,Ioc,Addr,Val) {				\
+#define VPD_OUT16(pAC,Ioc,Addr,Val) {			\
 		if ((pAC)->DgT.DgUseCfgCycle)			\
-			SkPciWriteCfgWord(pAC,Addr,Val) ;	\
+			SkPciWriteCfgWord(pAC,Addr,Val);	\
 		else						\
 			SK_OUT16(pAC,PCI_C(Addr),Val);		\
 		}
-#define VPD_OUT32(pAC,Ioc,Addr,Val) {				\
+#define VPD_OUT32(pAC,Ioc,Addr,Val) {			\
 		if ((pAC)->DgT.DgUseCfgCycle)			\
-			SkPciWriteCfgDWord(pAC,Addr,Val) ;	\
+			SkPciWriteCfgDWord(pAC,Addr,Val);	\
 		else						\
 			SK_OUT32(pAC,PCI_C(Addr),Val); 		\
 		}
-#define VPD_IN8(pAC,Ioc,Addr,pVal) {				\
+#define VPD_IN8(pAC,Ioc,Addr,pVal) {			\
 		if ((pAC)->DgT.DgUseCfgCycle) 			\
-			SkPciReadCfgByte(pAC,Addr,pVal) ;	\
+			SkPciReadCfgByte(pAC,Addr,pVal);	\
 		else						\
 			SK_IN8(pAC,PCI_C(Addr),pVal); 		\
 		}
-#define VPD_IN16(pAC,Ioc,Addr,pVal) {				\
+#define VPD_IN16(pAC,Ioc,Addr,pVal) {			\
 		if ((pAC)->DgT.DgUseCfgCycle) 			\
-			SkPciReadCfgWord(pAC,Addr,pVal) ;	\
+			SkPciReadCfgWord(pAC,Addr,pVal);	\
 		else						\
 			SK_IN16(pAC,PCI_C(Addr),pVal); 		\
 		}
-#define VPD_IN32(pAC,Ioc,Addr,pVal) {				\
+#define VPD_IN32(pAC,Ioc,Addr,pVal) {			\
 		if ((pAC)->DgT.DgUseCfgCycle)			\
-			SkPciReadCfgDWord(pAC,Addr,pVal) ;	\
+			SkPciReadCfgDWord(pAC,Addr,pVal);	\
 		else						\
 			SK_IN32(pAC,PCI_C(Addr),pVal);		\
 		}
@@ -213,50 +248,52 @@
 /* function prototypes ********************************************************/
 
 #ifndef	SK_KR_PROTO
+#ifdef SKDIAG
 extern SK_U32	VpdReadDWord(
 	SK_AC		*pAC,
 	SK_IOC		IoC,
-	int		addr) ;
+	int			addr);
+#endif	/* SKDIAG */
 
 extern int	VpdSetupPara(
 	SK_AC		*pAC,
-	char		*key,
-	char		*buf,
-	int		len,
-	int		type,
-	int		op) ;
+	const char	*key,
+	const char	*buf,
+	int			len,
+	int			type,
+	int			op);
 
 extern SK_VPD_STATUS	*VpdStat(
 	SK_AC		*pAC,
-	SK_IOC		IoC) ;
+	SK_IOC		IoC);
 
 extern int	VpdKeys(
 	SK_AC		*pAC,
 	SK_IOC		IoC,
 	char		*buf,
-	int		*len,
-	int		*elements) ;
+	int			*len,
+	int			*elements);
 
 extern int	VpdRead(
 	SK_AC		*pAC,
 	SK_IOC		IoC,
-	char		*key,
+	const char	*key,
 	char		*buf,
-	int		*len) ;
+	int			*len);
 
-extern	SK_BOOL	VpdMayWrite(
-	char		*key) ;
+extern SK_BOOL	VpdMayWrite(
+	char		*key);
 
 extern int	VpdWrite(
 	SK_AC		*pAC,
 	SK_IOC		IoC,
-	char		*key,
-	char		*buf) ;
+	const char	*key,
+	const char	*buf);
 
 extern int	VpdDelete(
 	SK_AC		*pAC,
 	SK_IOC		IoC,
-	char		*key) ;
+	char		*key);
 
 extern int	VpdUpdate(
 	SK_AC		*pAC,
@@ -265,34 +302,34 @@
 extern void	VpdErrLog(
 	SK_AC		*pAC,
 	SK_IOC		IoC,
-	char		*msg) ;
+	char		*msg);
 
 #ifdef	SKDIAG
 extern int	VpdReadBlock(
 	SK_AC		*pAC,
 	SK_IOC		IoC,
 	char		*buf,
-	int		addr,
-	int		len) ;
+	int			addr,
+	int			len);
 
 extern int	VpdWriteBlock(
 	SK_AC		*pAC,
 	SK_IOC		IoC,
 	char		*buf,
-	int		addr,
-	int		len) ;
+	int			addr,
+	int			len);
 #endif	/* SKDIAG */
 #else	/* SK_KR_PROTO */
-extern SK_U32	VpdReadDWord() ;
-extern int	VpdSetupPara() ;
-extern SK_VPD_STATUS	*VpdStat() ;
-extern int	VpdKeys() ;
-extern int	VpdRead() ;
-extern SK_BOOL	VpdMayWrite() ;
-extern int	VpdWrite() ;
-extern int	VpdDelete() ;
-extern int	VpdUpdate() ;
-extern void	VpdErrLog() ;
+extern SK_U32	VpdReadDWord();
+extern int	VpdSetupPara();
+extern SK_VPD_STATUS	*VpdStat();
+extern int	VpdKeys();
+extern int	VpdRead();
+extern SK_BOOL	VpdMayWrite();
+extern int	VpdWrite();
+extern int	VpdDelete();
+extern int	VpdUpdate();
+extern void	VpdErrLog();
 #endif	/* SK_KR_PROTO */
 
 #endif	/* __INC_SKVPD_H_ */
diff -ruN linux/drivers/net/sk98lin/h/xmac_ii.h linuxn/drivers/net/sk98lin/h/xmac_ii.h
--- linux/drivers/net/sk98lin/h/xmac_ii.h	Wed Jul  4 20:50:39 2001
+++ linuxn/drivers/net/sk98lin/h/xmac_ii.h	Tue May 20 12:17:41 2003
@@ -2,15 +2,16 @@
  *
  * Name:	xmac_ii.h
  * Project:	GEnesis, PCI Gigabit Ethernet Adapter
- * Version:	$Revision: 1.28 $
- * Date:	$Date: 2000/11/09 12:32:49 $
- * Purpose:	Defines and Macros for XaQti's Gigabit Ethernet Controller
+ * Version:	$Revision: 1.47 $
+ * Date:	$Date: 2003/03/31 07:37:25 $
+ * Purpose:	Defines and Macros for Gigabit Ethernet Controller
  *
  ******************************************************************************/
 
 /******************************************************************************
  *
- *	(C)Copyright 1998-2000 SysKonnect GmbH.
+ *	(C)Copyright 1998-2002 SysKonnect.
+ *	(C)Copyright 2002-2003 Marvell.
  *
  *	This program is free software; you can redistribute it and/or modify
  *	it under the terms of the GNU General Public License as published by
@@ -26,6 +27,86 @@
  * History:
  *
  *	$Log: xmac_ii.h,v $
+ *	Revision 1.47  2003/03/31 07:37:25  mkarl
+ *	Corrected Copyright.
+ *	Editorial changes.
+ *	
+ *	Revision 1.46  2003/01/28 09:47:45  rschmidt
+ *	Added defines for copper MDI/MDIX configuration
+ *	Added defines for LED Control Register
+ *	Editorial changes
+ *	
+ *	Revision 1.45  2002/12/10 14:35:13  rschmidt
+ *	Corrected defines for Extended PHY Specific Control
+ *	Added defines for Ext. PHY Specific Ctrl 2 Reg. (Fiber specific)
+ *	
+ *	Revision 1.44  2002/12/09 14:58:41  rschmidt
+ *	Added defines for Ext. PHY Specific Ctrl Reg. (downshift feature)
+ *	Added 'GMR_FS_UN_SIZE'-Bit to Rx GMAC FIFO Flush Mask
+ *	
+ *	Revision 1.43  2002/12/05 10:14:45  rschmidt
+ *	Added define for GMAC's Half Duplex Burst Mode
+ *	Added define for Rx GMAC FIFO Flush Mask (default)
+ *	
+ *	Revision 1.42  2002/11/12 16:48:19  rschmidt
+ *	Added defines for Cable Diagnostic Register (GPHY)
+ *	Editorial changes
+ *	
+ *	Revision 1.41  2002/10/21 11:20:22  rschmidt
+ *	Added bit GMR_FS_GOOD_FC to GMR_FS_ANY_ERR
+ *	Editorial changes
+ *	
+ *	Revision 1.40  2002/10/14 14:54:14  rschmidt
+ *	Added defines for GPHY Specific Status and GPHY Interrupt Status
+ *	Added bits PHY_M_IS_AN_ERROR and PHY_M_IS_FIFO_ERROR to PHY_M_DEF_MSK
+ *	Editorial changes
+ *	
+ *	Revision 1.39  2002/10/10 15:53:44  mkarl
+ *	added some bit definitions for link speed status and LED's
+ *	
+ *	Revision 1.38  2002/08/21 16:23:46  rschmidt
+ *	Added defines for PHY Specific Ctrl Reg
+ *	Editorial changes
+ *	
+ *	Revision 1.37  2002/08/16 14:50:33  rschmidt
+ *	Added defines for Auto-Neg. Advertisement YUKON Fiber (88E1011S only)
+ *	Changed define PHY_M_DEF_MSK for GPHY IRQ Mask
+ *	Editorial changes
+ *	
+ *	Revision 1.36  2002/08/12 13:21:10  rschmidt
+ *	Added defines for different Broadcom PHY Ids
+ *	
+ *	Revision 1.35  2002/08/08 15:58:01  rschmidt
+ *	Added defines for Manual LED Override register (YUKON)
+ *	Editorial changes
+ *	
+ *	Revision 1.34  2002/07/31 17:23:36  rwahl
+ *	Added define GMR_FS_ANY_ERR (analogous to XMR_FS_ANY_ERR).
+ *	
+ *	Revision 1.33  2002/07/23 16:03:37  rschmidt
+ *	Added defines for GPHY registers
+ *	Editorial changes
+ *	
+ *	Revision 1.32  2002/07/15 18:14:37  rwahl
+ *	Added GMAC MIB counters definitions.
+ *	Editorial changes.
+ *	
+ *	Revision 1.31  2002/07/15 15:42:50  rschmidt
+ *	Removed defines from PHY specific reg. which are
+ *	common to all PHYs
+ *	Added defines for GMAC MIB Counters
+ *	Editorial changes
+ *	
+ *	Revision 1.30  2002/06/05 08:22:12  rschmidt
+ *	Changed defines for GMAC Rx Control Register and Rx Status
+ *	Editorial changes
+ *	
+ *	Revision 1.29  2002/04/25 11:43:56  rschmidt
+ *	Added define PHY_B_AS_PAUSE_MSK for BCom Pause Res.
+ *	Added new registers and defines for YUKON (GMAC, GPHY)
+ *	Added Receive Frame Status Encoding for YUKON
+ *	Editorial changes
+ *	
  *	Revision 1.28  2000/11/09 12:32:49  rassmann
  *	Renamed variables.
  *	
@@ -82,7 +163,7 @@
  *	Changed shifted constant to ULONG.
  *
  *	Revision 1.11  1998/10/14 05:43:26  gklug
- *	add: shift pause codeing
+ *	add: shift pause coding
  *	fix: PAUSE bits definition
  *
  *	Revision 1.10  1998/10/13 09:19:21  malthoff
@@ -135,61 +216,61 @@
 /*
  * XMAC II registers
  *
- * The XMAC registers are 16 or 32 bits wide. The XMACs host processor
- * interface is set to 16 bit mode, therefore ALL registers will be
- * addressed with 16 bit accesses.
+ * The XMAC registers are 16 or 32 bits wide.
+ * The XMACs host processor interface is set to 16 bit mode,
+ * therefore ALL registers will be addressed with 16 bit accesses.
  *
  * The following macros are provided to access the XMAC registers
- * XM_IN16(), XM_OUT16, XM_IN32(), MX_OUT32(), XM_INADR(), XM_OUTADR(),
+ * XM_IN16(), XM_OUT16, XM_IN32(), XM_OUT32(), XM_INADR(), XM_OUTADR(),
  * XM_INHASH(), and XM_OUTHASH().
  * The macros are defined in SkGeHw.h.
  *
  * Note:	NA reg	= Network Address e.g DA, SA etc.
  *
  */
-#define XM_MMU_CMD	0x0000		/* 16 bit r/w	MMU Command Register */
+#define XM_MMU_CMD		0x0000	/* 16 bit r/w	MMU Command Register */
 	/* 0x0004:		reserved */
-#define XM_POFF		0x0008		/* 32 bit r/w	Packet Offset Register */
-#define XM_BURST	0x000c		/* 32 bit r/w	Burst Register for half duplex*/
+#define XM_POFF			0x0008	/* 32 bit r/w	Packet Offset Register */
+#define XM_BURST		0x000c	/* 32 bit r/w	Burst Register for half duplex*/
 #define XM_1L_VLAN_TAG	0x0010	/* 16 bit r/w	One Level VLAN Tag ID */
 #define XM_2L_VLAN_TAG	0x0014	/* 16 bit r/w	Two Level VLAN Tag ID */
 	/* 0x0018 - 0x001e:	reserved */
-#define XM_TX_CMD	0x0020		/* 16 bit r/w	Transmit Command Register */
-#define	XM_TX_RT_LIM	0x0024	/* 16 bit r/w	Transmit Retry Limit Register */
-#define XM_TX_STIME	0x0028		/* 16 bit r/w	Transmit Slottime Register */
-#define XM_TX_IPG	0x002c		/* 16 bit r/w	Transmit Inter Packet Gap */
-#define XM_RX_CMD	0x0030		/* 16 bit r/w	Receive Command Register */
-#define XM_PHY_ADDR	0x0034		/* 16 bit r/w	PHY Address Register */
-#define	XM_PHY_DATA	0x0038		/* 16 bit r/w	PHY Data Register */
+#define XM_TX_CMD		0x0020	/* 16 bit r/w	Transmit Command Register */
+#define XM_TX_RT_LIM	0x0024	/* 16 bit r/w	Transmit Retry Limit Register */
+#define XM_TX_STIME		0x0028	/* 16 bit r/w	Transmit Slottime Register */
+#define XM_TX_IPG		0x002c	/* 16 bit r/w	Transmit Inter Packet Gap */
+#define XM_RX_CMD		0x0030	/* 16 bit r/w	Receive Command Register */
+#define XM_PHY_ADDR		0x0034	/* 16 bit r/w	PHY Address Register */
+#define XM_PHY_DATA		0x0038	/* 16 bit r/w	PHY Data Register */
 	/* 0x003c: 		reserved */
-#define XM_GP_PORT	0x0040		/* 32 bit r/w	General Purpose Port Register */
-#define XM_IMSK		0x0044		/* 16 bit r/w	Interrupt Mask Register */
-#define XM_ISRC		0x0048		/* 16 bit ro	Interrupt Status Register */
-#define XM_HW_CFG	0x004c		/* 16 bit r/w	Hardware Config Register */
+#define XM_GP_PORT		0x0040	/* 32 bit r/w	General Purpose Port Register */
+#define XM_IMSK			0x0044	/* 16 bit r/w	Interrupt Mask Register */
+#define XM_ISRC			0x0048	/* 16 bit r/o	Interrupt Status Register */
+#define XM_HW_CFG		0x004c	/* 16 bit r/w	Hardware Config Register */
 	/* 0x0050 - 0x005e:	reserved */
-#define XM_TX_LO_WM	0x0060		/* 16 bit r/w	Tx FIFO Low Water Mark */
-#define XM_TX_HI_WM	0x0062		/* 16 bit r/w	Tx FIFO High Water Mark */
-#define XM_TX_THR	0x0064		/* 16 bit r/w	Tx Request Threshold */
-#define	XM_HT_THR	0x0066		/* 16 bit r/w	Host Request Threshold */
-#define	XM_PAUSE_DA	0x0068		/* NA reg r/w	Pause Destination Address */
+#define XM_TX_LO_WM		0x0060	/* 16 bit r/w	Tx FIFO Low Water Mark */
+#define XM_TX_HI_WM		0x0062	/* 16 bit r/w	Tx FIFO High Water Mark */
+#define XM_TX_THR		0x0064	/* 16 bit r/w	Tx Request Threshold */
+#define XM_HT_THR		0x0066	/* 16 bit r/w	Host Request Threshold */
+#define XM_PAUSE_DA		0x0068	/* NA reg r/w	Pause Destination Address */
 	/* 0x006e: 		reserved */
-#define XM_CTL_PARA	0x0070		/* 32 bit r/w	Control Parameter Register */
+#define XM_CTL_PARA		0x0070	/* 32 bit r/w	Control Parameter Register */
 #define XM_MAC_OPCODE	0x0074	/* 16 bit r/w	Opcode for MAC control frames */
 #define XM_MAC_PTIME	0x0076	/* 16 bit r/w	Pause time for MAC ctrl frames*/
-#define XM_TX_STAT	0x0078		/* 32 bit ro	Tx Status LIFO Register */
+#define XM_TX_STAT		0x0078	/* 32 bit r/o	Tx Status LIFO Register */
 
-	/* 0x0080 - 0x00fc:	16 NA reg r/w	Exakt Match Address Registers */
-	/* 				use the XM_EMX() macro to address */
+	/* 0x0080 - 0x00fc:	16 NA reg r/w	Exact Match Address Registers */
+	/* 				use the XM_EXM() macro to address */
 #define XM_EXM_START	0x0080	/* r/w	Start Address of the EXM Regs */
 
 	/*
 	 * XM_EXM(Reg)
 	 *
-	 * returns the XMAC address offset off specified Exakt Match Addr Reg
+	 * returns the XMAC address offset of specified Exact Match Addr Reg
 	 *
 	 * para:	Reg	EXM register to addr	(0 .. 15)
 	 *
-	 * usage:	XM_INADDR(XMAC_1,pAC,XM_EXM(i),&val[i]) ;
+	 * usage:	XM_INADDR(IoC, MAC_1, XM_EXM(i), &val[i]);
 	 */
 #define XM_EXM(Reg)	(XM_EXM_START + ((Reg) << 3))
 
@@ -199,78 +280,78 @@
 #define XM_RX_LO_WM		0x0118	/* 16 bit r/w	Receive Low Water Mark */
 #define XM_RX_HI_WM		0x011a	/* 16 bit r/w	Receive High Water Mark */
 #define XM_RX_THR		0x011c	/* 32 bit r/w	Receive Request Threshold */
-#define XM_DEV_ID		0x0120	/* 32 bit ro	Device ID Register */
+#define XM_DEV_ID		0x0120	/* 32 bit r/o	Device ID Register */
 #define XM_MODE			0x0124	/* 32 bit r/w	Mode Register */
-#define XM_LSA			0x0128	/* NA reg ro	Last Source Register */
+#define XM_LSA			0x0128	/* NA reg r/o	Last Source Register */
 	/* 0x012e:		reserved */
-#define XM_TS_READ		0x0130	/* 32 bit ro	TimeStamp Read Regeister */
-#define XM_TS_LOAD		0x0134	/* 32 bit ro	TimeStamp Load Value */
+#define XM_TS_READ		0x0130	/* 32 bit r/o	Time Stamp Read Register */
+#define XM_TS_LOAD		0x0134	/* 32 bit r/o	Time Stamp Load Value */
 	/* 0x0138 - 0x01fe:	reserved */
 #define XM_STAT_CMD	0x0200	/* 16 bit r/w	Statistics Command Register */
-#define	XM_RX_CNT_EV	0x0204	/* 32 bit ro	Rx Counter Event Register */
-#define XM_TX_CNT_EV	0x0208	/* 32 bit ro	Tx Counter Event Register */
+#define XM_RX_CNT_EV	0x0204	/* 32 bit r/o	Rx Counter Event Register */
+#define XM_TX_CNT_EV	0x0208	/* 32 bit r/o	Tx Counter Event Register */
 #define XM_RX_EV_MSK	0x020c	/* 32 bit r/w	Rx Counter Event Mask */
 #define XM_TX_EV_MSK	0x0210	/* 32 bit r/w	Tx Counter Event Mask */
 	/* 0x0204 - 0x027e:	reserved */
-#define XM_TXF_OK		0x0280	/* 32 bit ro	Frames Transmitted OK Conuter */
-#define XM_TXO_OK_HI	0x0284	/* 32 bit ro	Octets Transmitted OK High Cnt*/
-#define XM_TXO_OK_LO	0x0288	/* 32 bit ro	Octets Transmitted OK Low Cnt */
-#define XM_TXF_BC_OK	0x028c	/* 32 bit ro	Broadcast Frames Xmitted OK */
-#define XM_TXF_MC_OK	0x0290	/* 32 bit ro	Multicast Frames Xmitted OK */
-#define XM_TXF_UC_OK	0x0294	/* 32 bit ro	Unicast Frames Xmitted OK */
-#define XM_TXF_LONG		0x0298	/* 32 bit ro	Tx Long Frame Counter */
-#define XM_TXE_BURST	0x029c	/* 32 bit ro	Tx Burst Event Counter */
-#define XM_TXF_MPAUSE	0x02a0	/* 32 bit ro	Tx Pause MAC Ctrl Frame Cnt */
-#define XM_TXF_MCTRL	0x02a4	/* 32 bit ro	Tx MAC Ctrl Frame Counter */
-#define XM_TXF_SNG_COL	0x02a8	/* 32 bit ro	Tx Single Colliosion Counter */
-#define XM_TXF_MUL_COL	0x02ac	/* 32 bit ro	Tx Multiple Collision Counter */
-#define XM_TXF_ABO_COL	0x02b0	/* 32 bit ro	Tx aborted due to Exessive Col*/
-#define XM_TXF_LAT_COL	0x02b4	/* 32 bit ro	Tx Late Collision Counter */
-#define XM_TXF_DEF		0x02b8	/* 32 bit ro	Tx Deferred Frame Counter */
-#define XM_TXF_EX_DEF	0x02bc	/* 32 bit ro	Tx Excessive Deferall Counter */
-#define XM_TXE_FIFO_UR	0x02c0	/* 32 bit ro	Tx FIFO Underrun Event Cnt */
-#define XM_TXE_CS_ERR	0x02c4	/* 32 bit ro	Tx Carrier Sence Error Cnt */
-#define XM_TXP_UTIL		0x02c8	/* 32 bit ro	Tx Utilization in % */
+#define XM_TXF_OK		0x0280	/* 32 bit r/o	Frames Transmitted OK Conuter */
+#define XM_TXO_OK_HI	0x0284	/* 32 bit r/o	Octets Transmitted OK High Cnt*/
+#define XM_TXO_OK_LO	0x0288	/* 32 bit r/o	Octets Transmitted OK Low Cnt */
+#define XM_TXF_BC_OK	0x028c	/* 32 bit r/o	Broadcast Frames Xmitted OK */
+#define XM_TXF_MC_OK	0x0290	/* 32 bit r/o	Multicast Frames Xmitted OK */
+#define XM_TXF_UC_OK	0x0294	/* 32 bit r/o	Unicast Frames Xmitted OK */
+#define XM_TXF_LONG		0x0298	/* 32 bit r/o	Tx Long Frame Counter */
+#define XM_TXE_BURST	0x029c	/* 32 bit r/o	Tx Burst Event Counter */
+#define XM_TXF_MPAUSE	0x02a0	/* 32 bit r/o	Tx Pause MAC Ctrl Frame Cnt */
+#define XM_TXF_MCTRL	0x02a4	/* 32 bit r/o	Tx MAC Ctrl Frame Counter */
+#define XM_TXF_SNG_COL	0x02a8	/* 32 bit r/o	Tx Single Collision Counter */
+#define XM_TXF_MUL_COL	0x02ac	/* 32 bit r/o	Tx Multiple Collision Counter */
+#define XM_TXF_ABO_COL	0x02b0	/* 32 bit r/o	Tx aborted due to Exces. Col. */
+#define XM_TXF_LAT_COL	0x02b4	/* 32 bit r/o	Tx Late Collision Counter */
+#define XM_TXF_DEF		0x02b8	/* 32 bit r/o	Tx Deferred Frame Counter */
+#define XM_TXF_EX_DEF	0x02bc	/* 32 bit r/o	Tx Excessive Deferall Counter */
+#define XM_TXE_FIFO_UR	0x02c0	/* 32 bit r/o	Tx FIFO Underrun Event Cnt */
+#define XM_TXE_CS_ERR	0x02c4	/* 32 bit r/o	Tx Carrier Sense Error Cnt */
+#define XM_TXP_UTIL		0x02c8	/* 32 bit r/o	Tx Utilization in % */
 	/* 0x02cc - 0x02ce:	reserved */
-#define XM_TXF_64B		0x02d0	/* 32 bit ro	64 Byte Tx Frame Counter */
-#define XM_TXF_127B		0x02d4	/* 32 bit ro	65-127 Byte Tx Frame Counter */
-#define XM_TXF_255B		0x02d8	/* 32 bit ro	128-255 Byte Tx Frame Counter */
-#define XM_TXF_511B		0x02dc	/* 32 bit ro	256-511 Byte Tx Frame Counter */
-#define XM_TXF_1023B	0x02e0	/* 32 bit ro	512-1023 Byte Tx Frame Counter*/
-#define XM_TXF_MAX_SZ	0x02e4	/* 32 bit ro	1024-MaxSize Byte Tx Frame Cnt*/
+#define XM_TXF_64B		0x02d0	/* 32 bit r/o	64 Byte Tx Frame Counter */
+#define XM_TXF_127B		0x02d4	/* 32 bit r/o	65-127 Byte Tx Frame Counter */
+#define XM_TXF_255B		0x02d8	/* 32 bit r/o	128-255 Byte Tx Frame Counter */
+#define XM_TXF_511B		0x02dc	/* 32 bit r/o	256-511 Byte Tx Frame Counter */
+#define XM_TXF_1023B	0x02e0	/* 32 bit r/o	512-1023 Byte Tx Frame Counter*/
+#define XM_TXF_MAX_SZ	0x02e4	/* 32 bit r/o	1024-MaxSize Byte Tx Frame Cnt*/
 	/* 0x02e8 - 0x02fe:	reserved */
-#define XM_RXF_OK		0x0300	/* 32 bit ro	Frames Received OK */
-#define XM_RXO_OK_HI	0x0304	/* 32 bit ro	Octets Received OK High Cnt */
-#define XM_RXO_OK_LO	0x0308	/* 32 bit ro	Octets Received OK Low Counter*/
-#define XM_RXF_BC_OK	0x030c	/* 32 bit ro	Broadcast Frames Received OK */
-#define XM_RXF_MC_OK	0x0310	/* 32 bit ro	Multicast Frames Received OK */
-#define XM_RXF_UC_OK	0x0314	/* 32 bit ro	Unicast Frames Received OK */
-#define XM_RXF_MPAUSE	0x0318	/* 32 bit ro	Rx Pause MAC Ctrl Frame Cnt */
-#define XM_RXF_MCTRL	0x031c	/* 32 bit ro	Rx MAC Ctrl Frame Counter */
-#define XM_RXF_INV_MP	0x0320	/* 32 bit ro	Rx invalid Pause Frame Cnt */
-#define XM_RXF_INV_MOC	0x0324	/* 32 bit ro	Rx Frames with inv. MAC Opcode*/
-#define XM_RXE_BURST	0x0328	/* 32 bit ro	Rx Burst Event Counter */
-#define XM_RXE_FMISS	0x032c	/* 32 bit ro	Rx Missed Frames Event Cnt */
-#define XM_RXF_FRA_ERR	0x0330	/* 32 bit ro	Rx Framing Error Counter */
-#define XM_RXE_FIFO_OV	0x0334	/* 32 bit ro	Rx FIFO overflow Event Cnt */
-#define XM_RXF_JAB_PKT	0x0338	/* 32 bit ro	Rx Jabber Packet Frame Cnt */
-#define XM_RXE_CAR_ERR	0x033c	/* 32 bit ro	Rx Carrier Event Error Cnt */
-#define XM_RXF_LEN_ERR	0x0340	/* 32 bit ro	Rx in Range Length Error */
-#define XM_RXE_SYM_ERR	0x0344	/* 32 bit ro	Rx Symbol Error Counter */
-#define XM_RXE_SHT_ERR	0x0348	/* 32 bit ro	Rx Short Event Error Cnt */
-#define XM_RXE_RUNT		0x034c	/* 32 bit ro	Rx Runt Event Counter */
-#define XM_RXF_LNG_ERR	0x0350	/* 32 bit ro	Rx Frame too Long Error Cnt */
-#define XM_RXF_FCS_ERR	0x0354	/* 32 bit ro	Rx Frame Check Seq. Error Cnt */
+#define XM_RXF_OK		0x0300	/* 32 bit r/o	Frames Received OK */
+#define XM_RXO_OK_HI	0x0304	/* 32 bit r/o	Octets Received OK High Cnt */
+#define XM_RXO_OK_LO	0x0308	/* 32 bit r/o	Octets Received OK Low Counter*/
+#define XM_RXF_BC_OK	0x030c	/* 32 bit r/o	Broadcast Frames Received OK */
+#define XM_RXF_MC_OK	0x0310	/* 32 bit r/o	Multicast Frames Received OK */
+#define XM_RXF_UC_OK	0x0314	/* 32 bit r/o	Unicast Frames Received OK */
+#define XM_RXF_MPAUSE	0x0318	/* 32 bit r/o	Rx Pause MAC Ctrl Frame Cnt */
+#define XM_RXF_MCTRL	0x031c	/* 32 bit r/o	Rx MAC Ctrl Frame Counter */
+#define XM_RXF_INV_MP	0x0320	/* 32 bit r/o	Rx invalid Pause Frame Cnt */
+#define XM_RXF_INV_MOC	0x0324	/* 32 bit r/o	Rx Frames with inv. MAC Opcode*/
+#define XM_RXE_BURST	0x0328	/* 32 bit r/o	Rx Burst Event Counter */
+#define XM_RXE_FMISS	0x032c	/* 32 bit r/o	Rx Missed Frames Event Cnt */
+#define XM_RXF_FRA_ERR	0x0330	/* 32 bit r/o	Rx Framing Error Counter */
+#define XM_RXE_FIFO_OV	0x0334	/* 32 bit r/o	Rx FIFO overflow Event Cnt */
+#define XM_RXF_JAB_PKT	0x0338	/* 32 bit r/o	Rx Jabber Packet Frame Cnt */
+#define XM_RXE_CAR_ERR	0x033c	/* 32 bit r/o	Rx Carrier Event Error Cnt */
+#define XM_RXF_LEN_ERR	0x0340	/* 32 bit r/o	Rx in Range Length Error */
+#define XM_RXE_SYM_ERR	0x0344	/* 32 bit r/o	Rx Symbol Error Counter */
+#define XM_RXE_SHT_ERR	0x0348	/* 32 bit r/o	Rx Short Event Error Cnt */
+#define XM_RXE_RUNT		0x034c	/* 32 bit r/o	Rx Runt Event Counter */
+#define XM_RXF_LNG_ERR	0x0350	/* 32 bit r/o	Rx Frame too Long Error Cnt */
+#define XM_RXF_FCS_ERR	0x0354	/* 32 bit r/o	Rx Frame Check Seq. Error Cnt */
 	/* 0x0358 - 0x035a:	reserved */
-#define XM_RXF_CEX_ERR	0x035c	/* 32 bit ro	Rx Carrier Ext Error Frame Cnt*/
-#define XM_RXP_UTIL		0x0360	/* 32 bit ro	Rx Utilization in % */
+#define XM_RXF_CEX_ERR	0x035c	/* 32 bit r/o	Rx Carrier Ext Error Frame Cnt*/
+#define XM_RXP_UTIL		0x0360	/* 32 bit r/o	Rx Utilization in % */
 	/* 0x0364 - 0x0366:	reserved */
-#define XM_RXF_64B		0x0368	/* 32 bit ro	64 Byte Rx Frame Counter */
-#define XM_RXF_127B		0x036c	/* 32 bit ro	65-127 Byte Rx Frame Counter */
-#define XM_RXF_255B		0x0370	/* 32 bit ro	128-255 Byte Rx Frame Counter */
-#define XM_RXF_511B		0x0374	/* 32 bit ro	256-511 Byte Rx Frame Counter */
-#define XM_RXF_1023B	0x0378	/* 32 bit ro	512-1023 Byte Rx Frame Counter*/
-#define XM_RXF_MAX_SZ	0x037c	/* 32 bit ro	1024-MaxSize Byte Rx Frame Cnt*/
+#define XM_RXF_64B		0x0368	/* 32 bit r/o	64 Byte Rx Frame Counter */
+#define XM_RXF_127B		0x036c	/* 32 bit r/o	65-127 Byte Rx Frame Counter */
+#define XM_RXF_255B		0x0370	/* 32 bit r/o	128-255 Byte Rx Frame Counter */
+#define XM_RXF_511B		0x0374	/* 32 bit r/o	256-511 Byte Rx Frame Counter */
+#define XM_RXF_1023B	0x0378	/* 32 bit r/o	512-1023 Byte Rx Frame Counter*/
+#define XM_RXF_MAX_SZ	0x037c	/* 32 bit r/o	1024-MaxSize Byte Rx Frame Cnt*/
 	/* 0x02e8 - 0x02fe:	reserved */
 
 
@@ -279,104 +360,104 @@
  * XMAC Bit Definitions
  *
  * If the bit access behaviour differs from the register access behaviour
- * (r/w, ro) this is docomented after the bit number. The following bit
- * access behaviours are used:
+ * (r/w, r/o) this is documented after the bit number.
+ * The following bit access behaviours are used:
  *	(sc)	self clearing
  *	(ro)	read only
  */
 
-/*	XM_MMU_CMD	16 bit r/w	MMU Comamnd Register */
+/*	XM_MMU_CMD	16 bit r/w	MMU Command Register */
 								/* Bit 15..13:	reserved */
 #define XM_MMU_PHY_RDY	(1<<12)	/* Bit 12:	PHY Read Ready */
 #define XM_MMU_PHY_BUSY	(1<<11)	/* Bit 11:	PHY Busy */
 #define XM_MMU_IGN_PF	(1<<10)	/* Bit 10:	Ignore Pause Frame */
-#define XM_MMU_MAC_LB	(1<<9)	/* Bit	9:	Enable MAC Loopback */
-								/* Bit	8:	reserved */
-#define XM_MMU_FRC_COL	(1<<7)	/* Bit	7:	Force Collision */
-#define XM_MMU_SIM_COL	(1<<6)	/* Bit	6:	Simulate Collision */
-#define XM_MMU_NO_PRE	(1<<5)	/* Bit	5:	No MDIO Preamble */
-#define XM_MMU_GMII_FD	(1<<4)	/* Bit	4:	GMII uses Full Duplex */
-#define XM_MMU_RAT_CTRL	(1<<3)	/* Bit	3:	Enable Rate Control */
-#define XM_MMU_GMII_LOOP (1<<2)	/* Bit	2:	PHY is in Lookback Mode */
-#define XM_MMU_ENA_RX	(1<<1)	/* Bit	1:	Enable Receiver */
-#define XM_MMU_ENA_TX	(1<<0)	/* Bit	0:	Enable Transmitter */
+#define XM_MMU_MAC_LB	(1<<9)	/* Bit  9:	Enable MAC Loopback */
+								/* Bit  8:	reserved */
+#define XM_MMU_FRC_COL	(1<<7)	/* Bit  7:	Force Collision */
+#define XM_MMU_SIM_COL	(1<<6)	/* Bit  6:	Simulate Collision */
+#define XM_MMU_NO_PRE	(1<<5)	/* Bit  5:	No MDIO Preamble */
+#define XM_MMU_GMII_FD	(1<<4)	/* Bit  4:	GMII uses Full Duplex */
+#define XM_MMU_RAT_CTRL	(1<<3)	/* Bit  3:	Enable Rate Control */
+#define XM_MMU_GMII_LOOP (1<<2)	/* Bit  2:	PHY is in Loopback Mode */
+#define XM_MMU_ENA_RX	(1<<1)	/* Bit  1:	Enable Receiver */
+#define XM_MMU_ENA_TX	(1<<0)	/* Bit  0:	Enable Transmitter */
 
 
 /*	XM_TX_CMD	16 bit r/w	Transmit Command Register */
 								/* Bit 15..7:	reserved */
-#define XM_TX_BK2BK		(1<<6)	/* Bit	6:	Ignor Carrier Sense (tx Bk2Bk)*/
-#define XM_TX_ENC_BYP	(1<<5)	/* Bit	5:	Set Encoder in Bypass Mode */
-#define XM_TX_SAM_LINE	(1<<4)	/* Bit	4: (sc)	Start utilization calculation */
-#define XM_TX_NO_GIG_MD	(1<<3)	/* Bit	3:	Disable Carrier Extension */
-#define XM_TX_NO_PRE	(1<<2)	/* Bit	2:	Disable Preamble Generation */
-#define XM_TX_NO_CRC	(1<<1)	/* Bit	1:	Disable CRC Generation */
-#define XM_TX_AUTO_PAD	(1<<0)	/* Bit	0:	Enable Automatic Padding */
+#define XM_TX_BK2BK		(1<<6)	/* Bit  6:	Ignor Carrier Sense (Tx Bk2Bk)*/
+#define XM_TX_ENC_BYP	(1<<5)	/* Bit  5:	Set Encoder in Bypass Mode */
+#define XM_TX_SAM_LINE	(1<<4)	/* Bit  4: (sc)	Start utilization calculation */
+#define XM_TX_NO_GIG_MD	(1<<3)	/* Bit  3:	Disable Carrier Extension */
+#define XM_TX_NO_PRE	(1<<2)	/* Bit  2:	Disable Preamble Generation */
+#define XM_TX_NO_CRC	(1<<1)	/* Bit  1:	Disable CRC Generation */
+#define XM_TX_AUTO_PAD	(1<<0)	/* Bit  0:	Enable Automatic Padding */
 
 
 /*	XM_TX_RT_LIM	16 bit r/w	Transmit Retry Limit Register */
 								/* Bit 15..5:	reserved */
-#define	XM_RT_LIM_MSK	0x1f	/* Bit	4..0:	Tx Retry Limit */
+#define XM_RT_LIM_MSK	0x1f	/* Bit  4..0:	Tx Retry Limit */
 
 
 /*	XM_TX_STIME	16 bit r/w	Transmit Slottime Register */
 								/* Bit 15..7:	reserved */
-#define XM_STIME_MSK	0x7f	/* Bit	6..0:	Tx Slottime bits */
+#define XM_STIME_MSK	0x7f	/* Bit  6..0:	Tx Slottime bits */
 
 
 /*	XM_TX_IPG	16 bit r/w	Transmit Inter Packet Gap */
 								/* Bit 15..8:	reserved */
-#define XM_IPG_MSK		0xff	/* Bit	7..0:	IPG value bits */
+#define XM_IPG_MSK		0xff	/* Bit  7..0:	IPG value bits */
 
 
 /*	XM_RX_CMD	16 bit r/w	Receive Command Register */
 								/* Bit 15..9:	reserved */
-#define XM_RX_LENERR_OK (1<<8)	/* Bit	8	don't set Rx Err bit for */
+#define XM_RX_LENERR_OK (1<<8)	/* Bit  8	don't set Rx Err bit for */
 								/*		inrange error packets */
-#define XM_RX_BIG_PK_OK	(1<<7)	/* Bit	7	don't set Rx Err bit for */
+#define XM_RX_BIG_PK_OK	(1<<7)	/* Bit  7	don't set Rx Err bit for */
 								/*		jumbo packets */
-#define XM_RX_IPG_CAP	(1<<6)	/* Bit	6	repl. type field with IPG */
-#define XM_RX_TP_MD		(1<<5)	/* Bit	5:	Enable transparent Mode */
-#define XM_RX_STRIP_FCS	(1<<4)	/* Bit	4:	Enable FCS Stripping */
-#define XM_RX_SELF_RX	(1<<3)	/* Bit	3: 	Enable Rx of own packets */
-#define XM_RX_SAM_LINE	(1<<2)	/* Bit	2: (sc)	Start utilization calculation */
-#define XM_RX_STRIP_PAD	(1<<1)	/* Bit	1:	Strip pad bytes of rx frames */
-#define XM_RX_DIS_CEXT	(1<<0)	/* Bit	0:	Disable carrier ext. check */
+#define XM_RX_IPG_CAP	(1<<6)	/* Bit  6	repl. type field with IPG */
+#define XM_RX_TP_MD		(1<<5)	/* Bit  5:	Enable transparent Mode */
+#define XM_RX_STRIP_FCS	(1<<4)	/* Bit  4:	Enable FCS Stripping */
+#define XM_RX_SELF_RX	(1<<3)	/* Bit  3: 	Enable Rx of own packets */
+#define XM_RX_SAM_LINE	(1<<2)	/* Bit  2: (sc)	Start utilization calculation */
+#define XM_RX_STRIP_PAD	(1<<1)	/* Bit  1:	Strip pad bytes of Rx frames */
+#define XM_RX_DIS_CEXT	(1<<0)	/* Bit  0:	Disable carrier ext. check */
 
 
 /*	XM_PHY_ADDR	16 bit r/w	PHY Address Register */
 								/* Bit 15..5:	reserved */
-#define	XM_PHY_ADDR_SZ	0x1f	/* Bit	4..0:	PHY Address bits */
+#define XM_PHY_ADDR_SZ	0x1f	/* Bit  4..0:	PHY Address bits */
 
 
 /*	XM_GP_PORT	32 bit r/w	General Purpose Port Register */
 								/* Bit 31..7:	reserved */
-#define	XM_GP_ANIP		(1L<<6)	/* Bit	6: (ro)	Auto Negotiation in Progress */
-#define XM_GP_FRC_INT	(1L<<5)	/* Bit	5: (sc)	Force Interrupt */
-								/* Bit	4:	reserved */
-#define XM_GP_RES_MAC	(1L<<3)	/* Bit	3: (sc)	Reset MAC and FIFOs */
-#define XM_GP_RES_STAT	(1L<<2)	/* Bit	2: (sc)	Reset the statistics module */
-								/* Bit	1:	reserved */
-#define XM_GP_INP_ASS	(1L<<0)	/* Bit	0: (ro) GP Input Pin asserted */
+#define XM_GP_ANIP		(1L<<6)	/* Bit  6: (ro)	Auto-Neg. in progress */
+#define XM_GP_FRC_INT	(1L<<5)	/* Bit  5: (sc)	Force Interrupt */
+								/* Bit  4:	reserved */
+#define XM_GP_RES_MAC	(1L<<3)	/* Bit  3: (sc)	Reset MAC and FIFOs */
+#define XM_GP_RES_STAT	(1L<<2)	/* Bit  2: (sc)	Reset the statistics module */
+								/* Bit  1:	reserved */
+#define XM_GP_INP_ASS	(1L<<0)	/* Bit  0: (ro) GP Input Pin asserted */
 
 
 /*	XM_IMSK		16 bit r/w	Interrupt Mask Register */
-/*	XM_ISRC		16 bit ro	Interrupt Status Register */
+/*	XM_ISRC		16 bit r/o	Interrupt Status Register */
 								/* Bit 15:	reserved */
 #define XM_IS_LNK_AE	(1<<14) /* Bit 14:	Link Asynchronous Event */
 #define XM_IS_TX_ABORT	(1<<13) /* Bit 13:	Transmit Abort, late Col. etc */
 #define XM_IS_FRC_INT	(1<<12) /* Bit 12:	Force INT bit set in GP */
 #define XM_IS_INP_ASS	(1<<11)	/* Bit 11:	Input Asserted, GP bit 0 set */
 #define XM_IS_LIPA_RC	(1<<10)	/* Bit 10:	Link Partner requests config */
-#define XM_IS_RX_PAGE	(1<<9)	/* Bit	9:	Page Received */
-#define XM_IS_TX_PAGE	(1<<8)	/* Bit	8:	Next Page Loaded for Transmit */
-#define XM_IS_AND		(1<<7)	/* Bit	7:	Auto Negotiation Done */
-#define XM_IS_TSC_OV	(1<<6)	/* Bit	6:	Time Stamp Counter Overflow */
-#define XM_IS_RXC_OV	(1<<5)	/* Bit	5:	Rx Counter Event Overflow */
-#define XM_IS_TXC_OV	(1<<4)	/* Bit	4:	Tx Counter Event Overflow */
-#define XM_IS_RXF_OV	(1<<3)	/* Bit	3:	Receive FIFO Overflow */
-#define XM_IS_TXF_UR	(1<<2)	/* Bit	2:	Transmit FIFO Underrun */
-#define XM_IS_TX_COMP	(1<<1)	/* Bit	1:	Frame Tx Complete */
-#define XM_IS_RX_COMP	(1<<0)	/* Bit	0:	Frame Rx Complete */
+#define XM_IS_RX_PAGE	(1<<9)	/* Bit  9:	Page Received */
+#define XM_IS_TX_PAGE	(1<<8)	/* Bit  8:	Next Page Loaded for Transmit */
+#define XM_IS_AND		(1<<7)	/* Bit  7:	Auto-Negotiation Done */
+#define XM_IS_TSC_OV	(1<<6)	/* Bit  6:	Time Stamp Counter Overflow */
+#define XM_IS_RXC_OV	(1<<5)	/* Bit  5:	Rx Counter Event Overflow */
+#define XM_IS_TXC_OV	(1<<4)	/* Bit  4:	Tx Counter Event Overflow */
+#define XM_IS_RXF_OV	(1<<3)	/* Bit  3:	Receive FIFO Overflow */
+#define XM_IS_TXF_UR	(1<<2)	/* Bit  2:	Transmit FIFO Underrun */
+#define XM_IS_TX_COMP	(1<<1)	/* Bit  1:	Frame Tx Complete */
+#define XM_IS_RX_COMP	(1<<0)	/* Bit  0:	Frame Rx Complete */
 
 #define XM_DEF_MSK	(~(XM_IS_INP_ASS | XM_IS_LIPA_RC | XM_IS_RX_PAGE |\
 			XM_IS_AND | XM_IS_RXC_OV | XM_IS_TXC_OV | XM_IS_TXF_UR))
@@ -384,50 +465,50 @@
 
 /*	XM_HW_CFG	16 bit r/w	Hardware Config Register */
 								/* Bit 15.. 4:	reserved */
-#define	XM_HW_GEN_EOP	(1<<3)	/* Bit	3:	generate End of Packet pulse */
-#define XM_HW_COM4SIG	(1<<2)	/* Bit	2:	use Comma Detect for Sig. Det.*/
-								/* Bit	1:	reserved */
-#define XM_HW_GMII_MD	(1<<0)	/* Bit	0:	GMII Interface selected */
+#define XM_HW_GEN_EOP	(1<<3)	/* Bit  3:	generate End of Packet pulse */
+#define XM_HW_COM4SIG	(1<<2)	/* Bit  2:	use Comma Detect for Sig. Det.*/
+								/* Bit  1:	reserved */
+#define XM_HW_GMII_MD	(1<<0)	/* Bit  0:	GMII Interface selected */
 
 
 /*	XM_TX_LO_WM	16 bit r/w	Tx FIFO Low Water Mark */
 /*	XM_TX_HI_WM	16 bit r/w	Tx FIFO High Water Mark */
 								/* Bit 15..10	reserved */
-#define	XM_TX_WM_MSK	0x01ff	/* Bit	9.. 0	Tx FIFO Watermark bits */
+#define XM_TX_WM_MSK	0x01ff	/* Bit  9.. 0	Tx FIFO Watermark bits */
 
 /*	XM_TX_THR	16 bit r/w	Tx Request Threshold */
 /*	XM_HT_THR	16 bit r/w	Host Request Threshold */
-/*	XM_RX_THR	16 bit r/w	Receive Request Threshold */
+/*	XM_RX_THR	16 bit r/w	Rx Request Threshold */
 								/* Bit 15..11	reserved */
-#define	XM_THR_MSK		0x03ff	/* Bit 10.. 0	Tx FIFO Watermark bits */
+#define XM_THR_MSK		0x03ff	/* Bit 10.. 0	Rx/Tx Request Threshold bits */
 
 
-/*	XM_TX_STAT	32 bit ro	Tx Status LIFO Register */
+/*	XM_TX_STAT	32 bit r/o	Tx Status LIFO Register */
 #define XM_ST_VALID		(1UL<<31)	/* Bit 31:	Status Valid */
 #define XM_ST_BYTE_CNT	(0x3fffL<<17)	/* Bit 30..17:	Tx frame Length */
 #define XM_ST_RETRY_CNT	(0x1fL<<12)	/* Bit 16..12:	Retry Count */
 #define XM_ST_EX_COL	(1L<<11)	/* Bit 11:	Excessive Collisions */
 #define XM_ST_EX_DEF	(1L<<10)	/* Bit 10:	Excessive Deferral */
-#define XM_ST_BURST		(1L<<9)		/* Bit	9:	p. xmitted in burst md*/
-#define XM_ST_DEFER		(1L<<8)		/* Bit	8:	packet was defered */
-#define XM_ST_BC		(1L<<7)		/* Bit	7:	Broadcast packet */
-#define XM_ST_MC		(1L<<6)		/* Bit	6:	Multicast packet */
-#define XM_ST_UC		(1L<<5)		/* Bit	5:	Unicast packet */
-#define XM_ST_TX_UR		(1L<<4)		/* Bit	4:	FIFO Underrun occured */
-#define XM_ST_CS_ERR	(1L<<3)		/* Bit	3:	Carrier Sense Error */
-#define XM_ST_LAT_COL	(1L<<2)		/* Bit	2:	Late Collision Error */
-#define XM_ST_MUL_COL	(1L<<1)		/* Bit	1:	Multiple Collisions */
-#define XM_ST_SGN_COL	(1L<<0)		/* Bit	0:	Single Collision */
+#define XM_ST_BURST		(1L<<9)		/* Bit  9:	p. xmitted in burst md*/
+#define XM_ST_DEFER		(1L<<8)		/* Bit  8:	packet was defered */
+#define XM_ST_BC		(1L<<7)		/* Bit  7:	Broadcast packet */
+#define XM_ST_MC		(1L<<6)		/* Bit  6:	Multicast packet */
+#define XM_ST_UC		(1L<<5)		/* Bit  5:	Unicast packet */
+#define XM_ST_TX_UR		(1L<<4)		/* Bit  4:	FIFO Underrun occured */
+#define XM_ST_CS_ERR	(1L<<3)		/* Bit  3:	Carrier Sense Error */
+#define XM_ST_LAT_COL	(1L<<2)		/* Bit  2:	Late Collision Error */
+#define XM_ST_MUL_COL	(1L<<1)		/* Bit  1:	Multiple Collisions */
+#define XM_ST_SGN_COL	(1L<<0)		/* Bit  0:	Single Collision */
 
 /*	XM_RX_LO_WM	16 bit r/w	Receive Low Water Mark */
 /*	XM_RX_HI_WM	16 bit r/w	Receive High Water Mark */
 									/* Bit 15..11:	reserved */
-#define	XM_RX_WM_MSK	0x03ff		/* Bit 11.. 0:	Rx FIFO Watermark bits */
+#define XM_RX_WM_MSK	0x03ff		/* Bit 11.. 0:	Rx FIFO Watermark bits */
 
 
-/*	XM_DEV_ID	32 bit ro	Device ID Register */
-#define	XM_DEV_OUI	(0x00ffffffUL<<8)	/* Bit 31..8:	Device OUI */
-#define XM_DEV_REV	(0x07L << 5)		/* Bit	7..5:	Chip Rev Num */
+/*	XM_DEV_ID	32 bit r/o	Device ID Register */
+#define XM_DEV_OUI	(0x00ffffffUL<<8)	/* Bit 31..8:	Device OUI */
+#define XM_DEV_REV	(0x07L << 5)		/* Bit  7..5:	Chip Rev Num */
 
 
 /*	XM_MODE		32 bit r/w	Mode Register */
@@ -435,10 +516,10 @@
 #define XM_MD_ENA_REJ	(1L<<26)	/* Bit 26:	Enable Frame Reject */
 #define XM_MD_SPOE_E	(1L<<25)	/* Bit 25:	Send Pause on Edge */
 									/* 		extern generated */
-#define XM_MD_TX_REP	(1L<<24)	/* Bit 24:	Transmit Repeater Mode*/
-#define XM_MD_SPOFF_I	(1L<<23)	/* Bit 23:	Send Pause on FIFOfull*/
+#define XM_MD_TX_REP	(1L<<24)	/* Bit 24:	Transmit Repeater Mode */
+#define XM_MD_SPOFF_I	(1L<<23)	/* Bit 23:	Send Pause on FIFO full */
 									/*		intern generated */
-#define XM_MD_LE_STW	(1L<<22)	/* Bit 22:	Rx Stat Word in Lit En*/
+#define XM_MD_LE_STW	(1L<<22)	/* Bit 22:	Rx Stat Word in Little Endian */
 #define XM_MD_TX_CONT	(1L<<21)	/* Bit 21:	Send Continuous */
 #define XM_MD_TX_PAUSE	(1L<<20)	/* Bit 20: (sc)	Send Pause Frame */
 #define XM_MD_ATS		(1L<<19)	/* Bit 19:	Append Time Stamp */
@@ -447,40 +528,40 @@
 #define XM_MD_SPOH_I	(1L<<17)	/* Bit 17:	Send Pause on High */
 									/*		intern generated */
 #define XM_MD_CAP		(1L<<16)	/* Bit 16:	Check Address Pair */
-#define XM_MD_ENA_HSH	(1L<<15)	/* Bit 15:	Enable Hashing */
+#define XM_MD_ENA_HASH	(1L<<15)	/* Bit 15:	Enable Hashing */
 #define XM_MD_CSA		(1L<<14)	/* Bit 14:	Check Station Address */
 #define XM_MD_CAA		(1L<<13)	/* Bit 13:	Check Address Array */
-#define XM_MD_RX_MCTRL	(1L<<12)	/* Bit 12:	Rx MAC Control Frames */
+#define XM_MD_RX_MCTRL	(1L<<12)	/* Bit 12:	Rx MAC Control Frame */
 #define XM_MD_RX_RUNT	(1L<<11)	/* Bit 11:	Rx Runt Frames */
-#define XM_MD_RX_IRLE	(1L<<10)	/* Bit 10:	Rx in Range Len Err F */
-#define XM_MD_RX_LONG	(1L<<9)		/* Bit	9:	Rx Long Frames */
-#define XM_MD_RX_CRCE	(1L<<8)		/* Bit	8:	Rx CRC Error Frames */
-#define XM_MD_RX_ERR	(1L<<7)		/* Bit	7:	Rx Error Frames */
-#define XM_MD_DIS_UC	(1L<<6)		/* Bit	6:	Disable Rx Unicast */
-#define XM_MD_DIS_MC	(1L<<5)		/* Bit	5:	Disable Rx Multicast */
-#define XM_MD_DIS_BC	(1L<<4)		/* Bit	4:	Disable Rx Boradcast */
-#define XM_MD_ENA_PROM	(1L<<3)		/* Bit	3:	Enable Promiscuous */
-#define XM_MD_ENA_BE	(1L<<2)		/* Bit	2:	Enable Big Endian */
-#define XM_MD_FTF		(1L<<1)		/* Bit	1: (sc)	Flush Tx FIFO */
-#define XM_MD_FRF		(1L<<0)		/* Bit	0: (sc)	Flush Rx FIFO */
-
-#define	XM_PAUSE_MODE	(XM_MD_SPOE_E | XM_MD_SPOL_I | XM_MD_SPOH_I)
-#define XM_DEF_MODE	(XM_MD_RX_RUNT | XM_MD_RX_IRLE | XM_MD_RX_LONG |\
-			 XM_MD_RX_CRCE | XM_MD_RX_ERR | XM_MD_CSA | XM_MD_CAA)
+#define XM_MD_RX_IRLE	(1L<<10)	/* Bit 10:	Rx in Range Len Err Frame */
+#define XM_MD_RX_LONG	(1L<<9)		/* Bit  9:	Rx Long Frame */
+#define XM_MD_RX_CRCE	(1L<<8)		/* Bit  8:	Rx CRC Error Frame */
+#define XM_MD_RX_ERR	(1L<<7)		/* Bit  7:	Rx Error Frame */
+#define XM_MD_DIS_UC	(1L<<6)		/* Bit  6:	Disable Rx Unicast */
+#define XM_MD_DIS_MC	(1L<<5)		/* Bit  5:	Disable Rx Multicast */
+#define XM_MD_DIS_BC	(1L<<4)		/* Bit  4:	Disable Rx Broadcast */
+#define XM_MD_ENA_PROM	(1L<<3)		/* Bit  3:	Enable Promiscuous */
+#define XM_MD_ENA_BE	(1L<<2)		/* Bit  2:	Enable Big Endian */
+#define XM_MD_FTF		(1L<<1)		/* Bit  1: (sc)	Flush Tx FIFO */
+#define XM_MD_FRF		(1L<<0)		/* Bit  0: (sc)	Flush Rx FIFO */
+
+#define XM_PAUSE_MODE	(XM_MD_SPOE_E | XM_MD_SPOL_I | XM_MD_SPOH_I)
+#define XM_DEF_MODE		(XM_MD_RX_RUNT | XM_MD_RX_IRLE | XM_MD_RX_LONG |\
+				XM_MD_RX_CRCE | XM_MD_RX_ERR | XM_MD_CSA | XM_MD_CAA)
 
 /*	XM_STAT_CMD	16 bit r/w	Statistics Command Register */
 								/* Bit 16..6:	reserved */
-#define XM_SC_SNP_RXC	(1<<5)	/* Bit	5: (sc)	Snap Rx Counters */
-#define XM_SC_SNP_TXC	(1<<4)	/* Bit	4: (sc)	Snap Tx Counters */
-#define XM_SC_CP_RXC	(1<<3)	/* Bit	3: 	Copy Rx Counters Continuously */
-#define XM_SC_CP_TXC	(1<<2)	/* Bit	2:	Copy Tx Counters Continuously */
-#define XM_SC_CLR_RXC	(1<<1)	/* Bit	1: (sc)	Clear Rx Counters */
-#define XM_SC_CLR_TXC	(1<<0)	/* Bit	0: (sc) Clear Tx Counters */
+#define XM_SC_SNP_RXC	(1<<5)	/* Bit  5: (sc)	Snap Rx Counters */
+#define XM_SC_SNP_TXC	(1<<4)	/* Bit  4: (sc)	Snap Tx Counters */
+#define XM_SC_CP_RXC	(1<<3)	/* Bit  3: 	Copy Rx Counters Continuously */
+#define XM_SC_CP_TXC	(1<<2)	/* Bit  2:	Copy Tx Counters Continuously */
+#define XM_SC_CLR_RXC	(1<<1)	/* Bit  1: (sc)	Clear Rx Counters */
+#define XM_SC_CLR_TXC	(1<<0)	/* Bit  0: (sc) Clear Tx Counters */
 
 
-/*	XM_RX_CNT_EV	32 bit ro	Rx Counter Event Register */
+/*	XM_RX_CNT_EV	32 bit r/o	Rx Counter Event Register */
 /*	XM_RX_EV_MSK	32 bit r/w	Rx Counter Event Mask */
-#define	XMR_MAX_SZ_OV	(1UL<<31)	/* Bit 31:	1024-MaxSize Rx Cnt Ov*/
+#define XMR_MAX_SZ_OV	(1UL<<31)	/* Bit 31:	1024-MaxSize Rx Cnt Ov*/
 #define XMR_1023B_OV	(1L<<30)	/* Bit 30:	512-1023Byte Rx Cnt Ov*/
 #define XMR_511B_OV		(1L<<29)	/* Bit 29:	256-511 Byte Rx Cnt Ov*/
 #define XMR_255B_OV		(1L<<28)	/* Bit 28:	128-255 Byte Rx Cnt Ov*/
@@ -502,20 +583,20 @@
 #define XMR_FRA_ERR_OV	(1L<<12)	/* Bit 12:	Rx Framing Err Cnt Ov */
 #define XMR_FMISS_OV	(1L<<11)	/* Bit 11:	Rx Missed Ev Cnt Ov */
 #define XMR_BURST		(1L<<10)	/* Bit 10:	Rx Burst Event Cnt Ov */
-#define XMR_INV_MOC		(1L<<9)		/* Bit	9:	Rx with inv. MAC OC Ov*/
-#define XMR_INV_MP		(1L<<8)		/* Bit	8:	Rx inv Pause Frame Ov */
-#define XMR_MCTRL_OV	(1L<<7)		/* Bit	7:	Rx MAC Ctrl-F Cnt Ov */
-#define XMR_MPAUSE_OV	(1L<<6)		/* Bit	6:	Rx Pause MAC Ctrl-F Ov*/
-#define XMR_UC_OK_OV	(1L<<5)		/* Bit	5:	Rx Unicast Frame CntOv*/
-#define XMR_MC_OK_OV	(1L<<4)		/* Bit	4:	Rx Multicast Cnt Ov */
-#define XMR_BC_OK_OV	(1L<<3)		/* Bit	3:	Rx Broadcast Cnt Ov */
-#define XMR_OK_LO_OV	(1L<<2)		/* Bit	2:	Octets Rx OK Low CntOv*/
-#define XMR_OK_HI_OV	(1L<<1)		/* Bit	1:	Octets Rx OK Hi Cnt Ov*/
-#define XMR_OK_OV		(1L<<0)		/* Bit	0:	Frames Received Ok Ov */
+#define XMR_INV_MOC		(1L<<9)		/* Bit  9:	Rx with inv. MAC OC Ov*/
+#define XMR_INV_MP		(1L<<8)		/* Bit  8:	Rx inv Pause Frame Ov */
+#define XMR_MCTRL_OV	(1L<<7)		/* Bit  7:	Rx MAC Ctrl-F Cnt Ov */
+#define XMR_MPAUSE_OV	(1L<<6)		/* Bit  6:	Rx Pause MAC Ctrl-F Ov*/
+#define XMR_UC_OK_OV	(1L<<5)		/* Bit  5:	Rx Unicast Frame CntOv*/
+#define XMR_MC_OK_OV	(1L<<4)		/* Bit  4:	Rx Multicast Cnt Ov */
+#define XMR_BC_OK_OV	(1L<<3)		/* Bit  3:	Rx Broadcast Cnt Ov */
+#define XMR_OK_LO_OV	(1L<<2)		/* Bit  2:	Octets Rx OK Low CntOv*/
+#define XMR_OK_HI_OV	(1L<<1)		/* Bit  1:	Octets Rx OK Hi Cnt Ov*/
+#define XMR_OK_OV		(1L<<0)		/* Bit  0:	Frames Received Ok Ov */
 
-#define XMR_DEF_MSK	0x00000006L	/* all bits excepting 1 and 2 */
+#define XMR_DEF_MSK		(XMR_OK_LO_OV | XMR_OK_HI_OV)
 
-/*	XM_TX_CNT_EV	32 bit ro	Tx Counter Event Register */
+/*	XM_TX_CNT_EV	32 bit r/o	Tx Counter Event Register */
 /*	XM_TX_EV_MSK	32 bit r/w	Tx Counter Event Mask */
 									/* Bit 31..26:	reserved */
 #define XMT_MAX_SZ_OV	(1L<<25)	/* Bit 25:	1024-MaxSize Tx Cnt Ov*/
@@ -534,18 +615,18 @@
 #define XMT_ABO_COL_OV	(1L<<12)	/* Bit 12:	Tx abo dueto Ex Col Ov*/
 #define XMT_MUL_COL_OV	(1L<<11)	/* Bit 11:	Tx Mult Col Cnt Ov */
 #define XMT_SNG_COL		(1L<<10)	/* Bit 10:	Tx Single Col Cnt Ov */
-#define XMT_MCTRL_OV	(1L<<9)		/* Bit	9:	Tx MAC Ctrl Counter Ov*/
-#define XMT_MPAUSE		(1L<<8)		/* Bit	8:	Tx Pause MAC Ctrl-F Ov*/
-#define XMT_BURST		(1L<<7)		/* Bit	7:	Tx Burst Event Cnt Ov */
-#define XMT_LONG		(1L<<6)		/* Bit	6:	Tx Long Frame Cnt Ov */
-#define XMT_UC_OK_OV	(1L<<5)		/* Bit	5:	Tx Unicast Cnt Ov */
-#define XMT_MC_OK_OV	(1L<<4)		/* Bit	4:	Tx Multicast Cnt Ov */
-#define XMT_BC_OK_OV	(1L<<3)		/* Bit	3:	Tx Broadcast Cnt Ov */
-#define XMT_OK_LO_OV	(1L<<2)		/* Bit	2:	Octets Tx OK Low CntOv*/
-#define XMT_OK_HI_OV	(1L<<1)		/* Bit	1:	Octets Tx OK Hi Cnt Ov*/
-#define XMT_OK_OV		(1L<<0)		/* Bit	0:	Frames Tx Ok Ov */
+#define XMT_MCTRL_OV	(1L<<9)		/* Bit  9:	Tx MAC Ctrl Counter Ov*/
+#define XMT_MPAUSE		(1L<<8)		/* Bit  8:	Tx Pause MAC Ctrl-F Ov*/
+#define XMT_BURST		(1L<<7)		/* Bit  7:	Tx Burst Event Cnt Ov */
+#define XMT_LONG		(1L<<6)		/* Bit  6:	Tx Long Frame Cnt Ov */
+#define XMT_UC_OK_OV	(1L<<5)		/* Bit  5:	Tx Unicast Cnt Ov */
+#define XMT_MC_OK_OV	(1L<<4)		/* Bit  4:	Tx Multicast Cnt Ov */
+#define XMT_BC_OK_OV	(1L<<3)		/* Bit  3:	Tx Broadcast Cnt Ov */
+#define XMT_OK_LO_OV	(1L<<2)		/* Bit  2:	Octets Tx OK Low CntOv*/
+#define XMT_OK_HI_OV	(1L<<1)		/* Bit  1:	Octets Tx OK Hi Cnt Ov*/
+#define XMT_OK_OV		(1L<<0)		/* Bit  0:	Frames Tx Ok Ov */
 
-#define XMT_DEF_MSK	0x00000006L	/* all bits excepting 1 and 2 */
+#define XMT_DEF_MSK		(XMT_OK_LO_OV | XMT_OK_HI_OV)
 
 /*
  * Receive Frame Status Encoding
@@ -559,16 +640,16 @@
 									/* Bit 12:	reserved */
 #define XMR_FS_BURST	(1L<<11)	/* Bit 11:	Burst Mode */
 #define XMR_FS_CEX_ERR	(1L<<10)	/* Bit 10:	Carrier Ext. Error */
-#define XMR_FS_802_3	(1L<<9)		/* Bit	9:	802.3 Frame */
-#define XMR_FS_COL_ERR	(1L<<8)		/* Bit	8:	Collision Error */
-#define XMR_FS_CAR_ERR	(1L<<7)		/* Bit	7:	Carrier Event Error */
-#define XMR_FS_LEN_ERR	(1L<<6)		/* Bit	6:	In-Range Length Error */
-#define XMR_FS_FRA_ERR	(1L<<5)		/* Bit	5:	Framing Error */
-#define XMR_FS_RUNT		(1L<<4)		/* Bit	4:	Runt Error */
-#define XMR_FS_LNG_ERR	(1L<<3)		/* Bit	3:	Gaint Error */
-#define XMR_FS_FCS_ERR	(1L<<2)		/* Bit	2:	Frame Check Sequ Err */
-#define XMR_FS_ERR		(1L<<1)		/* Bit	1:	Frame Error */
-#define XMR_FS_MCTRL	(1L<<0)		/* Bit	0:	MAC Control Packet */
+#define XMR_FS_802_3	(1L<<9)		/* Bit  9:	802.3 Frame */
+#define XMR_FS_COL_ERR	(1L<<8)		/* Bit  8:	Collision Error */
+#define XMR_FS_CAR_ERR	(1L<<7)		/* Bit  7:	Carrier Event Error */
+#define XMR_FS_LEN_ERR	(1L<<6)		/* Bit  6:	In-Range Length Error */
+#define XMR_FS_FRA_ERR	(1L<<5)		/* Bit  5:	Framing Error */
+#define XMR_FS_RUNT		(1L<<4)		/* Bit  4:	Runt Frame */
+#define XMR_FS_LNG_ERR	(1L<<3)		/* Bit  3:	Giant (Jumbo) Frame */
+#define XMR_FS_FCS_ERR	(1L<<2)		/* Bit  2:	Frame Check Sequ Err */
+#define XMR_FS_ERR		(1L<<1)		/* Bit  1:	Frame Error */
+#define XMR_FS_MCTRL	(1L<<0)		/* Bit  0:	MAC Control Packet */
 
 /*
  * XMR_FS_ERR will be set if
@@ -584,102 +665,135 @@
 /*
  * XMAC-PHY Registers, indirect addressed over the XMAC
  */
-#define	PHY_XMAC_CTRL		0x00	/* 16 bit r/w	PHY Control Register */
-#define	PHY_XMAC_STAT		0x01	/* 16 bit r/w	PHY Status Register */
-#define	PHY_XMAC_ID0		0x02	/* 16 bit ro	PHY ID0 Register */
-#define	PHY_XMAC_ID1		0x03	/* 16 bit ro	PHY ID1 Register */
-#define	PHY_XMAC_AUNE_ADV	0x04	/* 16 bit r/w	Autoneg Advertisement */
-#define	PHY_XMAC_AUNE_LP	0x05	/* 16 bit ro	Link Partner Abi Reg */
-#define	PHY_XMAC_AUNE_EXP	0x06	/* 16 bit ro	Autoneg Expansion Reg */
-#define	PHY_XMAC_NEPG		0x07	/* 16 bit r/w	Next Page Register */
-#define	PHY_XMAC_NEPG_LP	0x08	/* 16 bit ro	Next Page Link P Reg */
+#define PHY_XMAC_CTRL		0x00	/* 16 bit r/w	PHY Control Register */
+#define PHY_XMAC_STAT		0x01	/* 16 bit r/w	PHY Status Register */
+#define PHY_XMAC_ID0		0x02	/* 16 bit r/o	PHY ID0 Register */
+#define PHY_XMAC_ID1		0x03	/* 16 bit r/o	PHY ID1 Register */
+#define PHY_XMAC_AUNE_ADV	0x04	/* 16 bit r/w	Auto-Neg. Advertisement */
+#define PHY_XMAC_AUNE_LP	0x05	/* 16 bit r/o	Link Partner Abi Reg */
+#define PHY_XMAC_AUNE_EXP	0x06	/* 16 bit r/o	Auto-Neg. Expansion Reg */
+#define PHY_XMAC_NEPG		0x07	/* 16 bit r/w	Next Page Register */
+#define PHY_XMAC_NEPG_LP	0x08	/* 16 bit r/o	Next Page Link P Reg */
 	/* 0x09 - 0x0e:		reserved */
-#define	PHY_XMAC_EXT_STAT	0x0f	/* 16 bit ro	Ext Status Register */
-#define	PHY_XMAC_RES_ABI	0x10	/* 16 bit ro	PHY Resolved Ability */
+#define PHY_XMAC_EXT_STAT	0x0f	/* 16 bit r/o	Ext Status Register */
+#define PHY_XMAC_RES_ABI	0x10	/* 16 bit r/o	PHY Resolved Ability */
 
 /*----------------------------------------------------------------------------*/
 /*
  * Broadcom-PHY Registers, indirect addressed over XMAC
  */
-#define	PHY_BCOM_CTRL		0x00	/* 16 bit r/w	PHY Control Register */
-#define	PHY_BCOM_STAT		0x01	/* 16 bit ro	PHY Status Register */
-#define	PHY_BCOM_ID0		0x02	/* 16 bit ro	PHY ID0 Register */
-#define	PHY_BCOM_ID1		0x03	/* 16 bit ro	PHY ID1 Register */
-#define	PHY_BCOM_AUNE_ADV	0x04	/* 16 bit r/w	Autoneg Advertisement */
-#define	PHY_BCOM_AUNE_LP	0x05	/* 16 bit ro	Link Part Ability Reg */
-#define	PHY_BCOM_AUNE_EXP	0x06	/* 16 bit ro	Autoneg Expansion Reg */
-#define	PHY_BCOM_NEPG		0x07	/* 16 bit r/w	Next Page Register */
-#define	PHY_BCOM_NEPG_LP	0x08	/* 16 bit ro	Next Page Link P Reg */
+#define PHY_BCOM_CTRL		0x00	/* 16 bit r/w	PHY Control Register */
+#define PHY_BCOM_STAT		0x01	/* 16 bit r/o	PHY Status Register */
+#define PHY_BCOM_ID0		0x02	/* 16 bit r/o	PHY ID0 Register */
+#define PHY_BCOM_ID1		0x03	/* 16 bit r/o	PHY ID1 Register */
+#define PHY_BCOM_AUNE_ADV	0x04	/* 16 bit r/w	Auto-Neg. Advertisement */
+#define PHY_BCOM_AUNE_LP	0x05	/* 16 bit r/o	Link Part Ability Reg */
+#define PHY_BCOM_AUNE_EXP	0x06	/* 16 bit r/o	Auto-Neg. Expansion Reg */
+#define PHY_BCOM_NEPG		0x07	/* 16 bit r/w	Next Page Register */
+#define PHY_BCOM_NEPG_LP	0x08	/* 16 bit r/o	Next Page Link P Reg */
 	/* Broadcom-specific registers */
-#define	PHY_BCOM_1000T_CTRL	0x09	/* 16 bit r/w	1000Base-T Ctrl Reg */
-#define	PHY_BCOM_1000T_STAT	0x0a	/* 16 bit ro	1000Base-T Status Reg */
+#define PHY_BCOM_1000T_CTRL	0x09	/* 16 bit r/w	1000Base-T Ctrl Reg */
+#define PHY_BCOM_1000T_STAT	0x0a	/* 16 bit r/o	1000Base-T Status Reg */
 	/* 0x0b - 0x0e:		reserved */
-#define	PHY_BCOM_EXT_STAT	0x0f	/* 16 bit ro	Extended Status Reg */
-#define	PHY_BCOM_P_EXT_CTRL	0x10	/* 16 bit r/w	PHY Extended Ctrl Reg */
-#define	PHY_BCOM_P_EXT_STAT	0x11	/* 16 bit ro	PHY Extended Stat Reg */
-#define	PHY_BCOM_RE_CTR		0x12	/* 16 bit r/w	Receive Error Counter */
-#define	PHY_BCOM_FC_CTR		0x13	/* 16 bit r/w	False Carr Sense Cnt */
-#define	PHY_BCOM_RNO_CTR	0x14	/* 16 bit r/w	Receiver NOT_OK Cnt */
+#define PHY_BCOM_EXT_STAT	0x0f	/* 16 bit r/o	Extended Status Reg */
+#define PHY_BCOM_P_EXT_CTRL	0x10	/* 16 bit r/w	PHY Extended Ctrl Reg */
+#define PHY_BCOM_P_EXT_STAT	0x11	/* 16 bit r/o	PHY Extended Stat Reg */
+#define PHY_BCOM_RE_CTR		0x12	/* 16 bit r/w	Receive Error Counter */
+#define PHY_BCOM_FC_CTR		0x13	/* 16 bit r/w	False Carr Sense Cnt */
+#define PHY_BCOM_RNO_CTR	0x14	/* 16 bit r/w	Receiver NOT_OK Cnt */
 	/* 0x15 - 0x17:		reserved */
-#define	PHY_BCOM_AUX_CTRL	0x18	/* 16 bit r/w	Auxiliary Control Reg */
-#define	PHY_BCOM_AUX_STAT	0x19	/* 16 bit ro	Auxiliary Stat Summary*/
-#define	PHY_BCOM_INT_STAT	0x1a	/* 16 bit ro	Interrupt Status Reg */
-#define	PHY_BCOM_INT_MASK	0x1b	/* 16 bit r/w	Interrupt Mask Reg */
+#define PHY_BCOM_AUX_CTRL	0x18	/* 16 bit r/w	Auxiliary Control Reg */
+#define PHY_BCOM_AUX_STAT	0x19	/* 16 bit r/o	Auxiliary Stat Summary */
+#define PHY_BCOM_INT_STAT	0x1a	/* 16 bit r/o	Interrupt Status Reg */
+#define PHY_BCOM_INT_MASK	0x1b	/* 16 bit r/w	Interrupt Mask Reg */
 	/* 0x1c:		reserved */
 	/* 0x1d - 0x1f:		test registers */
 
 /*----------------------------------------------------------------------------*/
 /*
+ * Marvel-PHY Registers, indirect addressed over GMAC
+ */
+#define PHY_MARV_CTRL		0x00	/* 16 bit r/w	PHY Control Register */
+#define PHY_MARV_STAT		0x01	/* 16 bit r/o	PHY Status Register */
+#define PHY_MARV_ID0		0x02	/* 16 bit r/o	PHY ID0 Register */
+#define PHY_MARV_ID1		0x03	/* 16 bit r/o	PHY ID1 Register */
+#define PHY_MARV_AUNE_ADV	0x04	/* 16 bit r/w	Auto-Neg. Advertisement */
+#define PHY_MARV_AUNE_LP	0x05	/* 16 bit r/o	Link Part Ability Reg */
+#define PHY_MARV_AUNE_EXP	0x06	/* 16 bit r/o	Auto-Neg. Expansion Reg */
+#define PHY_MARV_NEPG		0x07	/* 16 bit r/w	Next Page Register */
+#define PHY_MARV_NEPG_LP	0x08	/* 16 bit r/o	Next Page Link P Reg */
+	/* Marvel-specific registers */
+#define PHY_MARV_1000T_CTRL	0x09	/* 16 bit r/w	1000Base-T Ctrl Reg */
+#define PHY_MARV_1000T_STAT	0x0a	/* 16 bit r/o	1000Base-T Status Reg */
+	/* 0x0b - 0x0e:		reserved */
+#define PHY_MARV_EXT_STAT	0x0f	/* 16 bit r/o	Extended Status Reg */
+#define PHY_MARV_PHY_CTRL	0x10	/* 16 bit r/w	PHY Specific Ctrl Reg */
+#define PHY_MARV_PHY_STAT	0x11	/* 16 bit r/o	PHY Specific Stat Reg */
+#define PHY_MARV_INT_MASK	0x12	/* 16 bit r/w	Interrupt Mask Reg */
+#define PHY_MARV_INT_STAT	0x13	/* 16 bit r/o	Interrupt Status Reg */
+#define PHY_MARV_EXT_CTRL	0x14	/* 16 bit r/w	Ext. PHY Specific Ctrl */
+#define PHY_MARV_RXE_CNT	0x15	/* 16 bit r/w	Receive Error Counter */
+#define PHY_MARV_EXT_ADR	0x16	/* 16 bit r/w	Ext. Ad. for Cable Diag. */
+	/* 0x17:		reserved */
+#define PHY_MARV_LED_CTRL	0x18	/* 16 bit r/w	LED Control Reg */
+#define PHY_MARV_LED_OVER	0x19	/* 16 bit r/w	Manual LED Override Reg */
+#define PHY_MARV_EXT_CTRL_2	0x1a	/* 16 bit r/w	Ext. PHY Specific Ctrl 2 */
+#define PHY_MARV_EXT_P_STAT	0x1b	/* 16 bit r/w	Ext. PHY Spec. Stat Reg */
+#define PHY_MARV_CABLE_DIAG	0x1c	/* 16 bit r/o	Cable Diagnostic Reg */
+	/* 0x1d - 0x1f:		reserved */
+
+/*----------------------------------------------------------------------------*/
+/*
  * Level One-PHY Registers, indirect addressed over XMAC
  */
-#define	PHY_LONE_CTRL		0x00	/* 16 bit r/w	PHY Control Register */
-#define	PHY_LONE_STAT		0x01	/* 16 bit ro	PHY Status Register */
-#define	PHY_LONE_ID0		0x02	/* 16 bit ro	PHY ID0 Register */
-#define	PHY_LONE_ID1		0x03	/* 16 bit ro	PHY ID1 Register */
-#define	PHY_LONE_AUNE_ADV	0x04	/* 16 bit r/w	Autoneg Advertisement */
-#define	PHY_LONE_AUNE_LP	0x05	/* 16 bit ro	Link Part Ability Reg */
-#define	PHY_LONE_AUNE_EXP	0x06	/* 16 bit ro	Autoneg Expansion Reg */
-#define	PHY_LONE_NEPG		0x07	/* 16 bit r/w	Next Page Register */
-#define	PHY_LONE_NEPG_LP	0x08	/* 16 bit ro	Next Page Link Partner*/
+#define PHY_LONE_CTRL		0x00	/* 16 bit r/w	PHY Control Register */
+#define PHY_LONE_STAT		0x01	/* 16 bit r/o	PHY Status Register */
+#define PHY_LONE_ID0		0x02	/* 16 bit r/o	PHY ID0 Register */
+#define PHY_LONE_ID1		0x03	/* 16 bit r/o	PHY ID1 Register */
+#define PHY_LONE_AUNE_ADV	0x04	/* 16 bit r/w	Auto-Neg. Advertisement */
+#define PHY_LONE_AUNE_LP	0x05	/* 16 bit r/o	Link Part Ability Reg */
+#define PHY_LONE_AUNE_EXP	0x06	/* 16 bit r/o	Auto-Neg. Expansion Reg */
+#define PHY_LONE_NEPG		0x07	/* 16 bit r/w	Next Page Register */
+#define PHY_LONE_NEPG_LP	0x08	/* 16 bit r/o	Next Page Link Partner*/
 	/* Level One-specific registers */
-#define	PHY_LONE_1000T_CTRL	0x09	/* 16 bit r/w	1000Base-T Control Reg*/
-#define	PHY_LONE_1000T_STAT	0x0a	/* 16 bit ro	1000Base-T Status Reg */
+#define PHY_LONE_1000T_CTRL	0x09	/* 16 bit r/w	1000Base-T Control Reg*/
+#define PHY_LONE_1000T_STAT	0x0a	/* 16 bit r/o	1000Base-T Status Reg */
 	/* 0x0b -0x0e:		reserved */
-#define	PHY_LONE_EXT_STAT	0x0f	/* 16 bit ro	Extended Status Reg */
-#define	PHY_LONE_PORT_CFG	0x10	/* 16 bit r/w	Port Configuration Reg*/
-#define	PHY_LONE_Q_STAT		0x11	/* 16 bit ro	Quick Status Reg */
-#define	PHY_LONE_INT_ENAB	0x12	/* 16 bit r/w	Interrupt Enable Reg */
-#define	PHY_LONE_INT_STAT	0x13	/* 16 bit ro	Interrupt Status Reg */
-#define	PHY_LONE_LED_CFG	0x14	/* 16 bit r/w	LED Configuration Reg */
-#define	PHY_LONE_PORT_CTRL	0x15	/* 16 bit r/w	Port Control Reg */
-#define	PHY_LONE_CIM		0x16	/* 16 bit ro	CIM Reg */
+#define PHY_LONE_EXT_STAT	0x0f	/* 16 bit r/o	Extended Status Reg */
+#define PHY_LONE_PORT_CFG	0x10	/* 16 bit r/w	Port Configuration Reg*/
+#define PHY_LONE_Q_STAT		0x11	/* 16 bit r/o	Quick Status Reg */
+#define PHY_LONE_INT_ENAB	0x12	/* 16 bit r/w	Interrupt Enable Reg */
+#define PHY_LONE_INT_STAT	0x13	/* 16 bit r/o	Interrupt Status Reg */
+#define PHY_LONE_LED_CFG	0x14	/* 16 bit r/w	LED Configuration Reg */
+#define PHY_LONE_PORT_CTRL	0x15	/* 16 bit r/w	Port Control Reg */
+#define PHY_LONE_CIM		0x16	/* 16 bit r/o	CIM Reg */
 	/* 0x17 -0x1c:		reserved */
 
 /*----------------------------------------------------------------------------*/
 /*
  * National-PHY Registers, indirect addressed over XMAC
  */
-#define	PHY_NAT_CTRL		0x00	/* 16 bit r/w	PHY Control Register */
-#define	PHY_NAT_STAT		0x01	/* 16 bit r/w	PHY Status Register */
-#define	PHY_NAT_ID0			0x02	/* 16 bit ro	PHY ID0 Register */
-#define	PHY_NAT_ID1			0x03	/* 16 bit ro	PHY ID1 Register */
-#define	PHY_NAT_AUNE_ADV	0x04	/* 16 bit r/w	Autonegotiation Advertisement */
-#define	PHY_NAT_AUNE_LP		0x05	/* 16 bit ro	Link Partner Ability Reg */
-#define	PHY_NAT_AUNE_EXP	0x06	/* 16 bit ro	Autonegotiation Expansion Reg */
-#define	PHY_NAT_NEPG		0x07	/* 16 bit r/w	Next Page Register */
-#define	PHY_NAT_NEPG_LP		0x08	/* 16 bit ro	Next Page Link Partner Reg */
+#define PHY_NAT_CTRL		0x00	/* 16 bit r/w	PHY Control Register */
+#define PHY_NAT_STAT		0x01	/* 16 bit r/w	PHY Status Register */
+#define PHY_NAT_ID0			0x02	/* 16 bit r/o	PHY ID0 Register */
+#define PHY_NAT_ID1			0x03	/* 16 bit r/o	PHY ID1 Register */
+#define PHY_NAT_AUNE_ADV	0x04	/* 16 bit r/w	Auto-Neg. Advertisement */
+#define PHY_NAT_AUNE_LP		0x05	/* 16 bit r/o	Link Partner Ability Reg */
+#define PHY_NAT_AUNE_EXP	0x06	/* 16 bit r/o	Auto-Neg. Expansion Reg */
+#define PHY_NAT_NEPG		0x07	/* 16 bit r/w	Next Page Register */
+#define PHY_NAT_NEPG_LP		0x08	/* 16 bit r/o	Next Page Link Partner Reg */
 	/* National-specific registers */
-#define	PHY_NAT_1000T_CTRL	0x09	/* 16 bit r/w	1000Base-T Control Reg */
-#define	PHY_NAT_1000T_STAT	0x0a	/* 16 bit ro	1000Base-T Status Reg */
+#define PHY_NAT_1000T_CTRL	0x09	/* 16 bit r/w	1000Base-T Control Reg */
+#define PHY_NAT_1000T_STAT	0x0a	/* 16 bit r/o	1000Base-T Status Reg */
 	/* 0x0b -0x0e:		reserved */
-#define	PHY_NAT_EXT_STAT	0x0f	/* 16 bit ro	Extended Status Register */
-#define	PHY_NAT_EXT_CTRL1	0x10	/* 16 bit ro	Extended Control Reg1 */
-#define	PHY_NAT_Q_STAT1		0x11	/* 16 bit ro	Quick Status Reg1 */
-#define	PHY_NAT_10B_OP		0x12	/* 16 bit ro	10Base-T Operations Reg */
-#define	PHY_NAT_EXT_CTRL2	0x13	/* 16 bit ro	Extended Control Reg1 */
-#define	PHY_NAT_Q_STAT2		0x14	/* 16 bit ro	Quick Status Reg2 */
+#define PHY_NAT_EXT_STAT	0x0f	/* 16 bit r/o	Extended Status Register */
+#define PHY_NAT_EXT_CTRL1	0x10	/* 16 bit r/o	Extended Control Reg1 */
+#define PHY_NAT_Q_STAT1		0x11	/* 16 bit r/o	Quick Status Reg1 */
+#define PHY_NAT_10B_OP		0x12	/* 16 bit r/o	10Base-T Operations Reg */
+#define PHY_NAT_EXT_CTRL2	0x13	/* 16 bit r/o	Extended Control Reg1 */
+#define PHY_NAT_Q_STAT2		0x14	/* 16 bit r/o	Quick Status Reg2 */
 	/* 0x15 -0x18:		reserved */
-#define	PHY_NAT_PHY_ADDR	0x19	/* 16 bit ro	PHY Address Register */
+#define PHY_NAT_PHY_ADDR	0x19	/* 16 bit r/o	PHY Address Register */
 
 
 /*----------------------------------------------------------------------------*/
@@ -691,201 +805,205 @@
  * All other are general.
  */
 
-/*****	PHY_XMAC_CTRL	16 bit r/w	PHY Control Register *****/
-/*****	PHY_BCOM_CTRL	16 bit r/w	PHY Control Register *****/
-/*****	PHY_LONE_CTRL	16 bit r/w	PHY Control Register *****/
-#define	PHY_CT_RESET	(1<<15)	/* Bit 15: (sc)	clear all PHY releated regs */
+/*****  PHY_XMAC_CTRL	16 bit r/w	PHY Control Register *****/
+/*****  PHY_BCOM_CTRL	16 bit r/w	PHY Control Register *****/
+/*****  PHY_LONE_CTRL	16 bit r/w	PHY Control Register *****/
+#define PHY_CT_RESET	(1<<15)	/* Bit 15: (sc)	clear all PHY related regs */
 #define PHY_CT_LOOP		(1<<14)	/* Bit 14:	enable Loopback over PHY */
 #define PHY_CT_SPS_LSB	(1<<13) /* Bit 13: (BC,L1) Speed select, lower bit */
-#define PHY_CT_ANE		(1<<12)	/* Bit 12:	Autonegotiation Enabled */
+#define PHY_CT_ANE		(1<<12)	/* Bit 12:	Auto-Negotiation Enabled */
 #define PHY_CT_PDOWN	(1<<11)	/* Bit 11: (BC,L1) Power Down Mode */
 #define PHY_CT_ISOL		(1<<10)	/* Bit 10: (BC,L1) Isolate Mode */
-#define PHY_CT_RE_CFG	(1<<9)	/* Bit	9: (sc) Restart Autonegotiation */
-#define PHY_CT_DUP_MD	(1<<8)	/* Bit	8:	Duplex Mode */
-#define PHY_CT_COL_TST	(1<<7)	/* Bit	7: (BC,L1) Collsion Test enabled */
-#define PHY_CT_SPS_MSB	(1<<6)	/* Bit	6: (BC,L1) Speed select, upper bit */
-								/* Bit	5..0:	reserved */
-
-#define PHY_B_CT_SP1000	(1<<6)	/* Bit  6:	enable speed of 1000 MBit/s */
-#define PHY_B_CT_SP100	(1<<13)	/* Bit 13:	enable speed of  100 MBit/s */
-#define PHY_B_CT_SP10	(0)	/* Bit 6/13 not set,	speed of  10 MBit/s */
-
-#define PHY_L_CT_SP1000	(1<<6)	/* Bit  6:      enable speed of 1000 MBit/s */
-#define PHY_L_CT_SP100	(1<<13)	/* Bit 13:      enable speed of  100 MBit/s */
-#define PHY_L_CT_SP10	(0)	/* Bit 6/13 not set,    speed of  10 MBit/s */
-
-
-/*****	PHY_XMAC_STAT	16 bit r/w	PHY Status Register *****/
-/*****	PHY_BCOM_STAT	16 bit r/w	PHY Status Register *****/
-/*****	PHY_LONE_STAT	16 bit r/w	PHY Status Register *****/
+#define PHY_CT_RE_CFG	(1<<9)	/* Bit  9: (sc) Restart Auto-Negotiation */
+#define PHY_CT_DUP_MD	(1<<8)	/* Bit  8:	Duplex Mode */
+#define PHY_CT_COL_TST	(1<<7)	/* Bit  7: (BC,L1) Collision Test enabled */
+#define PHY_CT_SPS_MSB	(1<<6)	/* Bit  6: (BC,L1) Speed select, upper bit */
+								/* Bit  5..0:	reserved */
+
+#define PHY_CT_SP1000	PHY_CT_SPS_MSB	/* enable speed of 1000 Mbps */
+#define PHY_CT_SP100	PHY_CT_SPS_LSB	/* enable speed of  100 Mbps */
+#define PHY_CT_SP10		(0)				/* enable speed of   10 Mbps */
+
+
+/*****  PHY_XMAC_STAT	16 bit r/w	PHY Status Register *****/
+/*****  PHY_BCOM_STAT	16 bit r/w	PHY Status Register *****/
+/*****  PHY_MARV_STAT	16 bit r/w	PHY Status Register *****/
+/*****  PHY_LONE_STAT	16 bit r/w	PHY Status Register *****/
 								/* Bit 15..9:	reserved */
-				/*	(BC/L1) 100/10 MBit/s cap bits ignored*/
-#define PHY_ST_EXT_ST	(1<<8)	/* Bit	8:	Extended Status Present */
-								/* Bit	7:	reserved */
-#define PHY_ST_PRE_SUB	(1<<6)	/* Bit	6: (BC/L1) preamble suppression */
-#define PHY_ST_AN_OVER	(1<<5)	/* Bit	5:	Autonegotiation Over */
-#define PHY_ST_REM_FLT	(1<<4)	/* Bit	4:	Remode Fault Condition Occured*/
-#define PHY_ST_AN_CAP	(1<<3)	/* Bit	3:	Autonegotiation Capability */
-#define PHY_ST_LSYNC	(1<<2)	/* Bit	2:	Link Synchronized */
-#define PHY_ST_JAP_DET	(1<<1)	/* Bit	1: (BC/L1) Japper Detected */
-#define PHY_ST_EXT_REG	(1<<0)	/* Bit	0:	Extended Register available */
-
-
-/*	PHY_XMAC_ID1		16 bit ro	PHY ID1 Register */
-/*	PHY_BCOM_ID1		16 bit ro	PHY ID1 Register */
-/*	PHY_LONE_ID1		16 bit ro	PHY ID1 Register */
-#define	PHY_I1_OUI		(0x3f<<10)	/* Bit 15..10:	Organiz. Unique ID */
-#define PHY_I1_MOD_NUM	(0x3f<<4)	/* Bit	9.. 4:	Model Number */
-#define PHY_I1_REV		(0x0f<<0)	/* Bit	3.. 0:	Revision Number */
+				/*	(BC/L1) 100/10 Mbps cap bits ignored*/
+#define PHY_ST_EXT_ST	(1<<8)	/* Bit  8:	Extended Status Present */
+								/* Bit  7:	reserved */
+#define PHY_ST_PRE_SUP	(1<<6)	/* Bit  6: (BC/L1) preamble suppression */
+#define PHY_ST_AN_OVER	(1<<5)	/* Bit  5:	Auto-Negotiation Over */
+#define PHY_ST_REM_FLT	(1<<4)	/* Bit  4:	Remote Fault Condition Occured */
+#define PHY_ST_AN_CAP	(1<<3)	/* Bit  3:	Auto-Negotiation Capability */
+#define PHY_ST_LSYNC	(1<<2)	/* Bit  2:	Link Synchronized */
+#define PHY_ST_JAB_DET	(1<<1)	/* Bit  1: (BC/L1) Jabber Detected */
+#define PHY_ST_EXT_REG	(1<<0)	/* Bit  0:	Extended Register available */
+
+
+/*****	PHY_XMAC_ID1		16 bit r/o	PHY ID1 Register */
+/*****	PHY_BCOM_ID1		16 bit r/o	PHY ID1 Register */
+/*****	PHY_MARV_ID1		16 bit r/o	PHY ID1 Register */
+/*****	PHY_LONE_ID1		16 bit r/o	PHY ID1 Register */
+#define PHY_I1_OUI_MSK	(0x3f<<10)	/* Bit 15..10:	Organization Unique ID */
+#define PHY_I1_MOD_NUM	(0x3f<<4)	/* Bit  9.. 4:	Model Number */
+#define PHY_I1_REV_MSK	0x0f		/* Bit  3.. 0:	Revision Number */
+
+/* different Broadcom PHY Ids */
+#define PHY_BCOM_ID1_A1		0x6041
+#define PHY_BCOM_ID1_B2		0x6043
+#define PHY_BCOM_ID1_C0		0x6044
+#define PHY_BCOM_ID1_C5		0x6047
 
 
-/*****	PHY_XMAC_AUNE_ADV	16 bit r/w	Autoneg Advertisement *****/
-/*****	PHY_XMAC_AUNE_LP	16 bit ro	Link Partner Ability Reg *****/
+/*****  PHY_XMAC_AUNE_ADV	16 bit r/w	Auto-Negotiation Advertisement *****/
+/*****  PHY_XMAC_AUNE_LP	16 bit r/o	Link Partner Ability Reg *****/
 #define PHY_AN_NXT_PG	(1<<15)	/* Bit 15:	Request Next Page */
 #define PHY_X_AN_ACK	(1<<14)	/* Bit 14: (ro)	Acknowledge Received */
-#define PHY_X_AN_RFB	(3<<12)	/* Bit 13..12:	Remode Fault Bits */
+#define PHY_X_AN_RFB	(3<<12)	/* Bit 13..12:	Remote Fault Bits */
 								/* Bit 11.. 9:	reserved */
-#define PHY_X_AN_PAUSE	(3<<7)	/* Bit	8.. 7:	Pause Bits */
-#define PHY_X_AN_HD		(1<<6)	/* Bit	6:	Half Duplex */
-#define PHY_X_AN_FD		(1<<5)	/* Bit	5:	Full Duplex */
-								/* Bit	4.. 0:	reserved */
+#define PHY_X_AN_PAUSE	(3<<7)	/* Bit  8.. 7:	Pause Bits */
+#define PHY_X_AN_HD		(1<<6)	/* Bit  6:	Half Duplex */
+#define PHY_X_AN_FD		(1<<5)	/* Bit  5:	Full Duplex */
+								/* Bit  4.. 0:	reserved */
 
-/*****	PHY_BCOM_AUNE_ADV	16 bit r/w	Autoneg Advertisement *****/
-/*****	PHY_BCOM_AUNE_LP	16 bit ro	Link Partner Ability Reg *****/
+/*****  PHY_BCOM_AUNE_ADV	16 bit r/w	Auto-Negotiation Advertisement *****/
+/*****  PHY_BCOM_AUNE_LP	16 bit r/o	Link Partner Ability Reg *****/
 /*	PHY_AN_NXT_PG		(see XMAC) Bit 15:	Request Next Page */
 								/* Bit 14:	reserved */
 #define PHY_B_AN_RF		(1<<13)	/* Bit 13:	Remote Fault */
 								/* Bit 12:	reserved */
-#define PHY_B_AN_ASP	(1<<11)	/* Bit 11:	Asymetric Pause */
+#define PHY_B_AN_ASP	(1<<11)	/* Bit 11:	Asymmetric Pause */
 #define PHY_B_AN_PC		(1<<10)	/* Bit 10:	Pause Capable */
-								/* Bit	9..5:	100/10 BT cap bits ingnored */
-#define PHY_B_AN_SEL	(0x1f<<0)/* Bit 4..0:	Selector Field, 00001=Ethernet*/
+								/* Bit  9..5:	100/10 BT cap bits ingnored */
+#define PHY_B_AN_SEL	0x1f	/* Bit 4..0:	Selector Field, 00001=Ethernet*/
 
-/*****	PHY_LONE_AUNE_ADV	16 bit r/w	Autoneg Advertisement *****/
-/*****	PHY_LONE_AUNE_LP	16 bit ro	Link Partner Ability Reg *****/
+/*****  PHY_LONE_AUNE_ADV	16 bit r/w	Auto-Negotiation Advertisement *****/
+/*****  PHY_LONE_AUNE_LP	16 bit r/o	Link Partner Ability Reg *****/
 /*	PHY_AN_NXT_PG		(see XMAC) Bit 15:	Request Next Page */
 								/* Bit 14:	reserved */
 #define PHY_L_AN_RF		(1<<13)	/* Bit 13:	Remote Fault */
 								/* Bit 12:	reserved */
-#define PHY_L_AN_ASP	(1<<11)	/* Bit 11:	Asymetric Pause */
+#define PHY_L_AN_ASP	(1<<11)	/* Bit 11:	Asymmetric Pause */
 #define PHY_L_AN_PC		(1<<10)	/* Bit 10:	Pause Capable */
-								/* Bit	9..5:	100/10 BT cap bits ingnored */
-#define PHY_L_AN_SEL	(0x1f<<0)/* Bit 4..0:	Selector Field, 00001=Ethernet*/
+								/* Bit  9..5:	100/10 BT cap bits ingnored */
+#define PHY_L_AN_SEL	0x1f	/* Bit 4..0:	Selector Field, 00001=Ethernet*/
 
-/*****	PHY_NAT_AUNE_ADV	16 bit r/w	Autoneg Advertisement *****/
-/*****	PHY_NAT_AUNE_LP	16 bit ro	Link Partner Ability Reg *****/
+/*****  PHY_NAT_AUNE_ADV	16 bit r/w	Auto-Negotiation Advertisement *****/
+/*****  PHY_NAT_AUNE_LP		16 bit r/o	Link Partner Ability Reg *****/
 /*	PHY_AN_NXT_PG		(see XMAC) Bit 15:	Request Next Page */
 								/* Bit 14:	reserved */
 #define PHY_N_AN_RF		(1<<13)	/* Bit 13:	Remote Fault */
 								/* Bit 12:	reserved */
 #define PHY_N_AN_100F	(1<<11)	/* Bit 11:	100Base-T2 FD Support */
 #define PHY_N_AN_100H	(1<<10)	/* Bit 10:	100Base-T2 HD Support */
-								/* Bit	9..5:	100/10 BT cap bits ingnored */
-#define PHY_N_AN_SEL	(0x1f<<0)/* Bit 4..0:	Selector Field, 00001=Ethernet*/
+								/* Bit  9..5:	100/10 BT cap bits ingnored */
+#define PHY_N_AN_SEL	0x1f	/* Bit 4..0:	Selector Field, 00001=Ethernet*/
 
 /* field type definition for PHY_x_AN_SEL */
 #define PHY_SEL_TYPE	0x01	/* 00001 = Ethernet */
 
-/*****	PHY_XMAC_AUNE_EXP	16 bit ro	Autoneg Expansion Reg *****/
-				/* Bit 15..4:	reserved */
-#define PHY_AN_LP_NP	(1<<3)	/* Bit	3:	Link Partner can Next Page */
-#define PHY_AN_LOC_NP	(1<<2)	/* Bit	2:	Local PHY can Next Page */
-#define PHY_AN_RX_PG	(1<<1)	/* Bit	1:	Page Received */
-								/* Bit	0:	reserved */
+/*****  PHY_XMAC_AUNE_EXP	16 bit r/o	Auto-Negotiation Expansion Reg *****/
+								/* Bit 15..4:	reserved */
+#define PHY_AN_LP_NP	(1<<3)	/* Bit  3:	Link Partner can Next Page */
+#define PHY_AN_LOC_NP	(1<<2)	/* Bit  2:	Local PHY can Next Page */
+#define PHY_AN_RX_PG	(1<<1)	/* Bit  1:	Page Received */
+								/* Bit  0:	reserved */
 
-/*****	PHY_BCOM_AUNE_EXP	16 bit ro	Autoneg Expansion Reg *****/
+/*****  PHY_BCOM_AUNE_EXP	16 bit r/o	Auto-Negotiation Expansion Reg *****/
 								/* Bit 15..5:	reserved */
-#define PHY_B_AN_PDF	(1<<4)	/* Bit	4:	Parallel Detection Fault */
-/*	PHY_AN_LP_NP		(see XMAC) Bit	3:	Link Partner can Next Page */
-/*	PHY_AN_LOC_NP		(see XMAC) Bit	2:	Local PHY can Next Page */
-/*	PHY_AN_RX_PG		(see XMAC) Bit	1:	Page Received */
-#define PHY_B_AN_LP_CAP	(1<<0)	/* Bit	0:	Link Partner Autoneg Cap. */ 	
-
-/*****	PHY_LONE_AUNE_EXP	16 bit ro	Autoneg Expansion Reg *****/
-#define PHY_L_AN_BP		(1<<5)	/* Bit	5:	Base Page Indication */
-#define PHY_L_AN_PDF	(1<<4)	/* Bit	4:	Parallel Detection Fault */
-/*	PHY_AN_LP_NP		(see XMAC) Bit	3:	Link Partner can Next Page */
-/*	PHY_AN_LOC_NP		(see XMAC) Bit	2:	Local PHY can Next Page */
-/*	PHY_AN_RX_PG		(see XMAC) Bit	1:	Page Received */
-#define PHY_B_AN_LP_CAP	(1<<0)	/* Bit	0:	Link Partner Autoneg Cap. */ 	
-
-
-/*****	PHY_XMAC_NEPG		16 bit r/w	Next Page Register *****/
-/*****	PHY_BCOM_NEPG		16 bit r/w	Next Page Register *****/
-/*****	PHY_LONE_NEPG		16 bit r/w	Next Page Register *****/
-/*****	PHY_XMAC_NEPG_LP	16 bit ro	Next Page Link Partner *****/
-/*****	PHY_BCOM_NEPG_LP	16 bit ro	Next Page Link Partner *****/
-/*****	PHY_LONE_NEPG_LP	16 bit ro	Next Page Link Partner *****/
+#define PHY_B_AN_PDF	(1<<4)	/* Bit  4:	Parallel Detection Fault */
+/*	PHY_AN_LP_NP		(see XMAC) Bit  3:	Link Partner can Next Page */
+/*	PHY_AN_LOC_NP		(see XMAC) Bit  2:	Local PHY can Next Page */
+/*	PHY_AN_RX_PG		(see XMAC) Bit  1:	Page Received */
+#define PHY_B_AN_LP_CAP	(1<<0)	/* Bit  0:	Link Partner Auto-Neg. Cap. */ 	
+
+/*****  PHY_LONE_AUNE_EXP	16 bit r/o	Auto-Negotiation Expansion Reg *****/
+#define PHY_L_AN_BP		(1<<5)	/* Bit  5:	Base Page Indication */
+#define PHY_L_AN_PDF	(1<<4)	/* Bit  4:	Parallel Detection Fault */
+/*	PHY_AN_LP_NP		(see XMAC) Bit  3:	Link Partner can Next Page */
+/*	PHY_AN_LOC_NP		(see XMAC) Bit  2:	Local PHY can Next Page */
+/*	PHY_AN_RX_PG		(see XMAC) Bit  1:	Page Received */
+#define PHY_B_AN_LP_CAP	(1<<0)	/* Bit  0:	Link Partner Auto-Neg. Cap. */ 	
+
+
+/*****  PHY_XMAC_NEPG		16 bit r/w	Next Page Register *****/
+/*****  PHY_BCOM_NEPG		16 bit r/w	Next Page Register *****/
+/*****  PHY_LONE_NEPG		16 bit r/w	Next Page Register *****/
+/*****  PHY_XMAC_NEPG_LP	16 bit r/o	Next Page Link Partner *****/
+/*****  PHY_BCOM_NEPG_LP	16 bit r/o	Next Page Link Partner *****/
+/*****  PHY_LONE_NEPG_LP	16 bit r/o	Next Page Link Partner *****/
 #define PHY_NP_MORE		(1<<15)	/* Bit 15:	More, Next Pages to follow */
-#define PHY_NP_ACK1		(1<<14)	/* Bit 14: (ro)	Ack 1, for receiving a message*/
+#define PHY_NP_ACK1		(1<<14)	/* Bit 14: (ro)	Ack1, for receiving a message */
 #define PHY_NP_MSG_VAL	(1<<13)	/* Bit 13:	Message Page valid */
-#define PHY_NP_ACK2		(1<<12)	/* Bit 12:	Ack 2, comply with msg content*/
+#define PHY_NP_ACK2		(1<<12)	/* Bit 12:	Ack2, comply with msg content */
 #define PHY_NP_TOG		(1<<11)	/* Bit 11:	Toggle Bit, ensure sync */
 #define PHY_NP_MSG		0x07ff	/* Bit 10..0:	Message from/to Link Partner */
 
 /*
  * XMAC-Specific
  */
-/*****	PHY_XMAC_EXT_STAT	16 bit r/w	Extended Status Register *****/
+/*****  PHY_XMAC_EXT_STAT	16 bit r/w	Extended Status Register *****/
 #define PHY_X_EX_FD		(1<<15)	/* Bit 15:	Device Supports Full Duplex */
 #define PHY_X_EX_HD		(1<<14)	/* Bit 14:	Device Supports Half Duplex */
 								/* Bit 13..0:	reserved */
 
-/*****	PHY_XMAC_RES_ABI	16 bit ro	PHY Resolved Ability *****/
+/*****  PHY_XMAC_RES_ABI	16 bit r/o	PHY Resolved Ability *****/
 								/* Bit 15..9:	reserved */
-#define PHY_X_RS_PAUSE	(3<<7)	/* Bit	8..7:	selected Pause Mode */
-#define PHY_X_RS_HD		(1<<6)	/* Bit	6:	Half Duplex Mode selected */
-#define PHY_X_RS_FD		(1<<5)	/* Bit	5:	Full Duplex Mode selected */
-#define PHY_X_RS_ABLMIS (1<<4)	/* Bit	4:	duplex or pause cap mismatch */
-#define PHY_X_RS_PAUMIS (1<<3)	/* Bit	3:	pause capability missmatch */
-								/* Bit	2..0:	reserved */
+#define PHY_X_RS_PAUSE	(3<<7)	/* Bit  8..7:	selected Pause Mode */
+#define PHY_X_RS_HD		(1<<6)	/* Bit  6:	Half Duplex Mode selected */
+#define PHY_X_RS_FD		(1<<5)	/* Bit  5:	Full Duplex Mode selected */
+#define PHY_X_RS_ABLMIS (1<<4)	/* Bit  4:	duplex or pause cap mismatch */
+#define PHY_X_RS_PAUMIS (1<<3)	/* Bit  3:	pause capability missmatch */
+								/* Bit  2..0:	reserved */
 /*
  * Remote Fault Bits (PHY_X_AN_RFB) encoding
  */
-#define X_RFB_OK		(0<<12)	/* Bit 12..13	No errors, Link OK */
-#define X_RFB_LF		(1<<12)	/* Bit 12..13	Link Failure */
-#define X_RFB_OFF		(2<<12)	/* Bit 12..13	Offline */
-#define X_RFB_AN_ERR	(3<<12)	/* Bit 12..13	Autonegotiation Error */
+#define X_RFB_OK		(0<<12)	/* Bit 13..12	No errors, Link OK */
+#define X_RFB_LF		(1<<12)	/* Bit 13..12	Link Failure */
+#define X_RFB_OFF		(2<<12)	/* Bit 13..12	Offline */
+#define X_RFB_AN_ERR	(3<<12)	/* Bit 13..12	Auto-Negotiation Error */
 
 /*
  * Pause Bits (PHY_X_AN_PAUSE and PHY_X_RS_PAUSE) encoding
  */
-#define PHY_X_P_NO_PAUSE	(0<<7)	/* Bit	8..7:	no Pause Mode */
-#define PHY_X_P_SYM_MD		(1<<7)	/* Bit	8..7:	symmetric Pause Mode */
-#define PHY_X_P_ASYM_MD		(2<<7)	/* Bit	8..7:	asymmetric Pause Mode */
-#define PHY_X_P_BOTH_MD		(3<<7)	/* Bit	8..7:	both Pause Mode */
+#define PHY_X_P_NO_PAUSE	(0<<7)	/* Bit  8..7:	no Pause Mode */
+#define PHY_X_P_SYM_MD		(1<<7)	/* Bit  8..7:	symmetric Pause Mode */
+#define PHY_X_P_ASYM_MD		(2<<7)	/* Bit  8..7:	asymmetric Pause Mode */
+#define PHY_X_P_BOTH_MD		(3<<7)	/* Bit  8..7:	both Pause Mode */
 
 
 /*
  * Broadcom-Specific
  */
-/***** PHY_BCOM_1000T_CTRL	16 bit r/w	1000Base-T Control Reg *****/
-#define PHY_B_1000C_TEST	(7<<13)	/* Bit	15..13:	Test Modes */
-#define PHY_B_1000C_MSE		(1<<12)	/* Bit	12:	Master/Slave Enable */
-#define PHY_B_1000C_MSC		(1<<11)	/* Bit	11:	M/S Configuration */
-#define PHY_B_1000C_RD		(1<<10)	/* Bit	10:	Repeater/DTE */
-#define PHY_B_1000C_AFD		(1<<9)	/* Bit	9:	Advertise Full Duplex */
-#define PHY_B_1000C_AHD		(1<<8)	/* Bit	8:	Advertise Half Duplex */
-									/* Bit	7..0:	reserved */
-
-/***** PHY_BCOM_1000T_STAT	16 bit ro	1000Base-T Status Reg *****/
-#define PHY_B_1000S_MSF		(1<<15)	/* Bit	15:	Master/Slave Fault */
-#define PHY_B_1000S_MSR		(1<<14)	/* Bit	14:	Master/Slave Result */
-#define PHY_B_1000S_LRS		(1<<13)	/* Bit	13:	Local Receiver Status */
-#define PHY_B_1000S_RRS		(1<<12)	/* Bit	12:	Remote Receiver Status */
-#define PHY_B_1000S_LP_FD	(1<<11)	/* Bit	11:	Link Partner can FD */
-#define PHY_B_1000S_LP_HD	(1<<10)	/* Bit	10:	Link Partner can HD */
-									/* Bit	9..8:	reserved */
-#define PHY_B_1000S_IEC		(255<<0)/* Bit	7..0:	Idle Error Count */
+/*****  PHY_BCOM_1000T_CTRL	16 bit r/w	1000Base-T Control Reg *****/
+#define PHY_B_1000C_TEST	(7<<13)	/* Bit 15..13:	Test Modes */
+#define PHY_B_1000C_MSE		(1<<12)	/* Bit 12:	Master/Slave Enable */
+#define PHY_B_1000C_MSC		(1<<11)	/* Bit 11:	M/S Configuration */
+#define PHY_B_1000C_RD		(1<<10)	/* Bit 10:	Repeater/DTE */
+#define PHY_B_1000C_AFD		(1<<9)	/* Bit  9:	Advertise Full Duplex */
+#define PHY_B_1000C_AHD		(1<<8)	/* Bit  8:	Advertise Half Duplex */
+									/* Bit  7..0:	reserved */
+
+/*****  PHY_BCOM_1000T_STAT	16 bit r/o	1000Base-T Status Reg *****/
+#define PHY_B_1000S_MSF		(1<<15)	/* Bit 15:	Master/Slave Fault */
+#define PHY_B_1000S_MSR		(1<<14)	/* Bit 14:	Master/Slave Result */
+#define PHY_B_1000S_LRS		(1<<13)	/* Bit 13:	Local Receiver Status */
+#define PHY_B_1000S_RRS		(1<<12)	/* Bit 12:	Remote Receiver Status */
+#define PHY_B_1000S_LP_FD	(1<<11)	/* Bit 11:	Link Partner can FD */
+#define PHY_B_1000S_LP_HD	(1<<10)	/* Bit 10:	Link Partner can HD */
+									/* Bit  9..8:	reserved */
+#define PHY_B_1000S_IEC		0xff	/* Bit  7..0:	Idle Error Count */
 
-/*****	PHY_BCOM_EXT_STAT	16 bit ro	Extended Status Register *****/
+/*****  PHY_BCOM_EXT_STAT	16 bit r/o	Extended Status Register *****/
 #define PHY_B_ES_X_FD_CAP	(1<<15)	/* Bit 15:	1000Base-X FD capable */
 #define PHY_B_ES_X_HD_CAP	(1<<14)	/* Bit 14:	1000Base-X HD capable */
 #define PHY_B_ES_T_FD_CAP	(1<<13)	/* Bit 13:	1000Base-T FD capable */
 #define PHY_B_ES_T_HD_CAP	(1<<12)	/* Bit 12:	1000Base-T HD capable */
 									/* Bit 11..0:	reserved */
 
-/*****	PHY_BCOM_P_EXT_CTRL	16 bit r/w	PHY Extended Control Reg *****/
+/*****  PHY_BCOM_P_EXT_CTRL	16 bit r/w	PHY Extended Control Reg *****/
 #define PHY_B_PEC_MAC_PHY	(1<<15)	/* Bit 15:	10BIT/GMI-Interface */
 #define PHY_B_PEC_DIS_CROSS	(1<<14)	/* Bit 14:	Disable MDI Crossover */
 #define PHY_B_PEC_TX_DIS	(1<<13)	/* Bit 13:	Tx output Disabled */
@@ -901,9 +1019,9 @@
 #define PHY_B_PEC_LED_OFF	(1<<3)	/* Bit  3:	Force LED's off */
 #define PHY_B_PEC_EX_IPG	(1<<2)	/* Bit  2:	Extend Tx IPG Mode */
 #define PHY_B_PEC_3_LED		(1<<1)	/* Bit  1:	Three Link LED mode */
-#define PHY_B_PEC_HIGH_LA	(1<<0)	/* Bit  0:	GMII Fifo Elasticy */
+#define PHY_B_PEC_HIGH_LA	(1<<0)	/* Bit  0:	GMII FIFO Elasticy */
 
-/*****	PHY_BCOM_P_EXT_STAT	16 bit ro	PHY Extended Status Reg *****/
+/*****  PHY_BCOM_P_EXT_STAT	16 bit r/o	PHY Extended Status Reg *****/
 									/* Bit 15..14:	reserved */
 #define PHY_B_PES_CROSS_STAT	(1<<13)	/* Bit 13:	MDI Crossover Status */
 #define PHY_B_PES_INT_STAT	(1<<12)	/* Bit 12:	Interrupt Status */
@@ -920,20 +1038,20 @@
 #define PHY_B_PES_LOCK_ER	(1<<1)	/* Bit  1:	Lock Error */
 #define PHY_B_PES_MLT3_ER	(1<<0)	/* Bit  0:	MLT3 code Error */
 
-/*****	PHY_BCOM_FC_CTR		16 bit r/w	False Carrier Counter *****/
+/*****  PHY_BCOM_FC_CTR		16 bit r/w	False Carrier Counter *****/
 									/* Bit 15..8:	reserved */
-#define PHY_B_FC_CTR		(255<<0)/* Bit 7..0:	False Carrier Counter */
+#define PHY_B_FC_CTR		0xff	/* Bit  7..0:	False Carrier Counter */
 
-/*****	PHY_BCOM_RNO_CTR	16 bit r/w	Receive NOT_OK Counter *****/
-#define PHY_B_RC_LOC		(255<<8)/* Bit 15..8:	Local Rx NOT_OK cnt */
-#define PHY_B_RC_REM		(255<<0)/* Bit  7..0:	Remote Rx NOT_OK cnt */
+/*****  PHY_BCOM_RNO_CTR	16 bit r/w	Receive NOT_OK Counter *****/
+#define PHY_B_RC_LOC_MSK	0xff00	/* Bit 15..8:	Local Rx NOT_OK cnt */
+#define PHY_B_RC_REM_MSK	0x00ff	/* Bit  7..0:	Remote Rx NOT_OK cnt */
 
-/*****	PHY_BCOM_AUX_CTRL	16 bit r/w	Auxiliary Control Reg *****/
+/*****  PHY_BCOM_AUX_CTRL	16 bit r/w	Auxiliary Control Reg *****/
 #define PHY_B_AC_L_SQE		(1<<15)	/* Bit 15:	Low Squelch */
 #define PHY_B_AC_LONG_PACK	(1<<14)	/* Bit 14:	Rx Long Packets */
 #define PHY_B_AC_ER_CTRL	(3<<12)	/* Bit 13..12:	Edgerate Control */
 									/* Bit 11:	reserved */
-#define PHY_B_AC_TX_TST		(1<<10) /* Bit 10:	tx test bit, always 1 */
+#define PHY_B_AC_TX_TST		(1<<10) /* Bit 10:	Tx test bit, always 1 */
 									/* Bit  9.. 8:	reserved */
 #define PHY_B_AC_DIS_PRF	(1<<7)	/* Bit  7:	dis part resp filter */
 									/* Bit  6:	reserved */
@@ -942,14 +1060,14 @@
 #define PHY_B_AC_DIAG		(1<<3)	/* Bit  3:	Diagnostic Mode */
 									/* Bit  2.. 0:	reserved */
 
-/*****	PHY_BCOM_AUX_STAT	16 bit ro	Auxiliary Status Reg *****/
+/*****  PHY_BCOM_AUX_STAT	16 bit r/o	Auxiliary Status Reg *****/
 #define PHY_B_AS_AN_C		(1<<15)	/* Bit 15:	AutoNeg complete */
 #define PHY_B_AS_AN_CA		(1<<14)	/* Bit 14:	AN Complete Ack */
 #define PHY_B_AS_ANACK_D	(1<<13)	/* Bit 13:	AN Ack Detect */
 #define PHY_B_AS_ANAB_D		(1<<12)	/* Bit 12:	AN Ability Detect */
 #define PHY_B_AS_NPW		(1<<11)	/* Bit 11:	AN Next Page Wait */
-#define PHY_B_AS_AN_RES		(7<<8)	/* Bit 10..8:	AN HDC */
-#define PHY_B_AS_PDF		(1<<7)	/* Bit  7:	Parallel Detect. Fault*/
+#define PHY_B_AS_AN_RES_MSK	(7<<8)	/* Bit 10..8:	AN HDC */
+#define PHY_B_AS_PDF		(1<<7)	/* Bit  7:	Parallel Detect. Fault */
 #define PHY_B_AS_RF			(1<<6)	/* Bit  6:	Remote Fault */
 #define PHY_B_AS_ANP_R		(1<<5)	/* Bit  5:	AN Page Received */
 #define PHY_B_AS_LP_ANAB	(1<<4)	/* Bit  4:	LP AN Ability */
@@ -958,8 +1076,10 @@
 #define PHY_B_AS_PRR		(1<<1)	/* Bit  1:	Pause Resolution-Rx */
 #define PHY_B_AS_PRT		(1<<0)	/* Bit  0:	Pause Resolution-Tx */
 
-/*****	PHY_BCOM_INT_STAT	16 bit ro	Interrupt Status Reg *****/
-/*****	PHY_BCOM_INT_MASK	16 bit r/w	Interrupt Mask Reg *****/
+#define PHY_B_AS_PAUSE_MSK	(PHY_B_AS_PRR | PHY_B_AS_PRT)
+
+/*****  PHY_BCOM_INT_STAT	16 bit r/o	Interrupt Status Reg *****/
+/*****  PHY_BCOM_INT_MASK	16 bit r/w	Interrupt Mask Reg *****/
 									/* Bit 15:	reserved */
 #define PHY_B_IS_PSE		(1<<14)	/* Bit 14:	Pair Swap Error */
 #define PHY_B_IS_MDXI_SC	(1<<13)	/* Bit 13:	MDIX Status Change */
@@ -979,125 +1099,123 @@
 
 #define PHY_B_DEF_MSK	(~(PHY_B_IS_AN_PR | PHY_B_IS_LST_CHANGE))
 
-/*
- * Pause Bits (PHY_B_AN_ASP and PHY_B_AN_PC) encoding
- */
-#define PHY_B_P_NO_PAUSE	(0<<10)	/* Bit	11..10:	no Pause Mode */
-#define PHY_B_P_SYM_MD		(1<<10)	/* Bit	11..10:	symmetric Pause Mode */
-#define PHY_B_P_ASYM_MD		(2<<10)	/* Bit	11..10:	asymmetric Pause Mode */
-#define PHY_B_P_BOTH_MD		(3<<10)	/* Bit	11..10:	both Pause Mode */
+/* Pause Bits (PHY_B_AN_ASP and PHY_B_AN_PC) encoding */
+#define PHY_B_P_NO_PAUSE	(0<<10)	/* Bit 11..10:	no Pause Mode */
+#define PHY_B_P_SYM_MD		(1<<10)	/* Bit 11..10:	symmetric Pause Mode */
+#define PHY_B_P_ASYM_MD		(2<<10)	/* Bit 11..10:	asymmetric Pause Mode */
+#define PHY_B_P_BOTH_MD		(3<<10)	/* Bit 11..10:	both Pause Mode */
 
 /*
  * Resolved Duplex mode and Capabilities (Aux Status Summary Reg)
  */
-#define	PHY_B_RES_1000FD	(7<<8)	/* Bit	10..8:	1000Base-T Full Dup. */
-#define	PHY_B_RES_1000HD	(6<<8)	/* Bit	10..8:	1000Base-T Half Dup. */
+#define PHY_B_RES_1000FD	(7<<8)	/* Bit 10..8:	1000Base-T Full Dup. */
+#define PHY_B_RES_1000HD	(6<<8)	/* Bit 10..8:	1000Base-T Half Dup. */
 /* others: 100/10: invalid for us */
 
 /*
  * Level One-Specific
  */
-/*****	PHY_LONE_1000T_CTRL	16 bit r/w	1000Base-T Control Reg *****/
-#define PHY_L_1000C_TEST	(7<<13)	/* Bit	15..13:	Test Modes */
-#define PHY_L_1000C_MSE		(1<<12)	/* Bit	12:	Master/Slave Enable */
-#define PHY_L_1000C_MSC		(1<<11)	/* Bit	11:	M/S Configuration */
-#define PHY_L_1000C_RD		(1<<10)	/* Bit	10:	Repeater/DTE */
-#define PHY_L_1000C_AFD		(1<<9)	/* Bit	9:	Advertise Full Duplex */
-#define PHY_L_1000C_AHD		(1<<8)	/* Bit	8:	Advertise Half Duplex */
-									/* Bit	7..0:	reserved */
-
-/*****	PHY_LONE_1000T_STAT	16 bit ro	1000Base-T Status Reg *****/
-#define PHY_L_1000S_MSF		(1<<15)	/* Bit	15:	Master/Slave Fault */
-#define PHY_L_1000S_MSR		(1<<14)	/* Bit	14:	Master/Slave Result */
-#define PHY_L_1000S_LRS		(1<<13)	/* Bit	13:	Local Receiver Status */
-#define PHY_L_1000S_RRS		(1<<12)	/* Bit	12:	Remote Receiver Status*/
-#define PHY_L_1000S_LP_FD	(1<<11)	/* Bit	11:	Link Partner can FD */
-#define PHY_L_1000S_LP_HD	(1<<10)	/* Bit	10:	Link Partner can HD */
-									/* Bit	9..8:	reserved */
-#define PHY_B_1000S_IEC		(255<<0)/* Bit	7..0:	Idle Error Count */
+/*****  PHY_LONE_1000T_CTRL	16 bit r/w	1000Base-T Control Reg *****/
+#define PHY_L_1000C_TEST	(7<<13)	/* Bit 15..13:	Test Modes */
+#define PHY_L_1000C_MSE		(1<<12)	/* Bit 12:	Master/Slave Enable */
+#define PHY_L_1000C_MSC		(1<<11)	/* Bit 11:	M/S Configuration */
+#define PHY_L_1000C_RD		(1<<10)	/* Bit 10:	Repeater/DTE */
+#define PHY_L_1000C_AFD		(1<<9)	/* Bit  9:	Advertise Full Duplex */
+#define PHY_L_1000C_AHD		(1<<8)	/* Bit  8:	Advertise Half Duplex */
+									/* Bit  7..0:	reserved */
+
+/*****  PHY_LONE_1000T_STAT	16 bit r/o	1000Base-T Status Reg *****/
+#define PHY_L_1000S_MSF		(1<<15)	/* Bit 15:	Master/Slave Fault */
+#define PHY_L_1000S_MSR		(1<<14)	/* Bit 14:	Master/Slave Result */
+#define PHY_L_1000S_LRS		(1<<13)	/* Bit 13:	Local Receiver Status */
+#define PHY_L_1000S_RRS		(1<<12)	/* Bit 12:	Remote Receiver Status */
+#define PHY_L_1000S_LP_FD	(1<<11)	/* Bit 11:	Link Partner can FD */
+#define PHY_L_1000S_LP_HD	(1<<10)	/* Bit 10:	Link Partner can HD */
+									/* Bit  9..8:	reserved */
+#define PHY_B_1000S_IEC		0xff	/* Bit  7..0:	Idle Error Count */
 
-/*****	PHY_LONE_EXT_STAT	16 bit ro	Extended Status Register *****/
+/*****  PHY_LONE_EXT_STAT	16 bit r/o	Extended Status Register *****/
 #define PHY_L_ES_X_FD_CAP	(1<<15)	/* Bit 15:	1000Base-X FD capable */
 #define PHY_L_ES_X_HD_CAP	(1<<14)	/* Bit 14:	1000Base-X HD capable */
 #define PHY_L_ES_T_FD_CAP	(1<<13)	/* Bit 13:	1000Base-T FD capable */
 #define PHY_L_ES_T_HD_CAP	(1<<12)	/* Bit 12:	1000Base-T HD capable */
 									/* Bit 11..0:	reserved */
 
-/*****	PHY_LONE_PORT_CFG	16 bit r/w	Port Configuration Reg *****/
+/*****  PHY_LONE_PORT_CFG	16 bit r/w	Port Configuration Reg *****/
 #define PHY_L_PC_REP_MODE	(1<<15)	/* Bit 15:	Repeater Mode */
 									/* Bit 14:	reserved */
 #define PHY_L_PC_TX_DIS		(1<<13)	/* Bit 13:	Tx output Disabled */
 #define PHY_L_PC_BY_SCR		(1<<12)	/* Bit 12:	Bypass Scrambler */
 #define PHY_L_PC_BY_45		(1<<11)	/* Bit 11:	Bypass 4B5B-Decoder */
 #define PHY_L_PC_JAB_DIS	(1<<10)	/* Bit 10:	Jabber Disabled */
-#define PHY_L_PC_SQE		(1<<9)	/* Bit 9:	Enable Heartbeat */
-#define PHY_L_PC_TP_LOOP	(1<<8)	/* Bit 8:	TP Loopback */
-#define PHY_L_PC_SSS		(1<<7)	/* Bit 7:	Smart Speed Selection */
-#define PHY_L_PC_FIFO_SIZE	(1<<6)	/* Bit 6:	FIFO Size */
-#define PHY_L_PC_PRE_EN		(1<<5)	/* Bit 5:	Preamble Enable */
-#define PHY_L_PC_CIM		(1<<4)	/* Bit 4:	Carrier Integrity Mon */
-#define PHY_L_PC_10_SER		(1<<3)	/* Bit 3:	Use Serial Output */
-#define PHY_L_PC_ANISOL		(1<<2)	/* Bit 2:	Unisolate Port */
-#define PHY_L_PC_TEN_BIT	(1<<1)	/* Bit 1:	10bit iface mode on */
-#define PHY_L_PC_ALTCLOCK	(1<<0)	/* Bit 0: (ro)	ALTCLOCK Mode on */
+#define PHY_L_PC_SQE		(1<<9)	/* Bit  9:	Enable Heartbeat */
+#define PHY_L_PC_TP_LOOP	(1<<8)	/* Bit  8:	TP Loopback */
+#define PHY_L_PC_SSS		(1<<7)	/* Bit  7:	Smart Speed Selection */
+#define PHY_L_PC_FIFO_SIZE	(1<<6)	/* Bit  6:	FIFO Size */
+#define PHY_L_PC_PRE_EN		(1<<5)	/* Bit  5:	Preamble Enable */
+#define PHY_L_PC_CIM		(1<<4)	/* Bit  4:	Carrier Integrity Mon */
+#define PHY_L_PC_10_SER		(1<<3)	/* Bit  3:	Use Serial Output */
+#define PHY_L_PC_ANISOL		(1<<2)	/* Bit  2:	Unisolate Port */
+#define PHY_L_PC_TEN_BIT	(1<<1)	/* Bit  1:	10bit iface mode on */
+#define PHY_L_PC_ALTCLOCK	(1<<0)	/* Bit  0: (ro)	ALTCLOCK Mode on */
 
-/*****	PHY_LONE_Q_STAT		16 bit ro	Quick Status Reg *****/
+/*****  PHY_LONE_Q_STAT		16 bit r/o	Quick Status Reg *****/
 #define PHY_L_QS_D_RATE		(3<<14)	/* Bit 15..14:	Data Rate */
 #define PHY_L_QS_TX_STAT	(1<<13)	/* Bit 13:	Transmitting */
 #define PHY_L_QS_RX_STAT	(1<<12)	/* Bit 12:	Receiving */
 #define PHY_L_QS_COL_STAT	(1<<11)	/* Bit 11:	Collision */
 #define PHY_L_QS_L_STAT		(1<<10)	/* Bit 10:	Link is up */
-#define PHY_L_QS_DUP_MOD	(1<<9)	/* Bit 9:	Full/Half Duplex */
-#define PHY_L_QS_AN			(1<<8)	/* Bit 8:	AutoNeg is On */
-#define PHY_L_QS_AN_C		(1<<7)	/* Bit 7:	AN is Complete */
-#define PHY_L_QS_LLE		(7<<4)	/* Bit 6:	Line Length Estim. */
-#define PHY_L_QS_PAUSE		(1<<3)	/* Bit 3:	LP advertised Pause */
-#define PHY_L_QS_AS_PAUSE	(1<<2)	/* Bit 2:	LP adv. asym. Pause */
-#define PHY_L_QS_ISOLATE	(1<<1)	/* Bit 1:	CIM Isolated */
-#define PHY_L_QS_EVENT		(1<<0)	/* Bit 0:	Event has occurred */
+#define PHY_L_QS_DUP_MOD	(1<<9)	/* Bit  9:	Full/Half Duplex */
+#define PHY_L_QS_AN			(1<<8)	/* Bit  8:	AutoNeg is On */
+#define PHY_L_QS_AN_C		(1<<7)	/* Bit  7:	AN is Complete */
+#define PHY_L_QS_LLE		(7<<4)	/* Bit  6:	Line Length Estim. */
+#define PHY_L_QS_PAUSE		(1<<3)	/* Bit  3:	LP advertised Pause */
+#define PHY_L_QS_AS_PAUSE	(1<<2)	/* Bit  2:	LP adv. asym. Pause */
+#define PHY_L_QS_ISOLATE	(1<<1)	/* Bit  1:	CIM Isolated */
+#define PHY_L_QS_EVENT		(1<<0)	/* Bit  0:	Event has occurred */
 
-/*****	PHY_LONE_INT_ENAB	16 bit r/w	Interrupt Enable Reg *****/
-/*****	PHY_LONE_INT_STAT	16 bit ro	Interrupt Status Reg *****/
+/*****  PHY_LONE_INT_ENAB	16 bit r/w	Interrupt Enable Reg *****/
+/*****  PHY_LONE_INT_STAT	16 bit r/o	Interrupt Status Reg *****/
 									/* Bit 15..14:	reserved */
-#define PHY_L_IS_AN_F		(1<<13)	/* Bit 13:	Autoneg fault */
+#define PHY_L_IS_AN_F		(1<<13)	/* Bit 13:	Auto-Negotiation fault */
 									/* Bit 12:	not described */
 #define PHY_L_IS_CROSS		(1<<11)	/* Bit 11:	Crossover used */
-#define PHY_L_IS_POL		(1<<10)	/* Bit 10:	Polarity correct. used*/
-#define PHY_L_IS_SS			(1<<9)	/* Bit 9:	Smart Speed Downgrade*/
-#define PHY_L_IS_CFULL		(1<<8)	/* Bit 8:	Counter Full */
-#define PHY_L_IS_AN_C		(1<<7)	/* Bit 7:	AutoNeg Complete */
-#define PHY_L_IS_SPEED		(1<<6)	/* Bit 6:	Speed Changed */
-#define PHY_L_IS_DUP		(1<<5)	/* Bit 5:	Duplex Changed */
-#define PHY_L_IS_LS			(1<<4)	/* Bit 4:	Link Status Changed */
-#define PHY_L_IS_ISOL		(1<<3)	/* Bit 3:	Isolate Occured */
-#define PHY_L_IS_MDINT		(1<<2)	/* Bit 2: (ro)	STAT: MII Int Pending */
-#define PHY_L_IS_INTEN		(1<<1)	/* Bit 1:	ENAB: Enable IRQs */
-#define PHY_L_IS_FORCE		(1<<0)	/* Bit 0:	ENAB: Force Interrupt */
+#define PHY_L_IS_POL		(1<<10)	/* Bit 10:	Polarity correct. used */
+#define PHY_L_IS_SS			(1<<9)	/* Bit  9:	Smart Speed Downgrade */
+#define PHY_L_IS_CFULL		(1<<8)	/* Bit  8:	Counter Full */
+#define PHY_L_IS_AN_C		(1<<7)	/* Bit  7:	AutoNeg Complete */
+#define PHY_L_IS_SPEED		(1<<6)	/* Bit  6:	Speed Changed */
+#define PHY_L_IS_DUP		(1<<5)	/* Bit  5:	Duplex Changed */
+#define PHY_L_IS_LS			(1<<4)	/* Bit  4:	Link Status Changed */
+#define PHY_L_IS_ISOL		(1<<3)	/* Bit  3:	Isolate Occured */
+#define PHY_L_IS_MDINT		(1<<2)	/* Bit  2: (ro)	STAT: MII Int Pending */
+#define PHY_L_IS_INTEN		(1<<1)	/* Bit  1:	ENAB: Enable IRQs */
+#define PHY_L_IS_FORCE		(1<<0)	/* Bit  0:	ENAB: Force Interrupt */
 
 /* int. mask */
 #define PHY_L_DEF_MSK		(PHY_L_IS_LS | PHY_L_IS_ISOL | PHY_L_IS_INTEN)
 
-/*****	PHY_LONE_LED_CFG	16 bit r/w	LED Configuration Reg *****/
+/*****  PHY_LONE_LED_CFG	16 bit r/w	LED Configuration Reg *****/
 #define PHY_L_LC_LEDC		(3<<14)	/* Bit 15..14:	Col/Blink/On/Off */
 #define PHY_L_LC_LEDR		(3<<12)	/* Bit 13..12:	Rx/Blink/On/Off */
 #define PHY_L_LC_LEDT		(3<<10)	/* Bit 11..10:	Tx/Blink/On/Off */
-#define PHY_L_LC_LEDG		(3<<8)	/* Bit 9..8:	Giga/Blink/On/Off */
-#define PHY_L_LC_LEDS		(3<<6)	/* Bit 7..6:	10-100/Blink/On/Off */
-#define PHY_L_LC_LEDL		(3<<4)	/* Bit 5..4:	Link/Blink/On/Off */
-#define PHY_L_LC_LEDF		(3<<2)	/* Bit 3..2:	Duplex/Blink/On/Off */
-#define PHY_L_LC_PSTRECH	(1<<1)	/* Bit 1:	Strech LED Pulses */
-#define PHY_L_LC_FREQ		(1<<0)	/* Bit 0:	30/100 ms */
+#define PHY_L_LC_LEDG		(3<<8)	/* Bit  9..8:	Giga/Blink/On/Off */
+#define PHY_L_LC_LEDS		(3<<6)	/* Bit  7..6:	10-100/Blink/On/Off */
+#define PHY_L_LC_LEDL		(3<<4)	/* Bit  5..4:	Link/Blink/On/Off */
+#define PHY_L_LC_LEDF		(3<<2)	/* Bit  3..2:	Duplex/Blink/On/Off */
+#define PHY_L_LC_PSTRECH	(1<<1)	/* Bit  1:	Strech LED Pulses */
+#define PHY_L_LC_FREQ		(1<<0)	/* Bit  0:	30/100 ms */
 
-/*****	PHY_LONE_PORT_CTRL	16 bit r/w	Port Control Reg *****/
+/*****  PHY_LONE_PORT_CTRL	16 bit r/w	Port Control Reg *****/
 #define PHY_L_PC_TX_TCLK	(1<<15)	/* Bit 15:	Enable TX_TCLK */
 									/* Bit 14:	reserved */
 #define PHY_L_PC_ALT_NP		(1<<13)	/* Bit 14:	Alternate Next Page */
 #define PHY_L_PC_GMII_ALT	(1<<12)	/* Bit 13:	Alternate GMII driver */
 									/* Bit 11:	reserved */
 #define PHY_L_PC_TEN_CRS	(1<<10)	/* Bit 10:	Extend CRS*/
-									/* Bit 9..0:	not described */
+									/* Bit  9..0:	not described */
 
-/*****	PHY_LONE_CIM		16 bit ro	CIM Reg *****/
+/*****  PHY_LONE_CIM		16 bit r/o	CIM Reg *****/
 #define PHY_L_CIM_ISOL		(255<<8)/* Bit 15..8:	Isolate Count */
 #define PHY_L_CIM_FALSE_CAR	(255<<0)/* Bit  7..0:	False Carrier Count */
 
@@ -1105,37 +1223,37 @@
 /*
  * Pause Bits (PHY_L_AN_ASP and PHY_L_AN_PC) encoding
  */
-#define PHY_L_P_NO_PAUSE	(0<<10)	/* Bit	11..10:	no Pause Mode */
-#define PHY_L_P_SYM_MD		(1<<10)	/* Bit	11..10:	symmetric Pause Mode */
-#define PHY_L_P_ASYM_MD		(2<<10)	/* Bit	11..10:	asymmetric Pause Mode */
-#define PHY_L_P_BOTH_MD		(3<<10)	/* Bit	11..10:	both Pause Mode */
+#define PHY_L_P_NO_PAUSE	(0<<10)	/* Bit 11..10:	no Pause Mode */
+#define PHY_L_P_SYM_MD		(1<<10)	/* Bit 11..10:	symmetric Pause Mode */
+#define PHY_L_P_ASYM_MD		(2<<10)	/* Bit 11..10:	asymmetric Pause Mode */
+#define PHY_L_P_BOTH_MD		(3<<10)	/* Bit 11..10:	both Pause Mode */
 
 
 /*
  * National-Specific
  */
-/***** PHY_NAT_1000T_CTRL	16 bit r/w	1000Base-T Control Reg *****/
-#define PHY_N_1000C_TEST	(7<<13)	/* Bit	15..13:	Test Modes */
-#define PHY_N_1000C_MSE		(1<<12)	/* Bit	12:	Master/Slave Enable */
-#define PHY_N_1000C_MSC		(1<<11)	/* Bit	11:	M/S Configuration */
-#define PHY_N_1000C_RD		(1<<10)	/* Bit	10:	Repeater/DTE */
-#define PHY_N_1000C_AFD		(1<<9)	/* Bit	9:	Advertise Full Duplex */
-#define PHY_N_1000C_AHD		(1<<8)	/* Bit	8:	Advertise Half Duplex */
-#define PHY_N_1000C_APC		(1<<7)	/* Bit	7:	Asymetric Pause Cap. */
-									/* Bit	6..0:	reserved */
-
-/***** PHY_NAT_1000T_STAT	16 bit ro	1000Base-T Status Reg *****/
-#define PHY_N_1000S_MSF		(1<<15)	/* Bit	15:	Master/Slave Fault */
-#define PHY_N_1000S_MSR		(1<<14)	/* Bit	14:	Master/Slave Result */
-#define PHY_N_1000S_LRS		(1<<13)	/* Bit	13:	Local Receiver Status */
-#define PHY_N_1000S_RRS		(1<<12)	/* Bit	12:	Remote Receiver Status*/
-#define PHY_N_1000S_LP_FD	(1<<11)	/* Bit	11:	Link Partner can FD */
-#define PHY_N_1000S_LP_HD	(1<<10)	/* Bit	10:	Link Partner can HD */
-#define PHY_N_1000C_LP_APC	(1<<9)	/* Bit	9:	LP Asym. Pause Cap. */
-									/* Bit	8:	reserved */
-#define PHY_N_1000S_IEC		(255<<0)/* Bit	7..0:	Idle Error Count */
+/*****  PHY_NAT_1000T_CTRL	16 bit r/w	1000Base-T Control Reg *****/
+#define PHY_N_1000C_TEST	(7<<13)	/* Bit 15..13:	Test Modes */
+#define PHY_N_1000C_MSE		(1<<12)	/* Bit 12:	Master/Slave Enable */
+#define PHY_N_1000C_MSC		(1<<11)	/* Bit 11:	M/S Configuration */
+#define PHY_N_1000C_RD		(1<<10)	/* Bit 10:	Repeater/DTE */
+#define PHY_N_1000C_AFD		(1<<9)	/* Bit  9:	Advertise Full Duplex */
+#define PHY_N_1000C_AHD		(1<<8)	/* Bit  8:	Advertise Half Duplex */
+#define PHY_N_1000C_APC		(1<<7)	/* Bit  7:	Asymmetric Pause Cap. */
+									/* Bit  6..0:	reserved */
+
+/*****  PHY_NAT_1000T_STAT	16 bit r/o	1000Base-T Status Reg *****/
+#define PHY_N_1000S_MSF		(1<<15)	/* Bit 15:	Master/Slave Fault */
+#define PHY_N_1000S_MSR		(1<<14)	/* Bit 14:	Master/Slave Result */
+#define PHY_N_1000S_LRS		(1<<13)	/* Bit 13:	Local Receiver Status */
+#define PHY_N_1000S_RRS		(1<<12)	/* Bit 12:	Remote Receiver Status*/
+#define PHY_N_1000S_LP_FD	(1<<11)	/* Bit 11:	Link Partner can FD */
+#define PHY_N_1000S_LP_HD	(1<<10)	/* Bit 10:	Link Partner can HD */
+#define PHY_N_1000C_LP_APC	(1<<9)	/* Bit  9:	LP Asym. Pause Cap. */
+									/* Bit  8:	reserved */
+#define PHY_N_1000S_IEC		0xff	/* Bit  7..0:	Idle Error Count */
 
-/*****	PHY_NAT_EXT_STAT	16 bit ro	Extended Status Register *****/
+/*****  PHY_NAT_EXT_STAT	16 bit r/o	Extended Status Register *****/
 #define PHY_N_ES_X_FD_CAP	(1<<15)	/* Bit 15:	1000Base-X FD capable */
 #define PHY_N_ES_X_HD_CAP	(1<<14)	/* Bit 14:	1000Base-X HD capable */
 #define PHY_N_ES_T_FD_CAP	(1<<13)	/* Bit 13:	1000Base-T FD capable */
@@ -1143,12 +1261,475 @@
 									/* Bit 11..0:	reserved */
 
 /* todo: those are still missing */
-/*****	PHY_NAT_EXT_CTRL1	16 bit ro	Extended Control Reg1 *****/
-/*****	PHY_NAT_Q_STAT1		16 bit ro	Quick Status Reg1 *****/
-/*****	PHY_NAT_10B_OP		16 bit ro	10Base-T Operations Reg *****/
-/*****	PHY_NAT_EXT_CTRL2	16 bit ro	Extended Control Reg1 *****/
-/*****	PHY_NAT_Q_STAT2		16 bit ro	Quick Status Reg2 *****/
-/*****	PHY_NAT_PHY_ADDR	16 bit ro	PHY Address Register *****/
+/*****  PHY_NAT_EXT_CTRL1	16 bit r/o	Extended Control Reg1 *****/
+/*****  PHY_NAT_Q_STAT1		16 bit r/o	Quick Status Reg1 *****/
+/*****  PHY_NAT_10B_OP		16 bit r/o	10Base-T Operations Reg *****/
+/*****  PHY_NAT_EXT_CTRL2	16 bit r/o	Extended Control Reg1 *****/
+/*****  PHY_NAT_Q_STAT2		16 bit r/o	Quick Status Reg2 *****/
+/*****  PHY_NAT_PHY_ADDR	16 bit r/o	PHY Address Register *****/
+
+/*
+ * Marvell-Specific
+ */
+/*****  PHY_MARV_AUNE_ADV	16 bit r/w	Auto-Negotiation Advertisement *****/
+/*****  PHY_MARV_AUNE_LP	16 bit r/w	Link Part Ability Reg *****/
+#define PHY_M_AN_NXT_PG		BIT_15	/* Request Next Page */
+#define PHY_M_AN_ACK		BIT_14	/* (ro)	Acknowledge Received */
+#define PHY_M_AN_RF			BIT_13	/* Remote Fault */
+									/* Bit 12:	reserved */
+#define PHY_M_AN_ASP		BIT_11	/* Asymmetric Pause */
+#define PHY_M_AN_PC			BIT_10	/* MAC Pause implemented */
+#define PHY_M_AN_100_FD		BIT_8	/* Advertise 100Base-TX Full Duplex */
+#define PHY_M_AN_100_HD		BIT_7	/* Advertise 100Base-TX Half Duplex */
+#define PHY_M_AN_10_FD		BIT_6	/* Advertise 10Base-TX Full Duplex */
+#define PHY_M_AN_10_HD		BIT_5	/* Advertise 10Base-TX Half Duplex */
+
+/* special defines for FIBER (88E1011S only) */
+#define PHY_M_AN_ASP_X		BIT_8	/* Asymmetric Pause */
+#define PHY_M_AN_PC_X		BIT_7	/* MAC Pause implemented */
+#define PHY_M_AN_1000X_AHD	BIT_6	/* Advertise 10000Base-X Half Duplex */
+#define PHY_M_AN_1000X_AFD	BIT_5	/* Advertise 10000Base-X Full Duplex */
+
+/* Pause Bits (PHY_M_AN_ASP_X and PHY_M_AN_PC_X) encoding */
+#define PHY_M_P_NO_PAUSE_X	(0<<7)	/* Bit  8.. 7:	no Pause Mode */
+#define PHY_M_P_SYM_MD_X	(1<<7)	/* Bit  8.. 7:	symmetric Pause Mode */
+#define PHY_M_P_ASYM_MD_X	(2<<7)	/* Bit  8.. 7:	asymmetric Pause Mode */
+#define PHY_M_P_BOTH_MD_X	(3<<7)	/* Bit  8.. 7:	both Pause Mode */
+
+/*****  PHY_MARV_1000T_CTRL	16 bit r/w	1000Base-T Control Reg *****/
+#define PHY_M_1000C_TEST	(7<<13)	/* Bit 15..13:	Test Modes */
+#define PHY_M_1000C_MSE		(1<<12)	/* Bit 12:	Manual Master/Slave Enable */
+#define PHY_M_1000C_MSC		(1<<11)	/* Bit 11:	M/S Configuration (1=Master) */
+#define PHY_M_1000C_MPD		(1<<10)	/* Bit 10:	Multi-Port Device */
+#define PHY_M_1000C_AFD		(1<<9)	/* Bit  9:	Advertise Full Duplex */
+#define PHY_M_1000C_AHD		(1<<8)	/* Bit  8:	Advertise Half Duplex */
+									/* Bit  7..0:	reserved */
+
+/*****  PHY_MARV_PHY_CTRL	16 bit r/w	PHY Specific Ctrl Reg *****/
+
+#define PHY_M_PC_TX_FFD_MSK	(3<<14)	/* Bit 15..14:	Tx FIFO Depth Mask */
+#define PHY_M_PC_RX_FFD_MSK	(3<<12)	/* Bit 13..12:	Rx FIFO Depth Mask */
+#define PHY_M_PC_ASS_CRS_TX	(1<<11)	/* Bit 11:	Assert CRS on Transmit */
+#define PHY_M_PC_FL_GOOD	(1<<10)	/* Bit 10:	Force Link Good */
+#define PHY_M_PC_EN_DET_MSK	(3<<8)	/* Bit  9.. 8:	Energy Detect Mask */
+#define PHY_M_PC_ENA_EXT_D	(1<<7)	/* Bit  7:	Enable Ext. Distance (10BT) */
+#define PHY_M_PC_MDIX_MSK	(3<<5)	/* Bit  6.. 5:	MDI/MDIX Config. Mask */
+#define PHY_M_PC_DIS_125CLK	(1<<4)	/* Bit  4:	Disable 125 CLK */
+#define PHY_M_PC_MAC_POW_UP	(1<<3)	/* Bit  3:	MAC Power up */
+#define PHY_M_PC_SQE_T_ENA	(1<<2)	/* Bit  2:	SQE Test Enabled */
+#define PHY_M_PC_POL_R_DIS	(1<<1)	/* Bit  1:	Polarity Reversal Disabled */
+#define PHY_M_PC_DIS_JABBER	(1<<0)	/* Bit  0:	Disable Jabber */
+
+#define PHY_M_PC_MDI_XMODE(x)	SHIFT5(x)	
+#define PHY_M_PC_MAN_MDI	0    	/* 00 = Manual MDI configuration */
+#define PHY_M_PC_MAN_MDIX	1		/* 01 = Manual MDIX configuration */
+#define PHY_M_PC_ENA_AUTO	3		/* 11 = Enable Automatic Crossover */
+
+/*****  PHY_MARV_PHY_STAT	16 bit r/o	PHY Specific Status Reg *****/
+#define PHY_M_PS_SPEED_MSK	(3<<14)	/* Bit 15..14:	Speed Mask */
+#define PHY_M_PS_SPEED_1000	(1<<15)	/*       10 = 1000 Mbps */
+#define PHY_M_PS_SPEED_100	(1<<14)	/*       01 =  100 Mbps */
+#define PHY_M_PS_SPEED_10	0		/*       00 =   10 Mbps */
+#define PHY_M_PS_FULL_DUP	(1<<13)	/* Bit 13:	Full Duplex */
+#define PHY_M_PS_PAGE_REC	(1<<12)	/* Bit 12:	Page Received */
+#define PHY_M_PS_SPDUP_RES	(1<<11)	/* Bit 11:	Speed & Duplex Resolved */
+#define PHY_M_PS_LINK_UP	(1<<10)	/* Bit 10:	Link Up */
+#define PHY_M_PS_CABLE_MSK	(3<<7)	/* Bit  9.. 7:	Cable Length Mask */
+#define PHY_M_PS_MDI_X_STAT	(1<<6)	/* Bit  6:	MDI Crossover Stat (1=MDIX) */
+#define PHY_M_PS_DOWNS_STAT	(1<<5)	/* Bit  5:	Downshift Status (1=downsh.) */
+#define PHY_M_PS_ENDET_STAT	(1<<4)	/* Bit  4:	Energy Detect Status (1=act) */
+#define PHY_M_PS_TX_P_EN	(1<<3)	/* Bit  3:	Tx Pause Enabled */
+#define PHY_M_PS_RX_P_EN	(1<<2)	/* Bit  2:	Rx Pause Enabled */
+#define PHY_M_PS_POL_REV	(1<<1)	/* Bit  1:	Polarity Reversed */
+#define PHY_M_PC_JABBER		(1<<0)	/* Bit  0:	Jabber */
+
+#define PHY_M_PS_PAUSE_MSK	(PHY_M_PS_TX_P_EN | PHY_M_PS_RX_P_EN)
+
+/*****  PHY_MARV_INT_MASK	16 bit r/w	Interrupt Mask Reg *****/
+/*****  PHY_MARV_INT_STAT	16 bit r/o	Interrupt Status Reg *****/
+#define PHY_M_IS_AN_ERROR	(1<<15)	/* Bit 15:	Auto-Negotiation Error */
+#define PHY_M_IS_LSP_CHANGE	(1<<14)	/* Bit 14:	Link Speed Changed */
+#define PHY_M_IS_DUP_CHANGE	(1<<13)	/* Bit 13:	Duplex Mode Changed */
+#define PHY_M_IS_AN_PR		(1<<12)	/* Bit 12:	Page Received */
+#define PHY_M_IS_AN_COMPL	(1<<11)	/* Bit 11:	Auto-Negotiation Completed */
+#define PHY_M_IS_LST_CHANGE	(1<<10)	/* Bit 10:	Link Status Changed */
+#define PHY_M_IS_SYMB_ERROR	(1<<9)	/* Bit  9:	Symbol Error */
+#define PHY_M_IS_FALSE_CARR	(1<<8)	/* Bit  8:	False Carrier */
+#define PHY_M_IS_FIFO_ERROR	(1<<7)	/* Bit  7:	FIFO Overflow/Underrun Error */
+#define PHY_M_IS_MDI_CHANGE	(1<<6)	/* Bit  6:	MDI Crossover Changed */
+#define PHY_M_IS_DOWNSH_DET	(1<<5)	/* Bit  5:	Downshift Detected */
+#define PHY_M_IS_END_CHANGE	(1<<4)	/* Bit  4:	Energy Detect Changed */
+									/* Bit  3..2:	reserved */
+#define PHY_M_IS_POL_CHANGE	(1<<1)	/* Bit  1:	Polarity Changed */
+#define PHY_M_IS_JABBER		(1<<0)	/* Bit  0:	Jabber */
+
+#define PHY_M_DEF_MSK		(PHY_M_IS_AN_ERROR | PHY_M_IS_AN_PR | \
+							PHY_M_IS_LST_CHANGE | PHY_M_IS_FIFO_ERROR)
+
+/*****  PHY_MARV_EXT_CTRL	16 bit r/w	Ext. PHY Specific Ctrl *****/
+#define PHY_M_EC_M_DSC_MSK	(3<<10)	/* Bit 11..10:	Master downshift counter */
+#define PHY_M_EC_S_DSC_MSK	(3<<8)	/* Bit  9.. 8:	Slave  downshift counter */
+#define PHY_M_EC_MAC_S_MSK	(7<<4)	/* Bit  6.. 4:	Def. MAC interface speed */
+
+#define PHY_M_EC_M_DSC(x)		SHIFT10(x)	/* 00=1x; 01=2x; 10=3x; 11=4x */
+#define PHY_M_EC_S_DSC(x)		SHIFT8(x)	/* 00=dis; 01=1x; 10=2x; 11=3x */
+#define PHY_M_EC_MAC_S(x)		SHIFT4(x)	/* 01X=0; 110=2.5; 111=25 (MHz) */
+
+#define MAC_TX_CLK_0_MHZ	2
+#define MAC_TX_CLK_2_5_MHZ	6
+#define MAC_TX_CLK_25_MHZ	7
+
+/*****  PHY_MARV_LED_CTRL	16 bit r/w	LED Control Reg *****/
+#define PHY_M_LEDC_DIS_LED	(1<<15)	/* Bit 15:	Disable LED */
+#define PHY_M_LEDC_PULS_MSK	(7<<12)	/* Bit 14..12:  Pulse Stretch Mask */
+#define PHY_M_LEDC_F_INT	(1<<11)	/* Bit 11:	Force Interrupt */
+#define PHY_M_LEDC_BL_R_MSK	(7<<8)	/* Bit 10.. 8:  Blink Rate Mask */
+									/* Bit  7.. 5:	reserved */
+#define PHY_M_LEDC_LINK_MSK	(3<<3)	/* Bit  4.. 3:	Link Control Mask */
+#define PHY_M_LEDC_DP_CTRL	(1<<2)	/* Bit  2:	Duplex Control */
+#define PHY_M_LEDC_RX_CTRL	(1<<1)	/* Bit  1:	Rx activity / Link */
+#define PHY_M_LEDC_TX_CTRL	(1<<0)	/* Bit  0:	Tx activity / Link */
+
+#define PHY_M_LED_PULS_DUR(x)	SHIFT12(x)	/* Pulse Stretch Duration */
+
+#define	PULS_NO_STR		0		/* no pulse stretching */
+#define	PULS_21MS		1		/* 21 ms to 42 ms */
+#define PULS_42MS		2		/* 42 ms to 84 ms */
+#define PULS_84MS		3		/* 84 ms to 170 ms */
+#define PULS_170MS		4		/* 170 ms to 340 ms */
+#define PULS_340MS		5		/* 340 ms to 670 ms */
+#define PULS_670MS		6		/* 670 ms to 1.3 s */
+#define PULS_1300MS		7		/* 1.3 s to 2.7 s */
+
+#define PHY_M_LED_BLINK_RT(x)	SHIFT8(x)	/* Blink Rate */
+
+#define BLINK_42MS		0		/* 42 ms */
+#define BLINK_84MS		1		/* 84 ms */
+#define BLINK_170MS		2		/* 170 ms */
+#define BLINK_340MS		3		/* 340 ms */
+#define BLINK_670MS		4		/* 670 ms */
+								/* values 5 - 7: reserved */
+
+/*****  PHY_MARV_LED_OVER	16 bit r/w	Manual LED Override Reg *****/
+#define PHY_M_LED_MO_DUP(x)		SHIFT10(x)	/* Bit 11..10:  Duplex */
+#define PHY_M_LED_MO_10(x)		SHIFT8(x)	/* Bit  9.. 8:  Link 10 */
+#define PHY_M_LED_MO_100(x)		SHIFT6(x)	/* Bit  7.. 6:  Link 100 */
+#define PHY_M_LED_MO_1000(x)	SHIFT4(x)	/* Bit  5.. 4:  Link 1000 */
+#define PHY_M_LED_MO_RX(x)		SHIFT2(x)	/* Bit  3.. 2:  Rx */
+#define PHY_M_LED_MO_TX(x)		SHIFT0(x)	/* Bit  1.. 0:  Tx */
+
+#define MO_LED_NORM			0
+#define MO_LED_BLINK		1
+#define MO_LED_OFF			2
+#define MO_LED_ON			3
+
+/*****  PHY_MARV_EXT_CTRL_2	16 bit r/w	Ext. PHY Specific Ctrl 2 *****/
+									/* Bit 15.. 7:	reserved */
+#define PHY_M_EC2_FI_IMPED	(1<<6)	/* Bit  6:	Fiber Input  Impedance */
+#define PHY_M_EC2_FO_IMPED	(1<<5)	/* Bit  5:	Fiber Output Impedance */
+#define PHY_M_EC2_FO_M_CLK	(1<<4)	/* Bit  4:	Fiber Mode Clock Enable */
+#define PHY_M_EC2_FO_BOOST	(1<<3)	/* Bit  3:	Fiber Output Boost */
+#define PHY_M_EC2_FO_AM_MSK	7		/* Bit  2.. 0:	Fiber Output Amplitude */
+
+/*****  PHY_MARV_CABLE_DIAG	16 bit r/o	Cable Diagnostic Reg *****/
+#define PHY_M_CABD_ENA_TEST	(1<<15)	/* Bit 15:	Enable Test */
+#define PHY_M_CABD_STAT_MSK	(3<<13)	/* Bit 14..13:	Status */
+									/* Bit 12.. 8:	reserved */
+#define PHY_M_CABD_DIST_MSK	0xff	/* Bit  7.. 0:	Distance */
+
+/* values for Cable Diagnostic Status (11=fail; 00=OK; 10=open; 01=short) */
+#define CABD_STAT_NORMAL	0
+#define CABD_STAT_SHORT		1
+#define CABD_STAT_OPEN		2
+#define CABD_STAT_FAIL		3
+
+
+/*
+ * GMAC registers
+ *
+ * The GMAC registers are 16 or 32 bits wide.
+ * The GMACs host processor interface is 16 bits wide,
+ * therefore ALL registers will be addressed with 16 bit accesses.
+ *
+ * The following macros are provided to access the GMAC registers
+ * GM_IN16(), GM_OUT16, GM_IN32(), GM_OUT32(), GM_INADR(), GM_OUTADR(),
+ * GM_INHASH(), and GM_OUTHASH().
+ * The macros are defined in SkGeHw.h.
+ *
+ * Note:	NA reg	= Network Address e.g DA, SA etc.
+ *
+ */
+
+/* Port Registers */
+#define GM_GP_STAT		0x0000		/* 16 bit r/o	General Purpose Status */
+#define GM_GP_CTRL		0x0004		/* 16 bit r/w	General Purpose Control */
+#define GM_TX_CTRL		0x0008		/* 16 bit r/w	Transmit Control Reg. */
+#define GM_RX_CTRL		0x000c		/* 16 bit r/w	Receive Control Reg. */
+#define GM_TX_FLOW_CTRL	0x0010		/* 16 bit r/w	Transmit Flow-Control */
+#define GM_TX_PARAM		0x0014		/* 16 bit r/w	Transmit Parameter Reg. */
+#define GM_SERIAL_MODE	0x0018		/* 16 bit r/w	Serial Mode Register */
+
+/* Source Address Registers */
+#define GM_SRC_ADDR_1L	0x001c		/* 16 bit r/w	Source Address 1 (low) */
+#define GM_SRC_ADDR_1M	0x0020		/* 16 bit r/w	Source Address 1 (middle) */
+#define GM_SRC_ADDR_1H	0x0024		/* 16 bit r/w	Source Address 1 (high) */
+#define GM_SRC_ADDR_2L	0x0028		/* 16 bit r/w	Source Address 2 (low) */
+#define GM_SRC_ADDR_2M	0x002c		/* 16 bit r/w	Source Address 2 (middle) */
+#define GM_SRC_ADDR_2H	0x0030		/* 16 bit r/w	Source Address 2 (high) */
+
+/* Multicast Address Hash Registers */
+#define GM_MC_ADDR_H1	0x0034		/* 16 bit r/w	Multicast Address Hash 1 */
+#define GM_MC_ADDR_H2	0x0038		/* 16 bit r/w	Multicast Address Hash 2 */
+#define GM_MC_ADDR_H3	0x003c		/* 16 bit r/w	Multicast Address Hash 3 */
+#define GM_MC_ADDR_H4	0x0040		/* 16 bit r/w	Multicast Address Hash 4 */
+
+/* Interrupt Source Registers */
+#define GM_TX_IRQ_SRC	0x0044		/* 16 bit r/o	Tx Overflow IRQ Source */
+#define GM_RX_IRQ_SRC	0x0048		/* 16 bit r/o	Rx Overflow IRQ Source */
+#define GM_TR_IRQ_SRC	0x004c		/* 16 bit r/o	Tx/Rx Over. IRQ Source */
+
+/* Interrupt Mask Registers */
+#define GM_TX_IRQ_MSK	0x0050		/* 16 bit r/w	Tx Overflow IRQ Mask */
+#define GM_RX_IRQ_MSK	0x0054		/* 16 bit r/w	Rx Overflow IRQ Mask */
+#define GM_TR_IRQ_MSK	0x0058		/* 16 bit r/w	Tx/Rx Over. IRQ Mask */
+
+/* Serial Management Interface (SMI) Registers */
+#define GM_SMI_CTRL		0x0080		/* 16 bit r/w	SMI Control Register */
+#define GM_SMI_DATA		0x0084		/* 16 bit r/w	SMI Data Register */
+#define GM_PHY_ADDR		0x0088		/* 16 bit r/w	GPHY Address Register */
+
+/* MIB Counters */
+#define GM_MIB_CNT_BASE	0x0100		/* Base Address of MIB Counters */
+#define GM_MIB_CNT_SIZE	44			/* Number of MIB Counters */
+
+/*
+ * MIB Counters base address definitions (low word) -
+ * use offset 4 for access to high word	(32 bit r/o)
+ */
+#define GM_RXF_UC_OK \
+			(GM_MIB_CNT_BASE + 0)	/* Unicast Frames Received OK */
+#define GM_RXF_BC_OK \
+			(GM_MIB_CNT_BASE + 8)	/* Broadcast Frames Received OK */
+#define GM_RXF_MPAUSE \
+			(GM_MIB_CNT_BASE + 16)	/* Pause MAC Ctrl Frames Received */
+#define GM_RXF_MC_OK \
+			(GM_MIB_CNT_BASE + 24)	/* Multicast Frames Received OK */
+#define GM_RXF_FCS_ERR \
+			(GM_MIB_CNT_BASE + 32)	/* Rx Frame Check Seq. Error */
+	/* GM_MIB_CNT_BASE + 40:	reserved */
+#define GM_RXO_OK_LO \
+			(GM_MIB_CNT_BASE + 48)	/* Octets Received OK Low */
+#define GM_RXO_OK_HI \
+			(GM_MIB_CNT_BASE + 56)	/* Octets Received OK High */
+#define GM_RXO_ERR_LO \
+			(GM_MIB_CNT_BASE + 64)	/* Octets Received Invalid Low */
+#define GM_RXO_ERR_HI \
+			(GM_MIB_CNT_BASE + 72)	/* Octets Received Invalid High */
+#define GM_RXF_SHT \
+			(GM_MIB_CNT_BASE + 80)	/* Frames <64 Byte Received OK */
+#define GM_RXE_FRAG \
+			(GM_MIB_CNT_BASE + 88)	/* Frames <64 Byte Receeived with FCS Err */
+#define GM_RXF_64B \
+			(GM_MIB_CNT_BASE + 96)	/* 64 Byte Rx Frame */
+#define GM_RXF_127B \
+			(GM_MIB_CNT_BASE + 104)	/* 65-127 Byte Rx Frame */
+#define GM_RXF_255B \
+			(GM_MIB_CNT_BASE + 112)	/* 128-255 Byte Rx Frame */
+#define GM_RXF_511B \
+			(GM_MIB_CNT_BASE + 120)	/* 256-511 Byte Rx Frame */
+#define GM_RXF_1023B \
+			(GM_MIB_CNT_BASE + 128)	/* 512-1023 Byte Rx Frame */
+#define GM_RXF_1518B \
+			(GM_MIB_CNT_BASE + 136)	/* 1024-1518 Byte Rx Frame */
+#define GM_RXF_MAX_SZ \
+			(GM_MIB_CNT_BASE + 144)	/* 1519-MaxSize Byte Rx Frame */
+#define GM_RXF_LNG_ERR \
+			(GM_MIB_CNT_BASE + 152)	/* Rx Frame too Long Error */
+#define GM_RXF_JAB_PKT \
+			(GM_MIB_CNT_BASE + 160)	/* Rx Jabber Packet Frame */
+	/* GM_MIB_CNT_BASE + 168:	reserved */
+#define GM_RXE_FIFO_OV \
+			(GM_MIB_CNT_BASE + 176)	/* Rx FIFO overflow Event */
+	/* GM_MIB_CNT_BASE + 184:	reserved */
+#define GM_TXF_UC_OK \
+			(GM_MIB_CNT_BASE + 192)	/* Unicast Frames Xmitted OK */
+#define GM_TXF_BC_OK \
+			(GM_MIB_CNT_BASE + 200)	/* Broadcast Frames Xmitted OK */
+#define GM_TXF_MPAUSE \
+			(GM_MIB_CNT_BASE + 208)	/* Pause MAC Ctrl Frames Xmitted */
+#define GM_TXF_MC_OK \
+			(GM_MIB_CNT_BASE + 216)	/* Multicast Frames Xmitted OK */
+#define GM_TXO_OK_LO \
+			(GM_MIB_CNT_BASE + 224)	/* Octets Transmitted OK Low */
+#define GM_TXO_OK_HI \
+			(GM_MIB_CNT_BASE + 232)	/* Octets Transmitted OK High */
+#define GM_TXF_64B \
+			(GM_MIB_CNT_BASE + 240)	/* 64 Byte Tx Frame */
+#define GM_TXF_127B \
+			(GM_MIB_CNT_BASE + 248)	/* 65-127 Byte Tx Frame */
+#define GM_TXF_255B \
+			(GM_MIB_CNT_BASE + 256)	/* 128-255 Byte Tx Frame */
+#define GM_TXF_511B \
+			(GM_MIB_CNT_BASE + 264)	/* 256-511 Byte Tx Frame */
+#define GM_TXF_1023B \
+			(GM_MIB_CNT_BASE + 272)	/* 512-1023 Byte Tx Frame */
+#define GM_TXF_1518B \
+			(GM_MIB_CNT_BASE + 280)	/* 1024-1518 Byte Tx Frame */
+#define GM_TXF_MAX_SZ \
+			(GM_MIB_CNT_BASE + 288)	/* 1519-MaxSize Byte Tx Frame */
+	/* GM_MIB_CNT_BASE + 296:	reserved */
+#define GM_TXF_COL \
+			(GM_MIB_CNT_BASE + 304)	/* Tx Collision */
+#define GM_TXF_LAT_COL \
+			(GM_MIB_CNT_BASE + 312)	/* Tx Late Collision */
+#define GM_TXF_ABO_COL \
+			(GM_MIB_CNT_BASE + 320)	/* Tx aborted due to Exces. Col. */
+#define GM_TXF_MUL_COL \
+			(GM_MIB_CNT_BASE + 328)	/* Tx Multiple Collision */
+#define GM_TXF_SNG_COL \
+			(GM_MIB_CNT_BASE + 336)	/* Tx Single Collision */
+#define GM_TXE_FIFO_UR \
+			(GM_MIB_CNT_BASE + 344)	/* Tx FIFO Underrun Event */
+
+/*----------------------------------------------------------------------------*/
+/*
+ * GMAC Bit Definitions
+ *
+ * If the bit access behaviour differs from the register access behaviour
+ * (r/w, r/o) this is documented after the bit number.
+ * The following bit access behaviours are used:
+ *	(sc)	self clearing
+ *	(r/o)	read only
+ */
+
+/*	GM_GP_STAT	16 bit r/o	General Purpose Status Register */
+
+#define GM_GPSR_SPEED		(1<<15) /* Bit 15:	Port Speed (1 = 100 Mbps) */
+#define GM_GPSR_DUPLEX		(1<<14) /* Bit 14:	Duplex Mode (1 = Full) */
+#define GM_GPSR_FC_TX_DIS	(1<<13) /* Bit 13:	Tx Flow-Control Mode Disabled */
+#define GM_GPSR_LINK_UP		(1<<12)	/* Bit 12:	Link Up Status */
+#define GM_GPSR_PAUSE		(1<<11)	/* Bit 11:	Pause State */
+#define GM_GPSR_TX_ACTIVE	(1<<10)	/* Bit 10:	Tx in Progress */
+#define GM_GPSR_EXC_COL		(1<<9)	/* Bit  9:	Excessive Collisions Occured */
+#define GM_GPSR_LAT_COL		(1<<8)	/* Bit  8:	Late Collisions Occured */
+								/* Bit  7..6:	reserved */
+#define GM_GPSR_PHY_ST_CH	(1<<5)	/* Bit  5:	PHY Status Change */
+#define GM_GPSR_GIG_SPEED	(1<<4)	/* Bit  4:	Gigabit Speed (1 = 1000 Mbps) */
+#define GM_GPSR_PART_MODE	(1<<3)	/* Bit  3:	Partition mode */
+#define GM_GPSR_FC_RX_DIS	(1<<2)	/* Bit  2:	Rx Flow-Control Mode Disabled */
+#define GM_GPSR_PROM_EN		(1<<1)	/* Bit  1:	Promiscuous Mode Enabled */
+								/* Bit  0:	reserved */
+	
+/*	GM_GP_CTRL	16 bit r/w	General Purpose Control Register */
+								/* Bit 15:	reserved */
+#define GM_GPCR_PROM_ENA	(1<<14)	/* Bit 14:	Enable Promiscuous Mode */
+#define GM_GPCR_FC_TX_DIS	(1<<13) /* Bit 13:	Disable Tx Flow-Control Mode */
+#define GM_GPCR_TX_ENA		(1<<12) /* Bit 12:	Enable Transmit */
+#define GM_GPCR_RX_ENA		(1<<11) /* Bit 11:	Enable Receive */
+#define GM_GPCR_BURST_ENA	(1<<10)	/* Bit 10:	Enable Burst Mode */
+#define GM_GPCR_LOOP_ENA	(1<<9)	/* Bit  9:	Enable MAC Loopback Mode */
+#define GM_GPCR_PART_ENA	(1<<8)	/* Bit  8:	Enable Partition Mode */
+#define GM_GPCR_GIGS_ENA	(1<<7)	/* Bit  7:	Gigabit Speed (1000 Mbps) */
+#define GM_GPCR_FL_PASS		(1<<6)	/* Bit  6:	Force Link Pass */
+#define GM_GPCR_DUP_FULL	(1<<5)	/* Bit  5:	Full Duplex Mode */
+#define GM_GPCR_FC_RX_DIS	(1<<4)	/* Bit  4:	Disable Rx Flow-Control Mode */
+#define GM_GPCR_SPEED_100	(1<<3)  /* Bit  3:	Port Speed 100 Mbps */
+#define GM_GPCR_AU_DUP_DIS	(1<<2)	/* Bit  2:	Disable Auto-Update Duplex */
+#define GM_GPCR_AU_FCT_DIS	(1<<1)	/* Bit  1:	Disable Auto-Update Flow-C. */
+#define GM_GPCR_AU_SPD_DIS	(1<<0)	/* Bit  0:	Disable Auto-Update Speed */
+
+#define GM_GPCR_SPEED_1000	(GM_GPCR_GIGS_ENA | GM_GPCR_SPEED_100)
+#define GM_GPCR_AU_ALL_DIS	(GM_GPCR_AU_DUP_DIS | GM_GPCR_AU_FCT_DIS |\
+							 GM_GPCR_AU_SPD_DIS)
+	
+/*	GM_TX_CTRL				16 bit r/w	Transmit Control Register */
+
+#define GM_TXCR_FORCE_JAM	(1<<15)	/* Bit 15:	Force Jam / Flow-Control */
+#define GM_TXCR_CRC_DIS		(1<<14)	/* Bit 14:	Disable insertion of CRC */
+#define GM_TXCR_PAD_DIS		(1<<13)	/* Bit 13:	Disable padding of packets */
+#define GM_TXCR_COL_THR		(4<<10)	/* Bit 12..10:	Collision Threshold */
+	
+/*	GM_RX_CTRL				16 bit r/w	Receive Control Register */
+#define GM_RXCR_UCF_ENA		(1<<15)	/* Bit 15:	Enable Unicast filtering */
+#define GM_RXCR_MCF_ENA		(1<<14)	/* Bit 14:	Enable Multicast filtering */
+#define GM_RXCR_CRC_DIS		(1<<13)	/* Bit 13:	Remove 4-byte CRC */
+#define GM_RXCR_PASS_FC		(1<<12)	/* Bit 12:	Pass FC packets to FIFO */
+	
+/*	GM_TX_PARAM				16 bit r/w	Transmit Parameter Register */
+#define GM_TXPA_JAMLEN_MSK	(0x03<<14)	/* Bit 15..14:	Jam Length */
+#define GM_TXPA_JAMIPG_MSK	(0x1f<<9)	/* Bit 13..9:	Jam IPG */
+#define GM_TXPA_JAMDAT_MSK	(0x1f<<4)	/* Bit  8..4:	IPG Jam to Data */
+								/* Bit  3..0:	reserved */
+#define JAM_LEN_VAL(x)		SHIFT14(x)
+#define JAM_IPG_VAL(x)		SHIFT9(x)
+#define IPG_JAM_DATA(x)		SHIFT4(x)
+
+/*	GM_SERIAL_MODE			16 bit r/w	Serial Mode Register */
+#define GM_SMOD_DATABL_MSK	(0x1f<<11)	/* Bit 15..11:	Data Blinder */
+#define GM_SMOD_LIMIT_4		(1<<10)	/* Bit 10:	4 consecutive Tx trials */
+#define GM_SMOD_VLAN_ENA	(1<<9)	/* Bit  9:	Enable VLAN  (Max. Frame Len) */
+#define GM_SMOD_JUMBO_ENA	(1<<8)	/* Bit  8:	Enable Jumbo (Max. Frame Len) */
+								/* Bit  7..5:	reserved */
+#define GM_SMOD_IPG_MSK		0x1f	/* Bit 4..0:	Inter-Packet Gap (IPG) */
+	
+#define DATA_BLIND_VAL(x)	SHIFT11(x)
+#define DATA_BLIND_FAST_ETH	0x1c
+#define DATA_BLIND_GIGABIT	4
+
+#define IPG_VAL_FAST_ETH	0x1e
+#define IPG_VAL_GIGABIT		6
+
+/*	GM_SMI_CTRL				16 bit r/w	SMI Control Register */
+
+#define GM_SMI_CT_PHY_AD(x)	SHIFT11(x)
+#define GM_SMI_CT_REG_AD(x)	SHIFT6(x)
+#define GM_SMI_CT_OP_RD		(1<<5)	/* Bit  5:	OpCode Read (0=Write)*/
+#define GM_SMI_CT_RD_VAL	(1<<4)	/* Bit  4:	Read Valid (Read completed) */
+#define GM_SMI_CT_BUSY		(1<<3)	/* Bit  3:	Busy (Operation in progress) */
+								/* Bit   2..0:	reserved */
+	
+/*	GM_PHY_ADDR				16 bit r/w	GPHY Address Register */
+								/* Bit  15..6:	reserved */
+#define GM_PAR_MIB_CLR		(1<<5)	/* Bit  5:	Set MIB Clear Counter Mode */
+#define GM_PAR_MIB_TST		(1<<4)	/* Bit  4:	MIB Load Counter (Test Mode) */
+								/* Bit   3..0:	reserved */
+	
+/* Receive Frame Status Encoding */
+#define GMR_FS_LEN	(0xffffUL<<16)	/* Bit 31..16:	Rx Frame Length */
+								/* Bit  15..14:	reserved */
+#define GMR_FS_VLAN		(1L<<13)	/* Bit 13:	VLAN Packet */
+#define GMR_FS_JABBER	(1L<<12)	/* Bit 12:	Jabber Packet */
+#define GMR_FS_UN_SIZE	(1L<<11)	/* Bit 11:	Undersize Packet */
+#define GMR_FS_MC		(1L<<10)	/* Bit 10:	Multicast Packet */
+#define GMR_FS_BC		(1L<<9)		/* Bit  9:	Broadcast Packet */
+#define GMR_FS_RX_OK	(1L<<8)		/* Bit  8:	Receive OK (Good Packet) */
+#define GMR_FS_GOOD_FC	(1L<<7)		/* Bit  7:	Good Flow-Control Packet */
+#define GMR_FS_BAD_FC	(1L<<6)		/* Bit  6:	Bad  Flow-Control Packet */
+#define GMR_FS_MII_ERR	(1L<<5)		/* Bit  5:	MII Error */
+#define GMR_FS_LONG_ERR	(1L<<4)		/* Bit  4:	Too Long Packet */
+#define GMR_FS_FRAGMENT	(1L<<3)		/* Bit  3:	Fragment */
+								/* Bit  2:	reserved */
+#define GMR_FS_CRC_ERR	(1L<<1)		/* Bit  1:	CRC Error */
+#define GMR_FS_RX_FF_OV	(1L<<0)		/* Bit  0:	Rx FIFO Overflow */
+
+/*
+ * GMR_FS_ANY_ERR (analogous to XMR_FS_ANY_ERR)
+ */
+#define GMR_FS_ANY_ERR	(GMR_FS_CRC_ERR | \
+			GMR_FS_LONG_ERR | \
+			GMR_FS_MII_ERR | \
+			GMR_FS_BAD_FC | \
+			GMR_FS_GOOD_FC | \
+			GMR_FS_JABBER)
+
+/* Rx GMAC FIFO Flush Mask (default) */
+#define RX_FF_FL_DEF_MSK	(GMR_FS_CRC_ERR | \
+			GMR_FS_RX_FF_OV | \
+			GMR_FS_MII_ERR | \
+			GMR_FS_BAD_FC | \
+			GMR_FS_GOOD_FC | \
+			GMR_FS_UN_SIZE | \
+			GMR_FS_JABBER)
 
 /* typedefs *******************************************************************/
 
diff -ruN linux/drivers/net/sk98lin/skaddr.c linuxn/drivers/net/sk98lin/skaddr.c
--- linux/drivers/net/sk98lin/skaddr.c	Sat Aug  3 02:39:44 2002
+++ linuxn/drivers/net/sk98lin/skaddr.c	Tue May 20 12:17:40 2003
@@ -2,15 +2,16 @@
  *
  * Name:	skaddr.c
  * Project:	GEnesis, PCI Gigabit Ethernet Adapter
- * Version:	$Revision: 1.40 $
- * Date:	$Date: 2001/02/14 14:04:59 $
+ * Version:	$Revision: 1.49 $
+ * Date:	$Date: 2003/04/15 09:30:51 $
  * Purpose:	Manage Addresses (Multicast and Unicast) and Promiscuous Mode.
  *
  ******************************************************************************/
 
 /******************************************************************************
  *
- *	(C)Copyright 1998-2001 SysKonnect GmbH.
+ *	(C)Copyright 1998-2002 SysKonnect GmbH.
+ *	(C)Copyright 2002-2003 Marvell.
  *
  *	This program is free software; you can redistribute it and/or modify
  *	it under the terms of the GNU General Public License as published by
@@ -26,6 +27,47 @@
  * History:
  *
  *	$Log: skaddr.c,v $
+ *	Revision 1.49  2003/04/15 09:30:51  tschilli
+ *	Copyright messages changed.
+ *	"#error C++ is not yet supported." removed.
+ *	
+ *	Revision 1.48  2003/02/12 17:09:37  tschilli
+ *	Fix in SkAddrOverride() to set both (physical and logical) MAC addresses
+ *	in case that both addresses are identical.
+ *	
+ *	Revision 1.47  2002/09/17 06:31:10  tschilli
+ *	Handling of SK_PROM_MODE_ALL_MC flag in SkAddrGmacMcUpdate()
+ *	and SkAddrGmacPromiscuousChange() fixed.
+ *	Editorial changes.
+ *	
+ *	Revision 1.46  2002/08/22 07:55:41  tschilli
+ *	New function SkGmacMcHash() for GMAC multicast hashing algorithm added.
+ *	Editorial changes.
+ *	
+ *	Revision 1.45  2002/08/15 12:29:35  tschilli
+ *	SkAddrGmacMcUpdate() and SkAddrGmacPromiscuousChange() changed.
+ *	
+ *	Revision 1.44  2002/08/14 12:18:03  rschmidt
+ *	Replaced direct handling of MAC Hashing (XMAC and GMAC)
+ *	with routine SkMacHashing().
+ *	Replaced wrong 3rd para 'i' with 'PortNumber' in SkMacPromiscMode().
+ *	
+ *	Revision 1.43  2002/08/13 09:37:43  rschmidt
+ *	Corrected some SK_DBG_MSG outputs.
+ *	Replaced wrong 2nd para pAC with IoC in SkMacPromiscMode().
+ *	Editorial changes.
+ *	
+ *	Revision 1.42  2002/08/12 11:24:36  rschmidt
+ *	Remove setting of logical MAC address GM_SRC_ADDR_2 in SkAddrInit().
+ *	Replaced direct handling of MAC Promiscuous Mode (XMAC and GMAC)
+ *	with routine SkMacPromiscMode().
+ *	Editorial changes.
+ *	
+ *	Revision 1.41  2002/06/10 13:52:18  tschilli
+ *	Changes for handling YUKON.
+ *	All changes are internally and not visible to the programmer
+ *	using this module.
+ *	
  *	Revision 1.40  2001/02/14 14:04:59  rassmann
  *	Editorial changes.
  *	
@@ -166,13 +208,13 @@
  * Description:
  *
  * This module is intended to manage multicast addresses, address override,
- * and promiscuous mode on GEnesis adapters.
+ * and promiscuous mode on GEnesis and Yukon adapters.
  *
  * Address Layout:
  *	port address:		physical MAC address
- *	1st exact match:	logical MAC address
- *	2nd exact match:	RLMT multicast
- *	exact match 3-13:	OS-specific multicasts
+ *	1st exact match:	logical MAC address (GEnesis only)
+ *	2nd exact match:	RLMT multicast (GEnesis only)
+ *	exact match 3-13:	OS-specific multicasts (GEnesis only)
  *
  * Include File Hierarchy:
  *
@@ -183,13 +225,12 @@
 
 #ifndef	lint
 static const char SysKonnectFileId[] =
-	"@(#) $Id: skaddr.c,v 1.40 2001/02/14 14:04:59 rassmann Exp $ (C) SysKonnect.";
+	"@(#) $Id: skaddr.c,v 1.49 2003/04/15 09:30:51 tschilli Exp $ (C) Marvell.";
 #endif	/* !defined(lint) */
 
 #define __SKADDR_C
 
 #ifdef __cplusplus
-#error C++ is not yet supported.
 extern "C" {
 #endif	/* cplusplus */
 
@@ -199,6 +240,8 @@
 /* defines ********************************************************************/
 
 
+#define XMAC_POLY	0xEDB88320UL	/* CRC32-Poly - XMAC: Little Endian */
+#define GMAC_POLY	0x04C11DB7L	/* CRC16-Poly - GMAC: Little Endian */
 #define HASH_BITS	6				/* #bits in hash */
 #define	SK_MC_BIT	0x01
 
@@ -247,7 +290,7 @@
  *	All permanent MAC addresses are read from EPROM.
  *	If the current MAC addresses are not already set in software,
  *	they are set to the values of the permanent addresses.
- *	The current addresses are written to the corresponding XMAC.
+ *	The current addresses are written to the corresponding MAC.
  *
  *
  *	SK_INIT_RUN
@@ -266,38 +309,26 @@
 SK_IOC	IoC,	/* I/O context */
 int		Level)	/* initialization level */
 {
-	int				j;
-	SK_U32			i;
-	SK_U8			*InAddr;
-	SK_U16			*OutAddr;
+	int			j;
+	SK_U32		i;
+	SK_U8		*InAddr;
+	SK_U16		*OutAddr;
 	SK_ADDR_PORT	*pAPort;
 
 	switch (Level) {
 	case SK_INIT_DATA:
-		SK_MEMSET((char *)&pAC->Addr, 0, sizeof(SK_ADDR));
+		SK_MEMSET((char *) &pAC->Addr, 0, sizeof(SK_ADDR));
 
 		for (i = 0; i < SK_MAX_MACS; i++) {
 			pAPort = &pAC->Addr.Port[i];
 			pAPort->PromMode = SK_PROM_MODE_NONE;
-
-			pAPort->FirstExactMatchRlmt	= SK_ADDR_FIRST_MATCH_RLMT;
-			pAPort->FirstExactMatchDrv	= SK_ADDR_FIRST_MATCH_DRV;
-			pAPort->NextExactMatchRlmt	= SK_ADDR_FIRST_MATCH_RLMT;
-			pAPort->NextExactMatchDrv	= SK_ADDR_FIRST_MATCH_DRV;
-
-#if 0
-			/* Don't do this here ... */
-
-			/* Reset Promiscuous mode. */
-			(void)SkAddrPromiscuousChange(
-				pAC,
-				IoC,
-				i,
-				SK_PROM_MODE_NONE);
-#endif	/* 0 */
+			
+			pAPort->FirstExactMatchRlmt = SK_ADDR_FIRST_MATCH_RLMT;
+			pAPort->FirstExactMatchDrv = SK_ADDR_FIRST_MATCH_DRV;
+			pAPort->NextExactMatchRlmt = SK_ADDR_FIRST_MATCH_RLMT;
+			pAPort->NextExactMatchDrv = SK_ADDR_FIRST_MATCH_DRV;
 		}
-		
-#ifdef DEBUG
+#ifdef xDEBUG
 		for (i = 0; i < SK_MAX_MACS; i++) {
 			if (pAC->Addr.Port[i].NextExactMatchRlmt <
 				SK_ADDR_FIRST_MATCH_RLMT) {
@@ -305,7 +336,6 @@
 			}
 		}
 #endif	/* DEBUG */
-
 		/* pAC->Addr.InitDone = SK_INIT_DATA; */
 		break;
 
@@ -313,8 +343,7 @@
 		for (i = 0; i < SK_MAX_NETS; i++) {
 			pAC->Addr.Net[i].ActivePort = pAC->Rlmt.Net[i].ActivePort;
 		}
-		
-#ifdef DEBUG
+#ifdef xDEBUG
 		for (i = 0; i < SK_MAX_MACS; i++) {
 			if (pAC->Addr.Port[i].NextExactMatchRlmt <
 				SK_ADDR_FIRST_MATCH_RLMT) {
@@ -322,10 +351,10 @@
 			}
 		}
 #endif	/* DEBUG */
-
+		
 		/* Read permanent logical MAC address from Control Register File. */
 		for (j = 0; j < SK_MAC_ADDR_LEN; j++) {
-			InAddr = (SK_U8 *)&pAC->Addr.Net[0].PermanentMacAddress.a[j];
+			InAddr = (SK_U8 *) &pAC->Addr.Net[0].PermanentMacAddress.a[j];
 			SK_IN8(IoC, B2_MAC_1 + j, InAddr);
 		}
 
@@ -339,7 +368,6 @@
 		/* Set the current logical MAC address. */
 		pAC->Addr.Port[pAC->Addr.Net[0].ActivePort].Exact[0] =
 			pAC->Addr.Net[0].CurrentMacAddress;
-
 #if SK_MAX_NETS > 1
 		/* Set logical MAC address for net 2 to (log | 3). */
 		if (!pAC->Addr.Net[1].CurrentMacAddressSet) {
@@ -353,43 +381,36 @@
 		}
 #endif	/* SK_MAX_NETS > 1 */
 
-#ifdef xDEBUG
-		SK_DBG_MSG(
-			pAC,
-			SK_DBGMOD_ADDR,
-			SK_DBGCAT_INIT,
-			("Permanent MAC Address: %02X %02X %02X %02X %02X %02X\n",
-				pAC->Addr.PermanentMacAddress.a[0],
-				pAC->Addr.PermanentMacAddress.a[1],
-				pAC->Addr.PermanentMacAddress.a[2],
-				pAC->Addr.PermanentMacAddress.a[3],
-				pAC->Addr.PermanentMacAddress.a[4],
-				pAC->Addr.PermanentMacAddress.a[5]))
-		SK_DBG_MSG(
-			pAC,
-			SK_DBGMOD_ADDR,
-			SK_DBGCAT_INIT,
-			("Logical MAC Address: %02X %02X %02X %02X %02X %02X\n",
-				pAC->Addr.CurrentMacAddress.a[0],
-				pAC->Addr.CurrentMacAddress.a[1],
-				pAC->Addr.CurrentMacAddress.a[2],
-				pAC->Addr.CurrentMacAddress.a[3],
-				pAC->Addr.CurrentMacAddress.a[4],
-				pAC->Addr.CurrentMacAddress.a[5]))
+#ifdef DEBUG
+		for (i = 0; i < (SK_U32) pAC->GIni.GIMacsFound; i++) {
+			SK_DBG_MSG(pAC, SK_DBGMOD_ADDR, SK_DBGCAT_INIT,
+				("Permanent MAC Address (Net%d): %02X %02X %02X %02X %02X %02X\n",
+					i,
+					pAC->Addr.Net[i].PermanentMacAddress.a[0],
+					pAC->Addr.Net[i].PermanentMacAddress.a[1],
+					pAC->Addr.Net[i].PermanentMacAddress.a[2],
+					pAC->Addr.Net[i].PermanentMacAddress.a[3],
+					pAC->Addr.Net[i].PermanentMacAddress.a[4],
+					pAC->Addr.Net[i].PermanentMacAddress.a[5]))
+			
+			SK_DBG_MSG(pAC, SK_DBGMOD_ADDR, SK_DBGCAT_INIT,
+				("Logical MAC Address (Net%d): %02X %02X %02X %02X %02X %02X\n",
+					i,
+					pAC->Addr.Net[i].CurrentMacAddress.a[0],
+					pAC->Addr.Net[i].CurrentMacAddress.a[1],
+					pAC->Addr.Net[i].CurrentMacAddress.a[2],
+					pAC->Addr.Net[i].CurrentMacAddress.a[3],
+					pAC->Addr.Net[i].CurrentMacAddress.a[4],
+					pAC->Addr.Net[i].CurrentMacAddress.a[5]))
+		}
 #endif	/* DEBUG */
 
-#if 0
-		/* Don't do this here ... */
-
-		(void)SkAddrMcUpdate(pAC, IoC, pAC->Addr.ActivePort);
-#endif	/* 0 */
-
-		for (i = 0; i < (SK_U32)pAC->GIni.GIMacsFound; i++) {
+		for (i = 0; i < (SK_U32) pAC->GIni.GIMacsFound; i++) {
 			pAPort = &pAC->Addr.Port[i];
 
 			/* Read permanent port addresses from Control Register File. */
 			for (j = 0; j < SK_MAC_ADDR_LEN; j++) {
-				InAddr = (SK_U8 *)&pAPort->PermanentMacAddress.a[j];
+				InAddr = (SK_U8 *) &pAPort->PermanentMacAddress.a[j];
 				SK_IN8(IoC, B2_MAC_2 + 8 * i + j, InAddr);
 			}
 
@@ -403,27 +424,27 @@
 				pAPort->CurrentMacAddressSet = SK_TRUE;
 			}
 
-			/* Set port's current MAC addresses. */
-			OutAddr = (SK_U16 *)&pAPort->CurrentMacAddress.a[0];
-			XM_OUTADDR(IoC, i, XM_SA, OutAddr);
-
-#ifdef xDEBUG
-			SK_DBG_MSG(
-				pAC,
-				SK_DBGMOD_ADDR,
-				SK_DBGCAT_INIT,
-				("Permanent Physical MAC Address: %02X %02X %02X %02X %02X %02X\n",
+			/* Set port's current physical MAC address. */
+			OutAddr = (SK_U16 *) &pAPort->CurrentMacAddress.a[0];
+			
+			if (pAC->GIni.GIChipId == CHIP_ID_GENESIS) {
+				XM_OUTADDR(IoC, i, XM_SA, OutAddr);
+			}
+			else {
+				GM_OUTADDR(IoC, i, GM_SRC_ADDR_1L, OutAddr);
+			}
+#ifdef DEBUG
+			SK_DBG_MSG(pAC, SK_DBGMOD_ADDR, SK_DBGCAT_INIT,
+				("SkAddrInit: Permanent Physical MAC Address: %02X %02X %02X %02X %02X %02X\n",
 					pAPort->PermanentMacAddress.a[0],
 					pAPort->PermanentMacAddress.a[1],
 					pAPort->PermanentMacAddress.a[2],
 					pAPort->PermanentMacAddress.a[3],
 					pAPort->PermanentMacAddress.a[4],
 					pAPort->PermanentMacAddress.a[5]))
-			SK_DBG_MSG(
-				pAC,
-				SK_DBGMOD_ADDR,
-				SK_DBGCAT_INIT,
-				("Phsical MAC Address: %02X %02X %02X %02X %02X %02X\n",
+			
+			SK_DBG_MSG(pAC, SK_DBGMOD_ADDR, SK_DBGCAT_INIT,
+				("SkAddrInit: Physical MAC Address: %02X %02X %02X %02X %02X %02X\n",
 					pAPort->CurrentMacAddress.a[0],
 					pAPort->CurrentMacAddress.a[1],
 					pAPort->CurrentMacAddress.a[2],
@@ -436,7 +457,7 @@
 		break;
 
 	case SK_INIT_RUN:
-#ifdef DEBUG
+#ifdef xDEBUG
 		for (i = 0; i < SK_MAX_MACS; i++) {
 			if (pAC->Addr.Port[i].NextExactMatchRlmt <
 				SK_ADDR_FIRST_MATCH_RLMT) {
@@ -453,6 +474,7 @@
 	}
 
 	return (SK_ADDR_SUCCESS);
+	
 }	/* SkAddrInit */
 
 
@@ -461,11 +483,14 @@
  *	SkAddrMcClear - clear the multicast table
  *
  * Description:
- *	This routine clears the multicast table
- *	(either entry 2 or entries 3-16 and InexactFilter) of the given port.
+ *	This routine clears the multicast table.
+ *
  *	If not suppressed by Flag SK_MC_SW_ONLY, the hardware is updated
  *	immediately.
  *
+ *	It calls either SkAddrXmacMcClear or SkAddrGmacMcClear, according
+ *	to the adapter in use. The real work is done there.
+ *
  * Context:
  *	runtime, pageable
  *	may be called starting with SK_INIT_DATA with flag SK_MC_SW_ONLY
@@ -481,21 +506,59 @@
 SK_U32	PortNumber,	/* Index of affected port */
 int		Flags)		/* permanent/non-perm, sw-only */
 {
-	int i;
-
-	if (PortNumber >= (SK_U32)pAC->GIni.GIMacsFound) {
+	int ReturnCode;
+	
+	if (PortNumber >= (SK_U32) pAC->GIni.GIMacsFound) {
 		return (SK_ADDR_ILLEGAL_PORT);
 	}
+	
+	if (pAC->GIni.GIChipId == CHIP_ID_GENESIS) {
+		ReturnCode = SkAddrXmacMcClear(pAC, IoC, PortNumber, Flags);
+	}
+	else {
+		ReturnCode = SkAddrGmacMcClear(pAC, IoC, PortNumber, Flags);
+	}
+
+	return (ReturnCode);
+
+}	/* SkAddrMcClear */
+
+
+/******************************************************************************
+ *
+ *	SkAddrXmacMcClear - clear the multicast table
+ *
+ * Description:
+ *	This routine clears the multicast table
+ *	(either entry 2 or entries 3-16 and InexactFilter) of the given port.
+ *	If not suppressed by Flag SK_MC_SW_ONLY, the hardware is updated
+ *	immediately.
+ *
+ * Context:
+ *	runtime, pageable
+ *	may be called starting with SK_INIT_DATA with flag SK_MC_SW_ONLY
+ *	may be called after SK_INIT_IO without limitation
+ *
+ * Returns:
+ *	SK_ADDR_SUCCESS
+ *	SK_ADDR_ILLEGAL_PORT
+ */
+int	SkAddrXmacMcClear(
+SK_AC	*pAC,		/* adapter context */
+SK_IOC	IoC,		/* I/O context */
+SK_U32	PortNumber,	/* Index of affected port */
+int		Flags)		/* permanent/non-perm, sw-only */
+{
+	int i;
 
-	if (Flags & SK_ADDR_PERMANENT) {
+	if (Flags & SK_ADDR_PERMANENT) {	/* permanent => RLMT */
 
 		/* Clear RLMT multicast addresses. */
 		pAC->Addr.Port[PortNumber].NextExactMatchRlmt = SK_ADDR_FIRST_MATCH_RLMT;
 	}
 	else {	/* not permanent => DRV */
 
-		/* Clear InexactFilter. */
-
+		/* Clear InexactFilter */
 		for (i = 0; i < 8; i++) {
 			pAC->Addr.Port[PortNumber].InexactFilter.Bytes[i] = 0;
 		}
@@ -506,20 +569,114 @@
 	}
 
 	if (!(Flags & SK_MC_SW_ONLY)) {
-		(void)SkAddrMcUpdate(pAC, IoC, PortNumber);
+		(void) SkAddrXmacMcUpdate(pAC, IoC, PortNumber);
 	}
 
 	return (SK_ADDR_SUCCESS);
-}	/* SkAddrMcClear */
+	
+}	/* SkAddrXmacMcClear */
+
+
+/******************************************************************************
+ *
+ *	SkAddrGmacMcClear - clear the multicast table
+ *
+ * Description:
+ *	This routine clears the multicast hashing table (InexactFilter)
+ *	(either the RLMT or the driver bits) of the given port.
+ *
+ *	If not suppressed by Flag SK_MC_SW_ONLY, the hardware is updated
+ *	immediately.
+ *
+ * Context:
+ *	runtime, pageable
+ *	may be called starting with SK_INIT_DATA with flag SK_MC_SW_ONLY
+ *	may be called after SK_INIT_IO without limitation
+ *
+ * Returns:
+ *	SK_ADDR_SUCCESS
+ *	SK_ADDR_ILLEGAL_PORT
+ */
+int	SkAddrGmacMcClear(
+SK_AC	*pAC,		/* adapter context */
+SK_IOC	IoC,		/* I/O context */
+SK_U32	PortNumber,	/* Index of affected port */
+int		Flags)		/* permanent/non-perm, sw-only */
+{
+	int i;
+
+#ifdef DEBUG
+	SK_DBG_MSG(pAC, SK_DBGMOD_ADDR, SK_DBGCAT_CTRL,
+		("GMAC InexactFilter (not cleared): %02X %02X %02X %02X %02X %02X %02X %02X\n",
+			pAC->Addr.Port[PortNumber].InexactFilter.Bytes[0],
+			pAC->Addr.Port[PortNumber].InexactFilter.Bytes[1],
+			pAC->Addr.Port[PortNumber].InexactFilter.Bytes[2],
+			pAC->Addr.Port[PortNumber].InexactFilter.Bytes[3],
+			pAC->Addr.Port[PortNumber].InexactFilter.Bytes[4],
+			pAC->Addr.Port[PortNumber].InexactFilter.Bytes[5],
+			pAC->Addr.Port[PortNumber].InexactFilter.Bytes[6],
+			pAC->Addr.Port[PortNumber].InexactFilter.Bytes[7]))
+#endif	/* DEBUG */
+
+	/* Clear InexactFilter */
+	for (i = 0; i < 8; i++) {
+		pAC->Addr.Port[PortNumber].InexactFilter.Bytes[i] = 0;
+	}
+	
+	if (Flags & SK_ADDR_PERMANENT) {	/* permanent => RLMT */
+		
+		/* Copy DRV bits to InexactFilter. */
+		for (i = 0; i < 8; i++) {
+			pAC->Addr.Port[PortNumber].InexactFilter.Bytes[i] |=
+				pAC->Addr.Port[PortNumber].InexactDrvFilter.Bytes[i];
+			
+			/* Clear InexactRlmtFilter. */
+			pAC->Addr.Port[PortNumber].InexactRlmtFilter.Bytes[i] = 0;
+
+		}		
+	}
+	else {	/* not permanent => DRV */
+		
+		/* Copy RLMT bits to InexactFilter. */
+		for (i = 0; i < 8; i++) {
+			pAC->Addr.Port[PortNumber].InexactFilter.Bytes[i] |=
+				pAC->Addr.Port[PortNumber].InexactRlmtFilter.Bytes[i];
+			
+			/* Clear InexactDrvFilter. */
+			pAC->Addr.Port[PortNumber].InexactDrvFilter.Bytes[i] = 0;
+		}
+	}
+	
+#ifdef DEBUG
+	SK_DBG_MSG(pAC, SK_DBGMOD_ADDR, SK_DBGCAT_CTRL,
+		("GMAC InexactFilter (cleared): %02X %02X %02X %02X %02X %02X %02X %02X\n",
+			pAC->Addr.Port[PortNumber].InexactFilter.Bytes[0],
+			pAC->Addr.Port[PortNumber].InexactFilter.Bytes[1],
+			pAC->Addr.Port[PortNumber].InexactFilter.Bytes[2],
+			pAC->Addr.Port[PortNumber].InexactFilter.Bytes[3],
+			pAC->Addr.Port[PortNumber].InexactFilter.Bytes[4],
+			pAC->Addr.Port[PortNumber].InexactFilter.Bytes[5],
+			pAC->Addr.Port[PortNumber].InexactFilter.Bytes[6],
+			pAC->Addr.Port[PortNumber].InexactFilter.Bytes[7]))
+#endif	/* DEBUG */
+	
+	if (!(Flags & SK_MC_SW_ONLY)) {
+		(void) SkAddrGmacMcUpdate(pAC, IoC, PortNumber);
+	}
+	
+	return (SK_ADDR_SUCCESS);
+
+}	/* SkAddrGmacMcClear */
 
 #ifndef SK_ADDR_CHEAT
 
 /******************************************************************************
  *
- *	SkCrc32McHash - hash multicast address
+ *	SkXmacMcHash - hash multicast address
  *
  * Description:
  *	This routine computes the hash value for a multicast address.
+ *	A CRC32 algorithm is used.
  *
  * Notes:
  *	The code was adapted from the XaQti data sheet.
@@ -530,15 +687,84 @@
  * Returns:
  *	Hash value of multicast address.
  */
-unsigned SkCrc32McHash(
+SK_U32 SkXmacMcHash(
 unsigned char *pMc)	/* Multicast address */
 {
-	u32 Crc;
+	SK_U32 Idx;
+	SK_U32 Bit;
+	SK_U32 Data;
+	SK_U32 Crc;
+
+	Crc = 0xFFFFFFFFUL;
+	for (Idx = 0; Idx < SK_MAC_ADDR_LEN; Idx++) {
+		Data = *pMc++;
+		for (Bit = 0; Bit < 8; Bit++, Data >>= 1) {
+			Crc = (Crc >> 1) ^ (((Crc ^ Data) & 1) ? XMAC_POLY : 0);
+		}
+	}
 
-	Crc = ether_crc_le(SK_MAC_ADDR_LEN, pMc);
+	return (Crc & ((1 << HASH_BITS) - 1));
+
+}	/* SkXmacMcHash */
 
+
+/******************************************************************************
+ *
+ *	SkGmacMcHash - hash multicast address
+ *
+ * Description:
+ *	This routine computes the hash value for a multicast address.
+ *	A CRC16 algorithm is used.
+ *
+ * Notes:
+ *
+ *
+ * Context:
+ *	runtime, pageable
+ *
+ * Returns:
+ *	Hash value of multicast address.
+ */
+SK_U32 SkGmacMcHash(
+unsigned char *pMc)	/* Multicast address */
+{
+	SK_U32 Data;
+	SK_U32 TmpData;
+	SK_U32 Crc;
+	int Byte;
+	int Bit;
+
+	Crc = 0xFFFFFFFFUL;
+	for (Byte = 0; Byte < 6; Byte++) {
+		/* Get next byte. */
+		Data = (SK_U32) pMc[Byte];
+		
+		/* Change bit order in byte. */
+		TmpData = Data;
+		for (Bit = 0; Bit < 8; Bit++) {
+			if (TmpData & 1L) {
+				Data |=  1L << (7 - Bit);
+			}
+			else {
+				Data &= ~(1L << (7 - Bit));
+			}
+			TmpData >>= 1;
+		}
+		
+		Crc ^= (Data << 24);
+		for (Bit = 0; Bit < 8; Bit++) {
+			if (Crc & 0x80000000) {
+				Crc = (Crc << 1) ^ GMAC_POLY;
+			}
+			else {
+				Crc <<= 1;
+			}
+		}
+	}
+	
 	return (Crc & ((1 << HASH_BITS) - 1));
-}	/* SkCrc32McHash */
+
+}	/* SkGmacMcHash */
 
 #endif	/* not SK_ADDR_CHEAT */
 
@@ -549,11 +775,57 @@
  * Description:
  *	This routine enables reception for a given address on the given port.
  *
+ *	It calls either SkAddrXmacMcAdd or SkAddrGmacMcAdd, according to the
+ *	adapter in use. The real work is done there.
+ *
  * Notes:
  *	The return code is only valid for SK_PROM_MODE_NONE.
  *
- *	In the current version, only RLMT may add addresses to the non-active
- *	port.
+ * Context:
+ *	runtime, pageable
+ *	may be called after SK_INIT_DATA
+ *
+ * Returns:
+ *	SK_MC_FILTERING_EXACT
+ *	SK_MC_FILTERING_INEXACT
+ *	SK_MC_ILLEGAL_ADDRESS
+ *	SK_MC_ILLEGAL_PORT
+ *	SK_MC_RLMT_OVERFLOW
+ */
+int	SkAddrMcAdd(
+SK_AC		*pAC,		/* adapter context */
+SK_IOC		IoC,		/* I/O context */
+SK_U32		PortNumber,	/* Port Number */
+SK_MAC_ADDR	*pMc,		/* multicast address to be added */
+int			Flags)		/* permanent/non-permanent */
+{
+	int ReturnCode;
+	
+	if (PortNumber >= (SK_U32) pAC->GIni.GIMacsFound) {
+		return (SK_ADDR_ILLEGAL_PORT);
+	}
+	
+	if (pAC->GIni.GIChipId == CHIP_ID_GENESIS) {
+		ReturnCode = SkAddrXmacMcAdd(pAC, IoC, PortNumber, pMc, Flags);
+	}
+	else {
+		ReturnCode = SkAddrGmacMcAdd(pAC, IoC, PortNumber, pMc, Flags);
+	}
+
+	return (ReturnCode);
+
+}	/* SkAddrMcAdd */
+
+
+/******************************************************************************
+ *
+ *	SkAddrXmacMcAdd - add a multicast address to a port
+ *
+ * Description:
+ *	This routine enables reception for a given address on the given port.
+ *
+ * Notes:
+ *	The return code is only valid for SK_PROM_MODE_NONE.
  *
  *	The multicast bit is only checked if there are no free exact match
  *	entries.
@@ -566,28 +838,23 @@
  *	SK_MC_FILTERING_EXACT
  *	SK_MC_FILTERING_INEXACT
  *	SK_MC_ILLEGAL_ADDRESS
- *	SK_MC_ILLEGAL_PORT
  *	SK_MC_RLMT_OVERFLOW
  */
-int	SkAddrMcAdd(
+int	SkAddrXmacMcAdd(
 SK_AC		*pAC,		/* adapter context */
 SK_IOC		IoC,		/* I/O context */
 SK_U32		PortNumber,	/* Port Number */
 SK_MAC_ADDR	*pMc,		/* multicast address to be added */
-int			Flags)		/* permanent/non-permanent */
+int		Flags)		/* permanent/non-permanent */
 {
 	int	i;
 	SK_U8	Inexact;
 #ifndef SK_ADDR_CHEAT
-	unsigned HashBit;
+	SK_U32 HashBit;
 #endif	/* !defined(SK_ADDR_CHEAT) */
 
-	if (PortNumber >= (SK_U32)pAC->GIni.GIMacsFound) {
-		return (SK_ADDR_ILLEGAL_PORT);
-	}
-
-	if (Flags & SK_ADDR_PERMANENT) {
-#ifdef DEBUG
+	if (Flags & SK_ADDR_PERMANENT) {	/* permanent => RLMT */
+#ifdef xDEBUG
 		if (pAC->Addr.Port[PortNumber].NextExactMatchRlmt <
 			SK_ADDR_FIRST_MATCH_RLMT) {
 			Next0[PortNumber] |= 1;
@@ -600,7 +867,7 @@
 			return (SK_MC_RLMT_OVERFLOW);
 		}
 
-		/* Set an RLMT multicast address. */
+		/* Set a RLMT multicast address. */
 
 		pAC->Addr.Port[PortNumber].Exact[
 			pAC->Addr.Port[PortNumber].NextExactMatchRlmt++] = *pMc;
@@ -608,15 +875,7 @@
 		return (SK_MC_FILTERING_EXACT);
 	}
 
-#if 0
-	/* Not PERMANENT => DRV */
-	if (PortNumber != pAC->Addr.ActivePort) {
-		/* Only RLMT is allowed to do this. */
-		return (SK_MC_ILLEGAL_PORT);
-	}
-#endif	/* 0 */
-
-#ifdef DEBUG
+#ifdef xDEBUG
 	if (pAC->Addr.Port[PortNumber].NextExactMatchDrv <
 		SK_ADDR_FIRST_MATCH_DRV) {
 			Next0[PortNumber] |= 2;
@@ -630,22 +889,19 @@
 		pAC->Addr.Port[PortNumber].Exact[
 			pAC->Addr.Port[PortNumber].NextExactMatchDrv++] = *pMc;
 
-		/* Clear InexactFilter. */
+		/* Clear InexactFilter */
 		for (i = 0; i < 8; i++) {
 			pAC->Addr.Port[PortNumber].InexactFilter.Bytes[i] = 0;
 		}
 	}
 	else {
 		if (!(pMc->a[0] & SK_MC_BIT)) {
-			/*
-			 * Hashing only possible with
-			 * multicast addresses.
-			 */
+			/* Hashing only possible with multicast addresses. */
 			return (SK_MC_ILLEGAL_ADDRESS);
 		}
 #ifndef SK_ADDR_CHEAT
 		/* Compute hash value of address. */
-		HashBit = 63 - SkCrc32McHash(&pMc->a[0]);
+		HashBit = 63 - SkXmacMcHash(&pMc->a[0]);
 
 		/* Add bit to InexactFilter. */
 		pAC->Addr.Port[PortNumber].InexactFilter.Bytes[HashBit / 8] |=
@@ -668,90 +924,223 @@
 	else {
 		return (SK_MC_FILTERING_INEXACT);
 	}
-}	/* SkAddrMcAdd */
+
+}	/* SkAddrXmacMcAdd */
 
 
 /******************************************************************************
  *
- *	SkAddrMcUpdate - update the HW MC address table and set the MAC address
+ *	SkAddrGmacMcAdd - add a multicast address to a port
  *
  * Description:
- *	This routine enables reception of the addresses contained in a local
- *	table for a given port.
- *	It also programs the port's current physical MAC address.
+ *	This routine enables reception for a given address on the given port.
  *
  * Notes:
  *	The return code is only valid for SK_PROM_MODE_NONE.
  *
  * Context:
  *	runtime, pageable
- *	may be called after SK_INIT_IO
+ *	may be called after SK_INIT_DATA
  *
  * Returns:
- *	SK_MC_FILTERING_EXACT
  *	SK_MC_FILTERING_INEXACT
- *	SK_ADDR_ILLEGAL_PORT
+ *	SK_MC_ILLEGAL_ADDRESS
  */
-int	SkAddrMcUpdate(
-SK_AC	*pAC,		/* adapter context */
-SK_IOC	IoC,		/* I/O context */
-SK_U32	PortNumber)	/* Port Number */
+int	SkAddrGmacMcAdd(
+SK_AC		*pAC,		/* adapter context */
+SK_IOC		IoC,		/* I/O context */
+SK_U32		PortNumber,	/* Port Number */
+SK_MAC_ADDR	*pMc,		/* multicast address to be added */
+int		Flags)		/* permanent/non-permanent */
 {
-	SK_U32			i;
-	SK_U8			Inexact;
-	SK_U16			*OutAddr;
-	SK_U16			LoMode;		/* Lower 16 bits of XMAC Mode Reg. */
-	SK_ADDR_PORT	*pAPort;
-
-	if (PortNumber >= (SK_U32)pAC->GIni.GIMacsFound) {
-		return (SK_ADDR_ILLEGAL_PORT);
+	int	i;
+#ifndef SK_ADDR_CHEAT
+	SK_U32 HashBit;
+#endif	/* !defined(SK_ADDR_CHEAT) */
+		
+	if (!(pMc->a[0] & SK_MC_BIT)) {
+		/* Hashing only possible with multicast addresses. */
+		return (SK_MC_ILLEGAL_ADDRESS);
 	}
-
-	SK_DBG_MSG(
-		pAC,
-		SK_DBGMOD_ADDR,
-		SK_DBGCAT_CTRL,
-		("SkAddrMcUpdate on Port %u.\n", PortNumber))
 	
-	pAPort = &pAC->Addr.Port[PortNumber];
-
+#ifndef SK_ADDR_CHEAT
+	
+	/* Compute hash value of address. */
+	HashBit = SkGmacMcHash(&pMc->a[0]);
+	
+	if (Flags & SK_ADDR_PERMANENT) {	/* permanent => RLMT */
+		
+		/* Add bit to InexactRlmtFilter. */
+		pAC->Addr.Port[PortNumber].InexactRlmtFilter.Bytes[HashBit / 8] |=
+			1 << (HashBit % 8);
+		
+		/* Copy bit to InexactFilter. */
+		for (i = 0; i < 8; i++) {
+			pAC->Addr.Port[PortNumber].InexactFilter.Bytes[i] |=
+				pAC->Addr.Port[PortNumber].InexactRlmtFilter.Bytes[i];
+		}
 #ifdef DEBUG
-		SK_DBG_MSG(
-			pAC,
-			SK_DBGMOD_ADDR,
-			SK_DBGCAT_CTRL,
-			("Next0 on Port %d: %d\n", PortNumber, Next0[PortNumber]))
+		SK_DBG_MSG(pAC, SK_DBGMOD_ADDR, SK_DBGCAT_CTRL,
+		("GMAC InexactRlmtFilter: %02X %02X %02X %02X %02X %02X %02X %02X\n",
+			pAC->Addr.Port[PortNumber].InexactRlmtFilter.Bytes[0],
+			pAC->Addr.Port[PortNumber].InexactRlmtFilter.Bytes[1],
+			pAC->Addr.Port[PortNumber].InexactRlmtFilter.Bytes[2],
+			pAC->Addr.Port[PortNumber].InexactRlmtFilter.Bytes[3],
+			pAC->Addr.Port[PortNumber].InexactRlmtFilter.Bytes[4],
+			pAC->Addr.Port[PortNumber].InexactRlmtFilter.Bytes[5],
+			pAC->Addr.Port[PortNumber].InexactRlmtFilter.Bytes[6],
+			pAC->Addr.Port[PortNumber].InexactRlmtFilter.Bytes[7]))
 #endif	/* DEBUG */
-
-	/* Start with 0 to also program the logical MAC address. */
-	for (i = 0; i < pAPort->NextExactMatchRlmt; i++) {
-		/* Set exact match address i on HW. */
-		OutAddr = (SK_U16 *)&pAPort->Exact[i].a[0];
-		XM_OUTADDR(IoC, PortNumber, XM_EXM(i), OutAddr);
+	}
+	else {	/* not permanent => DRV */
+		
+		/* Add bit to InexactDrvFilter. */
+		pAC->Addr.Port[PortNumber].InexactDrvFilter.Bytes[HashBit / 8] |=
+			1 << (HashBit % 8);
+		
+		/* Copy bit to InexactFilter. */
+		for (i = 0; i < 8; i++) {
+			pAC->Addr.Port[PortNumber].InexactFilter.Bytes[i] |=
+				pAC->Addr.Port[PortNumber].InexactDrvFilter.Bytes[i];
+		}
+#ifdef DEBUG
+		SK_DBG_MSG(pAC, SK_DBGMOD_ADDR, SK_DBGCAT_CTRL,
+		("GMAC InexactDrvFilter: %02X %02X %02X %02X %02X %02X %02X %02X\n",
+			pAC->Addr.Port[PortNumber].InexactDrvFilter.Bytes[0],
+			pAC->Addr.Port[PortNumber].InexactDrvFilter.Bytes[1],
+			pAC->Addr.Port[PortNumber].InexactDrvFilter.Bytes[2],
+			pAC->Addr.Port[PortNumber].InexactDrvFilter.Bytes[3],
+			pAC->Addr.Port[PortNumber].InexactDrvFilter.Bytes[4],
+			pAC->Addr.Port[PortNumber].InexactDrvFilter.Bytes[5],
+			pAC->Addr.Port[PortNumber].InexactDrvFilter.Bytes[6],
+			pAC->Addr.Port[PortNumber].InexactDrvFilter.Bytes[7]))
+#endif	/* DEBUG */
+	}
+	
+#else	/* SK_ADDR_CHEAT */
+	
+	/* Set all bits in InexactFilter. */
+	for (i = 0; i < 8; i++) {
+		pAC->Addr.Port[PortNumber].InexactFilter.Bytes[i] = 0xFF;
+	}
+#endif	/* SK_ADDR_CHEAT */
+		
+	return (SK_MC_FILTERING_INEXACT);
+	
+}	/* SkAddrGmacMcAdd */
+
+
+/******************************************************************************
+ *
+ *	SkAddrMcUpdate - update the HW MC address table and set the MAC address
+ *
+ * Description:
+ *	This routine enables reception of the addresses contained in a local
+ *	table for a given port.
+ *	It also programs the port's current physical MAC address.
+ *
+ *	It calls either SkAddrXmacMcUpdate or SkAddrGmacMcUpdate, according
+ *	to the adapter in use. The real work is done there.
+ *
+ * Notes:
+ *	The return code is only valid for SK_PROM_MODE_NONE.
+ *
+ * Context:
+ *	runtime, pageable
+ *	may be called after SK_INIT_IO
+ *
+ * Returns:
+ *	SK_MC_FILTERING_EXACT
+ *	SK_MC_FILTERING_INEXACT
+ *	SK_ADDR_ILLEGAL_PORT
+ */
+int	SkAddrMcUpdate(
+SK_AC	*pAC,		/* adapter context */
+SK_IOC	IoC,		/* I/O context */
+SK_U32	PortNumber)	/* Port Number */
+{
+	int ReturnCode;
+	
+	if (PortNumber >= (SK_U32) pAC->GIni.GIMacsFound) {
+		return (SK_ADDR_ILLEGAL_PORT);
+	}
+	
+	if (pAC->GIni.GIChipId == CHIP_ID_GENESIS) {
+		ReturnCode = SkAddrXmacMcUpdate(pAC, IoC, PortNumber);
+	}
+	else {
+		ReturnCode = SkAddrGmacMcUpdate(pAC, IoC, PortNumber);
+	}
+	
+	return (ReturnCode);
+
+}	/* SkAddrMcUpdate */
+
+
+/******************************************************************************
+ *
+ *	SkAddrXmacMcUpdate - update the HW MC address table and set the MAC address
+ *
+ * Description:
+ *	This routine enables reception of the addresses contained in a local
+ *	table for a given port.
+ *	It also programs the port's current physical MAC address.
+ *
+ * Notes:
+ *	The return code is only valid for SK_PROM_MODE_NONE.
+ *
+ * Context:
+ *	runtime, pageable
+ *	may be called after SK_INIT_IO
+ *
+ * Returns:
+ *	SK_MC_FILTERING_EXACT
+ *	SK_MC_FILTERING_INEXACT
+ *	SK_ADDR_ILLEGAL_PORT
+ */
+int	SkAddrXmacMcUpdate(
+SK_AC	*pAC,		/* adapter context */
+SK_IOC	IoC,		/* I/O context */
+SK_U32	PortNumber)	/* Port Number */
+{
+	SK_U32		i;
+	SK_U8		Inexact;
+	SK_U16		*OutAddr;
+	SK_ADDR_PORT	*pAPort;
+
+	SK_DBG_MSG(pAC,SK_DBGMOD_ADDR, SK_DBGCAT_CTRL,
+		("SkAddrXmacMcUpdate on Port %u.\n", PortNumber))
+	
+	pAPort = &pAC->Addr.Port[PortNumber];
+
+#ifdef DEBUG
+	SK_DBG_MSG(pAC,SK_DBGMOD_ADDR, SK_DBGCAT_CTRL,
+		("Next0 on Port %d: %d\n", PortNumber, Next0[PortNumber]))
+#endif	/* DEBUG */
+
+	/* Start with 0 to also program the logical MAC address. */
+	for (i = 0; i < pAPort->NextExactMatchRlmt; i++) {
+		/* Set exact match address i on XMAC */
+		OutAddr = (SK_U16 *) &pAPort->Exact[i].a[0];
+		XM_OUTADDR(IoC, PortNumber, XM_EXM(i), OutAddr);
 	}
 
-	/* Clear other permanent exact match addresses on HW. */
+	/* Clear other permanent exact match addresses on XMAC */
 	if (pAPort->NextExactMatchRlmt <= SK_ADDR_LAST_MATCH_RLMT) {
-		SkXmClrExactAddr(
-			pAC,
-			IoC,
-			PortNumber,
-			pAPort->NextExactMatchRlmt,
+		
+		SkXmClrExactAddr(pAC, IoC, PortNumber, pAPort->NextExactMatchRlmt,
 			SK_ADDR_LAST_MATCH_RLMT);
 	}
 
 	for (i = pAPort->FirstExactMatchDrv; i < pAPort->NextExactMatchDrv; i++) {
-		OutAddr = (SK_U16 *)&pAPort->Exact[i].a[0];
+		OutAddr = (SK_U16 *) &pAPort->Exact[i].a[0];
 		XM_OUTADDR(IoC, PortNumber, XM_EXM(i), OutAddr);
 	}
 
-	/* Clear other non-permanent exact match addresses on HW. */
+	/* Clear other non-permanent exact match addresses on XMAC */
 	if (pAPort->NextExactMatchDrv <= SK_ADDR_LAST_MATCH_DRV) {
-		SkXmClrExactAddr(
-			pAC,
-			IoC,
-			PortNumber,
-			pAPort->NextExactMatchDrv,
+		
+		SkXmClrExactAddr(pAC, IoC, PortNumber, pAPort->NextExactMatchDrv,
 			SK_ADDR_LAST_MATCH_DRV);
 	}
 
@@ -760,36 +1149,33 @@
 	}
 
 	if (pAPort->PromMode & SK_PROM_MODE_ALL_MC) {
+		
 		/* Set all bits in 64-bit hash register. */
 		XM_OUTHASH(IoC, PortNumber, XM_HSM, &OnesHash);
-
-		/* Set bit 15 in mode register. */
-		XM_IN16(IoC, PortNumber, XM_MODE, &LoMode);
-		LoMode |= XM_MD_ENA_HSH;
-		XM_OUT16(IoC, PortNumber, XM_MODE, LoMode);
+		
+		/* Enable Hashing */
+		SkMacHashing(pAC, IoC, PortNumber, SK_TRUE);
 	}
 	else if (Inexact != 0) {
+		
 		/* Set 64-bit hash register to InexactFilter. */
 		XM_OUTHASH(IoC, PortNumber, XM_HSM, &pAPort->InexactFilter.Bytes[0]);
-
-		/* Set bit 15 in mode register. */
-		XM_IN16(IoC, PortNumber, XM_MODE, &LoMode);
-		LoMode |= XM_MD_ENA_HSH;
-		XM_OUT16(IoC, PortNumber, XM_MODE, LoMode);
+		
+		/* Enable Hashing */
+		SkMacHashing(pAC, IoC, PortNumber, SK_TRUE);
 	}
 	else {
-		/* Clear bit 15 in mode register. */
-		XM_IN16(IoC, PortNumber, XM_MODE, &LoMode);
-		LoMode &= ~XM_MD_ENA_HSH;
-		XM_OUT16(IoC, PortNumber, XM_MODE, LoMode);
+		/* Disable Hashing */
+		SkMacHashing(pAC, IoC, PortNumber, SK_FALSE);
 	}
 
 	if (pAPort->PromMode != SK_PROM_MODE_NONE) {
-		(void)SkAddrPromiscuousChange(pAC, IoC, PortNumber, pAPort->PromMode);
+		(void) SkAddrXmacPromiscuousChange(pAC, IoC, PortNumber, pAPort->PromMode);
 	}
 
-	/* Set port's current MAC address. */
-	OutAddr = (SK_U16 *)&pAPort->CurrentMacAddress.a[0];
+	/* Set port's current physical MAC address. */
+	OutAddr = (SK_U16 *) &pAPort->CurrentMacAddress.a[0];
+	
 	XM_OUTADDR(IoC, PortNumber, XM_SA, OutAddr);
 
 #ifdef xDEBUG
@@ -798,13 +1184,13 @@
 		SK_U16		*InAddr;
 
 		/* Get exact match address i from port PortNumber. */
-		InAddr = (SK_U16 *)&InAddr8[0];
+		InAddr = (SK_U16 *) &InAddr8[0];
+		
 		XM_INADDR(IoC, PortNumber, XM_EXM(i), InAddr);
-		SK_DBG_MSG(
-			pAC,
-			SK_DBGMOD_ADDR,
-			SK_DBGCAT_CTRL,
-			("MC address %d on Port %u: %02x %02x %02x %02x %02x %02x --  %02x %02x %02x %02x %02x %02x.\n",
+		
+		SK_DBG_MSG(pAC,SK_DBGMOD_ADDR, SK_DBGCAT_CTRL,
+			("SkAddrXmacMcUpdate: MC address %d on Port %u: ",
+			 "%02x %02x %02x %02x %02x %02x -- %02x %02x %02x %02x %02x %02x\n",
 				i,
 				PortNumber,
 				InAddr8[0],
@@ -829,7 +1215,113 @@
 	else {
 		return (SK_MC_FILTERING_INEXACT);
 	}
-}	/* SkAddrMcUpdate */
+	
+}	/* SkAddrXmacMcUpdate */
+
+
+/******************************************************************************
+ *
+ *	SkAddrGmacMcUpdate - update the HW MC address table and set the MAC address
+ *
+ * Description:
+ *	This routine enables reception of the addresses contained in a local
+ *	table for a given port.
+ *	It also programs the port's current physical MAC address.
+ *
+ * Notes:
+ *	The return code is only valid for SK_PROM_MODE_NONE.
+ *
+ * Context:
+ *	runtime, pageable
+ *	may be called after SK_INIT_IO
+ *
+ * Returns:
+ *	SK_MC_FILTERING_EXACT
+ *	SK_MC_FILTERING_INEXACT
+ *	SK_ADDR_ILLEGAL_PORT
+ */
+int	SkAddrGmacMcUpdate(
+SK_AC	*pAC,		/* adapter context */
+SK_IOC	IoC,		/* I/O context */
+SK_U32	PortNumber)	/* Port Number */
+{
+	SK_U32		i;
+	SK_U8		Inexact;
+	SK_U16		*OutAddr;
+	SK_ADDR_PORT	*pAPort;
+
+	SK_DBG_MSG(pAC,SK_DBGMOD_ADDR, SK_DBGCAT_CTRL,
+		("SkAddrGmacMcUpdate on Port %u.\n", PortNumber))
+	
+	pAPort = &pAC->Addr.Port[PortNumber];
+
+#ifdef DEBUG
+	SK_DBG_MSG(pAC,SK_DBGMOD_ADDR, SK_DBGCAT_CTRL,
+		("Next0 on Port %d: %d\n", PortNumber, Next0[PortNumber]))
+#endif	/* DEBUG */
+	
+	for (Inexact = 0, i = 0; i < 8; i++) {
+		Inexact |= pAPort->InexactFilter.Bytes[i];
+	}
+	
+	/* Set 64-bit hash register to InexactFilter. */
+	GM_OUTHASH(IoC, PortNumber, GM_MC_ADDR_H1,
+		&pAPort->InexactFilter.Bytes[0]);
+	
+	if (pAPort->PromMode & SK_PROM_MODE_ALL_MC) {				
+		
+		/* Set all bits in 64-bit hash register. */
+		GM_OUTHASH(IoC, PortNumber, GM_MC_ADDR_H1, &OnesHash);
+		
+		/* Enable Hashing */
+		SkMacHashing(pAC, IoC, PortNumber, SK_TRUE);
+	}
+	else {	
+		/* Enable Hashing. */
+		SkMacHashing(pAC, IoC, PortNumber, SK_TRUE);
+	}
+	
+	if (pAPort->PromMode != SK_PROM_MODE_NONE) {
+		(void) SkAddrGmacPromiscuousChange(pAC, IoC, PortNumber, pAPort->PromMode);
+	}
+	
+	/* Set port's current physical MAC address. */
+	OutAddr = (SK_U16 *) &pAPort->CurrentMacAddress.a[0];
+	GM_OUTADDR(IoC, PortNumber, GM_SRC_ADDR_1L, OutAddr);
+	
+	/* Set port's current logical MAC address. */
+	OutAddr = (SK_U16 *) &pAPort->Exact[0].a[0];
+	GM_OUTADDR(IoC, PortNumber, GM_SRC_ADDR_2L, OutAddr);
+	
+#ifdef DEBUG
+	SK_DBG_MSG(pAC, SK_DBGMOD_ADDR, SK_DBGCAT_CTRL,
+		("SkAddrGmacMcUpdate: Permanent Physical MAC Address: %02X %02X %02X %02X %02X %02X\n",
+			pAPort->Exact[0].a[0],
+			pAPort->Exact[0].a[1],
+			pAPort->Exact[0].a[2],
+			pAPort->Exact[0].a[3],
+			pAPort->Exact[0].a[4],
+			pAPort->Exact[0].a[5]))
+	
+	SK_DBG_MSG(pAC, SK_DBGMOD_ADDR, SK_DBGCAT_CTRL,
+		("SkAddrGmacMcUpdate: Physical MAC Address: %02X %02X %02X %02X %02X %02X\n",
+			pAPort->CurrentMacAddress.a[0],
+			pAPort->CurrentMacAddress.a[1],
+			pAPort->CurrentMacAddress.a[2],
+			pAPort->CurrentMacAddress.a[3],
+			pAPort->CurrentMacAddress.a[4],
+			pAPort->CurrentMacAddress.a[5]))
+#endif	/* DEBUG */
+	
+	/* Determine return value. */
+	if (Inexact == 0 && pAPort->PromMode == 0) {
+		return (SK_MC_FILTERING_EXACT);
+	}
+	else {
+		return (SK_MC_FILTERING_INEXACT);
+	}
+	
+}	/* SkAddrGmacMcUpdate */
 
 
 /******************************************************************************
@@ -863,7 +1355,7 @@
 
 	NetNumber = pAC->Rlmt.Port[PortNumber].Net->NetNumber;
 
-	if (PortNumber >= (SK_U32)pAC->GIni.GIMacsFound) {
+	if (PortNumber >= (SK_U32) pAC->GIni.GIMacsFound) {
 		return (SK_ADDR_ILLEGAL_PORT);
 	}
 
@@ -877,7 +1369,7 @@
 
 	if (Flags & SK_ADDR_SET_LOGICAL) {	/* Activate logical MAC address. */
 		/* Parameter *pNewAddr is ignored. */
-		for (i = 0; i < (SK_U32)pAC->GIni.GIMacsFound; i++) {
+		for (i = 0; i < (SK_U32) pAC->GIni.GIMacsFound; i++) {
 			if (!pAC->Addr.Port[i].CurrentMacAddressSet) {
 				return (SK_ADDR_TOO_EARLY);
 			}
@@ -891,12 +1383,12 @@
 			pAC->Addr.Net[NetNumber].CurrentMacAddress;
 
 		/* Write address to first exact match entry of active port. */
-		(void)SkAddrMcUpdate(pAC, IoC, PortNumber);
+		(void) SkAddrMcUpdate(pAC, IoC, PortNumber);
 	}
 	else if (Flags & SK_ADDR_CLEAR_LOGICAL) {
 		/* Deactivate logical MAC address. */
 		/* Parameter *pNewAddr is ignored. */
-		for (i = 0; i < (SK_U32)pAC->GIni.GIMacsFound; i++) {
+		for (i = 0; i < (SK_U32) pAC->GIni.GIMacsFound; i++) {
 			if (!pAC->Addr.Port[i].CurrentMacAddressSet) {
 				return (SK_ADDR_TOO_EARLY);
 			}
@@ -911,7 +1403,7 @@
 		}
 
 		/* Write address to first exact match entry of active port. */
-		(void)SkAddrMcUpdate(pAC, IoC, PortNumber);
+		(void) SkAddrMcUpdate(pAC, IoC, PortNumber);
 	}
 	else if (Flags & SK_ADDR_PHYSICAL_ADDRESS) {	/* Physical MAC address. */
 		if (SK_ADDR_EQUAL(pNewAddr->a,
@@ -919,7 +1411,7 @@
 			return (SK_ADDR_DUPLICATE_ADDRESS);
 		}
 
-		for (i = 0; i < (SK_U32)pAC->GIni.GIMacsFound; i++) {
+		for (i = 0; i < (SK_U32) pAC->GIni.GIMacsFound; i++) {
 			if (!pAC->Addr.Port[i].CurrentMacAddressSet) {
 				return (SK_ADDR_TOO_EARLY);
 			}
@@ -939,9 +1431,15 @@
 			pAC->Addr.Port[PortNumber].CurrentMacAddress;
 		pAC->Addr.Port[PortNumber].CurrentMacAddress = *pNewAddr;
 
-		/* Change port's address. */
-		OutAddr = (SK_U16 *)pNewAddr;
-		XM_OUTADDR(IoC, PortNumber, XM_SA, OutAddr);
+		/* Change port's physical MAC address. */
+		OutAddr = (SK_U16 *) pNewAddr;
+		
+		if (pAC->GIni.GIChipId == CHIP_ID_GENESIS) {
+			XM_OUTADDR(IoC, PortNumber, XM_SA, OutAddr);
+		}
+		else {
+			GM_OUTADDR(IoC, PortNumber, GM_SRC_ADDR_1L, OutAddr);
+		}
 
 		/* Report address change to RLMT. */
 		Para.Para32[0] = PortNumber;
@@ -954,7 +1452,7 @@
 			return (SK_ADDR_SUCCESS);
 		}
 		
-		for (i = 0; i < (SK_U32)pAC->GIni.GIMacsFound; i++) {
+		for (i = 0; i < (SK_U32) pAC->GIni.GIMacsFound; i++) {
 			if (!pAC->Addr.Port[i].CurrentMacAddressSet) {
 				return (SK_ADDR_TOO_EARLY);
 			}
@@ -964,31 +1462,44 @@
 				return (SK_ADDR_DUPLICATE_ADDRESS);
 			}
 		}
-
+		
+		/*
+		 * In case that the physical and the logical MAC addresses are equal
+		 * we must also change the physical MAC address here.
+		 * In this case we have an adapter which initially was programmed with
+		 * two identical MAC addresses.
+		 */
+		if (SK_ADDR_EQUAL(pAC->Addr.Port[PortNumber].CurrentMacAddress.a,
+				pAC->Addr.Port[PortNumber].Exact[0].a)) {
+			
+			pAC->Addr.Port[PortNumber].PreviousMacAddress =
+				pAC->Addr.Port[PortNumber].CurrentMacAddress;
+			pAC->Addr.Port[PortNumber].CurrentMacAddress = *pNewAddr;
+			
+			/* Report address change to RLMT. */
+			Para.Para32[0] = PortNumber;
+			Para.Para32[0] = -1;
+			SkEventQueue(pAC, SKGE_RLMT, SK_RLMT_PORT_ADDR, Para);
+		}
+		
 		/* Set PortNumber to number of net's active port. */
 		PortNumber = pAC->Rlmt.Net[NetNumber].
 			Port[pAC->Addr.Net[NetNumber].ActivePort]->PortNumber;
 
 		pAC->Addr.Net[NetNumber].CurrentMacAddress = *pNewAddr;
 		pAC->Addr.Port[PortNumber].Exact[0] = *pNewAddr;
-
 #ifdef DEBUG
-		SK_DBG_MSG(
-			pAC,
-			SK_DBGMOD_ADDR,
-			SK_DBGCAT_CTRL,
-			("Permanent MAC Address: %02X %02X %02X %02X %02X %02X\n",
+		SK_DBG_MSG(pAC,SK_DBGMOD_ADDR, SK_DBGCAT_CTRL,
+			("SkAddrOverride: Permanent MAC Address: %02X %02X %02X %02X %02X %02X\n",
 				pAC->Addr.Net[NetNumber].PermanentMacAddress.a[0],
 				pAC->Addr.Net[NetNumber].PermanentMacAddress.a[1],
 				pAC->Addr.Net[NetNumber].PermanentMacAddress.a[2],
 				pAC->Addr.Net[NetNumber].PermanentMacAddress.a[3],
 				pAC->Addr.Net[NetNumber].PermanentMacAddress.a[4],
 				pAC->Addr.Net[NetNumber].PermanentMacAddress.a[5]))
-		SK_DBG_MSG(
-			pAC,
-			SK_DBGMOD_ADDR,
-			SK_DBGCAT_CTRL,
-			("New logical MAC Address: %02X %02X %02X %02X %02X %02X\n",
+		
+		SK_DBG_MSG(pAC,SK_DBGMOD_ADDR, SK_DBGCAT_CTRL,
+			("SkAddrOverride: New logical MAC Address: %02X %02X %02X %02X %02X %02X\n",
 				pAC->Addr.Net[NetNumber].CurrentMacAddress.a[0],
 				pAC->Addr.Net[NetNumber].CurrentMacAddress.a[1],
 				pAC->Addr.Net[NetNumber].CurrentMacAddress.a[2],
@@ -997,11 +1508,12 @@
 				pAC->Addr.Net[NetNumber].CurrentMacAddress.a[5]))
 #endif	/* DEBUG */
 
-		/* Write address to first exact match entry of active port. */
-		(void)SkAddrMcUpdate(pAC, IoC, PortNumber);
+        /* Write address to first exact match entry of active port. */
+		(void) SkAddrMcUpdate(pAC, IoC, PortNumber);
 	}
 
 	return (SK_ADDR_SUCCESS);
+	
 }	/* SkAddrOverride */
 
 
@@ -1015,6 +1527,10 @@
  *	- all LLC frames
  *	- all MC frames
  *
+ *	It calls either SkAddrXmacPromiscuousChange or
+ *	SkAddrGmacPromiscuousChange, according to the adapter in use.
+ *	The real work is done there.
+ *
  * Context:
  *	runtime, pageable
  *	may be called after SK_INIT_IO
@@ -1029,6 +1545,48 @@
 SK_U32	PortNumber,		/* port whose promiscuous mode changes */
 int		NewPromMode)	/* new promiscuous mode */
 {
+	int ReturnCode;
+	
+	if (PortNumber >= (SK_U32) pAC->GIni.GIMacsFound) {
+		return (SK_ADDR_ILLEGAL_PORT);
+	}
+	
+	if (pAC->GIni.GIChipId == CHIP_ID_GENESIS) {
+		ReturnCode = SkAddrXmacPromiscuousChange(pAC, IoC, PortNumber, NewPromMode);
+	}
+	else {
+		ReturnCode = SkAddrGmacPromiscuousChange(pAC, IoC, PortNumber, NewPromMode);
+	}
+
+	return (ReturnCode);
+
+}	/* SkAddrPromiscuousChange */
+
+
+/******************************************************************************
+ *
+ *	SkAddrXmacPromiscuousChange - set promiscuous mode for given port
+ *
+ * Description:
+ *	This routine manages promiscuous mode:
+ *	- none
+ *	- all LLC frames
+ *	- all MC frames
+ *
+ * Context:
+ *	runtime, pageable
+ *	may be called after SK_INIT_IO
+ *
+ * Returns:
+ *	SK_ADDR_SUCCESS
+ *	SK_ADDR_ILLEGAL_PORT
+ */
+int	SkAddrXmacPromiscuousChange(
+SK_AC	*pAC,			/* adapter context */
+SK_IOC	IoC,			/* I/O context */
+SK_U32	PortNumber,		/* port whose promiscuous mode changes */
+int		NewPromMode)	/* new promiscuous mode */
+{
 	int			i;
 	SK_BOOL		InexactModeBit;
 	SK_U8		Inexact;
@@ -1037,14 +1595,11 @@
 	SK_U16		LoMode;		/* Lower 16 bits of XMAC Mode Register. */
 	int			CurPromMode = SK_PROM_MODE_NONE;
 
-	if (PortNumber >= (SK_U32)pAC->GIni.GIMacsFound) {
-		return (SK_ADDR_ILLEGAL_PORT);
-	}
-
 	/* Read CurPromMode from Hardware. */
 	XM_IN16(IoC, PortNumber, XM_MODE, &LoMode);
 
-	if (LoMode & XM_MD_ENA_PROM) {
+	if ((LoMode & XM_MD_ENA_PROM) != 0) {
+		/* Promiscuous mode! */
 		CurPromMode |= SK_PROM_MODE_LLC;
 	}
 	
@@ -1055,12 +1610,12 @@
 		CurPromMode |= (pAC->Addr.Port[PortNumber].PromMode & SK_PROM_MODE_ALL_MC);
 	}
 	else {
-		/* Read InexactModeBit (bit 15 in mode register). */
+		/* Get InexactModeBit (bit XM_MD_ENA_HASH in mode register) */
 		XM_IN16(IoC, PortNumber, XM_MODE, &LoMode);
 		
-		InexactModeBit = (LoMode & XM_MD_ENA_HSH) != 0;
+		InexactModeBit = (LoMode & XM_MD_ENA_HASH) != 0;
 
-		/* Read 64-bit hash register from HW. */
+		/* Read 64-bit hash register from XMAC */
 		XM_INHASH(IoC, PortNumber, XM_HSM, &HwInexactFilter.Bytes[0]);
 
 		for (HwInexact = 0xFF, i = 0; i < 8; i++) {
@@ -1080,13 +1635,12 @@
 
 	if ((NewPromMode & SK_PROM_MODE_ALL_MC) &&
 		!(CurPromMode & SK_PROM_MODE_ALL_MC)) {	/* All MC. */
+		
 		/* Set all bits in 64-bit hash register. */
 		XM_OUTHASH(IoC, PortNumber, XM_HSM, &OnesHash);
 
-		/* Set bit 15 in mode register. */
-		XM_IN16(IoC, PortNumber, XM_MODE, &LoMode);
-		LoMode |= XM_MD_ENA_HSH;
-		XM_OUT16(IoC, PortNumber, XM_MODE, LoMode);
+		/* Enable Hashing */
+		SkMacHashing(pAC, IoC, PortNumber, SK_TRUE);
 	}
 	else if ((CurPromMode & SK_PROM_MODE_ALL_MC) &&
 		!(NewPromMode & SK_PROM_MODE_ALL_MC)) {	/* Norm MC. */
@@ -1094,55 +1648,118 @@
 			Inexact |= pAC->Addr.Port[PortNumber].InexactFilter.Bytes[i];
 		}
 		if (Inexact == 0) {
-			/* Clear bit 15 in mode register. */
-			XM_IN16(IoC, PortNumber, XM_MODE, &LoMode);
-			LoMode &= ~XM_MD_ENA_HSH;
-			XM_OUT16(IoC, PortNumber, XM_MODE, LoMode);
+			/* Disable Hashing */
+			SkMacHashing(pAC, IoC, PortNumber, SK_FALSE);
 		}
 		else {
 			/* Set 64-bit hash register to InexactFilter. */
-			XM_OUTHASH(
-				IoC,
-				PortNumber,
-				XM_HSM,
+			XM_OUTHASH(IoC, PortNumber, XM_HSM,
 				&pAC->Addr.Port[PortNumber].InexactFilter.Bytes[0]);
 
-			/* Set bit 15 in mode register. */
-			XM_IN16(IoC, PortNumber, XM_MODE, &LoMode);
-			LoMode |= XM_MD_ENA_HSH;
-			XM_OUT16(IoC, PortNumber, XM_MODE, LoMode);
+			/* Enable Hashing */
+			SkMacHashing(pAC, IoC, PortNumber, SK_TRUE);
 		}
 	}
 
 	if ((NewPromMode & SK_PROM_MODE_LLC) &&
 		!(CurPromMode & SK_PROM_MODE_LLC)) {	/* Prom. LLC */
-		/* Set promiscuous bit in mode register. */
-		XM_IN16(IoC, PortNumber, XM_MODE, &LoMode);
-
-#if 0
-		/* Receive MAC frames. */
-		LoMode |= XM_MD_RX_MCTRL;
-#endif	/* 0 */
-
-		LoMode |= XM_MD_ENA_PROM;
-		XM_OUT16(IoC, PortNumber, XM_MODE, LoMode);
+		/* Set the MAC in Promiscuous Mode */
+		SkMacPromiscMode(pAC, IoC, PortNumber, SK_TRUE);
 	}
 	else if ((CurPromMode & SK_PROM_MODE_LLC) &&
 		!(NewPromMode & SK_PROM_MODE_LLC)) {	/* Norm. LLC. */
-		/* Clear promiscuous bit in mode register. */
-		XM_IN16(IoC, PortNumber, XM_MODE, &LoMode);
+		/* Clear Promiscuous Mode */
+		SkMacPromiscMode(pAC, IoC, PortNumber, SK_FALSE);
+	}
+	
+	return (SK_ADDR_SUCCESS);
+	
+}	/* SkAddrXmacPromiscuousChange */
 
-#if 0
-		/* Don't receive MAC frames. */
-		LoMode &= ~XM_MD_RX_MCTRL;
-#endif	/* 0 */
+
+/******************************************************************************
+ *
+ *	SkAddrGmacPromiscuousChange - set promiscuous mode for given port
+ *
+ * Description:
+ *	This routine manages promiscuous mode:
+ *	- none
+ *	- all LLC frames
+ *	- all MC frames
+ *
+ * Context:
+ *	runtime, pageable
+ *	may be called after SK_INIT_IO
+ *
+ * Returns:
+ *	SK_ADDR_SUCCESS
+ *	SK_ADDR_ILLEGAL_PORT
+ */
+int	SkAddrGmacPromiscuousChange(
+SK_AC	*pAC,			/* adapter context */
+SK_IOC	IoC,			/* I/O context */
+SK_U32	PortNumber,		/* port whose promiscuous mode changes */
+int		NewPromMode)	/* new promiscuous mode */
+{
+	SK_U16		ReceiveControl;	/* GMAC Receive Control Register */
+	int		CurPromMode = SK_PROM_MODE_NONE;
+
+	/* Read CurPromMode from Hardware. */
+	GM_IN16(IoC, PortNumber, GM_RX_CTRL, &ReceiveControl);
+
+	if ((ReceiveControl & (GM_RXCR_UCF_ENA | GM_RXCR_MCF_ENA)) == 0) {
+		/* Promiscuous mode! */
+		CurPromMode |= SK_PROM_MODE_LLC;
+	}
+
+	if ((ReceiveControl & GM_RXCR_MCF_ENA) == 0) {
+		/* All Multicast mode! */
+		CurPromMode |= (pAC->Addr.Port[PortNumber].PromMode & SK_PROM_MODE_ALL_MC);
+	}
+
+	pAC->Addr.Port[PortNumber].PromMode = NewPromMode;
+
+	if (NewPromMode == CurPromMode) {
+		return (SK_ADDR_SUCCESS);
+	}
+	
+	if ((NewPromMode & SK_PROM_MODE_ALL_MC) &&
+		!(CurPromMode & SK_PROM_MODE_ALL_MC)) {	/* All MC */
+		
+		/* Set all bits in 64-bit hash register. */
+		GM_OUTHASH(IoC, PortNumber, GM_MC_ADDR_H1, &OnesHash);
 		
-		LoMode &= ~XM_MD_ENA_PROM;
-		XM_OUT16(IoC, PortNumber, XM_MODE, LoMode);
+		/* Enable Hashing */
+		SkMacHashing(pAC, IoC, PortNumber, SK_TRUE);
 	}
 	
+	if ((CurPromMode & SK_PROM_MODE_ALL_MC) &&
+		!(NewPromMode & SK_PROM_MODE_ALL_MC)) {	/* Norm. MC */
+
+		/* Set 64-bit hash register to InexactFilter. */
+		GM_OUTHASH(IoC, PortNumber, GM_MC_ADDR_H1,
+			&pAC->Addr.Port[PortNumber].InexactFilter.Bytes[0]);
+
+		/* Enable Hashing. */
+		SkMacHashing(pAC, IoC, PortNumber, SK_TRUE);
+	}
+
+	if ((NewPromMode & SK_PROM_MODE_LLC) &&
+		!(CurPromMode & SK_PROM_MODE_LLC)) {	/* Prom. LLC */
+		
+		/* Set the MAC to Promiscuous Mode. */
+		SkMacPromiscMode(pAC, IoC, PortNumber, SK_TRUE);
+	}
+	else if ((CurPromMode & SK_PROM_MODE_LLC) &&
+		!(NewPromMode & SK_PROM_MODE_LLC)) {	/* Norm. LLC */
+		
+		/* Clear Promiscuous Mode. */
+		SkMacPromiscMode(pAC, IoC, PortNumber, SK_FALSE);
+	}
+
 	return (SK_ADDR_SUCCESS);
-}	/* SkAddrPromiscuousChange */
+	
+}	/* SkAddrGmacPromiscuousChange */
 
 
 /******************************************************************************
@@ -1163,7 +1780,7 @@
 int	SkAddrSwap(
 SK_AC	*pAC,			/* adapter context */
 SK_IOC	IoC,			/* I/O context */
-SK_U32	FromPortNumber,	/* Port1 Index */
+SK_U32	FromPortNumber,		/* Port1 Index */
 SK_U32	ToPortNumber)		/* Port2 Index */
 {
 	int			i;
@@ -1171,11 +1788,11 @@
 	SK_MAC_ADDR	MacAddr;
 	SK_U32		DWord;
 
-	if (FromPortNumber >= (SK_U32)pAC->GIni.GIMacsFound) {
+	if (FromPortNumber >= (SK_U32) pAC->GIni.GIMacsFound) {
 		return (SK_ADDR_ILLEGAL_PORT);
 	}
 
-	if (ToPortNumber >= (SK_U32)pAC->GIni.GIMacsFound) {
+	if (ToPortNumber >= (SK_U32) pAC->GIni.GIMacsFound) {
 		return (SK_ADDR_ILLEGAL_PORT);
 	}
 
@@ -1184,13 +1801,15 @@
 	}
 
 	/*
-	 * Swap
-	 * - Exact Match Entries
-	 * - FirstExactMatchRlmt;
-	 * - NextExactMatchRlmt;
-	 * - FirstExactMatchDrv;
-	 * - NextExactMatchDrv;
-	 * - 64-bit filter
+	 * Swap:
+	 * - Exact Match Entries (GEnesis and Yukon)
+	 *   Yukon uses first entry for the logical MAC
+	 *   address (stored in the second GMAC register).
+	 * - FirstExactMatchRlmt (GEnesis only)
+	 * - NextExactMatchRlmt (GEnesis only)
+	 * - FirstExactMatchDrv (GEnesis only)
+	 * - NextExactMatchDrv (GEnesis only)
+	 * - 64-bit filter (InexactFilter)
 	 * - Promiscuous Mode
 	 * of ports.
 	 */
@@ -1208,46 +1827,49 @@
 			pAC->Addr.Port[ToPortNumber].InexactFilter.Bytes[i];
 		pAC->Addr.Port[ToPortNumber].InexactFilter.Bytes[i] = Byte;
 	}
-
+	
 	i = pAC->Addr.Port[FromPortNumber].PromMode;
 	pAC->Addr.Port[FromPortNumber].PromMode = pAC->Addr.Port[ToPortNumber].PromMode;
 	pAC->Addr.Port[ToPortNumber].PromMode = i;
-
-	DWord = pAC->Addr.Port[FromPortNumber].FirstExactMatchRlmt;
-	pAC->Addr.Port[FromPortNumber].FirstExactMatchRlmt =
-		pAC->Addr.Port[ToPortNumber].FirstExactMatchRlmt;
-	pAC->Addr.Port[ToPortNumber].FirstExactMatchRlmt = DWord;
-
-	DWord = pAC->Addr.Port[FromPortNumber].NextExactMatchRlmt;
-	pAC->Addr.Port[FromPortNumber].NextExactMatchRlmt =
-		pAC->Addr.Port[ToPortNumber].NextExactMatchRlmt;
-	pAC->Addr.Port[ToPortNumber].NextExactMatchRlmt = DWord;
-
-	DWord = pAC->Addr.Port[FromPortNumber].FirstExactMatchDrv;
-	pAC->Addr.Port[FromPortNumber].FirstExactMatchDrv =
-		pAC->Addr.Port[ToPortNumber].FirstExactMatchDrv;
-	pAC->Addr.Port[ToPortNumber].FirstExactMatchDrv = DWord;
-
-	DWord = pAC->Addr.Port[FromPortNumber].NextExactMatchDrv;
-	pAC->Addr.Port[FromPortNumber].NextExactMatchDrv =
-		pAC->Addr.Port[ToPortNumber].NextExactMatchDrv;
-	pAC->Addr.Port[ToPortNumber].NextExactMatchDrv = DWord;
-
+	
+	if (pAC->GIni.GIChipId == CHIP_ID_GENESIS) {
+		DWord = pAC->Addr.Port[FromPortNumber].FirstExactMatchRlmt;
+		pAC->Addr.Port[FromPortNumber].FirstExactMatchRlmt =
+			pAC->Addr.Port[ToPortNumber].FirstExactMatchRlmt;
+		pAC->Addr.Port[ToPortNumber].FirstExactMatchRlmt = DWord;
+		
+		DWord = pAC->Addr.Port[FromPortNumber].NextExactMatchRlmt;
+		pAC->Addr.Port[FromPortNumber].NextExactMatchRlmt =
+			pAC->Addr.Port[ToPortNumber].NextExactMatchRlmt;
+		pAC->Addr.Port[ToPortNumber].NextExactMatchRlmt = DWord;
+		
+		DWord = pAC->Addr.Port[FromPortNumber].FirstExactMatchDrv;
+		pAC->Addr.Port[FromPortNumber].FirstExactMatchDrv =
+			pAC->Addr.Port[ToPortNumber].FirstExactMatchDrv;
+		pAC->Addr.Port[ToPortNumber].FirstExactMatchDrv = DWord;
+		
+		DWord = pAC->Addr.Port[FromPortNumber].NextExactMatchDrv;
+		pAC->Addr.Port[FromPortNumber].NextExactMatchDrv =
+			pAC->Addr.Port[ToPortNumber].NextExactMatchDrv;
+		pAC->Addr.Port[ToPortNumber].NextExactMatchDrv = DWord;
+	}
+	
 	/* CAUTION: Solution works if only ports of one adapter are in use. */
-	for (i = 0; (SK_U32)i < pAC->Rlmt.Net[pAC->Rlmt.Port[ToPortNumber].
+	for (i = 0; (SK_U32) i < pAC->Rlmt.Net[pAC->Rlmt.Port[ToPortNumber].
 		Net->NetNumber].NumPorts; i++) {
 		if (pAC->Rlmt.Net[pAC->Rlmt.Port[ToPortNumber].Net->NetNumber].
 			Port[i]->PortNumber == ToPortNumber) {
 			pAC->Addr.Net[pAC->Rlmt.Port[ToPortNumber].Net->NetNumber].
 				ActivePort = i;
 			/* 20001207 RA: Was "ToPortNumber;". */
-
 		}
 	}
-	(void)SkAddrMcUpdate(pAC, IoC, FromPortNumber);
-	(void)SkAddrMcUpdate(pAC, IoC, ToPortNumber);
+	
+	(void) SkAddrMcUpdate(pAC, IoC, FromPortNumber);
+	(void) SkAddrMcUpdate(pAC, IoC, ToPortNumber);
 
 	return (SK_ADDR_SUCCESS);
+	
 }	/* SkAddrSwap */
 
 #ifdef __cplusplus
diff -ruN linux/drivers/net/sk98lin/skcsum.c linuxn/drivers/net/sk98lin/skcsum.c
--- linux/drivers/net/sk98lin/skcsum.c	Wed Jul  4 20:50:39 2001
+++ linuxn/drivers/net/sk98lin/skcsum.c	Tue May 20 12:17:40 2003
@@ -2,15 +2,15 @@
  *
  * Name:	skcsum.c
  * Project:	GEnesis, PCI Gigabit Ethernet Adapter
- * Version:	$Revision: 1.8 $
- * Date:	$Date: 2001/02/06 11:15:36 $
+ * Version:	$Revision: 1.11 $
+ * Date:	$Date: 2003/03/11 14:05:55 $
  * Purpose:	Store/verify Internet checksum in send/receive packets.
  *
  ******************************************************************************/
 
 /******************************************************************************
  *
- *	(C)Copyright 1998-2001 SysKonnect GmbH.
+ *	(C)Copyright 1998-2003 SysKonnect GmbH.
  *
  *	This program is free software; you can redistribute it and/or modify
  *	it under the terms of the GNU General Public License as published by
@@ -26,6 +26,19 @@
  * History:
  *
  *	$Log: skcsum.c,v $
+ *	Revision 1.11  2003/03/11 14:05:55  rschmidt
+ *	Replaced memset() by macro SK_MEMSET()
+ *	Editorial changes
+ *	
+ *	Revision 1.10  2002/04/11 10:02:04  rwahl
+ *	Fix in SkCsGetSendInfo():
+ *	- function did not return ProtocolFlags in every case.
+ *	- pseudo header csum calculated wrong for big endian.
+ *	
+ *	Revision 1.9  2001/06/13 07:42:08  gklug
+ *	fix: NetNumber was wrong in CLEAR_STAT event
+ *	add: check for good NetNumber in Clear STAT
+ *	
  *	Revision 1.8  2001/02/06 11:15:36  rassmann
  *	Supporting two nets on dual-port adapters.
  *	
@@ -64,9 +77,8 @@
 #ifdef SK_USE_CSUM	/* Check if CSUM is to be used. */
 
 #ifndef lint
-static const char SysKonnectFileId[] = "@(#)"
-	"$Id: skcsum.c,v 1.8 2001/02/06 11:15:36 rassmann Exp $"
-	" (C) SysKonnect.";
+static const char SysKonnectFileId[] =
+	"@(#) $Id: skcsum.c,v 1.11 2003/03/11 14:05:55 rschmidt Exp $ (C) SysKonnect.";
 #endif	/* !lint */
 
 /******************************************************************************
@@ -98,8 +110,8 @@
  *
  *	"h/skdrv1st.h"
  *	"h/skcsum.h"
- *	 "h/sktypes.h"
- *	 "h/skqueue.h"
+ *	"h/sktypes.h"
+ *	"h/skqueue.h"
  *	"h/skdrv2nd.h"
  *
  ******************************************************************************/
@@ -164,7 +176,7 @@
  * little/big endian conversion on little endian machines only.
  */
 #ifdef SK_LITTLE_ENDIAN
-#define SKCS_HTON16(Val16)	(((unsigned) (Val16) >> 8) | (((Val16) & 0xFF) << 8))
+#define SKCS_HTON16(Val16)	(((unsigned) (Val16) >> 8) | (((Val16) & 0xff) << 8))
 #endif	/* SK_LITTLE_ENDIAN */
 #ifdef SK_BIG_ENDIAN
 #define SKCS_HTON16(Val16)	(Val16)
@@ -195,7 +207,7 @@
  *	zero.)
  *
  * Note:
- *	There is a bug in the ASIC whic may lead to wrong checksums.
+ *	There is a bug in the GENESIS ASIC which may lead to wrong checksums.
  *
  * Arguments:
  *	pAc - A pointer to the adapter context struct.
@@ -411,9 +423,9 @@
 			SKCS_OFS_IP_DESTINATION_ADDRESS + 0) +
 		(unsigned long) *(SK_U16 *) SKCS_IDX(pIpHeader,
 			SKCS_OFS_IP_DESTINATION_ADDRESS + 2) +
-		(unsigned long) (NextLevelProtocol << 8) +
+		(unsigned long) SKCS_HTON16(NextLevelProtocol) +
 		(unsigned long) SKCS_HTON16(IpDataLength);
-
+	
 	/* Add-in any carries. */
 
 	SKCS_OC_ADD(PseudoHeaderChecksum, PseudoHeaderChecksum, 0);
@@ -422,6 +434,7 @@
 
 	SKCS_OC_ADD(pPacketInfo->PseudoHeaderChecksum, PseudoHeaderChecksum, 0);
 
+	pPacketInfo->ProtocolFlags = ProtocolFlags;
 	NextLevelProtoStats->TxOkCts++;	/* Success. */
 }	/* SkCsGetSendInfo */
 
@@ -593,7 +606,7 @@
 	NextLevelProtocol = *(SK_U8 *)
 		SKCS_IDX(pIpHeader, SKCS_OFS_IP_NEXT_LEVEL_PROTOCOL);
 
-	if (IpHeaderChecksum != 0xFFFF) {
+	if (IpHeaderChecksum != 0xffff) {
 		pAc->Csum.ProtoStats[NetNumber][SKCS_PROTO_STATS_IP].RxErrCts++;
 		/* the NDIS tester wants to know the upper level protocol too */
 		if (NextLevelProtocol == SKCS_PROTO_ID_TCP) {
@@ -711,7 +724,7 @@
 
 	/* Check if the TCP/UDP checksum is ok. */
 
-	if ((unsigned) NextLevelProtocolChecksum == 0xFFFF) {
+	if ((unsigned) NextLevelProtocolChecksum == 0xffff) {
 
 		/* TCP/UDP checksum ok. */
 
@@ -889,14 +902,16 @@
 	 */
 	case SK_CSUM_EVENT_CLEAR_PROTO_STATS:
 
-		ProtoIndex = (int)Param.Para32[0];
-		NetNumber = (int)Param.Para32[1];
+		ProtoIndex = (int)Param.Para32[1];
+		NetNumber = (int)Param.Para32[0];
 		if (ProtoIndex < 0) {	/* Clear for all protocols. */
-			memset(&pAc->Csum.ProtoStats[NetNumber][0], 0,
-				sizeof(pAc->Csum.ProtoStats[NetNumber]));
+			if (NetNumber >= 0) {
+				SK_MEMSET(&pAc->Csum.ProtoStats[NetNumber][0], 0,
+					sizeof(pAc->Csum.ProtoStats[NetNumber]));
+			}
 		}
 		else {					/* Clear for individual protocol. */
-			memset(&pAc->Csum.ProtoStats[NetNumber][ProtoIndex], 0,
+			SK_MEMSET(&pAc->Csum.ProtoStats[NetNumber][ProtoIndex], 0,
 				sizeof(pAc->Csum.ProtoStats[NetNumber][ProtoIndex]));
 		}
 		break;
diff -ruN linux/drivers/net/sk98lin/skdim.c linuxn/drivers/net/sk98lin/skdim.c
--- linux/drivers/net/sk98lin/skdim.c	Thu Jan  1 01:00:00 1970
+++ linuxn/drivers/net/sk98lin/skdim.c	Tue May 20 12:17:40 2003
@@ -0,0 +1,712 @@
+/******************************************************************************
+ *
+ * Name:	skdim.c
+ * Project:	GEnesis, PCI Gigabit Ethernet Adapter
+ * Version:	$Revision: 1.1 $
+ * Date:	$Date: 2003/03/21 14:51:50 $
+ * Purpose:	All functions to maintain interrupt moderation
+ *
+ ******************************************************************************/
+
+/******************************************************************************
+ *
+ *	(C)Copyright 1998-2002 SysKonnect GmbH.
+ *
+ *	This program is free software; you can redistribute it and/or modify
+ *	it under the terms of the GNU General Public License as published by
+ *	the Free Software Foundation; either version 2 of the License, or
+ *	(at your option) any later version.
+ *
+ *	The information in this file is provided "AS IS" without warranty.
+ *
+ ******************************************************************************/
+
+/******************************************************************************
+ *
+ * History:
+ *
+ *
+ ******************************************************************************/
+
+/******************************************************************************
+ *
+ * Description:
+ *
+ * This module is intended to manage the dynamic interrupt moderation on both   
+ * GEnesis and Yukon adapters.
+ *
+ * Include File Hierarchy:
+ *
+ *	"skdrv1st.h"
+ *	"skdrv2nd.h"
+ *
+ ******************************************************************************/
+
+#ifndef	lint
+static const char SysKonnectFileId[] =
+	"@(#) $Id: skdim.c,v 1.1 2003/03/21 14:51:50 rroesler Exp $ (C) SysKonnect.";
+#endif	/* !defined(lint) */
+
+#define __SKADDR_C
+
+#ifdef __cplusplus
+#error C++ is not yet supported.
+extern "C" {
+#endif	/* cplusplus */
+
+/*******************************************************************************
+**
+** Includes
+**
+*******************************************************************************/
+
+#ifndef __INC_SKDRV1ST_H
+#include "h/skdrv1st.h"
+#endif
+
+#ifndef __INC_SKDRV2ND_H
+#include "h/skdrv2nd.h"
+#endif
+
+#include	<linux/kernel_stat.h>
+
+/*******************************************************************************
+**
+** Defines
+**
+*******************************************************************************/
+
+/*******************************************************************************
+**
+** Typedefs
+**
+*******************************************************************************/
+
+/*******************************************************************************
+**
+** Local function prototypes 
+**
+*******************************************************************************/
+
+static unsigned int GetCurrentSystemLoad(SK_AC *pAC);
+static SK_U64       GetIsrCalls(SK_AC *pAC);
+static SK_BOOL      IsIntModEnabled(SK_AC *pAC);
+static void         SetCurrIntCtr(SK_AC *pAC);
+static void         EnableIntMod(SK_AC *pAC); 
+static void         DisableIntMod(SK_AC *pAC);
+static void         ResizeDimTimerDuration(SK_AC *pAC);
+static void         DisplaySelectedModerationType(SK_AC *pAC);
+static void         DisplaySelectedModerationMask(SK_AC *pAC);
+static void         DisplayDescrRatio(SK_AC *pAC);
+
+/*******************************************************************************
+**
+** Global variables
+**
+*******************************************************************************/
+
+/*******************************************************************************
+**
+** Local variables
+**
+*******************************************************************************/
+
+/*******************************************************************************
+**
+** Global functions 
+**
+*******************************************************************************/
+
+/*******************************************************************************
+** Function     : SkDimModerate
+** Description  : Called in every ISR to check if moderation is to be applied
+**                or not for the current number of interrupts
+** Programmer   : Ralph Roesler
+** Last Modified: 22-mar-03
+** Returns      : void (!)
+** Notes        : -
+*******************************************************************************/
+
+void 
+SkDimModerate(SK_AC *pAC) {
+    unsigned int CurrSysLoad    = 0;  /* expressed in percent */
+    unsigned int LoadIncrease   = 0;  /* expressed in percent */
+    SK_U64       ThresholdInts  = 0;
+    SK_U64       IsrCallsPerSec = 0;
+
+#define M_DIMINFO pAC->DynIrqModInfo
+
+    if (!IsIntModEnabled(pAC)) {
+        if (M_DIMINFO.IntModTypeSelect == C_INT_MOD_DYNAMIC) {
+            CurrSysLoad = GetCurrentSystemLoad(pAC);
+            if (CurrSysLoad > 75) {
+                    /* 
+                    ** More than 75% total system load! Enable the moderation 
+                    ** to shield the system against too many interrupts.
+                    */
+                    EnableIntMod(pAC);
+            } else if (CurrSysLoad > M_DIMINFO.PrevSysLoad) {
+                LoadIncrease = (CurrSysLoad - M_DIMINFO.PrevSysLoad);
+                if (LoadIncrease > ((M_DIMINFO.PrevSysLoad *
+                                         C_INT_MOD_ENABLE_PERCENTAGE) / 100)) {
+                    if (CurrSysLoad > 10) {
+                        /* 
+                        ** More than 50% increase with respect to the 
+                        ** previous load of the system. Most likely this 
+                        ** is due to our ISR-proc...
+                        */
+                        EnableIntMod(pAC);
+                    }
+                }
+            } else {
+                /*
+                ** Neither too much system load at all nor too much increase
+                ** with respect to the previous system load. Hence, we can leave
+                ** the ISR-handling like it is without enabling moderation.
+                */
+            }
+            M_DIMINFO.PrevSysLoad = CurrSysLoad;
+        }   
+    } else {
+        if (M_DIMINFO.IntModTypeSelect == C_INT_MOD_DYNAMIC) {
+            ThresholdInts  = ((M_DIMINFO.MaxModIntsPerSec *
+                                   C_INT_MOD_DISABLE_PERCENTAGE) / 100);
+            IsrCallsPerSec = GetIsrCalls(pAC);
+            if (IsrCallsPerSec <= ThresholdInts) {
+                /* 
+                ** The number of interrupts within the last second is 
+                ** lower than the disable_percentage of the desried 
+                ** maxrate. Therefore we can disable the moderation.
+                */
+                DisableIntMod(pAC);
+                M_DIMINFO.MaxModIntsPerSec = 
+                   (M_DIMINFO.MaxModIntsPerSecUpperLimit +
+                    M_DIMINFO.MaxModIntsPerSecLowerLimit) / 2;
+            } else {
+                /*
+                ** The number of interrupts per sec is the same as expected.
+                ** Evalulate the descriptor-ratio. If it has changed, a resize 
+                ** in the moderation timer might be usefull
+                */
+                if (M_DIMINFO.AutoSizing) {
+                    ResizeDimTimerDuration(pAC);
+                }
+            }
+        }
+    }
+
+    /*
+    ** Some information to the log...
+    */
+    if (M_DIMINFO.DisplayStats) {
+        DisplaySelectedModerationType(pAC);
+        DisplaySelectedModerationMask(pAC);
+        DisplayDescrRatio(pAC);
+    }
+
+    M_DIMINFO.NbrProcessedDescr = 0; 
+    SetCurrIntCtr(pAC);
+}
+
+/*******************************************************************************
+** Function     : SkDimStartModerationTimer
+** Description  : Starts the audit-timer for the dynamic interrupt moderation
+** Programmer   : Ralph Roesler
+** Last Modified: 22-mar-03
+** Returns      : void (!)
+** Notes        : -
+*******************************************************************************/
+
+void 
+SkDimStartModerationTimer(SK_AC *pAC) {
+    SK_EVPARA    EventParam;   /* Event struct for timer event */
+ 
+    SK_MEMSET((char *) &EventParam, 0, sizeof(EventParam));
+    EventParam.Para32[0] = SK_DRV_MODERATION_TIMER;
+    SkTimerStart(pAC, pAC->IoBase, &pAC->DynIrqModInfo.ModTimer,
+                 SK_DRV_MODERATION_TIMER_LENGTH,
+                 SKGE_DRV, SK_DRV_TIMER, EventParam);
+}
+
+/*******************************************************************************
+** Function     : SkDimEnableModerationIfNeeded
+** Description  : Either enables or disables moderation
+** Programmer   : Ralph Roesler
+** Last Modified: 22-mar-03
+** Returns      : void (!)
+** Notes        : This function is called when a particular adapter is opened
+**                There is no Disable function, because when all interrupts 
+**                might be disable, the moderation timer has no meaning at all
+******************************************************************************/
+
+void
+SkDimEnableModerationIfNeeded(SK_AC *pAC) {
+
+    if (M_DIMINFO.IntModTypeSelect == C_INT_MOD_STATIC) {
+        EnableIntMod(pAC);   /* notification print in this function */
+    } else if (M_DIMINFO.IntModTypeSelect == C_INT_MOD_DYNAMIC) {
+        SkDimStartModerationTimer(pAC);
+        if (M_DIMINFO.DisplayStats) {
+            printk("Dynamic moderation has been enabled\n");
+        }
+    } else {
+        if (M_DIMINFO.DisplayStats) {
+            printk("No moderation has been enabled\n");
+        }
+    }
+}
+
+/*******************************************************************************
+** Function     : SkDimDisplayModerationSettings
+** Description  : Displays the current settings regaring interrupt moderation
+** Programmer   : Ralph Roesler
+** Last Modified: 22-mar-03
+** Returns      : void (!)
+** Notes        : -
+*******************************************************************************/
+
+void 
+SkDimDisplayModerationSettings(SK_AC *pAC) {
+    DisplaySelectedModerationType(pAC);
+    DisplaySelectedModerationMask(pAC);
+}
+
+/*******************************************************************************
+**
+** Local functions 
+**
+*******************************************************************************/
+
+/*******************************************************************************
+** Function     : GetCurrentSystemLoad
+** Description  : Retrieves the current system load of the system. This load
+**                is evaluated for all processors within the system.
+** Programmer   : Ralph Roesler
+** Last Modified: 22-mar-03
+** Returns      : unsigned int: load expressed in percentage
+** Notes        : The possible range being returned is from 0 up to 100.
+**                Whereas 0 means 'no load at all' and 100 'system fully loaded'
+**                It is impossible to determine what actually causes the system
+**                to be in 100%, but maybe that is due to too much interrupts.
+*******************************************************************************/
+
+static unsigned int
+GetCurrentSystemLoad(SK_AC *pAC) {
+    unsigned long jif         = jiffies;
+    unsigned int  UserTime    = 0;
+    unsigned int  SystemTime  = 0;
+    unsigned int  NiceTime    = 0;
+    unsigned int  IdleTime    = 0;
+    unsigned int  TotalTime   = 0;
+    unsigned int  UsedTime    = 0;
+    unsigned int  SystemLoad  = 0;
+    int           NbrCpu      = 0;
+
+    for (NbrCpu = 0; NbrCpu < smp_num_cpus; NbrCpu++) {
+        UserTime   = UserTime   + kstat.per_cpu_user[NbrCpu];
+        NiceTime   = NiceTime   + kstat.per_cpu_nice[NbrCpu];
+        SystemTime = SystemTime + kstat.per_cpu_system[NbrCpu];
+    }
+
+    UsedTime  = UserTime + NiceTime + SystemTime;
+    IdleTime  = jif * smp_num_cpus - UsedTime;
+    TotalTime = UsedTime + IdleTime;
+
+    SystemLoad = ( 100 * (UsedTime  - M_DIMINFO.PrevUsedTime) ) /
+                         (TotalTime - M_DIMINFO.PrevTotalTime);
+
+    if (M_DIMINFO.DisplayStats) {
+        printk("Current system load is: %u\n", SystemLoad);
+    }
+
+    M_DIMINFO.PrevTotalTime = TotalTime;
+    M_DIMINFO.PrevUsedTime  = UsedTime;
+
+    return (SystemLoad);
+}
+
+/*******************************************************************************
+** Function     : GetIsrCalls
+** Description  : Depending on the selected moderation mask, this function will
+**                return the number of interrupts handled in the previous time-
+**                frame. This evaluated number is based on the current number 
+**                of interrupts stored in PNMI-context and the previous stored 
+**                interrupts.
+** Programmer   : Ralph Roesler
+** Last Modified: 23-mar-03
+** Returns      : int:   the number of interrupts being executed in the last
+**                       timeframe
+** Notes        : It makes only sense to call this function, when dynamic 
+**                interrupt moderation is applied
+*******************************************************************************/
+
+static SK_U64
+GetIsrCalls(SK_AC *pAC) {
+    SK_U64   RxPort0IntDiff = 0;
+    SK_U64   RxPort1IntDiff = 0;
+    SK_U64   TxPort0IntDiff = 0;
+    SK_U64   TxPort1IntDiff = 0;
+
+    if (pAC->DynIrqModInfo.MaskIrqModeration == IRQ_MASK_TX_ONLY) {
+        if (pAC->GIni.GIMacsFound == 2) {
+            TxPort1IntDiff = pAC->Pnmi.Port[1].TxIntrCts - 
+                             pAC->DynIrqModInfo.PrevPort1TxIntrCts;
+        }
+        TxPort0IntDiff = pAC->Pnmi.Port[0].TxIntrCts - 
+                         pAC->DynIrqModInfo.PrevPort0TxIntrCts;
+    } else if (pAC->DynIrqModInfo.MaskIrqModeration == IRQ_MASK_RX_ONLY) {
+        if (pAC->GIni.GIMacsFound == 2) {
+            RxPort1IntDiff = pAC->Pnmi.Port[1].RxIntrCts - 
+                             pAC->DynIrqModInfo.PrevPort1RxIntrCts;
+        }
+        RxPort0IntDiff = pAC->Pnmi.Port[0].RxIntrCts - 
+                         pAC->DynIrqModInfo.PrevPort0RxIntrCts;
+    } else {
+        if (pAC->GIni.GIMacsFound == 2) {
+            RxPort1IntDiff = pAC->Pnmi.Port[1].RxIntrCts - 
+                             pAC->DynIrqModInfo.PrevPort1RxIntrCts;
+            TxPort1IntDiff = pAC->Pnmi.Port[1].TxIntrCts - 
+                             pAC->DynIrqModInfo.PrevPort1TxIntrCts;
+        } 
+        RxPort0IntDiff = pAC->Pnmi.Port[0].RxIntrCts - 
+                         pAC->DynIrqModInfo.PrevPort0RxIntrCts;
+        TxPort0IntDiff = pAC->Pnmi.Port[0].TxIntrCts - 
+                         pAC->DynIrqModInfo.PrevPort0TxIntrCts;
+    }
+
+    return (RxPort0IntDiff + RxPort1IntDiff + TxPort0IntDiff + TxPort1IntDiff);
+}
+
+/*******************************************************************************
+** Function     : GetRxCalls
+** Description  : This function will return the number of times a receive inter-
+**                rupt was processed. This is needed to evaluate any resizing 
+**                factor.
+** Programmer   : Ralph Roesler
+** Last Modified: 23-mar-03
+** Returns      : SK_U64: the number of RX-ints being processed
+** Notes        : It makes only sense to call this function, when dynamic 
+**                interrupt moderation is applied
+*******************************************************************************/
+
+static SK_U64
+GetRxCalls(SK_AC *pAC) {
+    SK_U64   RxPort0IntDiff = 0;
+    SK_U64   RxPort1IntDiff = 0;
+
+    if (pAC->GIni.GIMacsFound == 2) {
+        RxPort1IntDiff = pAC->Pnmi.Port[1].RxIntrCts - 
+                         pAC->DynIrqModInfo.PrevPort1RxIntrCts;
+    }
+    RxPort0IntDiff = pAC->Pnmi.Port[0].RxIntrCts - 
+                     pAC->DynIrqModInfo.PrevPort0RxIntrCts;
+
+    return (RxPort0IntDiff + RxPort1IntDiff);
+}
+
+/*******************************************************************************
+** Function     : SetCurrIntCtr
+** Description  : Will store the current number orf occured interrupts in the 
+**                adapter context. This is needed to evaluated the number of 
+**                interrupts within a current timeframe.
+** Programmer   : Ralph Roesler
+** Last Modified: 23-mar-03
+** Returns      : void (!)
+** Notes        : -
+*******************************************************************************/
+
+static void
+SetCurrIntCtr(SK_AC *pAC) {
+    if (pAC->GIni.GIMacsFound == 2) {
+        pAC->DynIrqModInfo.PrevPort1RxIntrCts = pAC->Pnmi.Port[1].RxIntrCts;
+        pAC->DynIrqModInfo.PrevPort1TxIntrCts = pAC->Pnmi.Port[1].TxIntrCts;
+    } 
+    pAC->DynIrqModInfo.PrevPort0RxIntrCts = pAC->Pnmi.Port[0].RxIntrCts;
+    pAC->DynIrqModInfo.PrevPort0TxIntrCts = pAC->Pnmi.Port[0].TxIntrCts;
+}
+
+/*******************************************************************************
+** Function     : IsIntModEnabled()
+** Description  : Retrieves the current value of the interrupts moderation
+**                command register. Its content determines whether any 
+**                moderation is running or not.
+** Programmer   : Ralph Roesler
+** Last Modified: 23-mar-03
+** Returns      : SK_TRUE  : if mod timer running
+**                SK_FALSE : if no moderation is being performed
+** Notes        : -
+*******************************************************************************/
+
+static SK_BOOL
+IsIntModEnabled(SK_AC *pAC) {
+    unsigned long CtrCmd;
+
+    SK_IN32(pAC->IoBase, B2_IRQM_CTRL, &CtrCmd);
+    if ((CtrCmd & TIM_START) == TIM_START) {
+       return SK_TRUE;
+    } else {
+       return SK_FALSE;
+    }
+}
+
+/*******************************************************************************
+** Function     : EnableIntMod()
+** Description  : Enables the interrupt moderation using the values stored in
+**                in the pAC->DynIntMod data structure
+** Programmer   : Ralph Roesler
+** Last Modified: 22-mar-03
+** Returns      : -
+** Notes        : -
+*******************************************************************************/
+
+static void
+EnableIntMod(SK_AC *pAC) {
+    unsigned long ModBase;
+
+    if (pAC->GIni.GIChipId == CHIP_ID_GENESIS) {
+       ModBase = C_CLK_FREQ_GENESIS / pAC->DynIrqModInfo.MaxModIntsPerSec;
+    } else {
+       ModBase = C_CLK_FREQ_YUKON / pAC->DynIrqModInfo.MaxModIntsPerSec;
+    }
+
+    SK_OUT32(pAC->IoBase, B2_IRQM_INI,  ModBase);
+    SK_OUT32(pAC->IoBase, B2_IRQM_MSK,  pAC->DynIrqModInfo.MaskIrqModeration);
+    SK_OUT32(pAC->IoBase, B2_IRQM_CTRL, TIM_START);
+    if (M_DIMINFO.DisplayStats) {
+        printk("Enabled interrupt moderation (%i ints/sec)\n",
+               M_DIMINFO.MaxModIntsPerSec);
+    }
+}
+
+/*******************************************************************************
+** Function     : DisableIntMod()
+** Description  : Disbles the interrupt moderation independent of what inter-
+**                rupts are running or not
+** Programmer   : Ralph Roesler
+** Last Modified: 23-mar-03
+** Returns      : -
+** Notes        : -
+*******************************************************************************/
+
+static void 
+DisableIntMod(SK_AC *pAC) {
+
+    SK_OUT32(pAC->IoBase, B2_IRQM_CTRL, TIM_STOP);
+    if (M_DIMINFO.DisplayStats) {
+        printk("Disabled interrupt moderation\n");
+    }
+} 
+
+/*******************************************************************************
+** Function     : ResizeDimTimerDuration();
+** Description  : Checks the current used descriptor ratio and resizes the 
+**                duration timer (longer/smaller) if possible. 
+** Programmer   : Ralph Roesler
+** Last Modified: 23-mar-03
+** Returns      : -
+** Notes        : There are both maximum and minimum timer duration value. 
+**                This function assumes that interrupt moderation is already
+**                enabled!
+*******************************************************************************/
+
+static void 
+ResizeDimTimerDuration(SK_AC *pAC) {
+    SK_BOOL IncreaseTimerDuration;
+    int     TotalMaxNbrDescr;
+    int     UsedDescrRatio;
+    int     RatioDiffAbs;
+    int     RatioDiffRel;
+    int     NewMaxModIntsPerSec;
+    int     ModAdjValue;
+    long    ModBase;
+
+    /*
+    ** Check first if we are allowed to perform any modification
+    */
+    if (IsIntModEnabled(pAC)) { 
+        if (M_DIMINFO.IntModTypeSelect != C_INT_MOD_DYNAMIC) {
+            return; 
+        } else {
+            if (M_DIMINFO.ModJustEnabled) {
+                M_DIMINFO.ModJustEnabled = SK_FALSE;
+                return;
+            }
+        }
+    }
+
+    /*
+    ** If we got until here, we have to evaluate the amount of the
+    ** descriptor ratio change...
+    */
+    TotalMaxNbrDescr = pAC->RxDescrPerRing * GetRxCalls(pAC);
+    UsedDescrRatio   = (M_DIMINFO.NbrProcessedDescr * 100) / TotalMaxNbrDescr;
+
+    if (UsedDescrRatio > M_DIMINFO.PrevUsedDescrRatio) {
+        RatioDiffAbs = (UsedDescrRatio - M_DIMINFO.PrevUsedDescrRatio);
+        RatioDiffRel = (RatioDiffAbs * 100) / UsedDescrRatio;
+        M_DIMINFO.PrevUsedDescrRatio = UsedDescrRatio;
+        IncreaseTimerDuration = SK_FALSE;  /* in other words: DECREASE */
+    } else if (UsedDescrRatio < M_DIMINFO.PrevUsedDescrRatio) {
+        RatioDiffAbs = (M_DIMINFO.PrevUsedDescrRatio - UsedDescrRatio);
+        RatioDiffRel = (RatioDiffAbs * 100) / M_DIMINFO.PrevUsedDescrRatio;
+        M_DIMINFO.PrevUsedDescrRatio = UsedDescrRatio;
+        IncreaseTimerDuration = SK_TRUE;   /* in other words: INCREASE */
+    } else {
+        RatioDiffAbs = (M_DIMINFO.PrevUsedDescrRatio - UsedDescrRatio);
+        RatioDiffRel = (RatioDiffAbs * 100) / M_DIMINFO.PrevUsedDescrRatio;
+        M_DIMINFO.PrevUsedDescrRatio = UsedDescrRatio;
+        IncreaseTimerDuration = SK_TRUE;   /* in other words: INCREASE */
+    }
+
+    /*
+    ** Now we can determine the change in percent
+    */
+    if ((RatioDiffRel >= 0) && (RatioDiffRel <= 5) ) {
+       ModAdjValue = 1;  /*  1% change - maybe some other value in future */
+    } else if ((RatioDiffRel > 5) && (RatioDiffRel <= 10) ) {
+       ModAdjValue = 1;  /*  1% change - maybe some other value in future */
+    } else if ((RatioDiffRel > 10) && (RatioDiffRel <= 15) ) {
+       ModAdjValue = 1;  /*  1% change - maybe some other value in future */
+    } else {
+       ModAdjValue = 1;  /*  1% change - maybe some other value in future */
+    }
+
+    if (IncreaseTimerDuration) {
+       NewMaxModIntsPerSec =  M_DIMINFO.MaxModIntsPerSec +
+                             (M_DIMINFO.MaxModIntsPerSec * ModAdjValue) / 100;
+    } else {
+       NewMaxModIntsPerSec =  M_DIMINFO.MaxModIntsPerSec -
+                             (M_DIMINFO.MaxModIntsPerSec * ModAdjValue) / 100;
+    }
+
+    /* 
+    ** Check if we exceed boundaries...
+    */
+    if ( (NewMaxModIntsPerSec > M_DIMINFO.MaxModIntsPerSecUpperLimit) ||
+         (NewMaxModIntsPerSec < M_DIMINFO.MaxModIntsPerSecLowerLimit)) {
+        if (M_DIMINFO.DisplayStats) {
+            printk("Cannot change ModTim from %i to %i ints/sec\n",
+                   M_DIMINFO.MaxModIntsPerSec, NewMaxModIntsPerSec);
+        }
+        return;
+    } else {
+        if (M_DIMINFO.DisplayStats) {
+            printk("Resized ModTim from %i to %i ints/sec\n",
+                   M_DIMINFO.MaxModIntsPerSec, NewMaxModIntsPerSec);
+        }
+    }
+
+    M_DIMINFO.MaxModIntsPerSec = NewMaxModIntsPerSec;
+
+    if (pAC->GIni.GIChipId == CHIP_ID_GENESIS) {
+        ModBase = C_CLK_FREQ_GENESIS / pAC->DynIrqModInfo.MaxModIntsPerSec;
+    } else {
+        ModBase = C_CLK_FREQ_YUKON / pAC->DynIrqModInfo.MaxModIntsPerSec;
+    }
+
+    /* 
+    ** We do not need to touch any other registers
+    */
+    SK_OUT32(pAC->IoBase, B2_IRQM_INI, ModBase);
+} 
+
+/*******************************************************************************
+** Function     : DisplaySelectedModerationType()
+** Description  : Displays what type of moderation we have
+** Programmer   : Ralph Roesler
+** Last Modified: 23-mar-03
+** Returns      : void!
+** Notes        : -
+*******************************************************************************/
+
+static void
+DisplaySelectedModerationType(SK_AC *pAC) {
+
+    if (pAC->DynIrqModInfo.DisplayStats) {
+        if (pAC->DynIrqModInfo.IntModTypeSelect == C_INT_MOD_STATIC) {
+             printk("Static int moderation runs with %i INTS/sec\n",
+                    pAC->DynIrqModInfo.MaxModIntsPerSec);
+        } else if (pAC->DynIrqModInfo.IntModTypeSelect == C_INT_MOD_DYNAMIC) {
+             if (IsIntModEnabled(pAC)) {
+                printk("Dynamic int moderation runs with %i INTS/sec\n",
+                       pAC->DynIrqModInfo.MaxModIntsPerSec);
+             } else {
+                printk("Dynamic int moderation currently not applied\n");
+             }
+        } else {
+             printk("No interrupt moderation selected!\n");
+        }
+    }
+}
+
+/*******************************************************************************
+** Function     : DisplaySelectedModerationMask()
+** Description  : Displays what interrupts are moderated
+** Programmer   : Ralph Roesler
+** Last Modified: 23-mar-03
+** Returns      : void!
+** Notes        : -
+*******************************************************************************/
+
+static void
+DisplaySelectedModerationMask(SK_AC *pAC) {
+
+    if (pAC->DynIrqModInfo.DisplayStats) {
+        if (pAC->DynIrqModInfo.IntModTypeSelect != C_INT_MOD_NONE) {
+            switch (pAC->DynIrqModInfo.MaskIrqModeration) {
+                case IRQ_MASK_TX_ONLY: 
+                   printk("Only Tx-interrupts are moderated\n");
+                   break;
+                case IRQ_MASK_RX_ONLY: 
+                   printk("Only Rx-interrupts are moderated\n");
+                   break;
+                case IRQ_MASK_SP_ONLY: 
+                   printk("Only special-interrupts are moderated\n");
+                   break;
+                case IRQ_MASK_TX_RX: 
+                   printk("Tx- and Rx-interrupts are moderated\n");
+                   break;
+                case IRQ_MASK_SP_RX: 
+                   printk("Special- and Rx-interrupts are moderated\n");
+                   break;
+                case IRQ_MASK_SP_TX: 
+                   printk("Special- and Tx-interrupts are moderated\n");
+                   break;
+                case IRQ_MASK_RX_TX_SP:
+                   printk("All Rx-, Tx and special-interrupts are moderated\n");
+                   break;
+                default:
+                   printk("Don't know what is moderated\n");
+                   break;
+            }
+        } else {
+            printk("No specific interrupts masked for moderation\n");
+        }
+    } 
+}
+
+/*******************************************************************************
+** Function     : DisplayDescrRatio
+** Description  : Like the name states...
+** Programmer   : Ralph Roesler
+** Last Modified: 23-mar-03
+** Returns      : void!
+** Notes        : -
+*******************************************************************************/
+
+static void
+DisplayDescrRatio(SK_AC *pAC) {
+    int TotalMaxNbrDescr = 0;
+
+    if (pAC->DynIrqModInfo.DisplayStats) {
+        TotalMaxNbrDescr = pAC->RxDescrPerRing * GetRxCalls(pAC);
+        printk("Ratio descriptors: %i/%i\n",
+               M_DIMINFO.NbrProcessedDescr, TotalMaxNbrDescr);
+    }
+}
+
+/*******************************************************************************
+**
+** End of file
+**
+*******************************************************************************/
diff -ruN linux/drivers/net/sk98lin/skge.c linuxn/drivers/net/sk98lin/skge.c
--- linux/drivers/net/sk98lin/skge.c	Fri Nov 29 00:53:14 2002
+++ linuxn/drivers/net/sk98lin/skge.c	Tue May 20 12:17:55 2003
@@ -2,18 +2,20 @@
  *
  * Name:    skge.c
  * Project:	GEnesis, PCI Gigabit Ethernet Adapter
- * Version:	$Revision: 1.29.2.6 $
- * Date:       	$Date: 2001/05/21 07:59:29 $
+ * Version:	$Revision: 1.54 $
+ * Date:       	$Date: 2003/04/28 13:07:27 $
  * Purpose:	The main driver source module
  *
  ******************************************************************************/
- 
+
 /******************************************************************************
  *
- *	(C)Copyright 1998-2001 SysKonnect GmbH.
+ *	(C)Copyright 1998-2003 SysKonnect GmbH.
  *
  *	Driver for SysKonnect Gigabit Ethernet Server Adapters:
  *
+ *	SK-9871 (single link 1000Base-ZX)
+ *	SK-9872 (dual link   1000Base-ZX)
  *	SK-9861 (single link 1000Base-SX, VF45 Volition Plug)
  *	SK-9862 (dual link   1000Base-SX, VF45 Volition Plug)
  *	SK-9841 (single link 1000Base-LX)
@@ -22,8 +24,14 @@
  *	SK-9844 (dual link   1000Base-SX)
  *	SK-9821 (single link 1000Base-T)
  *	SK-9822 (dual link   1000Base-T)
+ *	SK-9881 (single link 1000Base-SX V2 LC)
+ *	SK-9871 (single link 1000Base-ZX V2)
+ *	SK-9861 (single link 1000Base-SX V2, VF45 Volition Plug)
+ *	SK-9841 (single link 1000Base-LX V2)
+ *	SK-9843 (single link 1000Base-SX V2)
+ *	SK-9821 (single link 1000Base-T V2)
  *
- *	Created 10-Feb-1999, based on Linux' acenic.c, 3c59x.c and 
+ *	Created 10-Feb-1999, based on Linux' acenic.c, 3c59x.c and
  *	SysKonnects GEnesis Solaris driver
  *	Author: Christoph Goos (cgoos@syskonnect.de)
  *	        Mirko Lindner (mlindner@syskonnect.de)
@@ -48,6 +56,95 @@
  * History:
  *
  *	$Log: skge.c,v $
+ *	Revision 1.54  2003/04/28 13:07:27  mlindner
+ *	Fix: Delay race condition with some server machines
+ *	
+ *	Revision 1.53  2003/04/28 12:49:49  mlindner
+ *	Fix: Code optimization
+ *	
+ *	Revision 1.52  2003/04/28 12:24:32  mlindner
+ *	Fix: Disabled HW Error IRQ on 32-bit Yukon if sensor IRQ occurs
+ *	
+ *	Revision 1.51  2003/04/16 08:31:14  mlindner
+ *	Fix: Kernel 2.2 compilation
+ *	
+ *	Revision 1.49  2003/04/10 09:08:51  mlindner
+ *	Add: Blink mode verification
+ *	Fix: Checksum calculation
+ *	
+ *	Revision 1.48  2003/03/21 14:48:38  rroesler
+ *	Added code for interrupt moderation
+ *	
+ *	Revision 1.47  2003/03/12 13:56:15  mlindner
+ *	Fix: Mac update during SK_DRV_NET_UP
+ *	
+ *	Revision 1.46  2003/02/25 14:16:36  mlindner
+ *	Fix: Copyright statement
+ *	
+ *	Revision 1.45  2003/02/25 13:25:55  mlindner
+ *	Add: Performance improvements
+ *	Add: Support for various vendors
+ *	Fix: Init function
+ *	
+ *	Revision 1.44  2003/01/09 09:25:26  mlindner
+ *	Fix: Remove useless init_module/cleanup_module forward declarations
+ *	
+ *	Revision 1.43  2002/11/29 08:42:41  mlindner
+ *	Fix: Boot message
+ *	
+ *	Revision 1.42  2002/11/28 13:30:23  mlindner
+ *	Add: New frame check
+ *	
+ *	Revision 1.41  2002/11/27 13:55:18  mlindner
+ *	Fix: Drop wrong csum packets
+ *	Fix: Initialize proc_entry after hw check
+ *	
+ *	Revision 1.40  2002/10/31 07:50:37  tschilli
+ *	Function SkGeInitAssignRamToQueues() from common module inserted.
+ *	Autonegotiation is set to ON for all adapters.
+ *	LinkSpeedUsed is used in link up status report.
+ *	Role parameter will show up for 1000 Mbps links only.
+ *	GetConfiguration() inserted after init level 1 in SkGeChangeMtu().
+ *	All return values of SkGeInit() and SkGeInitPort() are checked.
+ *	
+ *	Revision 1.39  2002/10/02 12:56:05  mlindner
+ *	Add: Support for Yukon
+ *	Add: Support for ZEROCOPY, scatter-gather and hw checksum
+ *	Add: New transmit ring function (use SG and TCP/UDP hardware checksumming)
+ *	Add: New init function
+ *	Add: Speed check and setup
+ *	Add: Merge source for kernel 2.2.x and 2.4.x
+ *	Add: Opcode check for tcp
+ *	Add: Frame length check
+ *	Fix: Transmit complete interrupt
+ *	Fix: Interrupt moderation
+ *	
+ *	Revision 1.29.2.13  2002/01/14 12:44:52  mlindner
+ *	Fix: Rlmt modes
+ *	
+ *	Revision 1.29.2.12  2001/12/07 12:06:18  mlindner
+ *	Fix: malloc -> slab changes
+ *	
+ *	Revision 1.29.2.11  2001/12/06 15:19:20  mlindner
+ *	Add: DMA attributes
+ *	Fix: Module initialisation
+ *	Fix: pci_map_single and pci_unmap_single replaced
+ *	
+ *	Revision 1.29.2.10  2001/12/06 09:56:50  mlindner
+ *	Corrected some printk's
+ *	
+ *	Revision 1.29.2.9  2001/09/05 12:15:34  mlindner
+ *	Add: LBFO Changes
+ *	Fix: Counter Errors (Jumbo == to long errors)
+ *	Fix: Changed pAC->PciDev declaration
+ *	Fix: too short counters
+ *	
+ *	Revision 1.29.2.8  2001/06/25 12:10:44  mlindner
+ *	fix: ReceiveIrq() changed.
+ *	
+ *	Revision 1.29.2.7  2001/06/25 08:07:05  mlindner
+ *	fix: RLMT locking in ReceiveIrq() changed.
+ *	
  *	Revision 1.29.2.6  2001/05/21 07:59:29  mlindner
  *	fix: MTU init problems
  *	
@@ -189,7 +286,7 @@
  *	Printing "ethX:" before adapter type at adapter init.
  *	
  *
- *	10-Feb-1999 cg	Created, based on Linux' acenic.c, 3c59x.c and 
+ *	10-Feb-1999 cg	Created, based on Linux' acenic.c, 3c59x.c and
  *			SysKonnects GEnesis Solaris driver
  *
  ******************************************************************************/
@@ -198,11 +295,11 @@
  *
  * Possible compiler options (#define xxx / -Dxxx):
  *
- *	debugging can be enable by changing SK_DEBUG_CHKMOD and 
+ *	debugging can be enable by changing SK_DEBUG_CHKMOD and
  *	SK_DEBUG_CHKCAT in makefile (described there).
  *
  ******************************************************************************/
- 
+
 /******************************************************************************
  *
  * Description:
@@ -266,38 +363,42 @@
  ******************************************************************************/
 
 #include	"h/skversion.h"
-
 #include	<linux/module.h>
 #include	<linux/init.h>
 #include 	<linux/proc_fs.h>
-
 #include	"h/skdrv1st.h"
 #include	"h/skdrv2nd.h"
 
-/* defines ******************************************************************/
+/*******************************************************************************
+ *
+ * Defines
+ *
+ ******************************************************************************/
 /* for debuging on x86 only */
 /* #define BREAKPOINT() asm(" int $3"); */
 
+
+/* use the scatter-gather functionality with sendfile() */
+#define SK_ZEROCOPY
+
 /* use of a transmit complete interrupt */
 #define USE_TX_COMPLETE
 
-/* use interrupt moderation (for tx complete only) */
-// #define USE_INT_MOD
-#define INTS_PER_SEC	1000
-
 /*
  * threshold for copying small receive frames
  * set to 0 to avoid copying, set to 9001 to copy all frames
  */
-#define SK_COPY_THRESHOLD	200
+#define SK_COPY_THRESHOLD	50
 
 /* number of adapters that can be configured via command line params */
 #define SK_MAX_CARD_PARAM	16
 
 /*
- * use those defines for a compile-in version of the driver instead 
+ * use those defines for a compile-in version of the driver instead
  * of command line parameters
  */
+// #define LINK_SPEED_A	{"Auto", }
+// #define LINK_SPEED_B	{"Auto", }
 // #define AUTO_NEG_A	{"Sense", }
 // #define AUTO_NEG_B	{"Sense", }
 // #define DUP_CAP_A	{"Both", }
@@ -313,79 +414,90 @@
 #define DEV_KFREE_SKB_IRQ(skb) dev_kfree_skb_irq(skb)
 #define DEV_KFREE_SKB_ANY(skb) dev_kfree_skb_any(skb)
 
-/* function prototypes ******************************************************/
-static void	FreeResources(struct net_device *dev);
-int		init_module(void);
-void		cleanup_module(void);
-static int	SkGeBoardInit(struct net_device *dev, SK_AC *pAC);
+
+/* Set blink mode*/
+#define OEM_CONFIG_VALUE (	SK_ACT_LED_BLINK | \
+				SK_DUP_LED_NORMAL | \
+				SK_LED_LINK100_ON)
+
+
+/*******************************************************************************
+ *
+ * Local Function Prototypes
+ *
+ ******************************************************************************/
+
+static void	FreeResources(struct SK_NET_DEVICE *dev);
+static int	SkGeBoardInit(struct SK_NET_DEVICE *dev, SK_AC *pAC);
 static SK_BOOL	BoardAllocMem(SK_AC *pAC);
 static void	BoardFreeMem(SK_AC *pAC);
 static void	BoardInitMem(SK_AC *pAC);
-static void	SetupRing(SK_AC*, void*, uintptr_t, RXD**, RXD**, RXD**,
-			int*, SK_BOOL);
-
+static void	SetupRing(SK_AC*, void*, uintptr_t, RXD**, RXD**, RXD**, int*, SK_BOOL);
 static void	SkGeIsr(int irq, void *dev_id, struct pt_regs *ptregs);
 static void	SkGeIsrOnePort(int irq, void *dev_id, struct pt_regs *ptregs);
-static int	SkGeOpen(struct net_device *dev);
-static int	SkGeClose(struct net_device *dev);
-static int	SkGeXmit(struct sk_buff *skb, struct net_device *dev);
-static int	SkGeSetMacAddr(struct net_device *dev, void *p);
-static void	SkGeSetRxMode(struct net_device *dev);
-static struct net_device_stats *SkGeStats(struct net_device *dev);
-static int	SkGeIoctl(struct net_device *dev, struct ifreq *rq, int cmd);
+static int	SkGeOpen(struct SK_NET_DEVICE *dev);
+static int	SkGeClose(struct SK_NET_DEVICE *dev);
+static int	SkGeXmit(struct sk_buff *skb, struct SK_NET_DEVICE *dev);
+static int	SkGeSetMacAddr(struct SK_NET_DEVICE *dev, void *p);
+static void	SkGeSetRxMode(struct SK_NET_DEVICE *dev);
+static struct	net_device_stats *SkGeStats(struct SK_NET_DEVICE *dev);
+static int	SkGeIoctl(struct SK_NET_DEVICE *dev, struct ifreq *rq, int cmd);
 static void	GetConfiguration(SK_AC*);
 static void	ProductStr(SK_AC*);
 static int	XmitFrame(SK_AC*, TX_PORT*, struct sk_buff*);
 static void	FreeTxDescriptors(SK_AC*pAC, TX_PORT*);
 static void	FillRxRing(SK_AC*, RX_PORT*);
 static SK_BOOL	FillRxDescriptor(SK_AC*, RX_PORT*);
-static void	ReceiveIrq(SK_AC*, RX_PORT*);
+static void	ReceiveIrq(SK_AC*, RX_PORT*, SK_BOOL);
 static void	ClearAndStartRx(SK_AC*, int);
 static void	ClearTxIrq(SK_AC*, int, int);
 static void	ClearRxRing(SK_AC*, RX_PORT*);
 static void	ClearTxRing(SK_AC*, TX_PORT*);
 static void	SetQueueSizes(SK_AC	*pAC);
-static int	SkGeChangeMtu(struct net_device *dev, int new_mtu);
+static int	SkGeChangeMtu(struct SK_NET_DEVICE *dev, int new_mtu);
 static void	PortReInitBmu(SK_AC*, int);
 static int	SkGeIocMib(DEV_NET*, unsigned int, int);
+static int	XmitFrameSG(SK_AC*, TX_PORT*, struct sk_buff*);
+static void	StartDrvCleanupTimer(SK_AC *pAC);
+static void	StopDrvCleanupTimer(SK_AC *pAC);
 
+/*******************************************************************************
+ *
+ * Extern Function Prototypes
+ *
+ ******************************************************************************/
 
-/*Extern */
-
-extern struct proc_dir_entry *pSkRootDir;
-
-//extern struct proc_dir_entry Our_Proc_Dir;
-extern int proc_read(char *buffer, char **buffer_location,
-	off_t offset, int buffer_length, int *eof, void *data);
-
+extern int proc_read(char   *buffer,
+                     char  **buffer_location,
+                     off_t   offset,
+                     int     buffer_length,
+                     int    *eof,
+                     void   *data);
+
+extern void SkDimEnableModerationIfNeeded(SK_AC *pAC);	
+extern void SkDimDisplayModerationSettings(SK_AC *pAC);
+extern void SkDimStartModerationTimer(SK_AC *pAC);
+extern void SkDimModerate(SK_AC *pAC);
 
 #ifdef DEBUG
 static void	DumpMsg(struct sk_buff*, char*);
 static void	DumpData(char*, int);
 static void	DumpLong(char*, int);
 #endif
-
+void dump_frag( SK_U8 *data, int length);
 
 /* global variables *********************************************************/
 static const char *BootString = BOOT_STRING;
-struct net_device *sk98lin_root_dev = NULL;
+struct SK_NET_DEVICE *SkGeRootDev = NULL;
 static int probed __initdata = 0;
-struct inode_operations SkInodeOps;
-//static struct file_operations SkFileOps;  /* with open/relase */
 
 /* local variables **********************************************************/
 static uintptr_t TxQueueAddr[SK_MAX_MACS][2] = {{0x680, 0x600},{0x780, 0x700}};
 static uintptr_t RxQueueAddr[SK_MAX_MACS] = {0x400, 0x480};
 
+const char SK_Root_Dir_entry[8];
 
-
-void proc_fill_inode(struct inode *inode, int fill)
-{
-	if (fill)
-		MOD_INC_USE_COUNT;
-	else
-		MOD_DEC_USE_COUNT;
-}
+static struct proc_dir_entry	*pSkRootDir;
 
 
 
@@ -405,51 +517,59 @@
 static int __init skge_probe (void)
 {
 	int			proc_root_initialized = 0;
-	int 		boards_found = 0;
-	int			version_disp = 0;
-	SK_AC		*pAC;
-	DEV_NET		*pNet = NULL;
-	struct 		pci_dev	*pdev = NULL;
-	unsigned long		base_address;
-	struct net_device *dev = NULL;
+	int			boards_found = 0;
+	int			vendor_flag = SK_FALSE;
+	SK_AC			*pAC;
+	DEV_NET			*pNet = NULL;
 	struct proc_dir_entry	*pProcFile;
+	struct pci_dev	*pdev = NULL;
+	unsigned long		base_address;
+	struct SK_NET_DEVICE *dev = NULL;
+	SK_BOOL DeviceFound = SK_FALSE;
+	SK_BOOL BootStringCount = SK_FALSE;
 
 	if (probed)
 		return -ENODEV;
 	probed++;
-	
-	/* display driver info */
-	if (!version_disp)
-	{
-		/* set display flag to TRUE so that */
-		/* we only display this string ONCE */
-		version_disp = 1;
-		printk("%s\n", BootString);
-	}
 
 	if (!pci_present())		/* is PCI support present? */
 		return -ENODEV;
 
-	while((pdev = pci_find_device(PCI_VENDOR_ID_SYSKONNECT,
-				      PCI_DEVICE_ID_SYSKONNECT_GE, pdev)) != NULL) {
+		while((pdev = pci_find_class(PCI_CLASS_NETWORK_ETHERNET << 8, pdev)))
+		{
 
 		dev = NULL;
 		pNet = NULL;
 
-		if (pci_enable_device(pdev))
+
+		SK_PCI_ISCOMPLIANT(vendor_flag, pdev);
+		if (!vendor_flag)
 			continue;
 
+/*		if ((pdev->vendor != PCI_VENDOR_ID_SYSKONNECT) &&
+			((pdev->device != PCI_DEVICE_ID_SYSKONNECT_GE) ||
+			(pdev->device != PCI_DEVICE_ID_SYSKONNECT_YU))){
+			continue;
+		}
+*/
 		/* Configure DMA attributes. */
 		if (pci_set_dma_mask(pdev, (u64) 0xffffffffffffffff) &&
-		    pci_set_dma_mask(pdev, (u64) 0xffffffff))
-				continue;
+			pci_set_dma_mask(pdev, (u64) 0xffffffff))
+			continue;
 
-		if ((dev = init_etherdev(dev, sizeof(DEV_NET))) == 0) {
+
+		if ((dev = init_etherdev(dev, sizeof(DEV_NET))) == NULL) {
 			printk(KERN_ERR "Unable to allocate etherdev "
 			       "structure!\n");
 			break;
 		}
 
+		if (dev->priv == NULL) {
+			printk(KERN_ERR "Unable to allocate adapter "
+			       "structure!\n");
+			break;
+		}
+
 		pNet = dev->priv;
 		pNet->pAC = kmalloc(sizeof(SK_AC), GFP_KERNEL);
 		if (pNet->pAC == NULL){
@@ -459,15 +579,23 @@
 			break;
 		}
 
+		/* Print message */
+		if (!BootStringCount) {
+			/* set display flag to TRUE so that */
+			/* we only display this string ONCE */
+			BootStringCount = SK_TRUE;
+			printk("%s\n", BootString);
+		}
+
 		memset(pNet->pAC, 0, sizeof(SK_AC));
 		pAC = pNet->pAC;
-		pAC->PciDev = *pdev;
+		pAC->PciDev = pdev;
 		pAC->PciDevId = pdev->device;
 		pAC->dev[0] = dev;
 		pAC->dev[1] = dev;
 		sprintf(pAC->Name, "SysKonnect SK-98xx");
 		pAC->CheckQueue = SK_FALSE;
-		
+
 		pNet->Mtu = 1500;
 		pNet->Up = 0;
 		dev->irq = pdev->irq;
@@ -480,28 +608,23 @@
 		dev->set_mac_address =	&SkGeSetMacAddr;
 		dev->do_ioctl =		&SkGeIoctl;
 		dev->change_mtu =	&SkGeChangeMtu;
+		dev->flags &= 		~IFF_RUNNING;
 
-		if(!proc_root_initialized) {
-			pSkRootDir = create_proc_entry("sk98lin",
-				S_IFDIR | S_IWUSR | S_IRUGO | S_IXUGO, proc_net);
-			pSkRootDir->owner = THIS_MODULE;
-
-			proc_root_initialized = 1;
+#ifdef SK_ZEROCOPY
+		if (pAC->GIni.GIChipId == CHIP_ID_YUKON) {
+			/* Use only if yukon hardware */
+			/* SK and ZEROCOPY - fly baby... */
+			dev->features |= NETIF_F_SG | NETIF_F_IP_CSUM;
 		}
-
-		pProcFile = create_proc_entry(dev->name, 
-			S_IFREG | 0444, pSkRootDir);
-		pProcFile->read_proc = proc_read;
-		pProcFile->write_proc = NULL;
-		pProcFile->nlink = 1;
-		pProcFile->size = sizeof(dev->name+1);
-		pProcFile->data = (void*)pProcFile;
+#endif
 
 		/*
 		 * Dummy value.
 		 */
 		dev->base_addr = 42;
 		pci_set_master(pdev);
+
+		pci_set_master(pdev);
 		base_address = pci_resource_start (pdev, 0);
 
 #ifdef SK_BIG_ENDIAN
@@ -515,13 +638,13 @@
 			our2 |= PCI_REV_DESC;
 			SkPciWriteCfgDWord(pAC, PCI_OUR_REG_2, our2);
 		}
-#endif /* BIG ENDIAN */
+#endif
 
 		/*
 		 * Remap the regs into kernel space.
 		 */
-
 		pAC->IoBase = (char*)ioremap(base_address, 0x4000);
+
 		if (!pAC->IoBase){
 			printk(KERN_ERR "%s:  Unable to map I/O register, "
 			       "SK 98xx No. %i will be disabled.\n",
@@ -529,8 +652,8 @@
 			kfree(dev);
 			break;
 		}
-		pAC->Index = boards_found;
 
+		pAC->Index = boards_found;
 		if (SkGeBoardInit(dev, pAC)) {
 			FreeResources(dev);
 			kfree(dev);
@@ -540,9 +663,46 @@
 		memcpy((caddr_t) &dev->dev_addr,
 			(caddr_t) &pAC->Addr.Net[0].CurrentMacAddress, 6);
 
+		/* First adapter... Create proc and print message */
+		if (!DeviceFound) {
+			DeviceFound = SK_TRUE;
+			SK_MEMCPY(&SK_Root_Dir_entry, BootString,
+				sizeof(SK_Root_Dir_entry) - 1);
+
+			/*Create proc (directory)*/
+			if(!proc_root_initialized) {
+				pSkRootDir = create_proc_entry(SK_Root_Dir_entry,
+					S_IFDIR | S_IWUSR | S_IRUGO | S_IXUGO, proc_net);
+				proc_root_initialized = 1;
+			}
+
+			pSkRootDir->owner = THIS_MODULE;
+		}
+
+
+
+		/* Create proc file */
+		pProcFile = create_proc_entry(dev->name,
+			S_IFREG | S_IXUSR | S_IWGRP | S_IROTH,
+			pSkRootDir);
+
+		
+		pProcFile->read_proc = proc_read;
+		pProcFile->write_proc = NULL;
+		pProcFile->nlink = 1;
+		pProcFile->size = sizeof(dev->name + 1);
+		pProcFile->data = (void *)pProcFile;
+
 		pNet->PortNr = 0;
 		pNet->NetNr = 0;
 
+#ifdef SK_ZEROCOPY
+			if (pAC->GIni.GIChipId == CHIP_ID_YUKON) {
+				/* SG and ZEROCOPY - fly baby... */
+				dev->features |= NETIF_F_SG | NETIF_F_IP_CSUM;
+			}
+#endif
+
 		boards_found++;
 
 		/* More then one port found */
@@ -569,24 +729,39 @@
 			dev->set_mac_address =	&SkGeSetMacAddr;
 			dev->do_ioctl =		&SkGeIoctl;
 			dev->change_mtu =	&SkGeChangeMtu;
+			dev->flags &= 		~IFF_RUNNING;
 
-			pProcFile = create_proc_entry(dev->name, 
-				S_IFREG | 0444, pSkRootDir);
+#ifdef SK_ZEROCOPY
+			if (pAC->GIni.GIChipId == CHIP_ID_YUKON) {
+				/* SG and ZEROCOPY - fly baby... */
+				dev->features |= NETIF_F_SG | NETIF_F_IP_CSUM;
+			}
+#endif
+
+			pProcFile = create_proc_entry(dev->name,
+				S_IFREG | S_IXUSR | S_IWGRP | S_IROTH,
+				pSkRootDir);
+
+		
 			pProcFile->read_proc = proc_read;
 			pProcFile->write_proc = NULL;
 			pProcFile->nlink = 1;
-			pProcFile->size = sizeof(dev->name+1);
-			pProcFile->data = (void*)pProcFile;
+			pProcFile->size = sizeof(dev->name + 1);
+			pProcFile->data = (void *)pProcFile;
 
 			memcpy((caddr_t) &dev->dev_addr,
 			(caddr_t) &pAC->Addr.Net[1].CurrentMacAddress, 6);
 	
 			printk("%s: %s\n", dev->name, pAC->DeviceStr);
 			printk("      PrefPort:B  RlmtMode:Dual Check Link State\n");
-		
+
 		}
 
 
+		/* Save the hardware revision */
+		pAC->HWRevision = (((pAC->GIni.GIPciHwRev >> 4) & 0x0F)*10) +
+			(pAC->GIni.GIPciHwRev & 0x0F);
+
 		/*
 		 * This is bollocks, but we need to tell the net-init
 		 * code that it shall go for the next device.
@@ -617,7 +792,7 @@
  * Returns: N/A
  *	
  */
-static void FreeResources(struct net_device *dev)
+static void FreeResources(struct SK_NET_DEVICE *dev)
 {
 SK_U32 AllocFlag;
 DEV_NET		*pNet;
@@ -640,9 +815,11 @@
 	
 } /* FreeResources */
 
-MODULE_AUTHOR("Christoph Goos <cgoos@syskonnect.de>");
+MODULE_AUTHOR("Mirko Lindner <mlindner@syskonnect.de>");
 MODULE_DESCRIPTION("SysKonnect SK-NET Gigabit Ethernet SK-98xx driver");
 MODULE_LICENSE("GPL");
+MODULE_PARM(Speed_A,    "1-" __MODULE_STRING(SK_MAX_CARD_PARAM) "s");
+MODULE_PARM(Speed_B,    "1-" __MODULE_STRING(SK_MAX_CARD_PARAM) "s");
 MODULE_PARM(AutoNeg_A,  "1-" __MODULE_STRING(SK_MAX_CARD_PARAM) "s");
 MODULE_PARM(AutoNeg_B,  "1-" __MODULE_STRING(SK_MAX_CARD_PARAM) "s");
 MODULE_PARM(DupCap_A,   "1-" __MODULE_STRING(SK_MAX_CARD_PARAM) "s");
@@ -656,7 +833,25 @@
 /* not used, just there because every driver should have them: */
 MODULE_PARM(options,    "1-" __MODULE_STRING(SK_MAX_CARD_PARAM) "i");
 MODULE_PARM(debug,      "i");
+/* used for interrupt moderation */
+MODULE_PARM(IntsPerSec,     "1-" __MODULE_STRING(SK_MAX_CARD_PARAM) "i");
+MODULE_PARM(Moderation,     "1-" __MODULE_STRING(SK_MAX_CARD_PARAM) "s");
+MODULE_PARM(Stats,          "1-" __MODULE_STRING(SK_MAX_CARD_PARAM) "s");
+MODULE_PARM(ModerationMask, "1-" __MODULE_STRING(SK_MAX_CARD_PARAM) "s");
+MODULE_PARM(AutoSizing,     "1-" __MODULE_STRING(SK_MAX_CARD_PARAM) "s");
+
 
+#ifdef LINK_SPEED_A
+static char *Speed_A[SK_MAX_CARD_PARAM] = LINK_SPEED;
+#else
+static char *Speed_A[SK_MAX_CARD_PARAM] = {"", };
+#endif
+
+#ifdef LINK_SPEED_B
+static char *Speed_B[SK_MAX_CARD_PARAM] = LINK_SPEED;
+#else
+static char *Speed_B[SK_MAX_CARD_PARAM] = {"", };
+#endif
 
 #ifdef AUTO_NEG_A
 static char *AutoNeg_A[SK_MAX_CARD_PARAM] = AUTO_NEG_A;
@@ -718,10 +913,15 @@
 static char *RlmtMode[SK_MAX_CARD_PARAM] = {"", };
 #endif
 
-
 static int debug = 0; /* not used */
 static int options[SK_MAX_CARD_PARAM] = {0, }; /* not used */
 
+static int   IntsPerSec[SK_MAX_CARD_PARAM];
+static char *Moderation[SK_MAX_CARD_PARAM];
+static char *ModerationMask[SK_MAX_CARD_PARAM];
+static char *AutoSizing[SK_MAX_CARD_PARAM];
+static char *Stats[SK_MAX_CARD_PARAM];
+
 
 /*****************************************************************************
  *
@@ -737,7 +937,7 @@
 static int __init skge_init_module(void)
 {
 	int cards;
-	sk98lin_root_dev = NULL;
+	SkGeRootDev = NULL;
 	
 	/* just to avoid warnings ... */
 	debug = 0;
@@ -745,7 +945,7 @@
 
 	cards = skge_probe();
 	if (cards == 0) {
-		printk("No adapter found\n");
+		printk("sk98lin: No adapter found.\n");
 	}
 	return cards ? 0 : -ENODEV;
 } /* skge_init_module */
@@ -765,19 +965,19 @@
 {
 DEV_NET		*pNet;
 SK_AC		*pAC;
-struct net_device *next;
+struct SK_NET_DEVICE *next;
 unsigned long Flags;
 SK_EVPARA EvPara;
 
-	while (sk98lin_root_dev) {
-		pNet = (DEV_NET*) sk98lin_root_dev->priv;
+	while (SkGeRootDev) {
+		pNet = (DEV_NET*) SkGeRootDev->priv;
 		pAC = pNet->pAC;
 		next = pAC->Next;
 
-		netif_stop_queue(sk98lin_root_dev);
+		netif_stop_queue(SkGeRootDev);
 		SkGeYellowLED(pAC, pAC->IoBase, 0);
 
-		if(pAC->BoardLevel == 2) {
+		if(pAC->BoardLevel == SK_INIT_RUN) {
 			/* board is still alive */
 			spin_lock_irqsave(&pAC->SlowPathLock, Flags);
 			EvPara.Para32[0] = 0;
@@ -789,16 +989,16 @@
 			SkEventDispatcher(pAC, pAC->IoBase);
 			/* disable interrupts */
 			SK_OUT32(pAC->IoBase, B0_IMSK, 0);
-			SkGeDeInit(pAC, pAC->IoBase); 
+			SkGeDeInit(pAC, pAC->IoBase);
 			spin_unlock_irqrestore(&pAC->SlowPathLock, Flags);
-			pAC->BoardLevel = 0;
+			pAC->BoardLevel = SK_INIT_DATA;
 			/* We do NOT check here, if IRQ was pending, of course*/
 		}
 
-		if(pAC->BoardLevel == 1) {
+		if(pAC->BoardLevel == SK_INIT_IO) {
 			/* board is still alive */
-			SkGeDeInit(pAC, pAC->IoBase); 
-			pAC->BoardLevel = 0;
+			SkGeDeInit(pAC, pAC->IoBase);
+			pAC->BoardLevel = SK_INIT_DATA;
 		}
 
 		if ((pAC->GIni.GIMacsFound == 2) && pAC->RlmtNets == 2){
@@ -806,17 +1006,17 @@
 			kfree(pAC->dev[1]);
 		}
 
-		FreeResources(sk98lin_root_dev);
+		FreeResources(SkGeRootDev);
 
-		sk98lin_root_dev->get_stats = NULL;
-		/* 
+		SkGeRootDev->get_stats = NULL;
+		/*
 		 * otherwise unregister_netdev calls get_stats with
 		 * invalid IO ...  :-(
 		 */
-		unregister_netdev(sk98lin_root_dev);
-		kfree(sk98lin_root_dev);
+		unregister_netdev(SkGeRootDev);
+		kfree(SkGeRootDev);
 		kfree(pAC);
-		sk98lin_root_dev = next;
+		SkGeRootDev = next;
 	}
 
 	/* clear proc-dir */
@@ -827,6 +1027,7 @@
 module_init(skge_init_module);
 module_exit(skge_cleanup_module);
 
+
 /*****************************************************************************
  *
  * 	SkGeBoardInit - do level 0 and 1 initialization
@@ -840,13 +1041,14 @@
  *	0, if everything is ok
  *	!=0, on error
  */
-static int __init SkGeBoardInit(struct net_device *dev, SK_AC *pAC)
+static int __init SkGeBoardInit(struct SK_NET_DEVICE *dev, SK_AC *pAC)
 {
 short	i;
 unsigned long Flags;
 char	*DescrString = "sk98lin: Driver for Linux"; /* this is given to PNMI */
 char	*VerStr	= VER_STRING;
 int	Ret;			/* return code of request_irq */
+SK_BOOL	DualNet;
 
 	SK_DBG_MSG(NULL, SK_DBGMOD_DRV, SK_DBGCAT_DRV_ENTRY,
 		("IoBase: %08lX\n", (unsigned long)pAC->IoBase));
@@ -858,7 +1060,6 @@
 	}
 
 	/* Initialize the mutexes */
-
 	for (i=0; i<SK_MAX_MACS; i++) {
 		spin_lock_init(&pAC->TxPort[i][0].TxDesRingLock);
 		spin_lock_init(&pAC->RxPort[i].RxDesRingLock);
@@ -869,20 +1070,20 @@
 	
 	spin_lock_irqsave(&pAC->SlowPathLock, Flags);
 	/* Does a RESET on board ...*/
-	if (SkGeInit(pAC, pAC->IoBase, 0) != 0) {
+	if (SkGeInit(pAC, pAC->IoBase, SK_INIT_DATA) != 0) {
 		printk("HWInit (0) failed.\n");
 		spin_unlock_irqrestore(&pAC->SlowPathLock, Flags);
 		return(-EAGAIN);
 	}
-	SkI2cInit(  pAC, pAC->IoBase, 0);
-	SkEventInit(pAC, pAC->IoBase, 0);
-	SkPnmiInit( pAC, pAC->IoBase, 0);
-	SkAddrInit( pAC, pAC->IoBase, 0);
-	SkRlmtInit( pAC, pAC->IoBase, 0);
-	SkTimerInit(pAC, pAC->IoBase, 0);
+	SkI2cInit(  pAC, pAC->IoBase, SK_INIT_DATA);
+	SkEventInit(pAC, pAC->IoBase, SK_INIT_DATA);
+	SkPnmiInit( pAC, pAC->IoBase, SK_INIT_DATA);
+	SkAddrInit( pAC, pAC->IoBase, SK_INIT_DATA);
+	SkRlmtInit( pAC, pAC->IoBase, SK_INIT_DATA);
+	SkTimerInit(pAC, pAC->IoBase, SK_INIT_DATA);
 	
-	pAC->BoardLevel = 0;
-	pAC->RxBufSize = ETH_BUF_SIZE;
+	pAC->BoardLevel = SK_INIT_DATA;
+	pAC->RxBufSize  = ETH_BUF_SIZE;
 
 	SK_PNMI_SET_DRIVER_DESCR(pAC, DescrString);
 	SK_PNMI_SET_DRIVER_VER(pAC, VerStr);
@@ -891,25 +1092,24 @@
 
 	/* level 1 init common modules here (HW init) */
 	spin_lock_irqsave(&pAC->SlowPathLock, Flags);
-	if (SkGeInit(pAC, pAC->IoBase, 1) != 0) {
+	if (SkGeInit(pAC, pAC->IoBase, SK_INIT_IO) != 0) {
 		printk("HWInit (1) failed.\n");
 		spin_unlock_irqrestore(&pAC->SlowPathLock, Flags);
 		return(-EAGAIN);
 	}
-	SkI2cInit(  pAC, pAC->IoBase, 1);
-	SkEventInit(pAC, pAC->IoBase, 1);
-	SkPnmiInit( pAC, pAC->IoBase, 1);
-	SkAddrInit( pAC, pAC->IoBase, 1);
-	SkRlmtInit( pAC, pAC->IoBase, 1);
-	SkTimerInit(pAC, pAC->IoBase, 1);
+	SkI2cInit(  pAC, pAC->IoBase, SK_INIT_IO);
+	SkEventInit(pAC, pAC->IoBase, SK_INIT_IO);
+	SkPnmiInit( pAC, pAC->IoBase, SK_INIT_IO);
+	SkAddrInit( pAC, pAC->IoBase, SK_INIT_IO);
+	SkRlmtInit( pAC, pAC->IoBase, SK_INIT_IO);
+	SkTimerInit(pAC, pAC->IoBase, SK_INIT_IO);
 
 	GetConfiguration(pAC);
 	if (pAC->RlmtNets == 2) {
 		pAC->GIni.GIPortUsage = SK_MUL_LINK;
 	}
 
-
-	pAC->BoardLevel = 1;
+	pAC->BoardLevel = SK_INIT_IO;
 	spin_unlock_irqrestore(&pAC->SlowPathLock, Flags);
 
 	if (pAC->GIni.GIMacsFound == 2) {
@@ -918,12 +1118,13 @@
 		Ret = request_irq(dev->irq, SkGeIsrOnePort, SA_SHIRQ,
 			pAC->Name, dev);
 	} else {
-		printk(KERN_WARNING "%s: illegal number of ports: %d\n",
+		printk(KERN_WARNING "%s: Illegal number of ports: %d\n",
 		       dev->name, pAC->GIni.GIMacsFound);
 		return -EAGAIN;
 	}
+
 	if (Ret) {
-		printk(KERN_WARNING "%s: Requested IRQ %d is busy\n",
+		printk(KERN_WARNING "%s: Requested IRQ %d is busy.\n",
 		       dev->name, dev->irq);
 		return -EAGAIN;
 	}
@@ -931,7 +1132,7 @@
 
 	/* Alloc memory for this board (Mem for RxD/TxD) : */
 	if(!BoardAllocMem(pAC)) {
-		printk("No memory for descriptor rings\n");
+		printk("No memory for descriptor rings.\n");
        		return(-EAGAIN);
 	}
 
@@ -941,8 +1142,24 @@
 	pAC->CsOfs = (pAC->CsOfs2 << 16) | pAC->CsOfs1;
 
 	BoardInitMem(pAC);
-
+#if 0
 	SetQueueSizes(pAC);
+#else
+	/* tschilling: New common function with minimum size check. */
+	DualNet = SK_FALSE;
+	if (pAC->RlmtNets == 2) {
+		DualNet = SK_TRUE;
+	}
+	
+	if (SkGeInitAssignRamToQueues(
+		pAC,
+		pAC->ActivePort,
+		DualNet)) {
+		BoardFreeMem(pAC);
+		printk("SkGeInitAssignRamToQueues failed.\n");
+		return(-EAGAIN);
+	}
+#endif
 
 	/* Print adapter specific string from vpd */
 	ProductStr(pAC);
@@ -952,19 +1169,18 @@
 	printk("      PrefPort:%c  RlmtMode:%s\n",
 		'A' + pAC->Rlmt.Net[0].Port[pAC->Rlmt.Net[0].PrefPort]->PortNumber,
 		(pAC->RlmtMode==0)  ? "Check Link State" :
-		((pAC->RlmtMode==1) ? "Check Link State" : 
-		((pAC->RlmtMode==3) ? "Check Local Port" : 
-		((pAC->RlmtMode==7) ? "Check Segmentation" : 
+		((pAC->RlmtMode==1) ? "Check Link State" :
+		((pAC->RlmtMode==3) ? "Check Local Port" :
+		((pAC->RlmtMode==7) ? "Check Segmentation" :
 		((pAC->RlmtMode==17) ? "Dual Check Link State" :"Error")))));
 
-
 	SkGeYellowLED(pAC, pAC->IoBase, 1);
 
 	/*
 	 * Register the device here
 	 */
-	pAC->Next = sk98lin_root_dev;
-	sk98lin_root_dev = dev;
+	pAC->Next = SkGeRootDev;
+	SkGeRootDev = dev;
 
 	return (0);
 } /* SkGeBoardInit */
@@ -1001,17 +1217,19 @@
 	AllocLength = (RX_RING_SIZE + TX_RING_SIZE) * pAC->GIni.GIMacsFound
 		+ RX_RING_SIZE + 8;
 #endif
-	pDescrMem = pci_alloc_consistent(&pAC->PciDev, AllocLength,
+
+	pDescrMem = pci_alloc_consistent(pAC->PciDev, AllocLength,
 					 &pAC->pDescrMemDMA);
+
 	if (pDescrMem == NULL) {
 		return (SK_FALSE);
 	}
 	pAC->pDescrMem = pDescrMem;
+	BusAddr = (unsigned long) pAC->pDescrMemDMA;
 
 	/* Descriptors need 8 byte alignment, and this is ensured
 	 * by pci_alloc_consistent.
 	 */
-	BusAddr = (unsigned long) pAC->pDescrMemDMA;
 	for (i=0; i<pAC->GIni.GIMacsFound; i++) {
 		SK_DBG_MSG(NULL, SK_DBGMOD_DRV, SK_DBGCAT_DRV_TX_PROGRESS,
 			("TX%d/A: pDescrMem: %lX,   PhysDescrMem: %lX\n",
@@ -1059,7 +1277,8 @@
 	AllocLength = (RX_RING_SIZE + TX_RING_SIZE) * pAC->GIni.GIMacsFound
 		+ RX_RING_SIZE + 8;
 #endif
-	pci_free_consistent(&pAC->PciDev, AllocLength,
+
+	pci_free_consistent(pAC->PciDev, AllocLength,
 			    pAC->pDescrMem, pAC->pDescrMemDMA);
 	pAC->pDescrMem = NULL;
 } /* BoardFreeMem */
@@ -1146,8 +1365,7 @@
 		DescrSize = (((sizeof(TXD) - 1) / DESCR_ALIGN) + 1) *
 			DESCR_ALIGN;
 		DescrNum = TX_RING_SIZE / DescrSize;
-	}
-	else {
+	} else {
 		DescrSize = (((sizeof(RXD) - 1) / DESCR_ALIGN) + 1) *
 			DESCR_ALIGN;
 		DescrNum = RX_RING_SIZE / DescrSize;
@@ -1166,7 +1384,8 @@
 		pDescr->VNextRxd = VNextDescr & 0xffffffffULL;
 		pDescr->pNextRxd = pNextDescr;
 		pDescr->TcpSumStarts = pAC->CsOfs;
-		/* advance on step */
+
+		/* advance one step */
 		pPrevDescr = pDescr;
 		pDescr = pNextDescr;
 		pNextDescr = (RXD*) (((char*)pDescr) + DescrSize);
@@ -1240,8 +1459,7 @@
  */
 static void SkGeIsr(int irq, void *dev_id, struct pt_regs *ptregs)
 {
-struct net_device *dev = (struct net_device *)dev_id;
-
+struct SK_NET_DEVICE *dev = (struct SK_NET_DEVICE *)dev_id;
 DEV_NET		*pNet;
 SK_AC		*pAC;
 SK_U32		IntSrc;		/* interrupts source register contents */	
@@ -1269,22 +1487,22 @@
 			SK_DBG_MSG(NULL, SK_DBGMOD_DRV,
 				SK_DBGCAT_DRV_INT_SRC,
 				("EOF RX1 IRQ\n"));
-			ReceiveIrq(pAC, &pAC->RxPort[0]);
-			SK_PNMI_CNT_RX_INTR(pAC,0);
+			ReceiveIrq(pAC, &pAC->RxPort[0], SK_TRUE);
+			SK_PNMI_CNT_RX_INTR(pAC, 0);
 		}
 		if (IntSrc & IRQ_EOF_RX2) {
 			SK_DBG_MSG(NULL, SK_DBGMOD_DRV,
 				SK_DBGCAT_DRV_INT_SRC,
 				("EOF RX2 IRQ\n"));
-			ReceiveIrq(pAC, &pAC->RxPort[1]);
-			SK_PNMI_CNT_RX_INTR(pAC,1);
+			ReceiveIrq(pAC, &pAC->RxPort[1], SK_TRUE);
+			SK_PNMI_CNT_RX_INTR(pAC, 1);
 		}
 #ifdef USE_TX_COMPLETE /* only if tx complete interrupt used */
 		if (IntSrc & IRQ_EOF_AS_TX1) {
 			SK_DBG_MSG(NULL, SK_DBGMOD_DRV,
 				SK_DBGCAT_DRV_INT_SRC,
 				("EOF AS TX1 IRQ\n"));
-			SK_PNMI_CNT_TX_INTR(pAC,0);
+			SK_PNMI_CNT_TX_INTR(pAC, 0);
 			spin_lock(&pAC->TxPort[0][TX_PRIO_LOW].TxDesRingLock);
 			FreeTxDescriptors(pAC, &pAC->TxPort[0][TX_PRIO_LOW]);
 			spin_unlock(&pAC->TxPort[0][TX_PRIO_LOW].TxDesRingLock);
@@ -1293,7 +1511,7 @@
 			SK_DBG_MSG(NULL, SK_DBGMOD_DRV,
 				SK_DBGCAT_DRV_INT_SRC,
 				("EOF AS TX2 IRQ\n"));
-			SK_PNMI_CNT_TX_INTR(pAC,1);
+			SK_PNMI_CNT_TX_INTR(pAC, 1);
 			spin_lock(&pAC->TxPort[1][TX_PRIO_LOW].TxDesRingLock);
 			FreeTxDescriptors(pAC, &pAC->TxPort[1][TX_PRIO_LOW]);
 			spin_unlock(&pAC->TxPort[1][TX_PRIO_LOW].TxDesRingLock);
@@ -1303,7 +1521,7 @@
 			SK_DBG_MSG(NULL, SK_DBGMOD_DRV,
 				SK_DBGCAT_DRV_INT_SRC,
 				("EOF SY TX1 IRQ\n"));
-			SK_PNMI_CNT_TX_INTR(pAC,0);
+			SK_PNMI_CNT_TX_INTR(pAC, 1);
 			spin_lock(&pAC->TxPort[0][TX_PRIO_HIGH].TxDesRingLock);
 			FreeTxDescriptors(pAC, 0, TX_PRIO_HIGH);
 			spin_unlock(&pAC->TxPort[0][TX_PRIO_HIGH].TxDesRingLock);
@@ -1313,14 +1531,14 @@
 			SK_DBG_MSG(NULL, SK_DBGMOD_DRV,
 				SK_DBGCAT_DRV_INT_SRC,
 				("EOF SY TX2 IRQ\n"));
-			SK_PNMI_CNT_TX_INTR(pAC,1);
+			SK_PNMI_CNT_TX_INTR(pAC, 1);
 			spin_lock(&pAC->TxPort[1][TX_PRIO_HIGH].TxDesRingLock);
 			FreeTxDescriptors(pAC, 1, TX_PRIO_HIGH);
 			spin_unlock(&pAC->TxPort[1][TX_PRIO_HIGH].TxDesRingLock);
 			ClearTxIrq(pAC, 1, TX_PRIO_HIGH);
 		}
-#endif /* 0 */
-#endif /* USE_TX_COMPLETE */
+#endif
+#endif
 
 		/* do all IO at once */
 		if (IntSrc & IRQ_EOF_RX1)
@@ -1336,51 +1554,40 @@
 		SK_IN32(pAC->IoBase, B0_ISRC, &IntSrc);
 	} /* while (IntSrc & IRQ_MASK != 0) */
 
+	IntSrc &= pAC->GIni.GIValIrqMask;
 	if ((IntSrc & SPECIAL_IRQS) || pAC->CheckQueue) {
 		SK_DBG_MSG(NULL, SK_DBGMOD_DRV, SK_DBGCAT_DRV_INT_SRC,
-			("SPECIAL IRQ\n"));
+			("SPECIAL IRQ DP-Cards => %x\n", IntSrc));
 		pAC->CheckQueue = SK_FALSE;
 		spin_lock(&pAC->SlowPathLock);
 		if (IntSrc & SPECIAL_IRQS)
 			SkGeSirqIsr(pAC, pAC->IoBase, IntSrc);
+
 		SkEventDispatcher(pAC, pAC->IoBase);
 		spin_unlock(&pAC->SlowPathLock);
 	}
 	/*
-	 * do it all again is case we cleared an interrupt that 
+	 * do it all again is case we cleared an interrupt that
 	 * came in after handling the ring (OUTs may be delayed
 	 * in hardware buffers, but are through after IN)
+	 *
+	 * rroesler: has been commented out and shifted to
+	 *           SkGeDrvEvent(), because it is timer
+	 *           guarded now
+	 *
+	ReceiveIrq(pAC, &pAC->RxPort[0], SK_TRUE);
+	ReceiveIrq(pAC, &pAC->RxPort[1], SK_TRUE);
 	 */
-	// ReceiveIrq(pAC, &pAC->RxPort[pAC->ActivePort]);
-	ReceiveIrq(pAC, &pAC->RxPort[0]);
-	ReceiveIrq(pAC, &pAC->RxPort[1]);
-	
 
-
-
-#if 0
-// #ifdef USE_TX_COMPLETE /* only if tx complete interrupt used */
-	spin_lock(&pAC->TxPort[0][TX_PRIO_LOW].TxDesRingLock);
-	FreeTxDescriptors(pAC, &pAC->TxPort[0][TX_PRIO_LOW]);
-	spin_unlock(&pAC->TxPort[0][TX_PRIO_LOW].TxDesRingLock);
-
-	spin_lock(&pAC->TxPort[1][TX_PRIO_LOW].TxDesRingLock);
-	FreeTxDescriptors(pAC, &pAC->TxPort[1][TX_PRIO_LOW]);
-	spin_unlock(&pAC->TxPort[1][TX_PRIO_LOW].TxDesRingLock);
-
-#if 0	/* only if sync. queues used */
-	spin_lock(&pAC->TxPort[0][TX_PRIO_HIGH].TxDesRingLock);
-	FreeTxDescriptors(pAC, 0, TX_PRIO_HIGH);
-	spin_unlock(&pAC->TxPort[0][TX_PRIO_HIGH].TxDesRingLock);
-	
-	spin_lock(&pAC->TxPort[1][TX_PRIO_HIGH].TxDesRingLock);
-	FreeTxDescriptors(pAC, 1, TX_PRIO_HIGH);
-	spin_unlock(&pAC->TxPort[1][TX_PRIO_HIGH].TxDesRingLock);
-#endif /* 0 */
-#endif /* USE_TX_COMPLETE */
+	if (pAC->CheckQueue) {
+		pAC->CheckQueue = SK_FALSE;
+		spin_lock(&pAC->SlowPathLock);
+		SkEventDispatcher(pAC, pAC->IoBase);
+		spin_unlock(&pAC->SlowPathLock);
+	}
 
 	/* IRQ is processed - Enable IRQs again*/
-	SK_OUT32(pAC->IoBase, B0_IMSK, IRQ_MASK);
+	SK_OUT32(pAC->IoBase, B0_IMSK, pAC->GIni.GIValIrqMask);
 
 	return;
 } /* SkGeIsr */
@@ -1401,7 +1608,7 @@
  */
 static void SkGeIsrOnePort(int irq, void *dev_id, struct pt_regs *ptregs)
 {
-struct net_device *dev = (struct net_device *)dev_id;
+struct SK_NET_DEVICE *dev = (struct SK_NET_DEVICE *)dev_id;
 DEV_NET		*pNet;
 SK_AC		*pAC;
 SK_U32		IntSrc;		/* interrupts source register contents */	
@@ -1416,7 +1623,7 @@
 	if (IntSrc == 0) {
 		return;
 	}
-
+	
 	while (((IntSrc & IRQ_MASK) & ~SPECIAL_IRQS) != 0) {
 #if 0 /* software irq currently not used */
 		if (IntSrc & IRQ_SW) {
@@ -1429,15 +1636,15 @@
 			SK_DBG_MSG(NULL, SK_DBGMOD_DRV,
 				SK_DBGCAT_DRV_INT_SRC,
 				("EOF RX1 IRQ\n"));
-			ReceiveIrq(pAC, &pAC->RxPort[0]);
-			SK_PNMI_CNT_RX_INTR(pAC,0);
+			ReceiveIrq(pAC, &pAC->RxPort[0], SK_TRUE);
+			SK_PNMI_CNT_RX_INTR(pAC, 0);
 		}
 #ifdef USE_TX_COMPLETE /* only if tx complete interrupt used */
 		if (IntSrc & IRQ_EOF_AS_TX1) {
 			SK_DBG_MSG(NULL, SK_DBGMOD_DRV,
 				SK_DBGCAT_DRV_INT_SRC,
 				("EOF AS TX1 IRQ\n"));
-			SK_PNMI_CNT_TX_INTR(pAC,0);
+			SK_PNMI_CNT_TX_INTR(pAC, 0);
 			spin_lock(&pAC->TxPort[0][TX_PRIO_LOW].TxDesRingLock);
 			FreeTxDescriptors(pAC, &pAC->TxPort[0][TX_PRIO_LOW]);
 			spin_unlock(&pAC->TxPort[0][TX_PRIO_LOW].TxDesRingLock);
@@ -1447,14 +1654,14 @@
 			SK_DBG_MSG(NULL, SK_DBGMOD_DRV,
 				SK_DBGCAT_DRV_INT_SRC,
 				("EOF SY TX1 IRQ\n"));
-			SK_PNMI_CNT_TX_INTR(pAC,1);
+			SK_PNMI_CNT_TX_INTR(pAC, 0);
 			spin_lock(&pAC->TxPort[0][TX_PRIO_HIGH].TxDesRingLock);
 			FreeTxDescriptors(pAC, 0, TX_PRIO_HIGH);
 			spin_unlock(&pAC->TxPort[0][TX_PRIO_HIGH].TxDesRingLock);
 			ClearTxIrq(pAC, 0, TX_PRIO_HIGH);
 		}
-#endif /* 0 */
-#endif /* USE_TX_COMPLETE */
+#endif
+#endif
 
 		/* do all IO at once */
 		if (IntSrc & IRQ_EOF_RX1)
@@ -1466,39 +1673,32 @@
 		SK_IN32(pAC->IoBase, B0_ISRC, &IntSrc);
 	} /* while (IntSrc & IRQ_MASK != 0) */
 	
+	IntSrc &= pAC->GIni.GIValIrqMask;
 	if ((IntSrc & SPECIAL_IRQS) || pAC->CheckQueue) {
 		SK_DBG_MSG(NULL, SK_DBGMOD_DRV, SK_DBGCAT_DRV_INT_SRC,
-			("SPECIAL IRQ\n"));
+			("SPECIAL IRQ SP-Cards => %x\n", IntSrc));
 		pAC->CheckQueue = SK_FALSE;
 		spin_lock(&pAC->SlowPathLock);
 		if (IntSrc & SPECIAL_IRQS)
 			SkGeSirqIsr(pAC, pAC->IoBase, IntSrc);
+
 		SkEventDispatcher(pAC, pAC->IoBase);
 		spin_unlock(&pAC->SlowPathLock);
 	}
 	/*
-	 * do it all again is case we cleared an interrupt that 
+	 * do it all again is case we cleared an interrupt that
 	 * came in after handling the ring (OUTs may be delayed
 	 * in hardware buffers, but are through after IN)
+	 *
+	 * rroesler: has been commented out and shifted to
+	 *           SkGeDrvEvent(), because it is timer
+	 *           guarded now
+	 *
+	ReceiveIrq(pAC, &pAC->RxPort[0], SK_TRUE);
 	 */
-	ReceiveIrq(pAC, &pAC->RxPort[0]);
-
-#if 0
-// #ifdef USE_TX_COMPLETE /* only if tx complete interrupt used */
-	spin_lock(&pAC->TxPort[0][TX_PRIO_LOW].TxDesRingLock);
-	FreeTxDescriptors(pAC, &pAC->TxPort[0][TX_PRIO_LOW]);
-	spin_unlock(&pAC->TxPort[0][TX_PRIO_LOW].TxDesRingLock);
-
-#if 0	/* only if sync. queues used */
-	spin_lock(&pAC->TxPort[0][TX_PRIO_HIGH].TxDesRingLock);
-	FreeTxDescriptors(pAC, 0, TX_PRIO_HIGH);
-	spin_unlock(&pAC->TxPort[0][TX_PRIO_HIGH].TxDesRingLock);
-	
-#endif /* 0 */
-#endif /* USE_TX_COMPLETE */
 
 	/* IRQ is processed - Enable IRQs again*/
-	SK_OUT32(pAC->IoBase, B0_IMSK, IRQ_MASK);
+	SK_OUT32(pAC->IoBase, B0_IMSK, pAC->GIni.GIValIrqMask);
 
 	return;
 } /* SkGeIsrOnePort */
@@ -1521,13 +1721,13 @@
  *	!= 0 on error
  */
 static int SkGeOpen(
-struct net_device	*dev)
+struct SK_NET_DEVICE	*dev)
 {
-DEV_NET			*pNet;
-SK_AC			*pAC;
-unsigned long	Flags;		/* for spin lock */
-int		i;
-SK_EVPARA		EvPara;		/* an event parameter union */
+	DEV_NET			*pNet;
+	SK_AC			*pAC;
+	unsigned long	Flags;		/* for spin lock */
+	int				i;
+	SK_EVPARA		EvPara;		/* an event parameter union */
 
 	pNet = (DEV_NET*) dev->priv;
 	pAC = pNet->pAC;
@@ -1535,32 +1735,41 @@
 	SK_DBG_MSG(NULL, SK_DBGMOD_DRV, SK_DBGCAT_DRV_ENTRY,
 		("SkGeOpen: pAC=0x%lX:\n", (unsigned long)pAC));
 
-	if (pAC->BoardLevel == 0) {
+
+	/* Set blink mode */
+	if (pAC->PciDev->vendor == 0x1186)
+		pAC->GIni.GILedBlinkCtrl = OEM_CONFIG_VALUE;
+
+	if (pAC->BoardLevel == SK_INIT_DATA) {
 		/* level 1 init common modules here */
-		if (SkGeInit(pAC, pAC->IoBase, 1) != 0) {
-			printk("%s: HWInit(1) failed\n", pAC->dev[pNet->PortNr]->name);
+		if (SkGeInit(pAC, pAC->IoBase, SK_INIT_IO) != 0) {
+			printk("%s: HWInit (1) failed.\n", pAC->dev[pNet->PortNr]->name);
 			return (-1);
 		}
-		SkI2cInit	(pAC, pAC->IoBase, 1);
-		SkEventInit	(pAC, pAC->IoBase, 1);
-		SkPnmiInit	(pAC, pAC->IoBase, 1);
-		SkAddrInit	(pAC, pAC->IoBase, 1);
-		SkRlmtInit	(pAC, pAC->IoBase, 1);
-		SkTimerInit	(pAC, pAC->IoBase, 1);
-		pAC->BoardLevel = 1;
-	}
-
-	if (pAC->BoardLevel != 2) {
-		/* level 2 init modules here */
-		SkGeInit	(pAC, pAC->IoBase, 2);
-		SkI2cInit	(pAC, pAC->IoBase, 2);
-		SkEventInit	(pAC, pAC->IoBase, 2);
-		SkPnmiInit	(pAC, pAC->IoBase, 2);
-		SkAddrInit	(pAC, pAC->IoBase, 2);
-		SkRlmtInit	(pAC, pAC->IoBase, 2);
-		SkTimerInit	(pAC, pAC->IoBase, 2);
-		pAC->BoardLevel = 2;
+		SkI2cInit	(pAC, pAC->IoBase, SK_INIT_IO);
+		SkEventInit	(pAC, pAC->IoBase, SK_INIT_IO);
+		SkPnmiInit	(pAC, pAC->IoBase, SK_INIT_IO);
+		SkAddrInit	(pAC, pAC->IoBase, SK_INIT_IO);
+		SkRlmtInit	(pAC, pAC->IoBase, SK_INIT_IO);
+		SkTimerInit	(pAC, pAC->IoBase, SK_INIT_IO);
+		pAC->BoardLevel = SK_INIT_IO;
 	}
+
+	if (pAC->BoardLevel != SK_INIT_RUN) {
+		/* tschilling: Level 2 init modules here, check return value. */
+		if (SkGeInit(pAC, pAC->IoBase, SK_INIT_RUN) != 0) {
+			printk("%s: HWInit (2) failed.\n", pAC->dev[pNet->PortNr]->name);
+			return (-1);
+		}
+		SkI2cInit	(pAC, pAC->IoBase, SK_INIT_RUN);
+		SkEventInit	(pAC, pAC->IoBase, SK_INIT_RUN);
+		SkPnmiInit	(pAC, pAC->IoBase, SK_INIT_RUN);
+		SkAddrInit	(pAC, pAC->IoBase, SK_INIT_RUN);
+		SkRlmtInit	(pAC, pAC->IoBase, SK_INIT_RUN);
+		SkTimerInit	(pAC, pAC->IoBase, SK_INIT_RUN);
+		pAC->BoardLevel = SK_INIT_RUN;
+	}
+
 	for (i=0; i<pAC->GIni.GIMacsFound; i++) {
 		/* Enable transmit descriptor polling. */
 		SkGePollTxD(pAC, pAC->IoBase, i, SK_TRUE);
@@ -1568,20 +1777,14 @@
 	}
 	SkGeYellowLED(pAC, pAC->IoBase, 1);
 
-#ifdef USE_INT_MOD
-/* moderate only TX complete interrupts (these are not time critical) */
-#define IRQ_MOD_MASK (IRQ_EOF_AS_TX1 | IRQ_EOF_AS_TX2)
-	{
-		unsigned long ModBase;
-		ModBase = 53125000 / INTS_PER_SEC;
-		SK_OUT32(pAC->IoBase, B2_IRQM_INI, ModBase);
-		SK_OUT32(pAC->IoBase, B2_IRQM_MSK, IRQ_MOD_MASK);
-		SK_OUT32(pAC->IoBase, B2_IRQM_CTRL, TIM_START);
-	}
-#endif
+	StartDrvCleanupTimer(pAC);
+	SkDimEnableModerationIfNeeded(pAC);	
+	SkDimDisplayModerationSettings(pAC);
+
+	pAC->GIni.GIValIrqMask &= IRQ_MASK;
 
 	/* enable Interrupts */
-	SK_OUT32(pAC->IoBase, B0_IMSK, IRQ_MASK);
+	SK_OUT32(pAC->IoBase, B0_IMSK, pAC->GIni.GIValIrqMask);
 	SK_OUT32(pAC->IoBase, B0_HWE_IMSK, IRQ_HWE_MASK);
 
 	spin_lock_irqsave(&pAC->SlowPathLock, Flags);
@@ -1627,18 +1830,17 @@
  *	error code - on error
  */
 static int SkGeClose(
-struct net_device	*dev)
+struct SK_NET_DEVICE	*dev)
 {
-DEV_NET		*pNet;
-SK_AC		*pAC;
+	DEV_NET			*pNet;
+	SK_AC			*pAC;
 
-unsigned long	Flags;		/* for spin lock */
-int				i;
-int				PortIdx;
-SK_EVPARA		EvPara;
+	unsigned long	Flags;		/* for spin lock */
+	int				i;
+	int				PortIdx;
+	SK_EVPARA		EvPara;
 
 	netif_stop_queue(dev);
-
 	pNet = (DEV_NET*) dev->priv;
 	pAC = pNet->pAC;
 
@@ -1650,10 +1852,11 @@
 	SK_DBG_MSG(NULL, SK_DBGMOD_DRV, SK_DBGCAT_DRV_ENTRY,
 		("SkGeClose: pAC=0x%lX ", (unsigned long)pAC));
 
-	/* 
+        StopDrvCleanupTimer(pAC);
+
+	/*
 	 * Clear multicast table, promiscuous mode ....
 	 */
-	 
 	SkAddrMcClear(pAC, pAC->IoBase, PortIdx, 0);
 	SkAddrPromiscuousChange(pAC, pAC->IoBase, PortIdx,
 		SK_PROM_MODE_NONE);
@@ -1669,7 +1872,7 @@
 		SK_OUT32(pAC->IoBase, B0_IMSK, 0);
 		/* stop the hardware */
 		SkGeDeInit(pAC, pAC->IoBase);
-		pAC->BoardLevel = 0;
+		pAC->BoardLevel = SK_INIT_DATA;
 		spin_unlock_irqrestore(&pAC->SlowPathLock, Flags);
 	} else {
 
@@ -1683,21 +1886,22 @@
 		/* Stop port */
 		spin_lock_irqsave(&pAC->TxPort[pNet->PortNr]
 			[TX_PRIO_LOW].TxDesRingLock, Flags);
-		SkGeStopPort(pAC, pAC->IoBase, pNet->PortNr, 
+		SkGeStopPort(pAC, pAC->IoBase, pNet->PortNr,
 			SK_STOP_ALL, SK_HARD_RST);
 		spin_unlock_irqrestore(&pAC->TxPort[pNet->PortNr]
 			[TX_PRIO_LOW].TxDesRingLock, Flags);
 	}
+
 	if (pAC->RlmtNets == 1) {
 		/* clear all descriptor rings */
 		for (i=0; i<pAC->GIni.GIMacsFound; i++) {
-			ReceiveIrq(pAC, &pAC->RxPort[i]);
+			ReceiveIrq(pAC, &pAC->RxPort[i], SK_TRUE);
 			ClearRxRing(pAC, &pAC->RxPort[i]);
 			ClearTxRing(pAC, &pAC->TxPort[i][TX_PRIO_LOW]);
 		}
 	} else {
 		/* clear port descriptor rings */
-		ReceiveIrq(pAC, &pAC->RxPort[pNet->PortNr]);
+		ReceiveIrq(pAC, &pAC->RxPort[pNet->PortNr], SK_TRUE);
 		ClearRxRing(pAC, &pAC->RxPort[pNet->PortNr]);
 		ClearTxRing(pAC, &pAC->TxPort[pNet->PortNr][TX_PRIO_LOW]);
 	}
@@ -1712,6 +1916,7 @@
 	return (0);
 } /* SkGeClose */
 
+
 /*****************************************************************************
  *
  * 	SkGeXmit - Linux frame transmit function
@@ -1727,23 +1932,47 @@
  * WARNING: returning 1 in 'tbusy' case caused system crashes (double
  *	allocated skb's) !!!
  */
-static int SkGeXmit(struct sk_buff *skb, struct net_device *dev)
+static int SkGeXmit(struct sk_buff *skb, struct SK_NET_DEVICE *dev)
 {
 DEV_NET		*pNet;
 SK_AC		*pAC;
 int			Rc;	/* return code of XmitFrame */
-	
+
 	pNet = (DEV_NET*) dev->priv;
 	pAC = pNet->pAC;
 
-	if (pAC->RlmtNets == 2)
-		Rc = XmitFrame(pAC, &pAC->TxPort[pNet->PortNr][TX_PRIO_LOW], skb);
-	else
-		Rc = XmitFrame(pAC, &pAC->TxPort[pAC->ActivePort][TX_PRIO_LOW], skb);
+	if ((!skb_shinfo(skb)->nr_frags) ||
+		(pAC->GIni.GIChipId == CHIP_ID_GENESIS)) {
+		/* Don't activate scatter-gather and hardware checksum */
+
+		if (pAC->RlmtNets == 2)
+			Rc = XmitFrame(
+				pAC,
+				&pAC->TxPort[pNet->PortNr][TX_PRIO_LOW],
+				skb);
+		else
+			Rc = XmitFrame(
+				pAC,
+				&pAC->TxPort[pAC->ActivePort][TX_PRIO_LOW],
+				skb);
+	} else {
+		/* scatter-gather and hardware TCP checksumming anabled*/
+		if (pAC->RlmtNets == 2)
+			Rc = XmitFrameSG(
+				pAC,
+				&pAC->TxPort[pNet->PortNr][TX_PRIO_LOW],
+				skb);
+		else
+			Rc = XmitFrameSG(
+				pAC,
+				&pAC->TxPort[pAC->ActivePort][TX_PRIO_LOW],
+				skb);
+	}
 
 	/* Transmitter out of resources? */
-	if (Rc <= 0)
+	if (Rc <= 0) {
 		netif_stop_queue(dev);
+	}
 
 	/* If not taken, give buffer ownership back to the
 	 * queueing layer.
@@ -1773,17 +2002,17 @@
  *	if necessary.
  *
  * Returns:
- *  > 0 - on succes: the number of bytes in the message
- *  = 0 - on resource shortage: this frame sent or dropped, now
- *        the ring is full ( -> set tbusy)
- *  < 0 - on failure: other problems ( -> return failure to upper layers)
+ *	> 0 - on succes: the number of bytes in the message
+ *	= 0 - on resource shortage: this frame sent or dropped, now
+ *		the ring is full ( -> set tbusy)
+ *	< 0 - on failure: other problems ( -> return failure to upper layers)
  */
 static int XmitFrame(
 SK_AC 		*pAC,		/* pointer to adapter context */
 TX_PORT		*pTxPort,	/* pointer to struct of port to send to */
 struct sk_buff	*pMessage)	/* pointer to send-message */
 {
-TXD		*pTxd;		/* the rxd to fill */
+TXD		*pTxd, *pOldTxd;		/* the rxd to fill */
 unsigned long	Flags;
 SK_U64		PhysAddr;
 int		BytesSend;
@@ -1792,7 +2021,9 @@
 		("X"));
 
 	spin_lock_irqsave(&pTxPort->TxDesRingLock, Flags);
-
+#ifndef USE_TX_COMPLETE
+	FreeTxDescriptors(pAC, pTxPort);
+#endif
 	if (pTxPort->TxdRingFree == 0) {
 		/* no enough free descriptors in ring at the moment */
 		FreeTxDescriptors(pAC, pTxPort);
@@ -1803,6 +2034,8 @@
 				SK_DBGCAT_DRV_TX_PROGRESS,
 				("XmitFrame failed\n"));
 			/* this message can not be sent now */
+			/* Because tbusy seems to be set, the message should not be freed here */
+			/* It will be used by the scheduler of the ethernet handler */
 			return (-1);
 		}
 	}
@@ -1812,7 +2045,7 @@
 	pTxPort->TxdRingFree--;
 	/* the needed descriptor is reserved now */
 	
-	/* 
+	/*
 	 * everything allocated ok, so add buffer to descriptor
 	 */
 
@@ -1821,12 +2054,12 @@
 #endif
 
 	/* set up descriptor and CONTROL dword */
-	PhysAddr = (SK_U64) pci_map_page(&pAC->PciDev,
-					 virt_to_page(pMessage->data),
-					 ((unsigned long) pMessage->data &
-					  ~PAGE_MASK),
-					 pMessage->len,
-					 PCI_DMA_TODEVICE);
+	PhysAddr = (SK_U64) pci_map_page(pAC->PciDev,
+		virt_to_page(pMessage->data),
+		((unsigned long) pMessage->data &
+		~PAGE_MASK),
+		pMessage->len,
+		PCI_DMA_TODEVICE);
 	pTxd->VDataLow = (SK_U32)  (PhysAddr & 0xffffffff);
 	pTxd->VDataHigh = (SK_U32) (PhysAddr >> 32);
 	pTxd->pMBuf = pMessage;
@@ -1837,28 +2070,209 @@
 #else
 		TX_CTRL_EOF | pMessage->len;
 #endif
-	
-	if ((pTxPort->pTxdRingPrev->TBControl & TX_CTRL_OWN_BMU) == 0) {
+
+	pOldTxd = xchg(&pTxPort->pTxdRingPrev, pTxd);
+	if ((pOldTxd->TBControl & TX_CTRL_OWN_BMU) == 0) {
 		/* previous descriptor already done, so give tx start cmd */
 		/* StartTx(pAC, pTxPort->HwAddr); */
 		SK_OUT8(pTxPort->HwAddr, TX_Q_CTRL, TX_Q_CTRL_START);
-	}
-	pTxPort->pTxdRingPrev = pTxd;
-	
-	
+	}	
+
 	BytesSend = pMessage->len;
+	spin_unlock_irqrestore(&pTxPort->TxDesRingLock, Flags);
 	/* after releasing the lock, the skb may be immidiately freed */
-	if (pTxPort->TxdRingFree != 0) {
-		spin_unlock_irqrestore(&pTxPort->TxDesRingLock, Flags);
+	if (pTxPort->TxdRingFree != 0)
 		return (BytesSend);
-	}
-	else {
-		/* ring full: set tbusy on return */
-		spin_unlock_irqrestore(&pTxPort->TxDesRingLock, Flags);
+	else
 		return (0);
-	}
+
 } /* XmitFrame */
 
+/*****************************************************************************
+ *
+ * 	XmitFrameSG - fill one socket buffer into the transmit ring
+ *                (use SG and TCP/UDP hardware checksumming)
+ *
+ * Description:
+ *	This function puts a message into the transmit descriptor ring
+ *	if there is a descriptors left.
+ *
+ * Returns:
+ *	> 0 - on succes: the number of bytes in the message
+ *	= 0 - on resource shortage: this frame sent or dropped, now
+ *		the ring is full ( -> set tbusy)
+ *	< 0 - on failure: other problems ( -> return failure to upper layers)
+ */
+static int XmitFrameSG(
+SK_AC 		*pAC,			/* pointer to adapter context */
+TX_PORT		*pTxPort,		/* pointer to struct of port to send to */
+struct sk_buff	*pMessage)	/* pointer to send-message */
+{
+
+	int 		i;
+	int			BytesSend;
+	int			hlength;
+	int			protocol;
+	skb_frag_t		*sk_frag;
+	TXD			*pTxd;
+	TXD			*pTxdFst;
+	TXD			*pTxdLst;
+	SK_U64		PhysAddr;
+	unsigned long	Flags;
+
+	spin_lock_irqsave(&pTxPort->TxDesRingLock, Flags);
+#ifndef USE_TX_COMPLETE
+	FreeTxDescriptors(pAC, pTxPort);
+#endif
+	if ((skb_shinfo(pMessage)->nr_frags +1) > pTxPort->TxdRingFree) {
+		FreeTxDescriptors(pAC, pTxPort);
+		if ((skb_shinfo(pMessage)->nr_frags + 1) > pTxPort->TxdRingFree) {
+			spin_unlock_irqrestore(&pTxPort->TxDesRingLock, Flags);
+			SK_PNMI_CNT_NO_TX_BUF(pAC, pTxPort->PortIndex);
+			SK_DBG_MSG(NULL, SK_DBGMOD_DRV,
+				SK_DBGCAT_DRV_TX_PROGRESS,
+				("XmitFrameSG failed - Ring full\n"));
+				/* this message can not be sent now */
+			return(-1);
+		}
+	}
+
+
+	pTxd = pTxPort->pTxdRingHead;
+	pTxdFst = pTxd;
+	pTxdLst = pTxd;
+	BytesSend = 0;
+	protocol = 0;
+
+	/* map first fragment (header) */
+	PhysAddr = (SK_U64) pci_map_page(pAC->PciDev,
+			virt_to_page(pMessage->data),
+			((unsigned long) pMessage->data & ~PAGE_MASK),
+			skb_headlen(pMessage),
+			PCI_DMA_TODEVICE);
+
+	pTxd->VDataLow = (SK_U32)  (PhysAddr & 0xffffffff);
+	pTxd->VDataHigh = (SK_U32) (PhysAddr >> 32);
+
+	/* HW checksum? */
+	if (pMessage->ip_summed == CHECKSUM_HW) {
+		pTxd->TBControl = TX_CTRL_STF |
+				  TX_CTRL_ST_FWD |
+				  skb_headlen(pMessage);
+
+		/* We have to use the opcode for tcp here because the opcode for
+		udp is not working in the hardware yet (revision 2.0)*/
+		protocol = ((SK_U8)pMessage->data[23] & 0xf);
+		if ((protocol == 17) && (pAC->GIni.GIChipRev != 0))
+			pTxd->TBControl |=  BMU_UDP_CHECK;
+		else
+			pTxd->TBControl |= BMU_TCP_CHECK ;
+
+		hlength = ((SK_U8)pMessage->data[14] & 0xf) * 4;
+		pTxd->TcpSumOfs = 0; /* PH-Checksum already claculated */
+		pTxd->TcpSumSt = 14+hlength+16;
+		pTxd->TcpSumWr = 14+hlength;
+	
+	} else {
+		pTxd->TBControl = TX_CTRL_CHECK_DEFAULT |
+				  TX_CTRL_SOFTWARE |
+				  TX_CTRL_STF |
+				  skb_headlen(pMessage);
+	}
+
+	pTxd = pTxd->pNextTxd;
+	pTxPort->TxdRingFree--;
+	BytesSend += skb_headlen(pMessage);
+
+
+	/* Map SG fragments */
+	for (i = 0; i < skb_shinfo(pMessage)->nr_frags; i++) {
+		sk_frag = &skb_shinfo(pMessage)->frags[i];
+		
+		/* we already have the proper value in entry */
+		PhysAddr = (SK_U64) pci_map_page(pAC->PciDev,
+						 sk_frag->page,
+						 sk_frag->page_offset,
+						 sk_frag->size,
+						 PCI_DMA_TODEVICE);
+
+		pTxd->VDataLow = (SK_U32)  (PhysAddr & 0xffffffff);
+		pTxd->VDataHigh = (SK_U32) (PhysAddr >> 32);
+		pTxd->pMBuf = pMessage;
+		
+		/* HW checksum */
+		if (pMessage->ip_summed == CHECKSUM_HW) {
+			pTxd->TBControl = TX_CTRL_OWN_BMU |
+				  	  TX_CTRL_SOFTWARE |
+					  TX_CTRL_ST_FWD;
+
+			/* We have to use the opcode for tcp here because the opcode for
+			udp is not working in the hardware yet (revision 2.0)*/
+			if ((protocol == 17) && (pAC->GIni.GIChipRev != 0))
+				pTxd->TBControl |= BMU_UDP_CHECK ;
+			else
+				pTxd->TBControl |= BMU_TCP_CHECK ;
+
+		} else {
+			pTxd->TBControl = TX_CTRL_CHECK_DEFAULT |
+					  TX_CTRL_SOFTWARE |
+					  TX_CTRL_OWN_BMU;
+		}
+
+		/* Last fragment  */
+		if( (i+1) == skb_shinfo(pMessage)->nr_frags )  {
+#ifdef USE_TX_COMPLETE
+			pTxd->TBControl |= TX_CTRL_EOF |
+					   TX_CTRL_EOF_IRQ |
+					   sk_frag->size;
+#else
+			pTxd->TBControl |= TX_CTRL_EOF |
+					   sk_frag->size;
+#endif
+			pTxdFst->TBControl |= TX_CTRL_OWN_BMU |
+					      TX_CTRL_SOFTWARE;
+
+		} else {
+			pTxd->TBControl |= sk_frag->size;
+		}
+		pTxdLst = pTxd;
+		pTxd = pTxd->pNextTxd;
+		pTxPort->TxdRingFree--;
+		BytesSend += sk_frag->size;
+	}
+
+	if ((pTxPort->pTxdRingPrev->TBControl & TX_CTRL_OWN_BMU) == 0) {
+		/* previous descriptor already done, so give tx start cmd */
+		/* StartTx(pAC, pTxPort->HwAddr); */
+		SK_OUT8(pTxPort->HwAddr, TX_Q_CTRL, TX_Q_CTRL_START);
+	}
+
+	pTxPort->pTxdRingPrev = pTxdLst;
+	pTxPort->pTxdRingHead = pTxd;
+
+	spin_unlock_irqrestore(&pTxPort->TxDesRingLock, Flags);
+
+	if (pTxPort->TxdRingFree > 0)
+		return (BytesSend);
+	else
+		return (0);
+}
+
+
+void dump_frag( SK_U8 *data, int length)
+{
+        int i;
+
+        printk("Length: %d\n", length);
+        for( i=0; i < length; i++ ) {
+                printk(" %02x", (SK_U8)*(data + i) );
+                if( !((i+1) % 20) )
+                  printk("\n");
+        }
+        printk("\n\n");
+
+}
+
 
 /*****************************************************************************
  *
@@ -1889,28 +2303,27 @@
 
 	pNewTail = pTxPort->pTxdRingTail;
 	pTxd = pNewTail;
-	
-	/* 
+	/*
 	 * loop forever; exits if TX_CTRL_SOFTWARE bit not set in start frame
 	 * or TX_CTRL_OWN_BMU bit set in any frame
 	 */
 	while (1) {
 		Control = pTxd->TBControl;
 		if ((Control & TX_CTRL_SOFTWARE) == 0) {
-			/* 
+			/*
 			 * software controllable bit is set in first
 			 * fragment when given to BMU. Not set means that
-			 * this fragment was never sent or is already 
+			 * this fragment was never sent or is already
 			 * freed ( -> ring completely free now).
 			 */
 			pTxPort->pTxdRingTail = pTxd;
-			netif_start_queue(pAC->dev[pTxPort->PortIndex]);
+			netif_wake_queue(pAC->dev[pTxPort->PortIndex]);
 			return;
 		}
 		if (Control & TX_CTRL_OWN_BMU) {
 			pTxPort->pTxdRingTail = pTxd;
 			if (pTxPort->TxdRingFree > 0) {
-				netif_start_queue(pAC->dev[pTxPort->PortIndex]);
+				netif_wake_queue(pAC->dev[pTxPort->PortIndex]);
 			}
 			return;
 		}
@@ -1918,19 +2331,19 @@
 		/* release the DMA mapping */
 		PhysAddr = ((SK_U64) pTxd->VDataHigh) << (SK_U64) 32;
 		PhysAddr |= (SK_U64) pTxd->VDataLow;
-		pci_unmap_page(&pAC->PciDev, PhysAddr,
-			       pTxd->pMBuf->len,
-			       PCI_DMA_TODEVICE);
+		pci_unmap_page(pAC->PciDev, PhysAddr,
+				 pTxd->pMBuf->len,
+				 PCI_DMA_TODEVICE);
+
+		if (Control & TX_CTRL_EOF)
+			DEV_KFREE_SKB_ANY(pTxd->pMBuf);	/* free message */
 
-		/* free message */
-		DEV_KFREE_SKB_ANY(pTxd->pMBuf);
 		pTxPort->TxdRingFree++;
 		pTxd->TBControl &= ~TX_CTRL_SOFTWARE;
 		pTxd = pTxd->pNextTxd; /* point behind fragment with EOF */
 	} /* while(forever) */
 } /* FreeTxDescriptors */
 
-
 /*****************************************************************************
  *
  * 	FillRxRing - fill the receive ring with valid descriptors
@@ -1999,12 +2412,12 @@
 	pRxPort->pRxdRingTail = pRxd->pNextRxd;
 	pRxPort->RxdRingFree--;
 	Length = pAC->RxBufSize;
-	PhysAddr = (SK_U64) pci_map_page(&pAC->PciDev,
-					 virt_to_page(pMsgBlock->data),
-					 ((unsigned long) pMsgBlock->data &
-					  ~PAGE_MASK),
-					 pAC->RxBufSize - 2,
-					 PCI_DMA_FROMDEVICE);
+	PhysAddr = (SK_U64) pci_map_page(pAC->PciDev,
+		virt_to_page(pMsgBlock->data),
+		((unsigned long) pMsgBlock->data &
+		~PAGE_MASK),
+		pAC->RxBufSize - 2,
+		PCI_DMA_FROMDEVICE);
 	pRxd->VDataLow = (SK_U32) (PhysAddr & 0xffffffff);
 	pRxd->VDataHigh = (SK_U32) (PhysAddr >> 32);
 	pRxd->pMBuf = pMsgBlock;
@@ -2061,28 +2474,33 @@
  * Returns:	N/A
  */
 static void ReceiveIrq(
-SK_AC		*pAC,		/* pointer to adapter context */
-RX_PORT		*pRxPort)	/* pointer to receive port struct */
-{
-RXD		*pRxd;		/* pointer to receive descriptors */
-SK_U32		Control;	/* control field of descriptor */
-struct sk_buff	*pMsg;		/* pointer to message holding frame */
-struct sk_buff	*pNewMsg;	/* pointer to a new message for copying frame */
-int		FrameLength;	/* total length of received frame */
-SK_MBUF		*pRlmtMbuf;	/* ptr to a buffer for giving a frame to rlmt */
-SK_EVPARA	EvPara;		/* an event parameter union */	
-int		PortIndex = pRxPort->PortIndex;
+	SK_AC		*pAC,			/* pointer to adapter context */
+	RX_PORT		*pRxPort,		/* pointer to receive port struct */
+	SK_BOOL		SlowPathLock)	/* indicates if SlowPathLock is needed */
+{
+RXD				*pRxd;			/* pointer to receive descriptors */
+SK_U32			Control;		/* control field of descriptor */
+struct sk_buff	*pMsg;			/* pointer to message holding frame */
+struct sk_buff	*pNewMsg;		/* pointer to a new message for copying frame */
+int				FrameLength;	/* total length of received frame */
+int				IpFrameLength;	/* total length of ip frame */
+SK_MBUF			*pRlmtMbuf;		/* ptr to a buffer for giving a frame to rlmt */
+SK_EVPARA		EvPara;			/* an event parameter union */	
+unsigned long	Flags;			/* for spin lock */
+int				PortIndex = pRxPort->PortIndex;
 unsigned int	Offset;
 unsigned int	NumBytes;
 unsigned int	ForRlmt;
-SK_BOOL		IsBc;
-SK_BOOL		IsMc;
-SK_U32		FrameStat;
+SK_BOOL			IsBc;
+SK_BOOL			IsMc;
+SK_BOOL  IsBadFrame; 			/* Bad frame */
+
+SK_U32			FrameStat;
 unsigned short	Csum1;
 unsigned short	Csum2;
 unsigned short	Type;
-int		Result;
-SK_U64		PhysAddr;
+int				Result;
+SK_U64			PhysAddr;
 
 rx_start:	
 	/* do forever; exit if RX_CTRL_OWN_BMU found */
@@ -2093,8 +2511,8 @@
 		  pRxPort->RxdRingFree ++) {
 
 		/*
-		 * For a better understanding of this loop 
-		 * Go through every descriptor beginning at the head 
+		 * For a better understanding of this loop
+		 * Go through every descriptor beginning at the head
 		 * Please note: the ring might be completely received so the OWN bit
 		 * set is not a good crirteria to leave that loop.
 		 * Therefore the RingFree counter is used.
@@ -2112,6 +2530,7 @@
 			FillRxRing(pAC, pRxPort);
 			return;
 		}
+                pAC->DynIrqModInfo.NbrProcessedDescr++;
 
 		/* get length of frame and check it */
 		FrameLength = Control & RX_CTRL_LEN_MASK;
@@ -2124,33 +2543,75 @@
 			(RX_CTRL_STF | RX_CTRL_EOF)) {
 			goto rx_failed;
 		}
-		
+
 		/* here we have a complete frame in the ring */
 		pMsg = pRxd->pMBuf;
 
 		FrameStat = pRxd->FrameStat;
+
+		/* check for frame length mismatch */
+#define XMR_FS_LEN_SHIFT        18
+#define GMR_FS_LEN_SHIFT        16
+		if (pAC->GIni.GIChipId == CHIP_ID_GENESIS) {
+			if (FrameLength != (SK_U32) (FrameStat >> XMR_FS_LEN_SHIFT)) {
+				SK_DBG_MSG(NULL, SK_DBGMOD_DRV,
+					SK_DBGCAT_DRV_RX_PROGRESS,
+					("skge: Frame length mismatch (%u/%u).\n",
+					FrameLength,
+					(SK_U32) (FrameStat >> XMR_FS_LEN_SHIFT)));
+				goto rx_failed;
+			}
+		}
+		else {
+			if (FrameLength != (SK_U32) (FrameStat >> GMR_FS_LEN_SHIFT)) {
+				SK_DBG_MSG(NULL, SK_DBGMOD_DRV,
+					SK_DBGCAT_DRV_RX_PROGRESS,
+					("skge: Frame length mismatch (%u/%u).\n",
+					FrameLength,
+					(SK_U32) (FrameStat >> XMR_FS_LEN_SHIFT)));
+				goto rx_failed;
+			}
+		}
+
+		/* Set Rx Status */
+		if (pAC->GIni.GIChipId == CHIP_ID_GENESIS) {
+			IsBc = (FrameStat & XMR_FS_BC) != 0;
+			IsMc = (FrameStat & XMR_FS_MC) != 0;
+			IsBadFrame = (FrameStat &
+				(XMR_FS_ANY_ERR | XMR_FS_2L_VLAN)) != 0;
+		} else {
+			IsBc = (FrameStat & GMR_FS_BC) != 0;
+			IsMc = (FrameStat & GMR_FS_MC) != 0;
+			IsBadFrame = (((FrameStat & GMR_FS_ANY_ERR) != 0) ||
+							((FrameStat & GMR_FS_RX_OK) == 0));
+		}
+
 		SK_DBG_MSG(NULL, SK_DBGMOD_DRV, 0,
 			("Received frame of length %d on port %d\n",
 			FrameLength, PortIndex));
 		SK_DBG_MSG(NULL, SK_DBGMOD_DRV, 0,
 			("Number of free rx descriptors: %d\n",
 			pRxPort->RxdRingFree));
-		/*DumpMsg(pMsg, "Rx");	*/	
-		
+/* DumpMsg(pMsg, "Rx");	*/
+
 		if ((Control & RX_CTRL_STAT_VALID) != RX_CTRL_STAT_VALID ||
+			(IsBadFrame)) {
+#if 0
 			(FrameStat & (XMR_FS_ANY_ERR | XMR_FS_2L_VLAN)) != 0) {
+#endif
 			/* there is a receive error in this frame */
 			SK_DBG_MSG(NULL, SK_DBGMOD_DRV,
 				SK_DBGCAT_DRV_RX_PROGRESS,
 				("skge: Error in received frame, dropped!\n"
 				"Control: %x\nRxStat: %x\n",
 				Control, FrameStat));
+
 			PhysAddr = ((SK_U64) pRxd->VDataHigh) << (SK_U64)32;
 			PhysAddr |= (SK_U64) pRxd->VDataLow;
-			pci_dma_sync_single(&pAC->PciDev,
-					    (dma_addr_t) PhysAddr,
-					    FrameLength,
-					    PCI_DMA_FROMDEVICE);
+			pci_dma_sync_single(pAC->PciDev,
+						(dma_addr_t) PhysAddr,
+						FrameLength,
+						PCI_DMA_FROMDEVICE);
 			ReQueueRxBuffer(pAC, pRxPort, pMsg,
 				pRxd->VDataHigh, pRxd->VDataLow);
 
@@ -2165,16 +2626,16 @@
 			/*
 			 * Short frame detected and allocation successfull
 			 */
-			PhysAddr = ((SK_U64) pRxd->VDataHigh) << (SK_U64)32;
-			PhysAddr |= (SK_U64) pRxd->VDataLow;
-
 			/* use new skb and copy data */
 			skb_reserve(pNewMsg, 2);
 			skb_put(pNewMsg, FrameLength);
-			pci_dma_sync_single(&pAC->PciDev,
-					    (dma_addr_t) PhysAddr,
-					    FrameLength,
-					    PCI_DMA_FROMDEVICE);
+			PhysAddr = ((SK_U64) pRxd->VDataHigh) << (SK_U64)32;
+			PhysAddr |= (SK_U64) pRxd->VDataLow;
+
+			pci_dma_sync_single(pAC->PciDev,
+						(dma_addr_t) PhysAddr,
+						FrameLength,
+						PCI_DMA_FROMDEVICE);
 			eth_copy_and_sum(pNewMsg, pMsg->data,
 				FrameLength, 0);
 			ReQueueRxBuffer(pAC, pRxPort, pMsg,
@@ -2192,10 +2653,10 @@
 			PhysAddr |= (SK_U64) pRxd->VDataLow;
 
 			/* release the DMA mapping */
-			pci_unmap_page(&pAC->PciDev,
-				       PhysAddr,
-				       pAC->RxBufSize - 2,
-				       PCI_DMA_FROMDEVICE);
+			pci_unmap_single(pAC->PciDev,
+					 PhysAddr,
+					 pAC->RxBufSize - 2,
+					 PCI_DMA_FROMDEVICE);
 
 			/* set length in message */
 			skb_put(pMsg, FrameLength);
@@ -2204,33 +2665,70 @@
 			if (Type == 0x800) {
 				Csum1=le16_to_cpu(pRxd->TcpSums & 0xffff);
 				Csum2=le16_to_cpu((pRxd->TcpSums >> 16) & 0xffff);
-				if ((Csum1 & 0xfffe) && (Csum2 & 0xfffe)) {
-					Result = SkCsGetReceiveInfo(pAC,
-						&pMsg->data[14], 
-						Csum1, Csum2, pRxPort->PortIndex);
-					if (Result == 
-						SKCS_STATUS_IP_FRAGMENT ||
-						Result ==
-						SKCS_STATUS_IP_CSUM_OK ||
-						Result ==
-						SKCS_STATUS_TCP_CSUM_OK ||
-						Result ==
-						SKCS_STATUS_UDP_CSUM_OK) {
-						pMsg->ip_summed =
-						CHECKSUM_UNNECESSARY;
-					}
-				} /* checksum calculation valid */
+				IpFrameLength = (int) ntohs((unsigned short)
+								((unsigned short *) pMsg->data)[8]);
+				/*
+				 * Test: If frame is padded, a check is not possible!
+				 * Frame not padded? Length difference must be 14 (0xe)!
+				 */
+				if ((FrameLength - IpFrameLength) != 0xe) {
+				/* Frame padded => TCP offload not possible! */
+					pMsg->ip_summed = CHECKSUM_NONE;
+				} else {
+				/* Frame not padded => TCP offload! */
+					if ((((Csum1 & 0xfffe) && (Csum2 & 0xfffe)) &&
+						(pAC->GIni.GIChipId == CHIP_ID_GENESIS)) ||
+						(pAC->GIni.GIChipId == CHIP_ID_YUKON)) {
+						Result = SkCsGetReceiveInfo(pAC,
+							&pMsg->data[14],
+							Csum1, Csum2, pRxPort->PortIndex);
+							if (Result ==
+							SKCS_STATUS_IP_FRAGMENT ||
+							Result ==
+							SKCS_STATUS_IP_CSUM_OK ||
+							Result ==
+							SKCS_STATUS_TCP_CSUM_OK ||
+							Result ==
+							SKCS_STATUS_UDP_CSUM_OK) {
+								pMsg->ip_summed =
+								CHECKSUM_UNNECESSARY;
+						}
+						else if (Result ==
+							SKCS_STATUS_TCP_CSUM_ERROR ||
+							Result ==
+							SKCS_STATUS_UDP_CSUM_ERROR ||
+							Result ==
+							SKCS_STATUS_IP_CSUM_ERROR_UDP ||
+							Result ==
+							SKCS_STATUS_IP_CSUM_ERROR_TCP ||
+							Result ==
+							SKCS_STATUS_IP_CSUM_ERROR ) {
+							/* HW Checksum error */
+							SK_DBG_MSG(NULL, SK_DBGMOD_DRV,
+							SK_DBGCAT_DRV_RX_PROGRESS,
+							("skge: CRC error. Frame dropped!\n"));
+							goto rx_failed;
+						} else {
+								pMsg->ip_summed =
+								CHECKSUM_NONE;
+						}
+					}/* checksumControl calculation valid */
+				} /* Frame length check */
 			} /* IP frame */
 		} /* frame > SK_COPY_TRESHOLD */
 		
 		SK_DBG_MSG(NULL, SK_DBGMOD_DRV,	1,("V"));
 		ForRlmt = SK_RLMT_RX_PROTOCOL;
+#if 0
 		IsBc = (FrameStat & XMR_FS_BC)==XMR_FS_BC;
+#endif
 		SK_RLMT_PRE_LOOKAHEAD(pAC, PortIndex, FrameLength,
 			IsBc, &Offset, &NumBytes);
 		if (NumBytes != 0) {
+#if 0
 			IsMc = (FrameStat & XMR_FS_MC)==XMR_FS_MC;
-			SK_RLMT_LOOKAHEAD(pAC, PortIndex, 
+#endif
+			SK_RLMT_LOOKAHEAD(pAC, PortIndex,
 				&pMsg->data[Offset],
 				IsBc, IsMc, &ForRlmt);
 		}
@@ -2255,7 +2753,7 @@
 			}
 			else {
 				/* drop frame */
-				SK_DBG_MSG(NULL, SK_DBGMOD_DRV, 
+				SK_DBG_MSG(NULL, SK_DBGMOD_DRV,
 					SK_DBGCAT_DRV_RX_PROGRESS,
 					("D"));
 				DEV_KFREE_SKB(pMsg);
@@ -2264,7 +2762,7 @@
 		} /* if not for rlmt */
 		else {
 			/* packet for rlmt */
-			SK_DBG_MSG(NULL, SK_DBGMOD_DRV, 
+			SK_DBG_MSG(NULL, SK_DBGMOD_DRV,
 				SK_DBGCAT_DRV_RX_PROGRESS, ("R"));
 			pRlmtMbuf = SkDrvAllocRlmtMbuf(pAC,
 				pAC->IoBase, FrameLength);
@@ -2276,18 +2774,30 @@
 				memcpy((char*)(pRlmtMbuf->pData),
 					   (char*)(pMsg->data),
 					   FrameLength);
-				SkEventQueue(pAC, SKGE_RLMT,
-					SK_RLMT_PACKET_RECEIVED,
-					EvPara);
-				pAC->CheckQueue = SK_TRUE;
-				SK_DBG_MSG(NULL, SK_DBGMOD_DRV, 
+
+				/* SlowPathLock needed? */
+				if (SlowPathLock == SK_TRUE) {
+					spin_lock_irqsave(&pAC->SlowPathLock, Flags);
+					SkEventQueue(pAC, SKGE_RLMT,
+						SK_RLMT_PACKET_RECEIVED,
+						EvPara);
+					pAC->CheckQueue = SK_TRUE;
+					spin_unlock_irqrestore(&pAC->SlowPathLock, Flags);
+				} else {
+					SkEventQueue(pAC, SKGE_RLMT,
+						SK_RLMT_PACKET_RECEIVED,
+						EvPara);
+					pAC->CheckQueue = SK_TRUE;
+				}
+
+				SK_DBG_MSG(NULL, SK_DBGMOD_DRV,
 					SK_DBGCAT_DRV_RX_PROGRESS,
 					("Q"));
 			}
-			if ((pAC->dev[pRxPort->PortIndex]->flags & 
+			if ((pAC->dev[pRxPort->PortIndex]->flags &
 				(IFF_PROMISC | IFF_ALLMULTI)) != 0 ||
-				(ForRlmt & SK_RLMT_RX_PROTOCOL) == 
-				SK_RLMT_RX_PROTOCOL) { 
+				(ForRlmt & SK_RLMT_RX_PROTOCOL) ==
+				SK_RLMT_RX_PROTOCOL) {
 				pMsg->dev = pAC->dev[pRxPort->PortIndex];
 				pMsg->protocol = eth_type_trans(pMsg,
 					pAC->dev[pRxPort->PortIndex]);
@@ -2304,7 +2814,7 @@
 	/* RXD ring is empty -> fill and restart */
 	FillRxRing(pAC, pRxPort);
 	/* do not start if called from Close */
-	if (pAC->BoardLevel > 0) {
+	if (pAC->BoardLevel > SK_INIT_DATA) {
 		ClearAndStartRx(pAC, PortIndex);
 	}
 	return;
@@ -2315,12 +2825,13 @@
 		("Schrottdescriptor, length: 0x%x\n", FrameLength));
 
 	/* release the DMA mapping */
+
 	PhysAddr = ((SK_U64) pRxd->VDataHigh) << (SK_U64)32;
 	PhysAddr |= (SK_U64) pRxd->VDataLow;
-	pci_unmap_page(&pAC->PciDev,
-		       PhysAddr,
-		       pAC->RxBufSize - 2,
-		       PCI_DMA_FROMDEVICE);
+	pci_unmap_page(pAC->PciDev,
+			 PhysAddr,
+			 pAC->RxBufSize - 2,
+			 PCI_DMA_FROMDEVICE);
 	DEV_KFREE_SKB_IRQ(pRxd->pMBuf);
 	pRxd->pMBuf = NULL;
 	pRxPort->RxdRingFree++;
@@ -2386,7 +2897,7 @@
 {
 RXD		*pRxd;	/* pointer to the current descriptor */
 unsigned long	Flags;
- SK_U64		PhysAddr;
+SK_U64		PhysAddr;
 
 	if (pRxPort->RxdRingFree == pAC->RxDescrPerRing) {
 		return;
@@ -2395,12 +2906,13 @@
 	pRxd = pRxPort->pRxdRingHead;
 	do {
 		if (pRxd->pMBuf != NULL) {
+
 			PhysAddr = ((SK_U64) pRxd->VDataHigh) << (SK_U64)32;
 			PhysAddr |= (SK_U64) pRxd->VDataLow;
-			pci_unmap_page(&pAC->PciDev,
-				       PhysAddr,
-				       pAC->RxBufSize - 2,
-				       PCI_DMA_FROMDEVICE);
+			pci_unmap_page(pAC->PciDev,
+					 PhysAddr,
+					 pAC->RxBufSize - 2,
+					 PCI_DMA_FROMDEVICE);
 			DEV_KFREE_SKB(pRxd->pMBuf);
 			pRxd->pMBuf = NULL;
 		}
@@ -2472,7 +2984,7 @@
 if (pAC->RlmtNets == 1) {
 	StandbyRam = SK_RLMT_STANDBY_QRXSIZE + SK_RLMT_STANDBY_QXASIZE +
 		SK_RLMT_STANDBY_QXSSIZE;
-	RemainingRam = pAC->GIni.GIRamSize - 
+	RemainingRam = pAC->GIni.GIRamSize -
 		(pAC->GIni.GIMacsFound-1) * StandbyRam;
 	for (i=0; i<pAC->GIni.GIMacsFound; i++) {
 		pAC->GIni.GP[i].PRxQSize = SK_RLMT_STANDBY_QRXSIZE;
@@ -2549,7 +3061,7 @@
  *	0, if everything is ok
  *	!=0, on error
  */
-static int SkGeSetMacAddr(struct net_device *dev, void *p)
+static int SkGeSetMacAddr(struct SK_NET_DEVICE *dev, void *p)
 {
 
 DEV_NET *pNet = (DEV_NET*) dev->priv;
@@ -2557,12 +3069,12 @@
 
 struct sockaddr	*addr = p;
 unsigned long	Flags;
-
+	
 	SK_DBG_MSG(NULL, SK_DBGMOD_DRV, SK_DBGCAT_DRV_ENTRY,
 		("SkGeSetMacAddr starts now...\n"));
-	if(netif_running(dev)) {
+	if(netif_running(dev))
 		return -EBUSY;
-	}
+
 	memcpy(dev->dev_addr, addr->sa_data,dev->addr_len);
 	
 	spin_lock_irqsave(&pAC->SlowPathLock, Flags);
@@ -2595,7 +3107,7 @@
  *	0, if everything is ok
  *	!=0, on error
  */
-static void SkGeSetRxMode(struct net_device *dev)
+static void SkGeSetRxMode(struct SK_NET_DEVICE *dev)
 {
 
 DEV_NET		*pNet;
@@ -2649,7 +3161,6 @@
 				pMcList->dmi_addr[5]));
 		}
 		SkAddrMcUpdate(pAC, pAC->IoBase, PortIdx);
-	
 	}
 	spin_unlock_irqrestore(&pAC->SlowPathLock, Flags);
 	
@@ -2670,7 +3181,7 @@
  *	0, if everything is ok
  *	!=0, on error
  */
-static int SkGeChangeMtu(struct net_device *dev, int NewMtu)
+static int SkGeChangeMtu(struct SK_NET_DEVICE *dev, int NewMtu)
 {
 DEV_NET		*pNet;
 DEV_NET		*pOtherNet;
@@ -2689,6 +3200,10 @@
 		return -EINVAL;
 	}
 
+	if(pAC->BoardLevel != SK_INIT_RUN) {
+		return -EINVAL;
+	}
+
 	pNet->Mtu = NewMtu;
 	pOtherNet = (DEV_NET*)pAC->dev[1 - pNet->NetNr]->priv;
 	if ((pOtherNet->Mtu > 1500) && (NewMtu <= 1500) && (pOtherNet->Up==1)) {
@@ -2704,10 +3219,6 @@
 	SK_DBG_MSG(NULL, SK_DBGMOD_DRV, SK_DBGCAT_DRV_ENTRY,
 		("New MTU: %d\n", NewMtu));
 
-	if(pAC->BoardLevel != 2) {
-		return 0;
-	}
-
 	/* prevent reconfiguration while changing the MTU */
 
 	/* disable interrupts */
@@ -2715,7 +3226,7 @@
 	spin_lock_irqsave(&pAC->SlowPathLock, Flags);
 
 	/* Found more than one port */
-	if ((pAC->GIni.GIMacsFound == 2 ) && 
+	if ((pAC->GIni.GIMacsFound == 2 ) &&
 		(pAC->RlmtNets == 2)) {
 			/* Stop both ports */
 			EvPara.Para32[0] = 0;
@@ -2732,18 +3243,19 @@
 		spin_lock_irqsave(
 			&pAC->TxPort[i][TX_PRIO_LOW].TxDesRingLock, Flags);
 		netif_stop_queue(pAC->dev[i]);
+
 	}
 
-	/* 
+	/*
 	 * adjust number of rx buffers allocated
 	 */
 	if (NewMtu > 1500) {
 		/* use less rx buffers */
 		for (i=0; i<pAC->GIni.GIMacsFound; i++) {
 			/* Found more than one port */
-			if ((pAC->GIni.GIMacsFound == 2 ) && 
+			if ((pAC->GIni.GIMacsFound == 2 ) &&
 				(pAC->RlmtNets == 2)) {
-					pAC->RxPort[i].RxFillLimit = 
+					pAC->RxPort[i].RxFillLimit =
 						pAC->RxDescrPerRing - 100;
 			} else {
 				if (i == pAC->ActivePort)
@@ -2756,10 +3268,10 @@
 		}
 	}
 	else {
-		/* use normal anoumt of rx buffers */
+		/* use normal amount of rx buffers */
 		for (i=0; i<pAC->GIni.GIMacsFound; i++) {
 			/* Found more than one port */
-			if ((pAC->GIni.GIMacsFound == 2 ) && 
+			if ((pAC->GIni.GIMacsFound == 2 ) &&
 				(pAC->RlmtNets == 2)) {
 					pAC->RxPort[i].RxFillLimit = 1;
 			} else {
@@ -2771,53 +3283,52 @@
 			}
 		}
 	}
-	 
-	SkGeDeInit(pAC, pAC->IoBase); 
+	
+	SkGeDeInit(pAC, pAC->IoBase);
 
-	/* 
+	/*
 	 * enable/disable hardware support for long frames
 	 */
 	if (NewMtu > 1500) {
 //		pAC->JumboActivated = SK_TRUE; /* is never set back !!! */
 		pAC->GIni.GIPortUsage = SK_JUMBO_LINK;
-		for (i=0; i<pAC->GIni.GIMacsFound; i++) {
-			pAC->GIni.GP[i].PRxCmd = 
-				XM_RX_STRIP_FCS | XM_RX_LENERR_OK;
-		}
 	}
 	else {
-		if ((pAC->GIni.GIMacsFound == 2 ) && 
+		if ((pAC->GIni.GIMacsFound == 2 ) &&
 			(pAC->RlmtNets == 2)) {
 			pAC->GIni.GIPortUsage = SK_MUL_LINK;
 		} else {
 			pAC->GIni.GIPortUsage = SK_RED_LINK;
 		}
-		for (i=0; i<pAC->GIni.GIMacsFound; i++) {
-			pAC->GIni.GP[i].PRxCmd = XM_RX_STRIP_FCS;
-		}
 	}
 
-	SkGeInit(   pAC, pAC->IoBase, 1);
-	SkI2cInit(  pAC, pAC->IoBase, 1);
-	SkEventInit(pAC, pAC->IoBase, 1);
-	SkPnmiInit( pAC, pAC->IoBase, 1);
-	SkAddrInit( pAC, pAC->IoBase, 1);
-	SkRlmtInit( pAC, pAC->IoBase, 1);
-	SkTimerInit(pAC, pAC->IoBase, 1);
-	
-	SkGeInit(   pAC, pAC->IoBase, 2);
-	SkI2cInit(  pAC, pAC->IoBase, 2);
-	SkEventInit(pAC, pAC->IoBase, 2);
-	SkPnmiInit( pAC, pAC->IoBase, 2);
-	SkAddrInit( pAC, pAC->IoBase, 2);
-	SkRlmtInit( pAC, pAC->IoBase, 2);
-	SkTimerInit(pAC, pAC->IoBase, 2);
+	SkGeInit(   pAC, pAC->IoBase, SK_INIT_IO);
+	SkI2cInit(  pAC, pAC->IoBase, SK_INIT_IO);
+	SkEventInit(pAC, pAC->IoBase, SK_INIT_IO);
+	SkPnmiInit( pAC, pAC->IoBase, SK_INIT_IO);
+	SkAddrInit( pAC, pAC->IoBase, SK_INIT_IO);
+	SkRlmtInit( pAC, pAC->IoBase, SK_INIT_IO);
+	SkTimerInit(pAC, pAC->IoBase, SK_INIT_IO);
+	
+	/*
+	 * tschilling:
+	 * Speed and others are set back to default in level 1 init!
+	 */
+	GetConfiguration(pAC);
+	
+	SkGeInit(   pAC, pAC->IoBase, SK_INIT_RUN);
+	SkI2cInit(  pAC, pAC->IoBase, SK_INIT_RUN);
+	SkEventInit(pAC, pAC->IoBase, SK_INIT_RUN);
+	SkPnmiInit( pAC, pAC->IoBase, SK_INIT_RUN);
+	SkAddrInit( pAC, pAC->IoBase, SK_INIT_RUN);
+	SkRlmtInit( pAC, pAC->IoBase, SK_INIT_RUN);
+	SkTimerInit(pAC, pAC->IoBase, SK_INIT_RUN);
 
-	/* 
+	/*
 	 * clear and reinit the rx rings here
 	 */
 	for (i=0; i<pAC->GIni.GIMacsFound; i++) {
-		ReceiveIrq(pAC, &pAC->RxPort[i]);
+		ReceiveIrq(pAC, &pAC->RxPort[i], SK_TRUE);
 		ClearRxRing(pAC, &pAC->RxPort[i]);
 		FillRxRing(pAC, &pAC->RxPort[i]);
 
@@ -2828,15 +3339,8 @@
 
 	SkGeYellowLED(pAC, pAC->IoBase, 1);
 
-#ifdef USE_INT_MOD
-	{
-		unsigned long ModBase;
-		ModBase = 53125000 / INTS_PER_SEC;
-		SK_OUT32(pAC->IoBase, B2_IRQM_INI, ModBase);
-		SK_OUT32(pAC->IoBase, B2_IRQM_MSK, IRQ_MOD_MASK);
-		SK_OUT32(pAC->IoBase, B2_IRQM_CTRL, TIM_START);
-	}
-#endif
+	SkDimEnableModerationIfNeeded(pAC);	
+	SkDimDisplayModerationSettings(pAC);
 
 	netif_start_queue(pAC->dev[pNet->PortNr]);
 	for (i=pAC->GIni.GIMacsFound-1; i>=0; i--) {
@@ -2844,14 +3348,14 @@
 	}
 
 	/* enable Interrupts */
-	SK_OUT32(pAC->IoBase, B0_IMSK, IRQ_MASK);
+	SK_OUT32(pAC->IoBase, B0_IMSK, pAC->GIni.GIValIrqMask);
 	SK_OUT32(pAC->IoBase, B0_HWE_IMSK, IRQ_HWE_MASK);
 
 	SkEventQueue(pAC, SKGE_RLMT, SK_RLMT_START, EvPara);
 	SkEventDispatcher(pAC, pAC->IoBase);
 
 	/* Found more than one port */
-	if ((pAC->GIni.GIMacsFound == 2 ) && 
+	if ((pAC->GIni.GIMacsFound == 2 ) &&
 		(pAC->RlmtNets == 2)) {
 			/* Start both ports */
 			EvPara.Para32[0] = pAC->RlmtNets;
@@ -2866,7 +3370,7 @@
 			
 			if (pOtherNet->Up) {
 				EvPara.Para32[0] = pOtherNet->PortNr;
-				SkEventQueue(pAC, SKGE_RLMT, 
+				SkEventQueue(pAC, SKGE_RLMT,
 					SK_RLMT_START, EvPara);
 			}
 	} else {
@@ -2891,12 +3395,13 @@
  * Returns:
  *	pointer to the statistic structure.
  */
-static struct net_device_stats *SkGeStats(struct net_device *dev)
+static struct net_device_stats *SkGeStats(struct SK_NET_DEVICE *dev)
 {
 DEV_NET *pNet = (DEV_NET*) dev->priv;
 SK_AC	*pAC = pNet->pAC;
 SK_PNMI_STRUCT_DATA *pPnmiStruct;       /* structure for all Pnmi-Data */
-SK_PNMI_STAT    *pPnmiStat;             /* pointer to virtual XMAC stat. data */SK_PNMI_CONF    *pPnmiConf;             /* pointer to virtual link config. */
+SK_PNMI_STAT    *pPnmiStat;             /* pointer to virtual XMAC stat. data */
+SK_PNMI_CONF    *pPnmiConf;             /* pointer to virtual link config. */
 unsigned int    Size;                   /* size of pnmi struct */
 unsigned long	Flags;			/* for spin lock */
 
@@ -2915,7 +3420,18 @@
 	pAC->stats.tx_packets = (SK_U32) pPnmiStat->StatTxOkCts & 0xFFFFFFFF;
 	pAC->stats.rx_bytes = (SK_U32) pPnmiStruct->RxOctetsDeliveredCts;
 	pAC->stats.tx_bytes = (SK_U32) pPnmiStat->StatTxOctetsOkCts;
-	pAC->stats.rx_errors = (SK_U32) pPnmiStruct->InErrorsCts & 0xFFFFFFFF;
+	
+        if (pNet->Mtu <= 1500) {
+                pAC->stats.rx_errors = (SK_U32) pPnmiStruct->InErrorsCts & 0xFFFFFFFF;
+        } else {
+                pAC->stats.rx_errors = (SK_U32) ((pPnmiStruct->InErrorsCts -
+                        pPnmiStat->StatRxTooLongCts) & 0xFFFFFFFF);
+	}
+
+
+	if (pAC->GIni.GP[0].PhyType == SK_PHY_XMAC && pAC->HWRevision < 12)
+		pAC->stats.rx_errors = pAC->stats.rx_errors - pPnmiStat->StatRxShortsCts;
+
 	pAC->stats.tx_errors = (SK_U32) pPnmiStat->StatTxSingleCollisionCts & 0xFFFFFFFF;
 	pAC->stats.rx_dropped = (SK_U32) pPnmiStruct->RxNoBufCts & 0xFFFFFFFF;
 	pAC->stats.tx_dropped = (SK_U32) pPnmiStruct->TxNoBufCts & 0xFFFFFFFF;
@@ -2954,7 +3470,7 @@
  *	0, if everything is ok
  *	!=0, on error
  */
-static int SkGeIoctl(struct net_device *dev, struct ifreq *rq, int cmd)
+static int SkGeIoctl(struct SK_NET_DEVICE *dev, struct ifreq *rq, int cmd)
 {
 DEV_NET		*pNet;
 SK_AC		*pAC;
@@ -2978,7 +3494,7 @@
 	case SK_IOCTL_PRESETMIB:
 		if (!capable(CAP_NET_ADMIN)) return -EPERM;
  	case SK_IOCTL_GETMIB:
-		if(copy_from_user(&pAC->PnmiStruct, Ioctl.pData, 
+		if(copy_from_user(&pAC->PnmiStruct, Ioctl.pData,
 			Ioctl.Len<sizeof(pAC->PnmiStruct)?
 			Ioctl.Len : sizeof(pAC->PnmiStruct))) {
 			return -EFAULT;
@@ -3068,6 +3584,7 @@
 SK_AC	*pAC)	/* pointer to the adapter context structure */
 {
 SK_I32	Port;		/* preferred port */
+int	LinkSpeed;	/* Link speed */
 int	AutoNeg;	/* auto negotiation off (0) or on (1) */
 int	DuplexCap;	/* duplex capabilities (0=both, 1=full, 2=half */
 int	MSMode;		/* master / slave mode selection */
@@ -3085,8 +3602,8 @@
  *	-----------------------------------------------------------------
  *	Sense		|   AutoSense	|   AutoSense	|   AutoSense	|
  */
-int	Capabilities[3][3] = 
-		{ {		  -1, SK_LMODE_FULL,     SK_LMODE_HALF}, 
+int	Capabilities[3][3] =
+		{ {		  -1, SK_LMODE_FULL,     SK_LMODE_HALF},
 		  {SK_LMODE_AUTOBOTH, SK_LMODE_AUTOFULL, SK_LMODE_AUTOHALF},
 		  {SK_LMODE_AUTOSENSE, SK_LMODE_AUTOSENSE, SK_LMODE_AUTOSENSE} };
 #define DC_BOTH	0
@@ -3097,7 +3614,44 @@
 #define AN_SENS	2
 
 	/* settings for port A */
-	AutoNeg = AN_SENS; /* default: do auto Sense */
+	/* settings link speed */
+	LinkSpeed = SK_LSPEED_AUTO; 	/* default: do auto select */
+	if (Speed_A != NULL && pAC->Index<SK_MAX_CARD_PARAM &&
+		Speed_A[pAC->Index] != NULL) {
+		if (strcmp(Speed_A[pAC->Index],"")==0) {
+			LinkSpeed = SK_LSPEED_AUTO;
+		}
+		else if (strcmp(Speed_A[pAC->Index],"Auto")==0) {
+			LinkSpeed = SK_LSPEED_AUTO;
+		}
+		else if (strcmp(Speed_A[pAC->Index],"10")==0) {
+			LinkSpeed = SK_LSPEED_10MBPS;
+		}
+		else if (strcmp(Speed_A[pAC->Index],"100")==0) {
+			LinkSpeed = SK_LSPEED_100MBPS;
+		}
+		else if (strcmp(Speed_A[pAC->Index],"1000")==0) {
+			LinkSpeed = SK_LSPEED_1000MBPS;
+		}
+		else printk("%s: Illegal value for Speed_A\n",
+			pAC->dev[0]->name);
+	}
+
+	/* Check speed parameter */
+	/* Only copper type adapter and GE V2 cards */
+	if (((pAC->GIni.GIChipId != CHIP_ID_YUKON) ||
+		(pAC->GIni.GICopperType != SK_TRUE)) &&
+		((LinkSpeed != SK_LSPEED_AUTO) &&
+		(LinkSpeed != SK_LSPEED_1000MBPS))) {
+		printk("%s: Illegal value for Speed_A. "
+			"Not a copper card or GE V2 card\n    Using "
+			"speed 1000\n", pAC->dev[0]->name);
+		LinkSpeed = SK_LSPEED_1000MBPS;
+	}
+	pAC->GIni.GP[0].PLinkSpeed = LinkSpeed;
+
+	/* Autonegotiation */
+	AutoNeg = AN_ON; /* tschilling: Default: Autonegotiation on! */
 	AutoSet = SK_FALSE;
 	if (AutoNeg_A != NULL && pAC->Index<SK_MAX_CARD_PARAM &&
 		AutoNeg_A[pAC->Index] != NULL) {
@@ -3219,6 +3773,43 @@
 	
 	
 	/* settings for port B */
+	/* settings link speed */
+	LinkSpeed = SK_LSPEED_AUTO; 	/* default: do auto select */
+	if (Speed_B != NULL && pAC->Index<SK_MAX_CARD_PARAM &&
+		Speed_B[pAC->Index] != NULL) {
+		if (strcmp(Speed_B[pAC->Index],"")==0) {
+			LinkSpeed = SK_LSPEED_AUTO;
+		}
+		else if (strcmp(Speed_B[pAC->Index],"Auto")==0) {
+			LinkSpeed = SK_LSPEED_AUTO;
+		}
+		else if (strcmp(Speed_B[pAC->Index],"10")==0) {
+			LinkSpeed = SK_LSPEED_10MBPS;
+		}
+		else if (strcmp(Speed_B[pAC->Index],"100")==0) {
+			LinkSpeed = SK_LSPEED_100MBPS;
+		}
+		else if (strcmp(Speed_B[pAC->Index],"1000")==0) {
+			LinkSpeed = SK_LSPEED_1000MBPS;
+		}
+		else printk("%s: Illegal value for Speed_B\n",
+			pAC->dev[1]->name);
+	}
+
+	/* Check speed parameter */
+	/* Only copper type adapter and GE V2 cards */
+	if (((pAC->GIni.GIChipId != CHIP_ID_YUKON) ||
+		(pAC->GIni.GICopperType != SK_TRUE)) &&
+		((LinkSpeed != SK_LSPEED_AUTO) &&
+		(LinkSpeed != SK_LSPEED_1000MBPS))) {
+		printk("%s: Illegal value for Speed_B. "
+			"Not a copper card or GE V2 card\n    Using "
+			"speed 1000\n", pAC->dev[1]->name);
+		LinkSpeed = SK_LSPEED_1000MBPS;
+	}
+	pAC->GIni.GP[1].PLinkSpeed = LinkSpeed;
+
+	/* Auto negotiation */
 	AutoNeg = AN_SENS; /* default: do auto Sense */
 	AutoSet = SK_FALSE;
 	if (AutoNeg_B != NULL && pAC->Index<SK_MAX_CARD_PARAM &&
@@ -3370,7 +3961,7 @@
 	}
 
 	pAC->RlmtNets = 1;
-	
+
 	if (RlmtMode != NULL && pAC->Index<SK_MAX_CARD_PARAM &&
 		RlmtMode[pAC->Index] != NULL) {
 		if (strcmp(RlmtMode[pAC->Index], "") == 0) {
@@ -3385,7 +3976,7 @@
 		}
 		else if (strcmp(RlmtMode[pAC->Index], "CheckSeg") == 0) {
 			pAC->RlmtMode = SK_RLMT_CHECK_LINK |
-				SK_RLMT_CHECK_LOC_LINK | 
+				SK_RLMT_CHECK_LOC_LINK |
 				SK_RLMT_CHECK_SEG;
 		}
 		else if ((strcmp(RlmtMode[pAC->Index], "DualNet") == 0) &&
@@ -3396,16 +3987,110 @@
 		else {
 			printk("%s: Illegal value for"
 				" RlmtMode, using default\n", pAC->dev[0]->name);
-
-printk("MacFound = %d\nRlmtMode = %s", pAC->GIni.GIMacsFound, RlmtMode[pAC->Index]);
-	
-
 			pAC->RlmtMode = 0;
 		}
 	}
 	else {
 		pAC->RlmtMode = 0;
 	}
+	
+	/*
+	** Check the interrupt moderation parameters
+	*/
+	if (Moderation[pAC->Index] != NULL) {
+	    if (strcmp(Moderation[pAC->Index], "Static") == 0) {
+                pAC->DynIrqModInfo.IntModTypeSelect = C_INT_MOD_STATIC;
+	    } else if (strcmp(Moderation[pAC->Index], "Dynamic") == 0) {
+	        pAC->DynIrqModInfo.IntModTypeSelect = C_INT_MOD_DYNAMIC;
+	    } else {
+	        pAC->DynIrqModInfo.IntModTypeSelect = C_INT_MOD_NONE;
+	    }
+	} else {
+	    pAC->DynIrqModInfo.IntModTypeSelect = C_INT_MOD_NONE;
+	}
+
+	if (Stats[pAC->Index] != NULL) {
+	    if (strcmp(Stats[pAC->Index], "Yes") == 0) {
+	        pAC->DynIrqModInfo.DisplayStats = SK_TRUE;
+	    } else {
+		pAC->DynIrqModInfo.DisplayStats = SK_FALSE;
+	    }
+	} else {
+	    pAC->DynIrqModInfo.DisplayStats = SK_FALSE;
+	}
+
+        if (ModerationMask[pAC->Index] != NULL) {
+           if (strcmp(ModerationMask[pAC->Index], "Rx") == 0) {
+               pAC->DynIrqModInfo.MaskIrqModeration = IRQ_MASK_RX_ONLY;
+           } else if (strcmp(ModerationMask[pAC->Index], "Tx") == 0) {
+               pAC->DynIrqModInfo.MaskIrqModeration = IRQ_MASK_TX_ONLY;
+           } else if (strcmp(ModerationMask[pAC->Index], "Sp") == 0) {
+               pAC->DynIrqModInfo.MaskIrqModeration = IRQ_MASK_SP_ONLY;
+           } else if (strcmp(ModerationMask[pAC->Index], "RxSp") == 0) {
+               pAC->DynIrqModInfo.MaskIrqModeration = IRQ_MASK_SP_RX;
+           } else if (strcmp(ModerationMask[pAC->Index], "SpRx") == 0) {
+               pAC->DynIrqModInfo.MaskIrqModeration = IRQ_MASK_SP_RX;
+           } else if (strcmp(ModerationMask[pAC->Index], "RxTx") == 0) {
+               pAC->DynIrqModInfo.MaskIrqModeration = IRQ_MASK_TX_RX;
+           } else if (strcmp(ModerationMask[pAC->Index], "TxRx") == 0) {
+               pAC->DynIrqModInfo.MaskIrqModeration = IRQ_MASK_TX_RX;
+           } else if (strcmp(ModerationMask[pAC->Index], "TxSp") == 0) {
+               pAC->DynIrqModInfo.MaskIrqModeration = IRQ_MASK_SP_TX;
+           } else if (strcmp(ModerationMask[pAC->Index], "SpTx") == 0) {
+               pAC->DynIrqModInfo.MaskIrqModeration = IRQ_MASK_SP_TX;
+           } else if (strcmp(ModerationMask[pAC->Index], "RxTxSp") == 0) {
+               pAC->DynIrqModInfo.MaskIrqModeration = IRQ_MASK_RX_TX_SP;
+           } else if (strcmp(ModerationMask[pAC->Index], "RxSpTx") == 0) {
+               pAC->DynIrqModInfo.MaskIrqModeration = IRQ_MASK_RX_TX_SP;
+           } else if (strcmp(ModerationMask[pAC->Index], "TxRxSp") == 0) {
+               pAC->DynIrqModInfo.MaskIrqModeration = IRQ_MASK_RX_TX_SP;
+           } else if (strcmp(ModerationMask[pAC->Index], "TxSpRx") == 0) {
+               pAC->DynIrqModInfo.MaskIrqModeration = IRQ_MASK_RX_TX_SP;
+           } else if (strcmp(ModerationMask[pAC->Index], "SpTxRx") == 0) {
+               pAC->DynIrqModInfo.MaskIrqModeration = IRQ_MASK_RX_TX_SP;
+           } else if (strcmp(ModerationMask[pAC->Index], "SpRxTx") == 0) {
+               pAC->DynIrqModInfo.MaskIrqModeration = IRQ_MASK_RX_TX_SP;
+           } else { /* some rubbish */
+               pAC->DynIrqModInfo.MaskIrqModeration = IRQ_MASK_RX_ONLY;
+           }
+        } else {  /* operator has stated nothing */
+           pAC->DynIrqModInfo.MaskIrqModeration = IRQ_MASK_TX_RX;
+        }
+
+        if (AutoSizing[pAC->Index] != NULL) {
+           if (strcmp(AutoSizing[pAC->Index], "On") == 0) {
+               pAC->DynIrqModInfo.AutoSizing = SK_FALSE;
+           } else {
+               pAC->DynIrqModInfo.AutoSizing = SK_FALSE;
+           }
+        } else {  /* operator has stated nothing */
+           pAC->DynIrqModInfo.AutoSizing = SK_FALSE;
+        }
+
+        if (IntsPerSec[pAC->Index] != 0) {
+           if ((IntsPerSec[pAC->Index]< 30)&&(IntsPerSec[pAC->Index]> 40000)) {
+              pAC->DynIrqModInfo.MaxModIntsPerSec = C_INTS_PER_SEC_DEFAULT;
+           } else {
+              pAC->DynIrqModInfo.MaxModIntsPerSec = IntsPerSec[pAC->Index];
+           }
+        } else {
+           pAC->DynIrqModInfo.MaxModIntsPerSec = C_INTS_PER_SEC_DEFAULT;
+        }
+
+        /*
+	** Evaluate upper and lower moderation threshold
+	*/
+        pAC->DynIrqModInfo.MaxModIntsPerSecUpperLimit =
+            pAC->DynIrqModInfo.MaxModIntsPerSec +
+            (pAC->DynIrqModInfo.MaxModIntsPerSec / 2);
+
+        pAC->DynIrqModInfo.MaxModIntsPerSecLowerLimit =
+            pAC->DynIrqModInfo.MaxModIntsPerSec -
+            (pAC->DynIrqModInfo.MaxModIntsPerSec / 2);
+
+        pAC->DynIrqModInfo.PrevTimeVal = jiffies;  /* initial value */
+
+
 } /* GetConfiguration */
 
 
@@ -3440,8 +4125,44 @@
 	}
 } /* ProductStr */
 
+/*****************************************************************************
+ *
+ *      StartDrvCleanupTimer - Start timer to check for descriptors which
+ *                             might be placed in descriptor ring, but
+ *                             havent been handled up to now
+ *
+ * Description:
+ *      This function requests a HW-timer fo the Yukon card. The actions to
+ *      perform when this timer expires, are located in the SkDrvEvent().
+ *
+ * Returns: N/A
+ */
+static void
+StartDrvCleanupTimer(SK_AC *pAC) {
+    SK_EVPARA    EventParam;   /* Event struct for timer event */
+
+    SK_MEMSET((char *) &EventParam, 0, sizeof(EventParam));
+    EventParam.Para32[0] = SK_DRV_RX_CLEANUP_TIMER;
+    SkTimerStart(pAC, pAC->IoBase, &pAC->DrvCleanupTimer,
+                 SK_DRV_RX_CLEANUP_TIMER_LENGTH,
+                 SKGE_DRV, SK_DRV_TIMER, EventParam);
+}
 
-
+/*****************************************************************************
+ *
+ *      StopDrvCleanupTimer - Stop timer to check for descriptors
+ *
+ * Description:
+ *      This function requests a HW-timer fo the Yukon card. The actions to
+ *      perform when this timer expires, are located in the SkDrvEvent().
+ *
+ * Returns: N/A
+ */
+static void
+StopDrvCleanupTimer(SK_AC *pAC) {
+    SkTimerStop(pAC, pAC->IoBase, &pAC->DrvCleanupTimer);
+    SK_MEMSET((char *) &pAC->DrvCleanupTimer, 0, sizeof(SK_TIMER));
+}
 
 /****************************************************************************/
 /* functions for common modules *********************************************/
@@ -3500,8 +4221,8 @@
  *	Nothing
  */
 void  SkDrvFreeRlmtMbuf(
-SK_AC		*pAC,		/* pointer to adapter context */  
-SK_IOC		IoC,		/* the IO-context */              
+SK_AC		*pAC,		/* pointer to adapter context */
+SK_IOC		IoC,		/* the IO-context */
 SK_MBUF		*pMbuf)		/* size of the requested buffer */
 {
 SK_MBUF		*pFreeMbuf;
@@ -3551,7 +4272,7 @@
 int PciAddr,		/* PCI register address */
 SK_U32 *pVal)		/* pointer to store the read value */
 {
-	pci_read_config_dword(&pAC->PciDev, PciAddr, pVal);
+	pci_read_config_dword(pAC->PciDev, PciAddr, pVal);
 	return(0);
 } /* SkPciReadCfgDWord */
 
@@ -3573,7 +4294,7 @@
 int PciAddr,		/* PCI register address */
 SK_U16 *pVal)		/* pointer to store the read value */
 {
-	pci_read_config_word(&pAC->PciDev, PciAddr, pVal);
+	pci_read_config_word(pAC->PciDev, PciAddr, pVal);
 	return(0);
 } /* SkPciReadCfgWord */
 
@@ -3595,7 +4316,7 @@
 int PciAddr,		/* PCI register address */
 SK_U8 *pVal)		/* pointer to store the read value */
 {
-	pci_read_config_byte(&pAC->PciDev, PciAddr, pVal);
+	pci_read_config_byte(pAC->PciDev, PciAddr, pVal);
 	return(0);
 } /* SkPciReadCfgByte */
 
@@ -3617,7 +4338,7 @@
 int PciAddr,		/* PCI register address */
 SK_U32 Val)		/* pointer to store the read value */
 {
-	pci_write_config_dword(&pAC->PciDev, PciAddr, Val);
+	pci_write_config_dword(pAC->PciDev, PciAddr, Val);
 	return(0);
 } /* SkPciWriteCfgDWord */
 
@@ -3640,7 +4361,7 @@
 int PciAddr,		/* PCI register address */
 SK_U16 Val)		/* pointer to store the read value */
 {
-	pci_write_config_word(&pAC->PciDev, PciAddr, Val);
+	pci_write_config_word(pAC->PciDev, PciAddr, Val);
 	return(0);
 } /* SkPciWriteCfgWord */
 
@@ -3663,7 +4384,7 @@
 int PciAddr,		/* PCI register address */
 SK_U8 Val)		/* pointer to store the read value */
 {
-	pci_write_config_byte(&pAC->PciDev, PciAddr, Val);
+	pci_write_config_byte(pAC->PciDev, PciAddr, Val);
 	return(0);
 } /* SkPciWriteCfgByte */
 
@@ -3696,6 +4417,7 @@
 SK_EVPARA	NewPara;	/* parameter for further events */
 int		Stat;
 unsigned long	Flags;
+SK_BOOL		DualNet;
 
 	switch (Event) {
 	case SK_DRV_ADAP_FAIL:
@@ -3728,18 +4450,27 @@
 			&pAC->TxPort[FromPort][TX_PRIO_LOW].TxDesRingLock,
 			Flags);
 		SkGeStopPort(pAC, IoC, FromPort, SK_STOP_ALL, SK_HARD_RST);
+		pAC->dev[Param.Para32[0]]->flags &= ~IFF_RUNNING;
 		spin_unlock_irqrestore(
 			&pAC->TxPort[FromPort][TX_PRIO_LOW].TxDesRingLock,
 			Flags);
 		
 		/* clear rx ring from received frames */
-		ReceiveIrq(pAC, &pAC->RxPort[FromPort]);
+		ReceiveIrq(pAC, &pAC->RxPort[FromPort], SK_FALSE);
 		
 		ClearTxRing(pAC, &pAC->TxPort[FromPort][TX_PRIO_LOW]);
 		spin_lock_irqsave(
 			&pAC->TxPort[FromPort][TX_PRIO_LOW].TxDesRingLock,
 			Flags);
-		SkGeInitPort(pAC, IoC, FromPort);
+		
+		/* tschilling: Handling of return value inserted. */
+		if (SkGeInitPort(pAC, IoC, FromPort)) {
+			if (FromPort == 0) {
+				printk("%s: SkGeInitPort A failed.\n", pAC->dev[0]->name);
+			} else {
+				printk("%s: SkGeInitPort B failed.\n", pAC->dev[1]->name);
+			}
+		}
 		SkAddrMcUpdate(pAC,IoC, FromPort);
 		PortReInitBmu(pAC, FromPort);
 		SkGePollTxD(pAC, IoC, FromPort, SK_TRUE);
@@ -3755,7 +4486,22 @@
 			("NET UP EVENT, Port: %d ", Param.Para32[0]));
 		printk("%s: network connection up using"
 			" port %c\n", pAC->dev[Param.Para32[0]]->name, 'A'+Param.Para32[0]);
-		printk("    speed:           1000\n");
+
+		/* tschilling: Values changed according to LinkSpeedUsed. */
+		Stat = pAC->GIni.GP[FromPort].PLinkSpeedUsed;
+		if (Stat == SK_LSPEED_STAT_10MBPS) {
+			printk("    speed:           10\n");
+		} else if (Stat == SK_LSPEED_STAT_100MBPS) {
+			printk("    speed:           100\n");
+		} else if (Stat == SK_LSPEED_STAT_1000MBPS) {
+			printk("    speed:           1000\n");
+		} else {
+			printk("    speed:           unknown\n");
+		}
+
+		/* Mac update */
+		SkAddrMcUpdate(pAC,IoC, FromPort);
+
 		Stat = pAC->GIni.GP[FromPort].PLinkModeStatus;
 		if (Stat == SK_LMODE_STAT_AUTOHALF ||
 			Stat == SK_LMODE_STAT_AUTOFULL) {
@@ -3784,8 +4530,12 @@
 		else {
 			printk("    flowctrl:        none\n");
 		}
-		if (pAC->GIni.GP[FromPort].PhyType != SK_PHY_XMAC) {
-		Stat = pAC->GIni.GP[FromPort].PMSStatus;
+		
+		/* tschilling: Check against CopperType now. */
+		if ((pAC->GIni.GICopperType == SK_TRUE) &&
+			(pAC->GIni.GP[FromPort].PLinkSpeedUsed ==
+			SK_LSPEED_STAT_1000MBPS)) {
+			Stat = pAC->GIni.GP[FromPort].PMSStatus;
 			if (Stat == SK_MS_STAT_MASTER ) {
 				printk("    role:            master\n");
 			}
@@ -3796,20 +4546,35 @@
 				printk("    role:            ???\n");
 			}
 		}
+
+#ifdef SK_ZEROCOPY
+		if (pAC->GIni.GIChipId == CHIP_ID_YUKON)
+			printk("    scatter-gather:  enabled\n");
+		else
+			printk("    scatter-gather:  disabled\n");
+
+#else
+			printk("    scatter-gather:  disabled\n");
+#endif
 		
-		if ((Param.Para32[0] != pAC->ActivePort) && 
+		if ((Param.Para32[0] != pAC->ActivePort) &&
 			(pAC->RlmtNets == 1)) {
 			NewPara.Para32[0] = pAC->ActivePort;
 			NewPara.Para32[1] = Param.Para32[0];
 			SkEventQueue(pAC, SKGE_DRV, SK_DRV_SWITCH_INTERN,
 				NewPara);
 		}
+
+		/* Inform the world that link protocol is up. */
+		pAC->dev[Param.Para32[0]]->flags |= IFF_RUNNING;
+
 		break;
 	case SK_DRV_NET_DOWN:	 /* SK_U32 Reason */
 		/* action list 7 */
 		SK_DBG_MSG(NULL, SK_DBGMOD_DRV, SK_DBGCAT_DRV_EVENT,
 			("NET DOWN EVENT "));
 		printk("%s: network connection down\n", pAC->dev[Param.Para32[1]]->name);
+		pAC->dev[Param.Para32[1]]->flags &= ~IFF_RUNNING;
 		break;
 	case SK_DRV_SWITCH_HARD: /* SK_U32 FromPortIdx SK_U32 ToPortIdx */
 		SK_DBG_MSG(NULL, SK_DBGMOD_DRV, SK_DBGCAT_DRV_EVENT,
@@ -3841,24 +4606,48 @@
 			&pAC->TxPort[FromPort][TX_PRIO_LOW].TxDesRingLock,
 			Flags);
 
-		ReceiveIrq(pAC, &pAC->RxPort[FromPort]); /* clears rx ring */
-		ReceiveIrq(pAC, &pAC->RxPort[ToPort]); /* clears rx ring */
+		ReceiveIrq(pAC, &pAC->RxPort[FromPort], SK_FALSE); /* clears rx ring */
+		ReceiveIrq(pAC, &pAC->RxPort[ToPort], SK_FALSE); /* clears rx ring */
 		
 		ClearTxRing(pAC, &pAC->TxPort[FromPort][TX_PRIO_LOW]);
 		ClearTxRing(pAC, &pAC->TxPort[ToPort][TX_PRIO_LOW]);
 		spin_lock_irqsave(
-			&pAC->TxPort[FromPort][TX_PRIO_LOW].TxDesRingLock, 
+			&pAC->TxPort[FromPort][TX_PRIO_LOW].TxDesRingLock,
 			Flags);
 		spin_lock_irqsave(
 			&pAC->TxPort[ToPort][TX_PRIO_LOW].TxDesRingLock, Flags);
 		pAC->ActivePort = ToPort;
+#if 0
 		SetQueueSizes(pAC);
-		SkGeInitPort(pAC, IoC, FromPort);
-		SkGeInitPort(pAC, IoC, ToPort);
+#else
+		/* tschilling: New common function with minimum size check. */
+		DualNet = SK_FALSE;
+		if (pAC->RlmtNets == 2) {
+			DualNet = SK_TRUE;
+		}
+		
+		if (SkGeInitAssignRamToQueues(
+			pAC,
+			pAC->ActivePort,
+			DualNet)) {
+			spin_unlock_irqrestore(
+				&pAC->TxPort[ToPort][TX_PRIO_LOW].TxDesRingLock, Flags);
+			spin_unlock_irqrestore(
+				&pAC->TxPort[FromPort][TX_PRIO_LOW].TxDesRingLock,
+				Flags);
+			printk("SkGeInitAssignRamToQueues failed.\n");
+			break;
+		}
+#endif
+		/* tschilling: Handling of return values inserted. */
+		if (SkGeInitPort(pAC, IoC, FromPort) ||
+			SkGeInitPort(pAC, IoC, ToPort)) {
+			printk("%s: SkGeInitPort failed.\n", pAC->dev[0]->name);
+		}
 		if (Event == SK_DRV_SWITCH_SOFT) {
-			SkXmRxTxEnable(pAC, IoC, FromPort);
+			SkMacRxTxEnable(pAC, IoC, FromPort);
 		}
-		SkXmRxTxEnable(pAC, IoC, ToPort);
+		SkMacRxTxEnable(pAC, IoC, ToPort);
 		SkAddrSwap(pAC, IoC, FromPort, ToPort);
 		SkAddrMcUpdate(pAC, IoC, FromPort);
 		SkAddrMcUpdate(pAC, IoC, ToPort);
@@ -3881,9 +4670,35 @@
 		pMsg = (struct sk_buff*) pRlmtMbuf->pOs;
 		skb_put(pMsg, pRlmtMbuf->Length);
 		if (XmitFrame(pAC, &pAC->TxPort[pRlmtMbuf->PortIdx][TX_PRIO_LOW],
-			      pMsg) < 0)
+			pMsg) < 0)
+
 			DEV_KFREE_SKB_ANY(pMsg);
 		break;
+	case SK_DRV_TIMER:
+		if (Param.Para32[0] == SK_DRV_MODERATION_TIMER) {
+			/*
+			** expiration of the moderation timer implies that
+			** dynamic moderation is to be applied
+			*/
+			SkDimStartModerationTimer(pAC);
+			SkDimModerate(pAC);
+                        if (pAC->DynIrqModInfo.DisplayStats) {
+			    SkDimDisplayModerationSettings(pAC);
+                        }
+                } else if (Param.Para32[0] == SK_DRV_RX_CLEANUP_TIMER) {
+			/*
+			** check if we need to check for descriptors which
+			** haven't been handled the last millisecs
+			*/
+			StartDrvCleanupTimer(pAC);
+			if (pAC->GIni.GIMacsFound == 2) {
+				ReceiveIrq(pAC, &pAC->RxPort[1], SK_TRUE);
+			}
+			ReceiveIrq(pAC, &pAC->RxPort[0], SK_TRUE);
+		} else {
+			printk("Expiration of unknown timer\n");
+		}
+		break;
 	default:
 		break;
 	}
@@ -3943,7 +4758,8 @@
 
 } /* SkErrorLog */
 
-#ifdef DEBUG /***************************************************************/
+#ifdef DEBUG
+/****************************************************************************/
 /* "debug only" section *****************************************************/
 /****************************************************************************/
 
@@ -3990,7 +4806,7 @@
  *	DumpData - print a data area
  *
  * Description:
- *	This function prints a area of data to the system logfile/to the 
+ *	This function prints a area of data to the system logfile/to the
  *	console.
  *
  * Returns: N/A
@@ -4038,7 +4854,7 @@
  *	DumpLong - print a data area as long values
  *
  * Description:
- *	This function prints a area of data to the system logfile/to the 
+ *	This function prints a area of data to the system logfile/to the
  *	console.
  *
  * Returns: N/A
@@ -4090,11 +4906,10 @@
 	printk("------------------------\n");
 } /* DumpLong */
 
-#endif /* DEBUG */
-
-/*
- * Local variables:
- * compile-command: "make"
- * End:
- */
+#endif
 
+/*******************************************************************************
+ *
+ * End of file
+ *
+ ******************************************************************************/
diff -ruN linux/drivers/net/sk98lin/skgehwt.c linuxn/drivers/net/sk98lin/skgehwt.c
--- linux/drivers/net/sk98lin/skgehwt.c	Wed Jul  4 20:50:39 2001
+++ linuxn/drivers/net/sk98lin/skgehwt.c	Tue May 20 12:17:40 2003
@@ -1,32 +1,23 @@
 /******************************************************************************
  *
  * Name:	skgehwt.c
- * Project:	PCI Gigabit Ethernet Adapter
- * Version:	$Revision: 1.12 $
- * Date:	$Date: 1998/10/15 15:11:34 $
+ * Project:	GEnesis, PCI Gigabit Ethernet Adapter
+ * Version:	$Revision: 1.13 $
+ * Date:	$Date: 1999/11/22 13:31:12 $
  * Purpose:	Hardware Timer.
  *
  ******************************************************************************/
 
 /******************************************************************************
  *
- *	(C)Copyright 1989-1998 SysKonnect,
+ *	(C)Copyright 1998,1999 SysKonnect,
  *	a business unit of Schneider & Koch & Co. Datensysteme GmbH.
- *	All Rights Reserved
  *
- *	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF SYSKONNECT
- *	The copyright notice above does not evidence any
- *	actual or intended publication of such source code.
- *
- *	This Module contains Proprietary Information of SysKonnect
- *	and should be treated as Confidential.
- *
- *	The information in this file is provided for the exclusive use of
- *	the licensees of SysKonnect.
- *	Such users have the right to use, modify, and incorporate this code
- *	into products for purposes authorized by the license agreement
- *	provided they include this notice and the associated copyright notice
- *	with any such product.
+ *	This program is free software; you can redistribute it and/or modify
+ *	it under the terms of the GNU General Public License as published by
+ *	the Free Software Foundation; either version 2 of the License, or
+ *	(at your option) any later version.
+ *
  *	The information in this file is provided "AS IS" without warranty.
  *
  ******************************************************************************/
@@ -36,6 +27,9 @@
  * History:
  *
  *	$Log: skgehwt.c,v $
+ *	Revision 1.13  1999/11/22 13:31:12  cgoos
+ *	Changed license header to GPL.
+ *	
  *	Revision 1.12  1998/10/15 15:11:34  gklug
  *	fix: ID_sccs to SysKonnectFileId
  *	
@@ -83,7 +77,7 @@
 	Event queue and dispatcher
 */
 static const char SysKonnectFileId[] =
-	"$Header: /usr56/projects/ge/schedule/skgehwt.c,v 1.12 1998/10/15 15:11:34 gklug Exp $" ;
+	"$Header: /usr56/projects/ge/schedule/skgehwt.c,v 1.13 1999/11/22 13:31:12 cgoos Exp $" ;
 
 #include "h/skdrv1st.h"		/* Driver Specific Definitions */
 #include "h/skdrv2nd.h"		/* Adapter Control- and Driver specific Def. */
diff -ruN linux/drivers/net/sk98lin/skgeinit.c linuxn/drivers/net/sk98lin/skgeinit.c
--- linux/drivers/net/sk98lin/skgeinit.c	Wed Jul  4 20:50:39 2001
+++ linuxn/drivers/net/sk98lin/skgeinit.c	Tue May 20 12:17:40 2003
@@ -2,15 +2,16 @@
  *
  * Name:	skgeinit.c
  * Project:	GEnesis, PCI Gigabit Ethernet Adapter
- * Version:	$Revision: 1.63 $
- * Date:	$Date: 2001/04/05 11:02:09 $
+ * Version:	$Revision: 1.90 $
+ * Date:	$Date: 2003/04/28 09:12:20 $
  * Purpose:	Contains functions to initialize the GE HW
  *
  ******************************************************************************/
 
 /******************************************************************************
  *
- *	(C)Copyright 1998-2001 SysKonnect GmbH.
+ *	(C)Copyright 1998-2002 SysKonnect.
+ *	(C)Copyright 2002-2003 Marvell.
  *
  *	This program is free software; you can redistribute it and/or modify
  *	it under the terms of the GNU General Public License as published by
@@ -26,6 +27,149 @@
  * History:
  *
  *	$Log: skgeinit.c,v $
+ *	Revision 1.90  2003/04/28 09:12:20  rschmidt
+ *	Added init for GIValIrqMask (common IRQ mask).
+ *	Disabled HW Error IRQ on Yukon if sensor IRQ is set in SkGeInit1()
+ *	by changing the common mask stored in GIValIrqMask.
+ *	Editorial changes.
+ *	
+ *	Revision 1.89  2003/04/10 14:33:10  rschmidt
+ *	Fixed alignement error of patchable configuration parameter
+ *	in struct OemConfig caused by length of recognition string.
+ *	
+ *	Revision 1.88  2003/04/09 12:59:45  rschmidt
+ *	Added define around initialization of patchable OEM specific
+ *	configuration parameter.
+ *	
+ *	Revision 1.87  2003/04/08 16:46:13  rschmidt
+ *	Added configuration variable for OEMs and initialization for
+ *	GILedBlinkCtrl (LED Blink Control).
+ *	Improved detection for YUKON-Lite Rev. A1.
+ *	Editorial changes.
+ *	
+ *	Revision 1.86  2003/03/31 06:53:13  mkarl
+ *	Corrected Copyright.
+ *	Editorial changes.
+ *	
+ *	Revision 1.85  2003/02/05 15:30:33  rschmidt
+ *	Corrected setting of GIHstClkFact (Host Clock Factor) and
+ *	GIPollTimerVal (Descr. Poll Timer Init Value) for YUKON.
+ *	Editorial changes.
+ *	
+ *	Revision 1.84  2003/01/28 09:57:25  rschmidt
+ *	Added detection of YUKON-Lite Rev. A0 (stored in GIYukonLite).
+ *	Disabled Rx GMAC FIFO Flush for YUKON-Lite Rev. A0.
+ *	Added support for CLK_RUN (YUKON-Lite).
+ *	Added additional check of PME from D3cold for setting GIVauxAvail.
+ *	Editorial changes.
+ *	
+ *	Revision 1.83  2002/12/17 16:15:41  rschmidt
+ *	Added default setting of PhyType (Copper) for YUKON.
+ *	Added define around check for HW self test results.
+ *	Editorial changes.
+ *	
+ *	Revision 1.82  2002/12/05 13:40:21  rschmidt
+ *	Added setting of Rx GMAC FIFO Flush Mask register.
+ *	Corrected PhyType with new define SK_PHY_MARV_FIBER when
+ *	YUKON Fiber board was found.
+ *	Editorial changes.
+ *	
+ *	Revision 1.81  2002/11/15 12:48:35  rschmidt
+ *	Replaced message SKERR_HWI_E018 with SKERR_HWI_E024 for Rx queue error
+ *	in SkGeStopPort().
+ *	Added init for pAC->GIni.GIGenesis with SK_FALSE in YUKON-branch.
+ *	Editorial changes.
+ *	
+ *	Revision 1.80  2002/11/12 17:28:30  rschmidt
+ *	Initialized GIPciSlot64 and GIPciClock66 in SkGeInit1().
+ *	Reduced PCI FIFO watermarks for 32bit/33MHz bus in SkGeInitBmu().
+ *	Editorial changes.
+ *	
+ *	Revision 1.79  2002/10/21 09:31:02  mkarl
+ *	Changed SkGeInitAssignRamToQueues(), removed call to
+ *	SkGeInitAssignRamToQueues in SkGeInit1 and fixed compiler warning in
+ *	SkGeInit1.
+ *	
+ *	Revision 1.78  2002/10/16 15:55:07  mkarl
+ *	Fixed a bug in SkGeInitAssignRamToQueues.
+ *	
+ *	Revision 1.77  2002/10/14 15:07:22  rschmidt
+ *	Corrected timeout handling for Rx queue in SkGeStopPort() (#10748)
+ *	Editorial changes.
+ *	
+ *	Revision 1.76  2002/10/11 09:24:38  mkarl
+ *	Added check for HW self test results.
+ *	
+ *	Revision 1.75  2002/10/09 16:56:44  mkarl
+ *	Now call SkGeInitAssignRamToQueues() in Init Level 1 in order to assign
+ *	the adapter memory to the queues. This default assignment is not suitable
+ *	for dual net mode.
+ *	
+ *	Revision 1.74  2002/09/12 08:45:06  rwahl
+ *	Set defaults for PMSCap, PLinkSpeed & PLinkSpeedCap dependent on PHY.
+ *	
+ *	Revision 1.73  2002/08/16 15:19:45  rschmidt
+ *	Corrected check for Tx queues in SkGeCheckQSize().
+ *	Added init for new entry GIGenesis and GICopperType
+ *	Replaced all if(GIChipId == CHIP_ID_GENESIS) with new entry GIGenesis.
+ *	Replaced wrong 1st para pAC with IoC in SK_IN/OUT macros.
+ *	
+ *	Revision 1.72  2002/08/12 13:38:55  rschmidt
+ *	Added check if VAUX is available (stored in GIVauxAvail)
+ *	Initialized PLinkSpeedCap in Port struct with SK_LSPEED_CAP_1000MBPS
+ *	Editorial changes.
+ *	
+ *	Revision 1.71  2002/08/08 16:32:58  rschmidt
+ *	Added check for Tx queues in SkGeCheckQSize().
+ *	Added start of Time Stamp Timer (YUKON) in SkGeInit2().
+ *	Editorial changes.
+ *	
+ *	Revision 1.70  2002/07/23 16:04:26  rschmidt
+ *	Added init for GIWolOffs (HW-Bug in YUKON 1st rev.)
+ *	Minor changes
+ *	
+ *	Revision 1.69  2002/07/17 17:07:08  rwahl
+ *	- SkGeInit1(): fixed PHY type debug output; corrected init of GIFunc
+ *	  table & GIMacType.
+ *	- Editorial changes.
+ *	
+ *	Revision 1.68  2002/07/15 18:38:31  rwahl
+ *	Added initialization for MAC type dependent function table.
+ *	
+ *	Revision 1.67  2002/07/15 15:45:39  rschmidt
+ *	Added Tx Store & Forward for YUKON (GMAC Tx FIFO is only 1 kB)
+ *	Replaced SK_PHY_MARV by SK_PHY_MARV_COPPER
+ *	Editorial changes
+ *	
+ *	Revision 1.66  2002/06/10 09:35:08  rschmidt
+ *	Replaced C++ comments (//)
+ *	Editorial changes
+ *	
+ *	Revision 1.65  2002/06/05 08:33:37  rschmidt
+ *	Changed GIRamSize and Reset sequence for YUKON.
+ *	SkMacInit() replaced by SkXmInitMac() resp. SkGmInitMac()
+ *	
+ *	Revision 1.64  2002/04/25 13:03:20  rschmidt
+ *	Changes for handling YUKON.
+ *	Removed reference to xmac_ii.h (not necessary).
+ *	Moved all defines into header file.
+ *	Replaced all SkXm...() functions with SkMac...() to handle also
+ *	YUKON's GMAC.
+ *	Added handling for GMAC FIFO in SkGeInitMacFifo(), SkGeStopPort().
+ *	Removed 'goto'-directive from SkGeCfgSync(), SkGeCheckQSize().
+ *	Replaced all XMAC-access macros by functions: SkMacRxTxDisable(),
+ *	SkMacFlushTxFifo().
+ *	Optimized timeout handling in SkGeStopPort().
+ *	Initialized PLinkSpeed in Port struct with SK_LSPEED_AUTO.
+ *	Release of GMAC Link Control reset in SkGeInit1().
+ *	Initialized GIChipId and GIChipRev in GE Init structure.
+ *	Added GIRamSize and PhyType values for YUKON.
+ *	Removed use of PRxCmd to setup XMAC.
+ *	Moved setting of XM_RX_DIS_CEXT to SkXmInitMac().
+ *	Use of SkGeXmitLED() only for GENESIS.
+ *	Changes for V-CPU support.
+ *	Editorial changes.
+ *	
  *	Revision 1.63  2001/04/05 11:02:09  rassmann
  *	Stop Port check of the STOP bit did not take 2/18 sec as wanted.
  *	
@@ -139,7 +283,7 @@
  *	chg: Default is autosensing with AUTOFULL mode
  *
  *	Revision 1.31  1998/11/25 15:36:16  gklug
- *	fix: do NOT stop LED Timer when port should be stoped
+ *	fix: do NOT stop LED Timer when port should be stopped
  *
  *	Revision 1.30  1998/11/24 13:15:28  gklug
  *	add: Init PCkeckPar struct member
@@ -150,8 +294,8 @@
  *	transmit timeouts.
  *	Add TestStopBit() function to handle stop RX/TX
  *	problem with active descriptor poll timers.
- *	Bug Fix: Descriptor Poll Timer not started, beacuse
- *	GIPollTimerVal was initilaized with 0.
+ *	Bug Fix: Descriptor Poll Timer not started, because
+ *	GIPollTimerVal was initialized with 0.
  *
  *	Revision 1.28  1998/11/13 14:24:26  malthoff
  *	Bug Fix: SkGeStopPort() may hang if a Packet Arbiter Timout
@@ -181,7 +325,7 @@
  *
  *	Revision 1.21  1998/10/20 12:11:56  malthoff
  *	Don't dendy the Queue config if the size of the unused
- *	rx qeueu is zero.
+ *	Rx qeueu is zero.
  *
  *	Revision 1.20  1998/10/19 07:27:58  malthoff
  *	SkGeInitRamIface() is public to be called by diagnostics.
@@ -268,39 +412,23 @@
  *
  *	Revision 1.1  1998/07/23 09:48:57  malthoff
  *	Creation. First dummy 'C' file.
- *	SkGeInit(Level 0) is card_start for ML.
- *	SkGeDeInit() is card_stop for ML.
+ *	SkGeInit(Level 0) is card_start for GE.
+ *	SkGeDeInit() is card_stop for GE.
  *
  *
  ******************************************************************************/
 
 #include "h/skdrv1st.h"
-#include "h/xmac_ii.h"
 #include "h/skdrv2nd.h"
 
-/* defines ********************************************************************/
-
-/* defines for SkGeXmitLed() */
-#define XMIT_LED_INI	0
-#define XMIT_LED_CNT	(RX_LED_VAL - RX_LED_INI)
-#define XMIT_LED_CTRL	(RX_LED_CTRL- RX_LED_INI)
-#define XMIT_LED_TST	(RX_LED_TST - RX_LED_INI)
-
-/* Queue Size units */
-#define QZ_UNITS	0x7
-
-/* Types of RAM Buffer Queues */
-#define SK_RX_SRAM_Q	1	/* small receive queue */
-#define SK_RX_BRAM_Q	2	/* big receive queue */
-#define SK_TX_RAM_Q	3	/* small or big transmit queue */
-
-/* typedefs *******************************************************************/
 /* global variables ***********************************************************/
 
 /* local variables ************************************************************/
 
+#ifndef _lint
 static const char SysKonnectFileId[] =
-	"@(#)$Id: skgeinit.c,v 1.63 2001/04/05 11:02:09 rassmann Exp $ (C) SK ";
+	"@(#) $Id: skgeinit.c,v 1.90 2003/04/28 09:12:20 rschmidt Exp $ (C) Marvell.";
+#endif /* !_lint */
 
 struct s_QOffTab {
 	int	RxQOff;		/* Receive Queue Address Offset */
@@ -311,14 +439,27 @@
 	{Q_R1, Q_XS1, Q_XA1}, {Q_R2, Q_XS2, Q_XA2}
 };
 
+struct s_Config {
+	char	ScanString[8];
+	SK_U32	Value;
+};
+
+static struct s_Config OemConfig = {
+	{'O','E','M','_','C','o','n','f'},
+#ifdef SK_OEM_CONFIG
+	OEM_CONFIG_VALUE,
+#else
+	0,
+#endif
+};
 
 /******************************************************************************
  *
- *	SkGePollRxD() - Enable/Disable Descriptor Polling of RxD Ring
+ *	SkGePollRxD() - Enable / Disable Descriptor Polling of RxD Ring
  *
  * Description:
- *	Enable or disable the descriptor polling the receive descriptor
- *	ring (RxD) of port 'port'.
+ *	Enable or disable the descriptor polling of the receive descriptor
+ *	ring (RxD) for port 'Port'.
  *	The new configuration is *not* saved over any SkGeStopPort() and
  *	SkGeInitPort() calls.
  *
@@ -335,22 +476,18 @@
 
 	pPrt = &pAC->GIni.GP[Port];
 
-	if (PollRxD) {
-		SK_OUT32(IoC, Q_ADDR(pPrt->PRxQOff, Q_CSR), CSR_ENA_POL);
-	}
-	else {
-		SK_OUT32(IoC, Q_ADDR(pPrt->PRxQOff, Q_CSR), CSR_DIS_POL);
-	}
+	SK_OUT32(IoC, Q_ADDR(pPrt->PRxQOff, Q_CSR), (PollRxD) ?
+		CSR_ENA_POL : CSR_DIS_POL);
 }	/* SkGePollRxD */
 
 
 /******************************************************************************
  *
- *	SkGePollTxD() - Enable/Disable Descriptor Polling of TxD Rings
+ *	SkGePollTxD() - Enable / Disable Descriptor Polling of TxD Rings
  *
  * Description:
- *	Enable or disable the descriptor polling the transmit descriptor
- *	ring(s) (RxD) of port 'port'.
+ *	Enable or disable the descriptor polling of the transmit descriptor
+ *	ring(s) (TxD) for port 'Port'.
  *	The new configuration is *not* saved over any SkGeStopPort() and
  *	SkGeInitPort() calls.
  *
@@ -368,16 +505,12 @@
 
 	pPrt = &pAC->GIni.GP[Port];
 
-	if (PollTxD) {
-		DWord = CSR_ENA_POL;
-	}
-	else {
-		DWord = CSR_DIS_POL;
-	}
+	DWord = (PollTxD) ? CSR_ENA_POL : CSR_DIS_POL;
 
 	if (pPrt->PXSQSize != 0) {
 		SK_OUT32(IoC, Q_ADDR(pPrt->PXsQOff, Q_CSR), DWord);
 	}
+	
 	if (pPrt->PXAQSize != 0) {
 		SK_OUT32(IoC, Q_ADDR(pPrt->PXaQOff, Q_CSR), DWord);
 	}
@@ -397,7 +530,7 @@
  * Returns:
  *	nothing
  */
-void	SkGeYellowLED(
+void SkGeYellowLED(
 SK_AC	*pAC,		/* adapter context */
 SK_IOC	IoC,		/* IO context */
 int		State)		/* yellow LED state, 0 = OFF, 0 != ON */
@@ -430,7 +563,7 @@
  * Returns:
  *	nothing
  */
-void	SkGeXmitLED(
+void SkGeXmitLED(
 SK_AC	*pAC,		/* adapter context */
 SK_IOC	IoC,		/* IO context */
 int		Led,		/* offset to the LED Init Value register */
@@ -475,9 +608,8 @@
  *	DoCalcAddr() - Calculates the start and the end address of a queue.
  *
  * Description:
- *	This function calculates the start- end the end address
- *	of a queue. Afterwards the 'StartVal' is incremented to the
- *	next start position.
+ *	This function calculates the start and the end address of a queue.
+ *  Afterwards the 'StartVal' is incremented to the next start position.
  *	If the port is already initialized the calculated values
  *	will be checked against the configured values and an
  *	error will be returned, if they are not equal.
@@ -498,7 +630,7 @@
 {
 	SK_U32	EndVal;
 	SK_U32	NextStart;
-	int	Rtv;
+	int		Rtv;
 
 	Rtv = 0;
 	if (QuSize == 0) {
@@ -521,9 +653,124 @@
 	}
 
 	*StartVal = NextStart;
-	return (Rtv);
+	return(Rtv);
 }	/* DoCalcAddr */
 
+/******************************************************************************
+ *
+ *	SkGeInitAssignRamToQueues() - allocate default queue sizes
+ *
+ * Description:
+ *	This function assigns the memory to the different queues and ports.
+ *	When DualNet is set to SK_TRUE all ports get the same amount of memory.
+ *  Otherwise the first port gets most of the memory and all the
+ *	other ports just the required minimum.
+ *	This function can only be called when pAC->GIni.GIRamSize and
+ *	pAC->GIni.GIMacsFound have been initialized, usually this happens
+ *	at init level 1
+ *
+ * Returns:
+ *	0 - ok
+ *	1 - invalid input values
+ *	2 - not enough memory
+ */
+
+int SkGeInitAssignRamToQueues(
+SK_AC	*pAC,			/* Adapter context */
+int		ActivePort,		/* Active Port in RLMT mode */
+SK_BOOL	DualNet)		/* adapter context */
+{
+	int	i;
+	int	UsedKilobytes;			/* memory already assigned */
+	int	ActivePortKilobytes;	/* memory available for active port */
+	SK_GEPORT *pGePort;
+
+	UsedKilobytes = 0;
+
+	if (ActivePort >= pAC->GIni.GIMacsFound) {
+		SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_INIT,
+			("SkGeInitAssignRamToQueues: ActivePort (%d) invalid\n",
+			ActivePort));
+		return(1);
+	}
+	if (((pAC->GIni.GIMacsFound * (SK_MIN_RXQ_SIZE + SK_MIN_TXQ_SIZE)) +
+		((RAM_QUOTA_SYNC == 0) ? 0 : SK_MIN_TXQ_SIZE)) > pAC->GIni.GIRamSize) {
+		SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_INIT,
+			("SkGeInitAssignRamToQueues: Not enough memory (%d)\n",
+			 pAC->GIni.GIRamSize));
+		return(2);
+	}
+
+	if (DualNet) {
+		/* every port gets the same amount of memory */
+		ActivePortKilobytes = pAC->GIni.GIRamSize / pAC->GIni.GIMacsFound;
+		for (i = 0; i < pAC->GIni.GIMacsFound; i++) {
+
+			pGePort = &pAC->GIni.GP[i];
+			
+			/* take away the minimum memory for active queues */
+			ActivePortKilobytes -= (SK_MIN_RXQ_SIZE + SK_MIN_TXQ_SIZE);
+
+			/* receive queue gets the minimum + 80% of the rest */
+			pGePort->PRxQSize = (int) (ROUND_QUEUE_SIZE_KB((
+				ActivePortKilobytes * (unsigned long) RAM_QUOTA_RX) / 100))
+				+ SK_MIN_RXQ_SIZE;
+
+			ActivePortKilobytes -= (pGePort->PRxQSize - SK_MIN_RXQ_SIZE);
+
+			/* synchronous transmit queue */
+			pGePort->PXSQSize = 0;
+
+			/* asynchronous transmit queue */
+			pGePort->PXAQSize = (int) ROUND_QUEUE_SIZE_KB(ActivePortKilobytes +
+				SK_MIN_TXQ_SIZE);
+		}
+	}
+	else {	
+		/* Rlmt Mode or single link adapter */
+
+		/* Set standby queue size defaults for all standby ports */
+		for (i = 0; i < pAC->GIni.GIMacsFound; i++) {
+
+			if (i != ActivePort) {
+				pGePort = &pAC->GIni.GP[i];
+
+				pGePort->PRxQSize = SK_MIN_RXQ_SIZE;
+				pGePort->PXAQSize = SK_MIN_TXQ_SIZE;
+				pGePort->PXSQSize = 0;
+
+				/* Count used RAM */
+				UsedKilobytes += pGePort->PRxQSize + pGePort->PXAQSize;
+			}
+		}
+		/* what's left? */
+		ActivePortKilobytes = pAC->GIni.GIRamSize - UsedKilobytes;
+
+		/* assign it to the active port */
+		/* first take away the minimum memory */
+		ActivePortKilobytes -= (SK_MIN_RXQ_SIZE + SK_MIN_TXQ_SIZE);
+		pGePort = &pAC->GIni.GP[ActivePort];
+
+		/* receive queue get's the minimum + 80% of the rest */
+		pGePort->PRxQSize = (int) (ROUND_QUEUE_SIZE_KB((ActivePortKilobytes *
+			(unsigned long) RAM_QUOTA_RX) / 100)) + SK_MIN_RXQ_SIZE;
+
+		ActivePortKilobytes -= (pGePort->PRxQSize - SK_MIN_RXQ_SIZE);
+
+		/* synchronous transmit queue */
+		pGePort->PXSQSize = 0;
+
+		/* asynchronous transmit queue */
+		pGePort->PXAQSize = (int) ROUND_QUEUE_SIZE_KB(ActivePortKilobytes) +
+			SK_MIN_TXQ_SIZE;
+	}
+#ifdef VCPU
+	VCPUprintf(0, "PRxQSize=%u, PXSQSize=%u, PXAQSize=%u\n",
+		pGePort->PRxQSize, pGePort->PXSQSize, pGePort->PXAQSize);
+#endif /* VCPU */
+
+	return(0);
+}	/* SkGeInitAssignRamToQueues */
 
 /******************************************************************************
  *
@@ -531,18 +778,20 @@
  *
  * Description:
  *	This function verifies the Queue Size Configuration specified
- *	in the variabels PRxQSize, PXSQSize, and PXAQSize of all
+ *	in the variables PRxQSize, PXSQSize, and PXAQSize of all
  *	used ports.
  *	This requirements must be fullfilled to have a valid configuration:
  *		- The size of all queues must not exceed GIRamSize.
  *		- The queue sizes must be specified in units of 8 kB.
- *		- The size of rx queues of available ports must not be
- *		  smaller than 16kB.
+ *		- The size of Rx queues of available ports must not be
+ *		  smaller than 16 kB.
+ *		- The size of at least one Tx queue (synch. or asynch.)
+ *        of available ports must not be smaller than 16 kB
+ *        when Jumbo Frames are used.
  *		- The RAM start and end addresses must not be changed
  *		  for ports which are already initialized.
- *	Furthermore SkGeCheckQSize() defines the Start and End
- *	Addresses of all ports and stores them into the HWAC port
- *	structure.
+ *	Furthermore SkGeCheckQSize() defines the Start and End Addresses
+ *  of all ports and stores them into the HWAC port	structure.
  *
  * Returns:
  *	0:	Queue Size Configuration valid
@@ -553,7 +802,7 @@
 int		 Port)		/* port index */
 {
 	SK_GEPORT *pPrt;
-	int	UsedMem;
+	int	UsedMem;	/* total memory used (max. found ports) */
 	int	i;
 	int	Rtv;
 	int	Rtv2;
@@ -564,27 +813,37 @@
 	for (i = 0; i < pAC->GIni.GIMacsFound; i++) {
 		pPrt = &pAC->GIni.GP[i];
 
-		if (( pPrt->PRxQSize & QZ_UNITS) ||
-			(pPrt->PXSQSize & QZ_UNITS) ||
-			(pPrt->PXAQSize & QZ_UNITS)) {
+		if ((pPrt->PRxQSize & QZ_UNITS) != 0 ||
+			(pPrt->PXSQSize & QZ_UNITS) != 0 ||
+			(pPrt->PXAQSize & QZ_UNITS) != 0) {
 
 			SK_ERR_LOG(pAC, SK_ERRCL_SW, SKERR_HWI_E012, SKERR_HWI_E012MSG);
-			Rtv = 1;
-			goto CheckQSizeEnd;
+			return(1);
 		}
 
-		UsedMem += pPrt->PRxQSize + pPrt->PXSQSize + pPrt->PXAQSize;
-
 		if (i == Port && pPrt->PRxQSize < SK_MIN_RXQ_SIZE) {
 			SK_ERR_LOG(pAC, SK_ERRCL_SW, SKERR_HWI_E011, SKERR_HWI_E011MSG);
-			Rtv = 1;
-			goto CheckQSizeEnd;
+			return(1);
+		}
+		
+		/*
+		 * the size of at least one Tx queue (synch. or asynch.) has to be > 0.
+		 * if Jumbo Frames are used, this size has to be >= 16 kB.
+		 */
+		if ((i == Port && pPrt->PXSQSize == 0 && pPrt->PXAQSize == 0) ||
+			(pAC->GIni.GIPortUsage == SK_JUMBO_LINK &&
+            ((pPrt->PXSQSize > 0 && pPrt->PXSQSize < SK_MIN_TXQ_SIZE) ||
+			 (pPrt->PXAQSize > 0 && pPrt->PXAQSize < SK_MIN_TXQ_SIZE)))) {
+				SK_ERR_LOG(pAC, SK_ERRCL_SW, SKERR_HWI_E023, SKERR_HWI_E023MSG);
+				return(1);
 		}
+		
+		UsedMem += pPrt->PRxQSize + pPrt->PXSQSize + pPrt->PXAQSize;
 	}
+	
 	if (UsedMem > pAC->GIni.GIRamSize) {
 		SK_ERR_LOG(pAC, SK_ERRCL_SW, SKERR_HWI_E012, SKERR_HWI_E012MSG);
-		Rtv = 1;
-		goto CheckQSizeEnd;
+		return(1);
 	}
 
 	/* Now start address calculation */
@@ -597,24 +856,23 @@
 			&pPrt->PRxQRamStart, &pPrt->PRxQRamEnd);
 		Rtv |= Rtv2;
 
-		/* Calculate/Check values for the synchronous tx queue */
+		/* Calculate/Check values for the synchronous Tx queue */
 		Rtv2 = DoCalcAddr(pAC, pPrt, pPrt->PXSQSize, &StartAddr,
 			&pPrt->PXsQRamStart, &pPrt->PXsQRamEnd);
 		Rtv |= Rtv2;
 
-		/* Calculate/Check values for the asynchronous tx queue */
+		/* Calculate/Check values for the asynchronous Tx queue */
 		Rtv2 = DoCalcAddr(pAC, pPrt, pPrt->PXAQSize, &StartAddr,
 			&pPrt->PXaQRamStart, &pPrt->PXaQRamEnd);
 		Rtv |= Rtv2;
 
 		if (Rtv) {
 			SK_ERR_LOG(pAC, SK_ERRCL_SW, SKERR_HWI_E013, SKERR_HWI_E013MSG);
-			break;
+			return(1);
 		}
 	}
 
-CheckQSizeEnd:
-	return (Rtv);
+	return(0);
 }	/* SkGeCheckQSize */
 
 
@@ -625,10 +883,10 @@
  * Description:
  *	This function initializes the MAC Arbiter.
  *	It must not be called if there is still an
- *	initilaized or active port.
+ *	initialized or active port.
  *
  * Returns:
- *	nothing:
+ *	nothing
  */
 static void SkGeInitMacArb(
 SK_AC	*pAC,		/* adapter context */
@@ -652,7 +910,7 @@
 	/* Fast Output Enable Mode was intended to use with Rev. B2, but now? */
 
 	/*
-	 * There is not start or enable buttom to push, therefore
+	 * There is no start or enable button to push, therefore
 	 * the MAC arbiter is configured and enabled now.
 	 */
 }	/* SkGeInitMacArb */
@@ -665,10 +923,10 @@
  * Description:
  *	This function initializes the Packet Arbiter.
  *	It must not be called if there is still an
- *	initilaized or active port.
+ *	initialized or active port.
  *
  * Returns:
- *	nothing:
+ *	nothing
  */
 static void SkGeInitPktArb(
 SK_AC	*pAC,		/* adapter context */
@@ -693,7 +951,7 @@
 			SK_OUT16(IoC, B3_PA_CTRL, PA_ENA_TO_TX1);
 		}
 		else {
-			SK_OUT16(IoC, B3_PA_CTRL,(PA_ENA_TO_TX1 | PA_ENA_TO_TX2));
+			SK_OUT16(IoC, B3_PA_CTRL, PA_ENA_TO_TX1 | PA_ENA_TO_TX2);
 		}
 	}
 }	/* SkGeInitPktArb */
@@ -714,6 +972,10 @@
 SK_IOC	IoC,		/* IO context */
 int		Port)		/* Port Index (MAC_1 + n) */
 {
+	SK_U16	Word;
+#ifdef VCPU
+	SK_U32	DWord;
+#endif /* VCPU */
 	/*
 	 * For each FIFO:
 	 *	- release local reset
@@ -721,19 +983,53 @@
 	 *	- setup defaults for the control register
 	 *	- enable the FIFO
 	 */
-	/* Configure RX MAC FIFO */
-	SK_OUT8(IoC, MR_ADDR(Port, RX_MFF_CTRL2), MFF_RST_CLR);
-	SK_OUT16(IoC, MR_ADDR(Port, RX_MFF_CTRL1), MFF_RX_CTRL_DEF);
-	SK_OUT8(IoC, MR_ADDR(Port, RX_MFF_CTRL2), MFF_ENA_OP_MD);
-
-	/* Configure TX MAC FIFO */
-	SK_OUT8(IoC, MR_ADDR(Port, TX_MFF_CTRL2), MFF_RST_CLR);
-	SK_OUT16(IoC, MR_ADDR(Port, TX_MFF_CTRL1), MFF_TX_CTRL_DEF);
-	SK_OUT8(IoC, MR_ADDR(Port, TX_MFF_CTRL2), MFF_ENA_OP_MD);
-
-	/* Enable frame flushing if jumbo frames used */
-	if (pAC->GIni.GIPortUsage == SK_JUMBO_LINK) {
-		SK_OUT16(IoC, MR_ADDR(Port, RX_MFF_CTRL1), MFF_ENA_FLUSH);
+	
+	Word = GMF_RX_CTRL_DEF;
+	
+	if (pAC->GIni.GIGenesis) {
+		/* Configure Rx MAC FIFO */
+		SK_OUT8(IoC, MR_ADDR(Port, RX_MFF_CTRL2), MFF_RST_CLR);
+		SK_OUT16(IoC, MR_ADDR(Port, RX_MFF_CTRL1), MFF_RX_CTRL_DEF);
+		SK_OUT8(IoC, MR_ADDR(Port, RX_MFF_CTRL2), MFF_ENA_OP_MD);
+	
+		/* Configure Tx MAC FIFO */
+		SK_OUT8(IoC, MR_ADDR(Port, TX_MFF_CTRL2), MFF_RST_CLR);
+		SK_OUT16(IoC, MR_ADDR(Port, TX_MFF_CTRL1), MFF_TX_CTRL_DEF);
+		SK_OUT8(IoC, MR_ADDR(Port, TX_MFF_CTRL2), MFF_ENA_OP_MD);
+	
+		/* Enable frame flushing if jumbo frames used */
+		if (pAC->GIni.GIPortUsage == SK_JUMBO_LINK) {
+			SK_OUT16(IoC, MR_ADDR(Port, RX_MFF_CTRL1), MFF_ENA_FLUSH);
+		}
+	}
+	else {
+		/* set Rx GMAC FIFO Flush Mask */
+		SK_OUT16(IoC, MR_ADDR(Port, RX_GMF_FL_MSK), (SK_U16)RX_FF_FL_DEF_MSK);
+		
+		/* disable Rx GMAC FIFO Flush for Rev. A0 only */
+		if (pAC->GIni.GIYukonLite && pAC->GIni.GIChipId == CHIP_ID_YUKON) {
+
+			Word &= ~GMF_RX_F_FL_ON;
+		}
+		
+		/* Configure Rx MAC FIFO */
+		SK_OUT8(IoC, MR_ADDR(Port, RX_GMF_CTRL_T), (SK_U8)GMF_RST_CLR);
+		SK_OUT16(IoC, MR_ADDR(Port, RX_GMF_CTRL_T), Word);
+		
+		/* set Rx GMAC FIFO Flush Threshold (default: 0x0a -> 56 bytes) */
+		SK_OUT16(IoC, MR_ADDR(Port, RX_GMF_FL_THR), RX_GMF_FL_THR_DEF);
+		
+		/* Configure Tx MAC FIFO */
+		SK_OUT8(IoC, MR_ADDR(Port, TX_GMF_CTRL_T), (SK_U8)GMF_RST_CLR);
+		SK_OUT16(IoC, MR_ADDR(Port, TX_GMF_CTRL_T), (SK_U16)GMF_TX_CTRL_DEF);
+		
+#ifdef VCPU
+		SK_IN32(IoC, MR_ADDR(Port, RX_GMF_AF_THR), &DWord);
+		SK_IN32(IoC, MR_ADDR(Port, TX_GMF_AE_THR), &DWord);
+#endif /* VCPU */
+		
+		/* set Tx GMAC FIFO Almost Empty Threshold */
+/*		SK_OUT32(IoC, MR_ADDR(Port, TX_GMF_AE_THR), 0); */
 	}
 }	/* SkGeInitMacFifo */
 
@@ -750,11 +1046,11 @@
  *
  * Note:
  *	o To ensure receiving the Link Sync Event the LinkSyncCounter
- *	  should be initialized BEFORE clearing the XMACs reset!
+ *	  should be initialized BEFORE clearing the XMAC's reset!
  *	o Enable IS_LNK_SYNC_M1 and IS_LNK_SYNC_M2 after calling this
  *	  function.
  *
- * Retruns:
+ * Returns:
  *	nothing
  */
 void SkGeLoadLnkSyncCnt(
@@ -784,13 +1080,13 @@
 	SK_IN32(IoC, B0_IMSK, &OrgIMsk);
 	if (Port == MAC_1) {
 		NewIMsk = OrgIMsk & ~IS_LNK_SYNC_M1;
-		if (ISrc & IS_LNK_SYNC_M1) {
+		if ((ISrc & IS_LNK_SYNC_M1) != 0) {
 			IrqPend = SK_TRUE;
 		}
 	}
 	else {
 		NewIMsk = OrgIMsk & ~IS_LNK_SYNC_M2;
-		if (ISrc & IS_LNK_SYNC_M2) {
+		if ((ISrc & IS_LNK_SYNC_M2) != 0) {
 			IrqPend = SK_TRUE;
 		}
 	}
@@ -829,14 +1125,14 @@
  *	TXA_ENA_FSYNC. This means if the size of
  *	the synchronous queue is unequal zero but no specific
  *	synchronous bandwidth is configured, the synchronous queue
- *	will always have the 'unlimitted' transmit priority!
+ *	will always have the 'unlimited' transmit priority!
  *
  *	This mode will be restored if the synchronous bandwidth is
  *	deallocated ('IntTime' = 0 and 'LimCount' = 0).
  *
  * Returns:
  *	0:	success
- *	1:	paramter configuration error
+ *	1:	parameter configuration error
  *	2:	try to configure quality of service although no
  *		synchronous queue is configured
  */
@@ -855,59 +1151,59 @@
 	/* check the parameters */
 	if (LimCount > IntTime ||
 		(LimCount == 0 && IntTime != 0) ||
-		(LimCount !=0 && IntTime == 0)) {
+		(LimCount != 0 && IntTime == 0)) {
 
 		SK_ERR_LOG(pAC, SK_ERRCL_SW, SKERR_HWI_E010, SKERR_HWI_E010MSG);
-		Rtv = 1;
-		goto CfgSyncEnd;
+		return(1);
 	}
-	if (pAC->GIni.GP[Port].PXSQSize != 0) {
-		/* calculate register values */
-		IntTime = (IntTime / 2) * pAC->GIni.GIHstClkFact / 100;
-		LimCount = LimCount / 8;
-		if (IntTime > TXA_MAX_VAL || LimCount > TXA_MAX_VAL) {
-			SK_ERR_LOG(pAC, SK_ERRCL_SW, SKERR_HWI_E010, SKERR_HWI_E010MSG);
-			Rtv = 1;
-			goto CfgSyncEnd;
-		}
-
-		/*
-		 * - Enable 'Force Sync' to ensure the synchronous queue
-		 *   has the priority while configuring the new values.
-		 * - Also 'disable alloc' to ensure the settings complies
-		 *   to the SyncMode parameter.
-		 * - Disable 'Rate Control' to configure the new values.
-		 * - write IntTime and Limcount
-		 * - start 'Rate Control' and disable 'Force Sync'
-		 *   if Interval Timer or Limit Counter not zero.
-		 */
-		SK_OUT8(IoC, MR_ADDR(Port, TXA_CTRL),
-			TXA_ENA_FSYNC | TXA_DIS_ALLOC | TXA_STOP_RC);
-		SK_OUT32(IoC, MR_ADDR(Port, TXA_ITI_INI), IntTime);
-		SK_OUT32(IoC, MR_ADDR(Port, TXA_LIM_INI), LimCount);
-		SK_OUT8(IoC, MR_ADDR(Port, TXA_CTRL),
-			(SyncMode & (TXA_ENA_ALLOC|TXA_DIS_ALLOC)));
-		if (IntTime != 0 || LimCount != 0) {
-			SK_OUT8(IoC, MR_ADDR(Port, TXA_CTRL),
-				TXA_DIS_FSYNC|TXA_START_RC);
-		}
-	}
-	else {
+	
+	if (pAC->GIni.GP[Port].PXSQSize == 0) {
 		SK_ERR_LOG(pAC, SK_ERRCL_SW, SKERR_HWI_E009, SKERR_HWI_E009MSG);
-		Rtv = 2;
+		return(2);
+	}
+	
+	/* calculate register values */
+	IntTime = (IntTime / 2) * pAC->GIni.GIHstClkFact / 100;
+	LimCount = LimCount / 8;
+	
+	if (IntTime > TXA_MAX_VAL || LimCount > TXA_MAX_VAL) {
+		SK_ERR_LOG(pAC, SK_ERRCL_SW, SKERR_HWI_E010, SKERR_HWI_E010MSG);
+		return(1);
 	}
 
-CfgSyncEnd:
-	return (Rtv);
+	/*
+	 * - Enable 'Force Sync' to ensure the synchronous queue
+	 *   has the priority while configuring the new values.
+	 * - Also 'disable alloc' to ensure the settings complies
+	 *   to the SyncMode parameter.
+	 * - Disable 'Rate Control' to configure the new values.
+	 * - write IntTime and LimCount
+	 * - start 'Rate Control' and disable 'Force Sync'
+	 *   if Interval Timer or Limit Counter not zero.
+	 */
+	SK_OUT8(IoC, MR_ADDR(Port, TXA_CTRL),
+		TXA_ENA_FSYNC | TXA_DIS_ALLOC | TXA_STOP_RC);
+	
+	SK_OUT32(IoC, MR_ADDR(Port, TXA_ITI_INI), IntTime);
+	SK_OUT32(IoC, MR_ADDR(Port, TXA_LIM_INI), LimCount);
+	
+	SK_OUT8(IoC, MR_ADDR(Port, TXA_CTRL),
+		(SK_U8)(SyncMode & (TXA_ENA_ALLOC | TXA_DIS_ALLOC)));
+	
+	if (IntTime != 0 || LimCount != 0) {
+		SK_OUT8(IoC, MR_ADDR(Port, TXA_CTRL), TXA_DIS_FSYNC | TXA_START_RC);
+	}
+
+	return(0);
 }	/* SkGeCfgSync */
 
 
 /******************************************************************************
  *
- *	DoInitRamQueue() - Initilaize the RAM Buffer Address of a single Queue
+ *	DoInitRamQueue() - Initialize the RAM Buffer Address of a single Queue
  *
  * Desccription:
- *	If the queue is used, enable and initilaize it.
+ *	If the queue is used, enable and initialize it.
  *	Make sure the queue is still reset, if it is not used.
  *
  * Returns:
@@ -952,22 +1248,21 @@
 			/* write threshold for Rx Queue */
 
 			SK_OUT32(IoC, RB_ADDR(QuIoOffs, RB_RX_UTPP), RxUpThresVal);
-			SK_OUT32(IoC, RB_ADDR(QuIoOffs,RB_RX_LTPP), RxLoThresVal);
+			SK_OUT32(IoC, RB_ADDR(QuIoOffs, RB_RX_LTPP), RxLoThresVal);
 
 			/* the high priority threshold not used */
 			break;
 		case SK_TX_RAM_Q:
 			/*
-			 * Do NOT use Store and forward under normal
-			 * operation due to performance optimization.
-			 * But if Jumbo frames are configured we NEED
-			 * the store and forward of the RAM buffer.
+			 * Do NOT use Store & Forward under normal operation due to
+			 * performance optimization (GENESIS only).
+			 * But if Jumbo Frames are configured (XMAC Tx FIFO is only 4 kB)
+			 * or YUKON is used ((GMAC Tx FIFO is only 1 kB)
+			 * we NEED Store & Forward of the RAM buffer.
 			 */
-			if (pAC->GIni.GIPortUsage == SK_JUMBO_LINK) {
-				/*
-				 * enable Store & Forward Mode for the
-				 * Tx Side
-				 */
+			if (pAC->GIni.GIPortUsage == SK_JUMBO_LINK ||
+				!pAC->GIni.GIGenesis) {
+				/* enable Store & Forward Mode for the Tx Side */
 				SK_OUT8(IoC, RB_ADDR(QuIoOffs, RB_CTRL), RB_ENA_STFWD);
 			}
 			break;
@@ -980,7 +1275,7 @@
 		/* ensure the queue is still disabled */
 		SK_OUT8(IoC, RB_ADDR(QuIoOffs, RB_CTRL), RB_RST_SET);
 	}
-}	/* DoInitRamQueue*/
+}	/* DoInitRamQueue */
 
 
 /******************************************************************************
@@ -1012,10 +1307,13 @@
 
 	DoInitRamQueue(pAC, IoC, pPrt->PRxQOff, pPrt->PRxQRamStart,
 		pPrt->PRxQRamEnd, RxQType);
+	
 	DoInitRamQueue(pAC, IoC, pPrt->PXsQOff, pPrt->PXsQRamStart,
 		pPrt->PXsQRamEnd, SK_TX_RAM_Q);
+	
 	DoInitRamQueue(pAC, IoC, pPrt->PXaQOff, pPrt->PXaQRamStart,
 		pPrt->PXaQRamEnd, SK_TX_RAM_Q);
+
 }	/* SkGeInitRamBufs */
 
 
@@ -1024,7 +1322,7 @@
  *	SkGeInitRamIface() - Initialize the RAM Interface
  *
  * Description:
- *	This function initializes the Adapbers RAM Interface.
+ *	This function initializes the Adapters RAM Interface.
  *
  * Note:
  *	This function is used in the diagnostics.
@@ -1052,6 +1350,7 @@
 	SK_OUT8(IoC, B3_RI_RTO_R2, SK_RI_TO_53);
 	SK_OUT8(IoC, B3_RI_RTO_XA2, SK_RI_TO_53);
 	SK_OUT8(IoC, B3_RI_RTO_XS2, SK_RI_TO_53);
+
 }	/* SkGeInitRamIface */
 
 
@@ -1070,25 +1369,37 @@
 SK_IOC	IoC,		/* IO context */
 int		Port)		/* Port Index (MAC_1 + n) */
 {
-	SK_GEPORT *pPrt;
+	SK_GEPORT	*pPrt;
+	SK_U32		RxWm;
+	SK_U32		TxWm;
 
 	pPrt = &pAC->GIni.GP[Port];
 
+	RxWm = SK_BMU_RX_WM;
+	TxWm = SK_BMU_TX_WM;
+	
+	if (!pAC->GIni.GIPciSlot64 && !pAC->GIni.GIPciClock66) {
+		/* for better performance */
+		RxWm /= 2;
+		TxWm /= 2;
+	}
+
 	/* Rx Queue: Release all local resets and set the watermark */
 	SK_OUT32(IoC, Q_ADDR(pPrt->PRxQOff, Q_CSR), CSR_CLR_RESET);
-	SK_OUT32(IoC, Q_ADDR(pPrt->PRxQOff, Q_F), SK_BMU_RX_WM);
+	SK_OUT32(IoC, Q_ADDR(pPrt->PRxQOff, Q_F), RxWm);
 
 	/*
-	 * Tx Queue: Release all local resets if the queue is used!
+	 * Tx Queue: Release all local resets if the queue is used !
 	 * 		set watermark
 	 */
 	if (pPrt->PXSQSize != 0) {
 		SK_OUT32(IoC, Q_ADDR(pPrt->PXsQOff, Q_CSR), CSR_CLR_RESET);
-		SK_OUT32(IoC, Q_ADDR(pPrt->PXsQOff, Q_F), SK_BMU_TX_WM);
+		SK_OUT32(IoC, Q_ADDR(pPrt->PXsQOff, Q_F), TxWm);
 	}
+	
 	if (pPrt->PXAQSize != 0) {
 		SK_OUT32(IoC, Q_ADDR(pPrt->PXaQOff, Q_CSR), CSR_CLR_RESET);
-		SK_OUT32(IoC, Q_ADDR(pPrt->PXaQOff, Q_F), SK_BMU_TX_WM);
+		SK_OUT32(IoC, Q_ADDR(pPrt->PXaQOff, Q_F), TxWm);
 	}
 	/*
 	 * Do NOT enable the descriptor poll timers here, because
@@ -1107,7 +1418,7 @@
  *	that RX/TX stop is done and SV idle is NOT set.
  *	In this case we have to issue another stop command.
  *
- * Retruns:
+ * Returns:
  *	The queues control status register
  */
 static SK_U32 TestStopBit(
@@ -1118,12 +1429,16 @@
 	SK_U32	QuCsr;	/* CSR contents */
 
 	SK_IN32(IoC, Q_ADDR(QuIoOffs, Q_CSR), &QuCsr);
-	if ((QuCsr & (CSR_STOP|CSR_SV_IDLE)) == 0) {
+	
+	if ((QuCsr & (CSR_STOP | CSR_SV_IDLE)) == 0) {
+		/* Stop Descriptor overridden by start command */
 		SK_OUT32(IoC, Q_ADDR(QuIoOffs, Q_CSR), CSR_STOP);
+
 		SK_IN32(IoC, Q_ADDR(QuIoOffs, Q_CSR), &QuCsr);
 	}
-	return (QuCsr);
-}	/* TestStopBit*/
+	
+	return(QuCsr);
+}	/* TestStopBit */
 
 
 /******************************************************************************
@@ -1131,31 +1446,31 @@
  *	SkGeStopPort() - Stop the Rx/Tx activity of the port 'Port'.
  *
  * Description:
- *	After calling this function the descriptor rings and rx and tx
+ *	After calling this function the descriptor rings and Rx and Tx
  *	queues of this port may be reconfigured.
  *
- *	It is possible to stop the receive and transmit path seperate or
+ *	It is possible to stop the receive and transmit path separate or
  *	both together.
  *
- *	Dir =	SK_STOP_TX 	Stops the transmit path only and resets
- *				the XMAC. The receive queue is still and
- *				the pending rx frames may still transfered
+ *	Dir =	SK_STOP_TX 	Stops the transmit path only and resets the MAC.
+ *				The receive queue is still active and
+ *				the pending Rx frames may be still transferred
  *				into the RxD.
  *		SK_STOP_RX	Stop the receive path. The tansmit path
- *				has to be stoped once before.
+ *				has to be stopped once before.
  *		SK_STOP_ALL	SK_STOP_TX + SK_STOP_RX
  *
- *	RstMode=SK_SOFT_RST	Resets the XMAC. The PHY is still alive.
- *		SK_HARD_RST	Resets the XMAC and the PHY.
+ *	RstMode = SK_SOFT_RST	Resets the MAC. The PHY is still alive.
+ *			SK_HARD_RST	Resets the MAC and the PHY.
  *
  * Example:
  *	1) A Link Down event was signaled for a port. Therefore the activity
- *	of this port should be stoped and a hardware reset should be issued
- *	to enable the workaround of XMAC errata #2. But the received frames
+ *	of this port should be stopped and a hardware reset should be issued
+ *	to enable the workaround of XMAC Errata #2. But the received frames
  *	should not be discarded.
  *		...
  *		SkGeStopPort(pAC, IoC, Port, SK_STOP_TX, SK_HARD_RST);
- *		(transfer all pending rx frames)
+ *		(transfer all pending Rx frames)
  *		SkGeStopPort(pAC, IoC, Port, SK_STOP_RX, SK_HARD_RST);
  *		...
  *
@@ -1170,29 +1485,29 @@
  *
  * Extended Description:
  *	If SK_STOP_TX is set,
- *		o disable the XMACs receive and transmiter to prevent
+ *		o disable the MAC's receive and transmitter to prevent
  *		  from sending incomplete frames
  *		o stop the port's transmit queues before terminating the
  *		  BMUs to prevent from performing incomplete PCI cycles
  *		  on the PCI bus
- *		- The network rx and tx activity and PCI tx transfer is
+ *		- The network Rx and Tx activity and PCI Tx transfer is
  *		  disabled now.
- *		o reset the XMAC depending on the RstMode
+ *		o reset the MAC depending on the RstMode
  *		o Stop Interval Timer and Limit Counter of Tx Arbiter,
  *		  also disable Force Sync bit and Enable Alloc bit.
- *		o perform a local reset of the port's tx path
- *			- reset the PCI FIFO of the async tx queue
- *			- reset the PCI FIFO of the sync tx queue
- *			- reset the RAM Buffer async tx queue
- *			- reset the RAM Butter sync tx queue
+ *		o perform a local reset of the port's Tx path
+ *			- reset the PCI FIFO of the async Tx queue
+ *			- reset the PCI FIFO of the sync Tx queue
+ *			- reset the RAM Buffer async Tx queue
+ *			- reset the RAM Buffer sync Tx queue
  *			- reset the MAC Tx FIFO
  *		o switch Link and Tx LED off, stop the LED counters
  *
  *	If SK_STOP_RX is set,
  *		o stop the port's receive queue
  *		- The path data transfer activity is fully stopped now.
- *		o perform a local reset of the port's rx path
- *			- reset the PCI FIFO of the rx queue
+ *		o perform a local reset of the port's Rx path
+ *			- reset the PCI FIFO of the Rx queue
  *			- reset the RAM Buffer receive queue
  *			- reset the MAC Rx FIFO
  *		o switch Rx LED off, stop the LED counter
@@ -1204,36 +1519,30 @@
  *	o This function may be called during the driver states RESET_PORT and
  *	  SWITCH_PORT.
  */
-void	SkGeStopPort(
+void SkGeStopPort(
 SK_AC	*pAC,	/* adapter context */
 SK_IOC	IoC,	/* I/O context */
 int		Port,	/* port to stop (MAC_1 + n) */
 int		Dir,	/* Direction to Stop (SK_STOP_RX, SK_STOP_TX, SK_STOP_ALL) */
 int		RstMode)/* Reset Mode (SK_SOFT_RST, SK_HARD_RST) */
 {
-#ifndef	SK_DIAG
+#ifndef SK_DIAG
 	SK_EVPARA Para;
-#endif	/* !SK_DIAG */
+#endif /* !SK_DIAG */
 	SK_GEPORT *pPrt;
 	SK_U32	DWord;
-	SK_U16	Word;
 	SK_U32	XsCsr;
 	SK_U32	XaCsr;
-	int		i;
-	SK_BOOL	AllPortsDis;
 	SK_U64	ToutStart;
+	int		i;
 	int		ToutCnt;
 
 	pPrt = &pAC->GIni.GP[Port];
 
-	if (Dir & SK_STOP_TX) {
-		/* disable the XMACs receiver and transmitter */
-		XM_IN16(IoC, Port, XM_MMU_CMD, &Word);
-		XM_OUT16(IoC, Port, XM_MMU_CMD, Word & ~(XM_MMU_ENA_RX | XM_MMU_ENA_TX));
-
-		/* dummy read to ensure writing */
-		XM_IN16(IoC, Port, XM_MMU_CMD, &Word);
-
+	if ((Dir & SK_STOP_TX) != 0) {
+		/* disable receiver and transmitter */
+		SkMacRxTxDisable(pAC, IoC, Port);
+		
 		/* stop both transmit queues */
 		/*
 		 * If the BMU is in the reset state CSR_STOP will terminate
@@ -1249,21 +1558,14 @@
 			 * Clear packet arbiter timeout to make sure
 			 * this loop will terminate.
 			 */
-			if (Port == MAC_1) {
-				Word = PA_CLR_TO_TX1;
-			}
-			else {
-				Word = PA_CLR_TO_TX2;
-			}
-			SK_OUT16(IoC, B3_PA_CTRL, Word);
+			SK_OUT16(IoC, B3_PA_CTRL, (Port == MAC_1) ? PA_CLR_TO_TX1 :
+				PA_CLR_TO_TX2);
 
 			/*
-			 * If the transfer stucks at the XMAC the STOP command will not
-			 * terminate if we don't flush the XMAC's transmit FIFO!
+			 * If the transfer stucks at the MAC the STOP command will not
+			 * terminate if we don't flush the XMAC's transmit FIFO !
 			 */
-			XM_IN32(IoC, Port, XM_MODE, &DWord);
-			DWord |= XM_MD_FTF;
-			XM_OUT32(IoC, Port, XM_MODE, DWord);
+			SkMacFlushTxFifo(pAC, IoC, Port);
 
 			XsCsr = TestStopBit(pAC, IoC, pPrt->PXsQOff);
 			XaCsr = TestStopBit(pAC, IoC, pPrt->PXaQOff);
@@ -1274,40 +1576,32 @@
 				 * This needs to be checked at 1/18 sec only.
 				 */
 				ToutCnt++;
-				switch (ToutCnt) {
-				case 1:
-					/*
-					 * Cache Incoherency workaround: Assume a start command
-					 * has been lost while sending the frame. 
-					 */
-					ToutStart = SkOsGetTime(pAC);
-					if (XsCsr & CSR_STOP) {
-						SK_OUT32(IoC, Q_ADDR(pPrt->PXsQOff, Q_CSR), CSR_START);
-					}
-					if (XaCsr & CSR_STOP) {
-						SK_OUT32(IoC, Q_ADDR(pPrt->PXaQOff, Q_CSR), CSR_START);
-					}
-					break;
-				case 2:
-				default:
+				if (ToutCnt > 1) {
 					/* Might be a problem when the driver event handler
-					 * calls StopPort again.
-					 * XXX.
+					 * calls StopPort again. XXX.
 					 */
 
 					/* Fatal Error, Loop aborted */
-					/* Create an Error Log Entry */
-					SK_ERR_LOG(
-						pAC,
-						SK_ERRCL_HW,
-						SKERR_HWI_E018,
+					SK_ERR_LOG(pAC, SK_ERRCL_HW, SKERR_HWI_E018,
 						SKERR_HWI_E018MSG);
 #ifndef SK_DIAG
 					Para.Para64 = Port;
 					SkEventQueue(pAC, SKGE_DRV, SK_DRV_PORT_FAIL, Para);
-#endif	/* !SK_DIAG */
+#endif /* !SK_DIAG */
 					return;
 				}
+				/*
+				 * Cache incoherency workaround: Assume a start command
+				 * has been lost while sending the frame.
+				 */
+				ToutStart = SkOsGetTime(pAC);
+
+				if ((XsCsr & CSR_STOP) != 0) {
+					SK_OUT32(IoC, Q_ADDR(pPrt->PXsQOff, Q_CSR), CSR_START);
+				}
+				if ((XaCsr & CSR_STOP) != 0) {
+					SK_OUT32(IoC, Q_ADDR(pPrt->PXaQOff, Q_CSR), CSR_START);
+				}
 			}
 
 			/*
@@ -1315,46 +1609,51 @@
 			 * required to wait until CSR_STOP is reset and CSR_SV_IDLE is set.
 			 */
 		} while ((XsCsr & (CSR_STOP | CSR_SV_IDLE)) != CSR_SV_IDLE ||
-			 (XaCsr & (CSR_STOP | CSR_SV_IDLE)) != CSR_SV_IDLE);
+				 (XaCsr & (CSR_STOP | CSR_SV_IDLE)) != CSR_SV_IDLE);
 
-		/* reset the XMAC depending on the RstMode */
+		/* Reset the MAC depending on the RstMode */
 		if (RstMode == SK_SOFT_RST) {
-			SkXmSoftRst(pAC, IoC, Port);
+			SkMacSoftRst(pAC, IoC, Port);
 		}
 		else {
-			SkXmHardRst(pAC, IoC, Port);
+			SkMacHardRst(pAC, IoC, Port);
 		}
-
- 		/*
-		 * Stop Interval Timer and Limit Counter of Tx Arbiter,
- 		 * also disable Force Sync bit and Enable Alloc bit.
-		 */
+ 		
+		/* Disable Force Sync bit and Enable Alloc bit */
 		SK_OUT8(IoC, MR_ADDR(Port, TXA_CTRL),
 			TXA_DIS_FSYNC | TXA_DIS_ALLOC | TXA_STOP_RC);
-		SK_OUT32(IoC, MR_ADDR(Port, TXA_ITI_INI), 0x00000000L);
-		SK_OUT32(IoC, MR_ADDR(Port, TXA_LIM_INI), 0x00000000L);
+		
+		/* Stop Interval Timer and Limit Counter of Tx Arbiter */
+		SK_OUT32(IoC, MR_ADDR(Port, TXA_ITI_INI), 0L);
+		SK_OUT32(IoC, MR_ADDR(Port, TXA_LIM_INI), 0L);
 
-		/*
-		 * perform a local reset of the port's tx path
-		 *	- reset the PCI FIFO of the async tx queue
-		 *	- reset the PCI FIFO of the sync tx queue
-		 *	- reset the RAM Buffer async tx queue
-		 *	- reset the RAM Butter sync tx queue
-		 *	- reset the MAC Tx FIFO
-		 */
+		/* Perform a local reset of the port's Tx path */
+
+		/* Reset the PCI FIFO of the async Tx queue */
 		SK_OUT32(IoC, Q_ADDR(pPrt->PXaQOff, Q_CSR), CSR_SET_RESET);
+		/* Reset the PCI FIFO of the sync Tx queue */
 		SK_OUT32(IoC, Q_ADDR(pPrt->PXsQOff, Q_CSR), CSR_SET_RESET);
+		/* Reset the RAM Buffer async Tx queue */
 		SK_OUT8(IoC, RB_ADDR(pPrt->PXaQOff, RB_CTRL), RB_RST_SET);
+		/* Reset the RAM Buffer sync Tx queue */
 		SK_OUT8(IoC, RB_ADDR(pPrt->PXsQOff, RB_CTRL), RB_RST_SET);
-		/* Note: MFF_RST_SET does NOT reset the XMAC! */
-		SK_OUT8(IoC, MR_ADDR(Port, TX_MFF_CTRL2), MFF_RST_SET);
-
-		/* switch Link and Tx LED off, stop the LED counters */
-		/* Link LED is switched off by the RLMT and the Diag itself */
-		SkGeXmitLED(pAC, IoC, MR_ADDR(Port, TX_LED_INI), SK_LED_DIS);
+		
+		/* Reset Tx MAC FIFO */
+		if (pAC->GIni.GIGenesis) {
+			/* Note: MFF_RST_SET does NOT reset the XMAC ! */
+			SK_OUT8(IoC, MR_ADDR(Port, TX_MFF_CTRL2), MFF_RST_SET);
+
+			/* switch Link and Tx LED off, stop the LED counters */
+			/* Link LED is switched off by the RLMT and the Diag itself */
+			SkGeXmitLED(pAC, IoC, MR_ADDR(Port, TX_LED_INI), SK_LED_DIS);
+		}
+		else {
+			/* Reset TX MAC FIFO */
+			SK_OUT8(IoC, MR_ADDR(Port, TX_GMF_CTRL_T), (SK_U8)GMF_RST_SET);
+		}
 	}
 
-	if (Dir & SK_STOP_RX) {
+	if ((Dir & SK_STOP_RX) != 0) {
 		/*
 		 * The RX Stop Command will not terminate if no buffers
 		 * are queued in the RxD ring. But it will always reach
@@ -1363,64 +1662,52 @@
 		 */
 		/* stop the port's receive queue */
 		SK_OUT32(IoC, Q_ADDR(pPrt->PRxQOff, Q_CSR), CSR_STOP);
+		
 		i = 100;
 		do {
 			/*
 			 * Clear packet arbiter timeout to make sure
 			 * this loop will terminate
 			 */
-			if (Port == MAC_1) {
-				Word = PA_CLR_TO_RX1;
-			}
-			else {
-				Word = PA_CLR_TO_RX2;
-			}
-			SK_OUT16(IoC, B3_PA_CTRL, Word);
-
+			SK_OUT16(IoC, B3_PA_CTRL, (Port == MAC_1) ? PA_CLR_TO_RX1 :
+				PA_CLR_TO_RX2);
+			
 			DWord = TestStopBit(pAC, IoC, pPrt->PRxQOff);
-			if (i != 0) {
-				i--;
-			}
 
-			/* finish if CSR_STOP is done or CSR_SV_IDLE is true and i==0 */
+			/* timeout if i==0 (bug fix for #10748) */
+			if (--i == 0) {
+				SK_ERR_LOG(pAC, SK_ERRCL_HW, SKERR_HWI_E024,
+					SKERR_HWI_E024MSG);
+				break;
+			}
 			/*
 			 * because of the ASIC problem report entry from 21.08.98
 			 * it is required to wait until CSR_STOP is reset and
 			 * CSR_SV_IDLE is set.
 			 */
-		} while ((DWord & (CSR_STOP | CSR_SV_IDLE)) != CSR_SV_IDLE &&
-			((DWord & CSR_SV_IDLE) == 0 || i != 0));
+		} while ((DWord & (CSR_STOP | CSR_SV_IDLE)) != CSR_SV_IDLE);
 
-		/* The path data transfer activity is fully stopped now. */
+		/* The path data transfer activity is fully stopped now */
 
-		/*
-		 * perform a local reset of the port's rx path
-		 *	- reset the PCI FIFO of the rx queue
-		 *	- reset the RAM Buffer receive queue
-		 *	- reset the MAC Rx FIFO
-		 */
+		/* Perform a local reset of the port's Rx path */
+
+		 /*	Reset the PCI FIFO of the Rx queue */
 		SK_OUT32(IoC, Q_ADDR(pPrt->PRxQOff, Q_CSR), CSR_SET_RESET);
+		/* Reset the RAM Buffer receive queue */
 		SK_OUT8(IoC, RB_ADDR(pPrt->PRxQOff, RB_CTRL), RB_RST_SET);
-		SK_OUT8(IoC, MR_ADDR(Port, RX_MFF_CTRL2), MFF_RST_SET);
 
-		/* switch Rx LED off, stop the LED counter */
-		SkGeXmitLED(pAC, IoC, MR_ADDR(Port, RX_LED_INI), SK_LED_DIS);
-
-	}
-
- 	/*
-	 * If all ports are stopped reset the RAM Interface.
-	 */
-	for (i = 0, AllPortsDis = SK_TRUE; i < pAC->GIni.GIMacsFound; i++) {
-		if (pAC->GIni.GP[i].PState != SK_PRT_RESET &&
-			pAC->GIni.GP[i].PState != SK_PRT_STOP) {
+		/* Reset Rx MAC FIFO */
+		if (pAC->GIni.GIGenesis) {
+			
+			SK_OUT8(IoC, MR_ADDR(Port, RX_MFF_CTRL2), MFF_RST_SET);
 
-			AllPortsDis = SK_FALSE;
-			break;
+			/* switch Rx LED off, stop the LED counter */
+			SkGeXmitLED(pAC, IoC, MR_ADDR(Port, RX_LED_INI), SK_LED_DIS);
+		}
+		else {
+			/* Reset Rx MAC FIFO */
+			SK_OUT8(IoC, MR_ADDR(Port, RX_GMF_CTRL_T), (SK_U8)GMF_RST_SET);
 		}
-	}
-	if (AllPortsDis) {
-		pAC->GIni.GIAnyPortAct = SK_FALSE;
 	}
 }	/* SkGeStopPort */
 
@@ -1444,12 +1731,12 @@
 
 	for (i = 0; i < SK_MAX_MACS; i++) {
 		pPrt = &pAC->GIni.GP[i];
+
 		pPrt->PState = SK_PRT_RESET;
 		pPrt->PRxQOff = QOffTab[i].RxQOff;
 		pPrt->PXsQOff = QOffTab[i].XsQOff;
 		pPrt->PXaQOff = QOffTab[i].XaQOff;
 		pPrt->PCheckPar = SK_FALSE;
-		pPrt->PRxCmd = XM_RX_STRIP_FCS | XM_RX_LENERR_OK;
 		pPrt->PIsave = 0;
 		pPrt->PPrevShorts = 0;
 		pPrt->PLinkResCt = 0;
@@ -1458,6 +1745,9 @@
 		pPrt->PPrevFcs = 0;
 		pPrt->PRxLim = SK_DEF_RX_WA_LIM;
 		pPrt->PLinkMode = SK_LMODE_AUTOFULL;
+		pPrt->PLinkSpeedCap = SK_LSPEED_CAP_1000MBPS;
+		pPrt->PLinkSpeed = SK_LSPEED_1000MBPS;
+		pPrt->PLinkSpeedUsed = SK_LSPEED_STAT_UNKNOWN;
 		pPrt->PLinkModeConf = SK_LMODE_AUTOSENSE;
 		pPrt->PFlowCtrlMode = SK_FLOW_MODE_SYM_OR_REM;
 		pPrt->PLinkBroken = SK_TRUE; /* See WA code */
@@ -1466,8 +1756,7 @@
 		pPrt->PLinkModeStatus = SK_LMODE_STAT_UNKNOWN;
 		pPrt->PFlowCtrlCap = SK_FLOW_MODE_SYM_OR_REM;
 		pPrt->PFlowCtrlStatus = SK_FLOW_STAT_NONE;
-		pPrt->PMSCap = (SK_MS_CAP_AUTO | SK_MS_CAP_MASTER | 
-				SK_MS_CAP_SLAVE);
+		pPrt->PMSCap = 0;
 		pPrt->PMSMode = SK_MS_MODE_AUTO;
 		pPrt->PMSStatus = SK_MS_STAT_UNSET;
 		pPrt->PAutoNegFail = SK_FALSE;
@@ -1476,7 +1765,9 @@
 	}
 
 	pAC->GIni.GIPortUsage = SK_RED_LINK;
-	pAC->GIni.GIAnyPortAct = SK_FALSE;
+	pAC->GIni.GILedBlinkCtrl = (SK_U16)OemConfig.Value;
+	pAC->GIni.GIValIrqMask = IS_ALL_MSK;
+
 }	/* SkGeInit0*/
 
 #ifdef SK_PCI_RESET
@@ -1520,45 +1811,42 @@
 	/* We know the RAM Interface Arbiter is enabled. */
 	SkPciWriteCfgWord(pAC, PCI_PM_CTL_STS, PCI_PM_STATE_D3);
 	SkPciReadCfgWord(pAC, PCI_PM_CTL_STS, &PmCtlSts);
-	if ((PmCtlSts & PCI_PM_STATE) != PCI_PM_STATE_D3) {
-		return (1);
+	
+	if ((PmCtlSts & PCI_PM_STATE_MSK) != PCI_PM_STATE_D3) {
+		return(1);
 	}
 
-	/*
-	 * Return to D0 state.
-	 */
+	/* Return to D0 state. */
 	SkPciWriteCfgWord(pAC, PCI_PM_CTL_STS, PCI_PM_STATE_D0);
 
 	/* Check for D0 state. */
 	SkPciReadCfgWord(pAC, PCI_PM_CTL_STS, &PmCtlSts);
-	if ((PmCtlSts & PCI_PM_STATE) != PCI_PM_STATE_D0) {
-		return (1);
+	
+	if ((PmCtlSts & PCI_PM_STATE_MSK) != PCI_PM_STATE_D0) {
+		return(1);
 	}
 
-	/*
-	 * Check PCI Config Registers.
-	 */
+	/* Check PCI Config Registers. */
 	SkPciReadCfgWord(pAC, PCI_COMMAND, &PciCmd);
 	SkPciReadCfgByte(pAC, PCI_CACHE_LSZ, &Cls);
 	SkPciReadCfgDWord(pAC, PCI_BASE_1ST, &Bp1);
 	SkPciReadCfgDWord(pAC, PCI_BASE_2ND, &Bp2);
-	SkPciReadCfgByte(pAC, PCI_LAT_TIM, &lat);
+	SkPciReadCfgByte(pAC, PCI_LAT_TIM, &Lat);
+	
 	if (PciCmd != 0 || Cls != 0 || (Bp1 & 0xfffffff0L) != 0 || Bp2 != 1 ||
-		Lat != 0 ) {
-		return (0);
+		Lat != 0) {
+		return(1);
 	}
 
-	/*
-	 * Restore Config Space.
-	 */
+	/* Restore PCI Config Space. */
 	for (i = 0; i < PCI_CFG_SIZE; i++) {
 		SkPciWriteCfgDWord(pAC, i*4, ConfigSpace[i]);
 	}
 
-	return (0);
+	return(0);
 }	/* SkGePciReset */
 
-#endif	/* SK_PCI_RESET */
+#endif /* SK_PCI_RESET */
 
 /******************************************************************************
  *
@@ -1572,13 +1860,14 @@
  *	o Get the hardware configuration
  *		+ Read the number of MACs/Ports.
  *		+ Read the RAM size.
- *		+ Read the PCI Revision ID.
+ *		+ Read the PCI Revision Id.
  *		+ Find out the adapters host clock speed
  *		+ Read and check the PHY type
  *
  * Returns:
  *	0:	success
  *	5:	Unexpected PHY type detected
+ *	6:	HW self test failed
  */
 static int SkGeInit1(
 SK_AC	*pAC,		/* adapter context */
@@ -1586,91 +1875,256 @@
 {
 	SK_U8	Byte;
 	SK_U16	Word;
+	SK_U16	CtrlStat;
+	SK_U32	DWord;
 	int	RetVal;
 	int	i;
 
 	RetVal = 0;
 
+	/* save CLK_RUN bits (YUKON-Lite) */
+	SK_IN16(IoC, B0_CTST, &CtrlStat);
+
 #ifdef SK_PCI_RESET
 	(void)SkGePciReset(pAC, IoC);
-#endif	/* SK_PCI_RESET */
+#endif /* SK_PCI_RESET */
 
-	/* Do the reset */
+	/* do the SW-reset */
 	SK_OUT8(IoC, B0_CTST, CS_RST_SET);
 
-	/* Release the reset */
+	/* release the SW-reset */
 	SK_OUT8(IoC, B0_CTST, CS_RST_CLR);
 
-	/* Reset all error bits in the PCI STATUS register */
+	/* reset all error bits in the PCI STATUS register */
 	/*
-	 * Note: Cfg cycles cannot be used, because they are not
+	 * Note: PCI Cfg cycles cannot be used, because they are not
 	 *		 available on some platforms after 'boot time'.
 	 */
-	SK_OUT8(IoC, B2_TST_CTRL1, TST_CFG_WRITE_ON);
 	SK_IN16(IoC, PCI_C(PCI_STATUS), &Word);
+	
+	SK_OUT8(IoC, B2_TST_CTRL1, TST_CFG_WRITE_ON);
 	SK_OUT16(IoC, PCI_C(PCI_STATUS), Word | PCI_ERRBITS);
 	SK_OUT8(IoC, B2_TST_CTRL1, TST_CFG_WRITE_OFF);
 
-	/* Release Master_Reset */
+	/* release Master Reset */
 	SK_OUT8(IoC, B0_CTST, CS_MRST_CLR);
 
-	/* Read number of MACs */
+#ifdef CLK_RUN
+	CtrlStat |= CS_CLK_RUN_ENA;
+#endif /* CLK_RUN */
+
+	/* restore CLK_RUN bits */
+	SK_OUT16(IoC, B0_CTST, CtrlStat &
+		(CS_CLK_RUN_HOT | CS_CLK_RUN_RST | CS_CLK_RUN_ENA));
+	
+	/* read Chip Identification Number */
+	SK_IN8(IoC, B2_CHIP_ID, &Byte);
+	pAC->GIni.GIChipId = Byte;
+	
+	/* read number of MACs */
 	SK_IN8(IoC, B2_MAC_CFG, &Byte);
-	if (Byte & CFG_SNG_MAC) {
-		pAC->GIni.GIMacsFound = 1;
-	}
-	else {
-		pAC->GIni.GIMacsFound = 2;
-	}
-	SK_IN8(IoC, PCI_C(PCI_REV_ID), &Byte);
-	pAC->GIni.GIPciHwRev = (int) Byte;
+	pAC->GIni.GIMacsFound = (Byte & CFG_SNG_MAC) ? 1 : 2;
+	
+	/* get Chip Revision Number */
+	pAC->GIni.GIChipRev = (SK_U8)((Byte & CFG_CHIP_R_MSK) >> 4);
 
-	/* Read the adapters RAM size */
+	/* get diff. PCI parameters */
+	SK_IN16(IoC, B0_CTST, &CtrlStat);
+	
+	/* read the adapters RAM size */
 	SK_IN8(IoC, B2_E_0, &Byte);
-	if (Byte == 3) {
-		pAC->GIni.GIRamSize = (int)(Byte-1) * 512;
-		pAC->GIni.GIRamOffs = (SK_U32)512 * 1024;
+	
+	pAC->GIni.GIYukonLite = SK_FALSE;
+
+	if (pAC->GIni.GIChipId == CHIP_ID_GENESIS) {
+
+		pAC->GIni.GIGenesis = SK_TRUE;
+
+		if (Byte == 3) {						
+			/* special case: 4 x 64k x 36, offset = 0x80000 */
+			pAC->GIni.GIRamSize = 1024;
+			pAC->GIni.GIRamOffs = (SK_U32)512 * 1024;
+		}
+		else {
+			pAC->GIni.GIRamSize = (int)Byte * 512;
+			pAC->GIni.GIRamOffs = 0;
+		}
+		/* all GE adapters work with 53.125 MHz host clock */
+		pAC->GIni.GIHstClkFact = SK_FACT_53;
+		
+		/* set Descr. Poll Timer Init Value to 250 ms */
+		pAC->GIni.GIPollTimerVal =
+			SK_DPOLL_DEF * (SK_U32)pAC->GIni.GIHstClkFact / 100;
 	}
 	else {
-		pAC->GIni.GIRamSize = (int)Byte * 512;
+		pAC->GIni.GIGenesis = SK_FALSE;
+
+		pAC->GIni.GIRamSize = (Byte == 0) ? 128 : (int)Byte * 4;
+		
 		pAC->GIni.GIRamOffs = 0;
+		
+		/* WA for chip Rev. A */
+		pAC->GIni.GIWolOffs = (pAC->GIni.GIChipRev == 0) ? WOL_REG_OFFS : 0;
+		
+		/* get PM Capabilities of PCI config space */
+		SK_IN16(IoC, PCI_C(PCI_PM_CAP_REG), &Word);
+
+		/* check if VAUX is available */
+		if (((CtrlStat & CS_VAUX_AVAIL) != 0) &&
+			/* check also if PME from D3cold is set */
+			((Word & PCI_PME_D3C_SUP) != 0)) {
+			/* set entry in GE init struct */
+			pAC->GIni.GIVauxAvail = SK_TRUE;
+		}
+		
+		if (pAC->GIni.GIChipId == CHIP_ID_YUKON_LITE) {
+			/* this is Rev. A1 */
+			pAC->GIni.GIYukonLite = SK_TRUE;
+		}
+		else {
+			/* save Flash-Address Register */
+			SK_IN32(IoC, B2_FAR, &DWord);
+
+			/* test Flash-Address Register */
+			SK_OUT8(IoC, B2_FAR + 3, 0xff);
+			SK_IN8(IoC, B2_FAR + 3, &Byte);
+
+			if (Byte != 0) {
+				/* this is Rev. A0 */
+				pAC->GIni.GIYukonLite = SK_TRUE;
+
+				/* restore Flash-Address Register */
+				SK_OUT32(IoC, B2_FAR, DWord);
+			}
+		}
+
+		/* read the Interrupt source */
+		SK_IN32(IoC, B0_ISRC, &DWord);
+		
+		if ((DWord & IS_HW_ERR) != 0) {
+			/* read the HW Error Interrupt source */
+			SK_IN32(IoC, B0_HWE_ISRC, &DWord);
+			
+			if ((DWord & IS_IRQ_SENSOR) != 0) {
+				/* disable HW Error IRQ */
+				pAC->GIni.GIValIrqMask &= ~IS_HW_ERR;
+			}
+		}
+		
+		for (i = 0; i < pAC->GIni.GIMacsFound; i++) {
+			/* set GMAC Link Control reset */
+			SK_OUT16(IoC, MR_ADDR(i, GMAC_LINK_CTRL), GMLC_RST_SET);
+
+			/* clear GMAC Link Control reset */
+			SK_OUT16(IoC, MR_ADDR(i, GMAC_LINK_CTRL), GMLC_RST_CLR);
+		}
+		/* all YU chips work with 78.125 MHz host clock */
+		pAC->GIni.GIHstClkFact = SK_FACT_78;
+		
+		pAC->GIni.GIPollTimerVal = SK_DPOLL_MAX;	/* 215 ms */
 	}
 
-	/* All known GE Adapters works with 53.125 MHz host clock */
-	pAC->GIni.GIHstClkFact = SK_FACT_53;
-	pAC->GIni.GIPollTimerVal =
-		SK_DPOLL_DEF * (SK_U32)pAC->GIni.GIHstClkFact / 100;
+	/* check if 64-bit PCI Slot is present */
+	pAC->GIni.GIPciSlot64 = (SK_BOOL)((CtrlStat & CS_BUS_SLOT_SZ) != 0);
 	
-	/* Read the PHY type */
+	/* check if 66 MHz PCI Clock is active */
+	pAC->GIni.GIPciClock66 = (SK_BOOL)((CtrlStat & CS_BUS_CLOCK) != 0);
+
+	/* read PCI HW Revision Id. */
+	SK_IN8(IoC, PCI_C(PCI_REV_ID), &Byte);
+	pAC->GIni.GIPciHwRev = Byte;
+
+	/* read the PMD type */
+	SK_IN8(IoC, B2_PMD_TYP, &Byte);
+	pAC->GIni.GICopperType = (SK_U8)(Byte == 'T');
+
+	/* read the PHY type */
 	SK_IN8(IoC, B2_E_1, &Byte);
+
 	Byte &= 0x0f;	/* the PHY type is stored in the lower nibble */
-	for (i=0; i<pAC->GIni.GIMacsFound; i++) {
-		pAC->GIni.GP[i].PhyType = Byte;
-		switch (Byte) {
-		case SK_PHY_XMAC:
-			pAC->GIni.GP[i].PhyAddr = PHY_ADDR_XMAC;
-			break;
-		case SK_PHY_BCOM:
-			pAC->GIni.GP[i].PhyAddr = PHY_ADDR_BCOM;
-			break;
-		case SK_PHY_LONE:
-			pAC->GIni.GP[i].PhyAddr = PHY_ADDR_LONE;
-			break;
-		case SK_PHY_NAT:
-			pAC->GIni.GP[i].PhyAddr = PHY_ADDR_NAT;
-			break;
-		default:
-			/* ERROR: unexpected PHY typ detected */
-			RetVal = 5;
-			break;
+	for (i = 0; i < pAC->GIni.GIMacsFound; i++) {
+		
+		if (pAC->GIni.GIGenesis) {
+			switch (Byte) {
+			case SK_PHY_XMAC:
+				pAC->GIni.GP[i].PhyAddr = PHY_ADDR_XMAC;
+				break;
+			case SK_PHY_BCOM:
+				pAC->GIni.GP[i].PhyAddr = PHY_ADDR_BCOM;
+				pAC->GIni.GP[i].PMSCap =
+					SK_MS_CAP_AUTO | SK_MS_CAP_MASTER | SK_MS_CAP_SLAVE;
+				break;
+#ifdef OTHER_PHY
+			case SK_PHY_LONE:
+				pAC->GIni.GP[i].PhyAddr = PHY_ADDR_LONE;
+				break;
+			case SK_PHY_NAT:
+				pAC->GIni.GP[i].PhyAddr = PHY_ADDR_NAT;
+				break;
+#endif /* OTHER_PHY */
+			default:
+				/* ERROR: unexpected PHY type detected */
+				RetVal = 5;
+				break;
+			}
 		}
+		else {
+			if (Byte < SK_PHY_MARV_COPPER) {
+				/* if this field is not initialized */
+				Byte = SK_PHY_MARV_COPPER;
+				pAC->GIni.GICopperType = SK_TRUE;
+			}
+			pAC->GIni.GP[i].PhyAddr = PHY_ADDR_MARV;
+			
+			if (pAC->GIni.GICopperType) {
+				pAC->GIni.GP[i].PLinkSpeedCap = SK_LSPEED_CAP_AUTO |
+					SK_LSPEED_CAP_10MBPS | SK_LSPEED_CAP_100MBPS |
+					SK_LSPEED_CAP_1000MBPS;
+				pAC->GIni.GP[i].PLinkSpeed = SK_LSPEED_AUTO;
+				pAC->GIni.GP[i].PMSCap =
+					SK_MS_CAP_AUTO | SK_MS_CAP_MASTER | SK_MS_CAP_SLAVE;
+			}
+			else {
+				Byte = SK_PHY_MARV_FIBER;
+			}
+		}
+		
+		pAC->GIni.GP[i].PhyType = Byte;
+		
+		SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_INIT,
+			("PHY type: %d  PHY addr: %04x\n", Byte,
+			pAC->GIni.GP[i].PhyAddr));
 	}
-	SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_INIT,
-		("PHY type: %d  PHY addr: %x\n", pAC->GIni.GP[i].PhyType,
-		pAC->GIni.GP[i].PhyAddr));
+	
+	/* get Mac Type & set function pointers dependent on */
+	if (pAC->GIni.GIGenesis) {
+		pAC->GIni.GIMacType = SK_MAC_XMAC;
+
+		pAC->GIni.GIFunc.pFnMacUpdateStats	= SkXmUpdateStats;
+		pAC->GIni.GIFunc.pFnMacStatistic	= SkXmMacStatistic;
+		pAC->GIni.GIFunc.pFnMacResetCounter	= SkXmResetCounter;
+		pAC->GIni.GIFunc.pFnMacOverflow		= SkXmOverflowStatus;
+	}
+	else {
+		pAC->GIni.GIMacType = SK_MAC_GMAC;
 
-	return (RetVal);
-}	/* SkGeInit1*/
+		pAC->GIni.GIFunc.pFnMacUpdateStats	= SkGmUpdateStats;
+		pAC->GIni.GIFunc.pFnMacStatistic	= SkGmMacStatistic;
+		pAC->GIni.GIFunc.pFnMacResetCounter	= SkGmResetCounter;
+		pAC->GIni.GIFunc.pFnMacOverflow		= SkGmOverflowStatus;
+
+#ifdef SPECIAL_HANDLING
+		if (pAC->GIni.GIChipId == CHIP_ID_YUKON) {
+			/* check HW self test result */
+			SK_IN8(IoC, B2_E_3, &Byte);
+			if ((Byte & B2_E3_RES_MASK) != 0) {
+				RetVal = 6;
+			}
+		}
+#endif
+	}
+	return(RetVal);
+}	/* SkGeInit1 */
 
 
 /******************************************************************************
@@ -1692,64 +2146,48 @@
 SK_AC	*pAC,		/* adapter context */
 SK_IOC	IoC)		/* IO context */
 {
-	SK_GEPORT *pPrt;
 	SK_U32	DWord;
-	int	i;
-
-	/* start the Blink Source Counter */
-	DWord = SK_BLK_DUR * (SK_U32)pAC->GIni.GIHstClkFact / 100;
-	SK_OUT32(IoC, B2_BSC_INI, DWord);
-	SK_OUT8(IoC, B2_BSC_CTRL, BSC_START);
+	int		i;
 
 	/* start the Descriptor Poll Timer */
 	if (pAC->GIni.GIPollTimerVal != 0) {
 		if (pAC->GIni.GIPollTimerVal > SK_DPOLL_MAX) {
 			pAC->GIni.GIPollTimerVal = SK_DPOLL_MAX;
 
-			/* Create an Error Log Entry */
 			SK_ERR_LOG(pAC, SK_ERRCL_SW, SKERR_HWI_E017, SKERR_HWI_E017MSG);
 		}
 		SK_OUT32(IoC, B28_DPT_INI, pAC->GIni.GIPollTimerVal);
 		SK_OUT8(IoC, B28_DPT_CTRL, DPT_START);
 	}
 
-	/*
-	 * Configure
-	 *	- the MAC-Arbiter and
-	 *	- the Paket Arbiter
-	 *
-	 * The MAC and the packet arbiter will be started once
-	 * and never be stopped.
-	 */
-	SkGeInitMacArb(pAC, IoC);
-	SkGeInitPktArb(pAC, IoC);
+	if (pAC->GIni.GIGenesis) {
+		/* start the Blink Source Counter */
+		DWord = SK_BLK_DUR * (SK_U32)pAC->GIni.GIHstClkFact / 100;
+
+		SK_OUT32(IoC, B2_BSC_INI, DWord);
+		SK_OUT8(IoC, B2_BSC_CTRL, BSC_START);
+
+		/*
+		 * Configure the MAC Arbiter and the Packet Arbiter.
+		 * They will be started once and never be stopped.
+		 */
+		SkGeInitMacArb(pAC, IoC);
+
+		SkGeInitPktArb(pAC, IoC);
+	}
+	else {
+		/* start Time Stamp Timer */
+		SK_OUT8(IoC, GMAC_TI_ST_CTRL, (SK_U8)GMT_ST_START);
+	}
 
 	/* enable the Tx Arbiters */
-	SK_OUT8(IoC, MR_ADDR(MAC_1, TXA_CTRL), TXA_ENA_ARB);
-	if (pAC->GIni.GIMacsFound > 1) {
-		SK_OUT8(IoC, MR_ADDR(MAC_2, TXA_CTRL), TXA_ENA_ARB);
+	for (i = 0; i < pAC->GIni.GIMacsFound; i++) {
+		SK_OUT8(IoC, MR_ADDR(i, TXA_CTRL), TXA_ENA_ARB);
 	}
 
 	/* enable the RAM Interface Arbiter */
 	SkGeInitRamIface(pAC, IoC);
 
-	for (i = 0; i < SK_MAX_MACS; i++) {
-		pPrt = &pAC->GIni.GP[i];
-		if (pAC->GIni.GIPortUsage == SK_JUMBO_LINK) {
-			pPrt->PRxCmd |= XM_RX_BIG_PK_OK;
-		}
-
-		if (pPrt->PLinkModeConf == SK_LMODE_HALF) {
-			/*
-			 * If in manual half duplex mode
-			 * the other side might be in full duplex mode
-			 * so ignore if a carrier extension is not seen on
-			 * frames received
-			 */
-			pPrt->PRxCmd |= XM_RX_DIS_CEXT;
-		}
-
-	}
 }	/* SkGeInit2 */
 
 /******************************************************************************
@@ -1758,9 +2196,8 @@
  *
  * Description:
  *	Level	0:	Initialize the Module structures.
- *	Level	1:	Generic Hardware Initialization. The
- *			IOP/MemBase pointer has to be set before
- *			calling this level.
+ *	Level	1:	Generic Hardware Initialization. The IOP/MemBase pointer has
+ *				to be set before calling this level.
  *
  *			o Do a software reset.
  *			o Clear all reset bits.
@@ -1780,18 +2217,19 @@
  *
  * Returns:
  *	0:	success
- *	1:	Number of MACs exceeds SK_MAX_MACS	( after level 1)
- *	2:	Adapter not present or not accessable
+ *	1:	Number of MACs exceeds SK_MAX_MACS	(after level 1)
+ *	2:	Adapter not present or not accessible
  *	3:	Illegal initialization level
  *	4:	Initialization Level 1 Call missing
  *	5:	Unexpected PHY type detected
+ *	6:	HW self test failed
  */
 int	SkGeInit(
 SK_AC	*pAC,		/* adapter context */
 SK_IOC	IoC,		/* IO context */
 int		Level)		/* initialization level */
 {
-	int	RetVal;		/* return value */
+	int		RetVal;		/* return value */
 	SK_U32	DWord;
 
 	RetVal = 0;
@@ -1804,20 +2242,25 @@
 		SkGeInit0(pAC, IoC);
 		pAC->GIni.GILevel = SK_INIT_DATA;
 		break;
+	
 	case SK_INIT_IO:
 		/* Initialization Level 1 */
 		RetVal = SkGeInit1(pAC, IoC);
+		if (RetVal != 0) {
+			break;
+		}
 
-		/* Check if the adapter seems to be accessable */
+		/* check if the adapter seems to be accessible */
 		SK_OUT32(IoC, B2_IRQM_INI, 0x11335577L);
 		SK_IN32(IoC, B2_IRQM_INI, &DWord);
-		SK_OUT32(IoC, B2_IRQM_INI, 0x00000000L);
+		SK_OUT32(IoC, B2_IRQM_INI, 0L);
+		
 		if (DWord != 0x11335577L) {
 			RetVal = 2;
 			break;
 		}
 
-		/* Check if the number of GIMacsFound matches SK_MAX_MACS */
+		/* check if the number of GIMacsFound matches SK_MAX_MACS */
 		if (pAC->GIni.GIMacsFound > SK_MAX_MACS) {
 			RetVal = 1;
 			break;
@@ -1826,12 +2269,13 @@
 		/* Level 1 successfully passed */
 		pAC->GIni.GILevel = SK_INIT_IO;
 		break;
+	
 	case SK_INIT_RUN:
 		/* Initialization Level 2 */
 		if (pAC->GIni.GILevel != SK_INIT_IO) {
-#ifndef	SK_DIAG
+#ifndef SK_DIAG
 			SK_ERR_LOG(pAC, SK_ERRCL_SW, SKERR_HWI_E002, SKERR_HWI_E002MSG);
-#endif
+#endif /* !SK_DIAG */
 			RetVal = 4;
 			break;
 		}
@@ -1840,20 +2284,20 @@
 		/* Level 2 successfully passed */
 		pAC->GIni.GILevel = SK_INIT_RUN;
 		break;
+	
 	default:
-		/* Create an Error Log Entry */
 		SK_ERR_LOG(pAC, SK_ERRCL_SW, SKERR_HWI_E003, SKERR_HWI_E003MSG);
 		RetVal = 3;
 		break;
 	}
 
-	return (RetVal);
-}	/* SkGeInit*/
+	return(RetVal);
+}	/* SkGeInit */
 
 
 /******************************************************************************
  *
- *	SkGeDeInit() - Deinitialize the adapter.
+ *	SkGeDeInit() - Deinitialize the adapter
  *
  * Description:
  *	All ports of the adapter will be stopped if not already done.
@@ -1862,17 +2306,19 @@
  * Returns:
  *	nothing
  */
-void	SkGeDeInit(
+void SkGeDeInit(
 SK_AC	*pAC,		/* adapter context */
 SK_IOC	IoC)		/* IO context */
 {
 	int	i;
 	SK_U16	Word;
 
-	/* Ensure I2C is ready. */
+#ifndef VCPU
+	/* ensure I2C is ready */
 	SkI2cWaitIrq(pAC, IoC);
+#endif
 
-	/* Stop all current transfer activity */
+	/* stop all current transfer activity */
 	for (i = 0; i < pAC->GIni.GIMacsFound; i++) {
 		if (pAC->GIni.GP[i].PState != SK_PRT_STOP &&
 			pAC->GIni.GP[i].PState != SK_PRT_RESET) {
@@ -1883,39 +2329,39 @@
 
 	/* Reset all bits in the PCI STATUS register */
 	/*
-	 * Note: Cfg cycles cannot be used, because they are not
+	 * Note: PCI Cfg cycles cannot be used, because they are not
 	 *	 available on some platforms after 'boot time'.
 	 */
-	SK_OUT8(IoC, B2_TST_CTRL1, TST_CFG_WRITE_ON);
 	SK_IN16(IoC, PCI_C(PCI_STATUS), &Word);
+	
+	SK_OUT8(IoC, B2_TST_CTRL1, TST_CFG_WRITE_ON);
 	SK_OUT16(IoC, PCI_C(PCI_STATUS), Word | PCI_ERRBITS);
 	SK_OUT8(IoC, B2_TST_CTRL1, TST_CFG_WRITE_OFF);
 
-	/* Do the reset, all LEDs are switched off now */
+	/* do the reset, all LEDs are switched off now */
 	SK_OUT8(IoC, B0_CTST, CS_RST_SET);
-}	/* SkGeDeInit*/
+}	/* SkGeDeInit */
 
 
 /******************************************************************************
  *
- *	SkGeInitPort()	Initialize the specified prot.
+ *	SkGeInitPort()	Initialize the specified port.
  *
  * Description:
  *	PRxQSize, PXSQSize, and PXAQSize has to be
- *	configured for the specified port before calling this
- *	function. The descriptor rings has to be initialized, too.
+ *	configured for the specified port before calling this function.
+ *  The descriptor rings has to be initialized too.
  *
  *	o (Re)configure queues of the specified port.
- *	o configure the XMAC of the specified port.
- *	o put ASIC and XMAC(s) in operational mode.
+ *	o configure the MAC of the specified port.
+ *	o put ASIC and MAC(s) in operational mode.
  *	o initialize Rx/Tx and Sync LED
  *	o initialize RAM Buffers and MAC FIFOs
  *
  *	The port is ready to connect when returning.
  *
  * Note:
- *	The XMACs Rx and Tx state machine is still disabled when
- *	returning.
+ *	The MAC's Rx and Tx state machine is still disabled when returning.
  *
  * Returns:
  *	0:	success
@@ -1936,45 +2382,48 @@
 
 	if (SkGeCheckQSize(pAC, Port) != 0) {
 		SK_ERR_LOG(pAC, SK_ERRCL_SW, SKERR_HWI_E004, SKERR_HWI_E004MSG);
-		return (1);
+		return(1);
 	}
+	
 	if (pPrt->PState == SK_PRT_INIT || pPrt->PState == SK_PRT_RUN) {
 		SK_ERR_LOG(pAC, SK_ERRCL_SW, SKERR_HWI_E005, SKERR_HWI_E005MSG);
-		return (2);
+		return(2);
 	}
 
-	/* Configuration ok, initialize the Port now */
+	/* configuration ok, initialize the Port now */
 
-	/* Initialize Rx, Tx and Link LED */
-	/*
-	 * If 1000BT Phy needs LED initialization than swap
-	 * LED and XMAC initialization order
-	 */
- 	SkGeXmitLED(pAC, IoC, MR_ADDR(Port, TX_LED_INI), SK_LED_ENA);
- 	SkGeXmitLED(pAC, IoC, MR_ADDR(Port, RX_LED_INI), SK_LED_ENA);
-	/* The Link LED is initialized by RLMT or Diagnostics itself */ 
+	if (pAC->GIni.GIGenesis) {
+		/* initialize Rx, Tx and Link LED */
+		/*
+		 * If 1000BT Phy needs LED initialization than swap
+		 * LED and XMAC initialization order
+		 */
+		SkGeXmitLED(pAC, IoC, MR_ADDR(Port, TX_LED_INI), SK_LED_ENA);
+		SkGeXmitLED(pAC, IoC, MR_ADDR(Port, RX_LED_INI), SK_LED_ENA);
+		/* The Link LED is initialized by RLMT or Diagnostics itself */
+		
+		SkXmInitMac(pAC, IoC, Port);
+	}
+	else {
 
-	/* Do NOT initialize the Link Sync Counter */
+		SkGmInitMac(pAC, IoC, Port);
+	}
+	
+	/* do NOT initialize the Link Sync Counter */
 
-	/*
-	 * Configure
-	 *	- XMAC
-	 *	- MAC FIFOs
-	 *	- RAM Buffers
-	 *	- enable Force Sync bit if synchronous queue available
-	 *	- BMUs
-	 */
-	SkXmInitMac(pAC, IoC, Port);
 	SkGeInitMacFifo(pAC, IoC, Port);
+	
 	SkGeInitRamBufs(pAC, IoC, Port);
+	
 	if (pPrt->PXSQSize != 0) {
+		/* enable Force Sync bit if synchronous queue available */
 		SK_OUT8(IoC, MR_ADDR(Port, TXA_CTRL), TXA_ENA_FSYNC);
 	}
+	
 	SkGeInitBmu(pAC, IoC, Port);
 
-	/* Mark port as initialized. */
+	/* mark port as initialized */
 	pPrt->PState = SK_PRT_INIT;
-	pAC->GIni.GIAnyPortAct = SK_TRUE;
 
-	return (0);
+	return(0);
 }	/* SkGeInitPort */
diff -ruN linux/drivers/net/sk98lin/skgemib.c linuxn/drivers/net/sk98lin/skgemib.c
--- linux/drivers/net/sk98lin/skgemib.c	Thu Jan  1 01:00:00 1970
+++ linuxn/drivers/net/sk98lin/skgemib.c	Tue May 20 12:17:40 2003
@@ -0,0 +1,1060 @@
+/*****************************************************************************
+ *
+ * Name:	skgemib.c
+ * Project:	GEnesis, PCI Gigabit Ethernet Adapter
+ * Version:	$Revision: 1.8 $
+ * Date:	$Date: 2003/03/27 11:19:15 $
+ * Purpose:	Private Network Management Interface Management Database
+ *
+ ****************************************************************************/
+
+/******************************************************************************
+ *
+ *	(C)Copyright 1998-2002 SysKonnect GmbH.
+ *	(C)Copyright 2002-2003 Marvell.
+ *
+ *	This program is free software; you can redistribute it and/or modify
+ *	it under the terms of the GNU General Public License as published by
+ *	the Free Software Foundation; either version 2 of the License, or
+ *	(at your option) any later version.
+ *
+ *	The information in this file is provided "AS IS" without warranty.
+ *
+ ******************************************************************************/
+
+/*****************************************************************************
+ *
+ * History:
+ *
+ *	$Log: skgemib.c,v $
+ *	Revision 1.8  2003/03/27 11:19:15  tschilli
+ *	Copyright messages changed.
+ *	
+ *	Revision 1.7  2002/12/16 09:04:34  tschilli
+ *	Code for VCT handling added.
+ *	
+ *	Revision 1.6  2002/08/09 15:40:21  rwahl
+ *	Editorial change (renamed ConfSpeedCap).
+ *	
+ *	Revision 1.5  2002/08/09 11:05:34  rwahl
+ *	Added oid handling for link speed cap.
+ *	
+ *	Revision 1.4  2002/08/09 09:40:27  rwahl
+ *	Added support for NDIS OID_PNP_xxx.
+ *	
+ *	Revision 1.3  2002/07/17 19:39:54  rwahl
+ *	Added handler for OID_SKGE_SPEED_MODE & OID_SKGE_SPEED_STATUS.
+ *	
+ *	Revision 1.2  2002/05/22 08:59:00  rwahl
+ *	- static functions only for release build.
+ *	- Source file must be included.
+ *	
+ *	Revision 1.1  2002/05/22 08:12:42  rwahl
+ *	Initial version.
+ *	
+ ****************************************************************************/
+
+/*
+ * PRIVATE OID handler function prototypes
+ */
+PNMI_STATIC int Addr(SK_AC *pAC, SK_IOC IoC, int action,
+	SK_U32 Id, char *pBuf, unsigned int *pLen, SK_U32 Instance,
+	unsigned int TableIndex, SK_U32 NetIndex);
+PNMI_STATIC int CsumStat(SK_AC *pAC, SK_IOC IoC, int action, SK_U32 Id,
+	char *pBuf, unsigned int *pLen, SK_U32 Instance,
+	unsigned int TableIndex, SK_U32 NetIndex);
+PNMI_STATIC int General(SK_AC *pAC, SK_IOC IoC, int action, SK_U32 Id,
+	char *pBuf, unsigned int *pLen, SK_U32 Instance,
+	unsigned int TableIndex, SK_U32 NetIndex);
+PNMI_STATIC int Mac8023Stat(SK_AC *pAC, SK_IOC IoC, int action, SK_U32 Id,
+	char *pBuf, unsigned int *pLen, SK_U32 Instance,
+	unsigned int TableIndex, SK_U32 NetIndex);
+PNMI_STATIC int MacPrivateConf(SK_AC *pAC, SK_IOC IoC, int action, SK_U32 Id,
+	char *pBuf, unsigned int *pLen, SK_U32 Instance,
+	unsigned int TableIndex, SK_U32 NetIndex);
+PNMI_STATIC int MacPrivateStat(SK_AC *pAC, SK_IOC IoC, int action, SK_U32 Id,
+	char *pBuf, unsigned int *pLen, SK_U32 Instance,
+	unsigned int TableIndex, SK_U32 NetIndex);
+PNMI_STATIC int Monitor(SK_AC *pAC, SK_IOC IoC, int action,
+	SK_U32 Id, char *pBuf, unsigned int *pLen, SK_U32 Instance,
+	unsigned int TableIndex, SK_U32 NetIndex);
+PNMI_STATIC int OidStruct(SK_AC *pAC, SK_IOC IoC, int action, SK_U32 Id,
+	char *pBuf, unsigned int *pLen, SK_U32 Instance,
+	unsigned int TableIndex, SK_U32 NetIndex);
+PNMI_STATIC int Perform(SK_AC *pAC, SK_IOC IoC, int action, SK_U32 Id,
+	char *pBuf, unsigned int* pLen, SK_U32 Instance,
+	unsigned int TableIndex, SK_U32 NetIndex);
+PNMI_STATIC int Rlmt(SK_AC *pAC, SK_IOC IoC, int action, SK_U32 Id,
+	char *pBuf, unsigned int *pLen, SK_U32 Instance,
+	unsigned int TableIndex, SK_U32 NetIndex);
+PNMI_STATIC int RlmtStat(SK_AC *pAC, SK_IOC IoC, int action, SK_U32 Id,
+	char *pBuf, unsigned int *pLen, SK_U32 Instance,
+	unsigned int TableIndex, SK_U32 NetIndex);
+PNMI_STATIC int SensorStat(SK_AC *pAC, SK_IOC IoC, int action, SK_U32 Id,
+	char *pBuf, unsigned int *pLen, SK_U32 Instance,
+	unsigned int TableIndex, SK_U32 NetIndex);
+PNMI_STATIC int Vpd(SK_AC *pAC, SK_IOC IoC, int action, SK_U32 Id,
+	char *pBuf, unsigned int *pLen, SK_U32 Instance,
+	unsigned int TableIndex, SK_U32 NetIndex);
+PNMI_STATIC int Vct(SK_AC *pAC, SK_IOC IoC, int action, SK_U32 Id,
+	char *pBuf, unsigned int *pLen, SK_U32 Instance,
+	unsigned int TableIndex, SK_U32 NetIndex);
+
+#ifdef SK_POWER_MGMT
+PNMI_STATIC int PowerManagement(SK_AC *pAC, SK_IOC IoC, int action, SK_U32 Id,
+	char *pBuf, unsigned int *pLen, SK_U32 Instance,
+	unsigned int TableIndex, SK_U32 NetIndex);
+#endif
+
+
+
+/* defines *******************************************************************/
+#define ID_TABLE_SIZE (sizeof(IdTable)/sizeof(IdTable[0]))
+
+
+/* global variables **********************************************************/
+
+/*
+ * Table to correlate OID with handler function and index to
+ * hardware register stored in StatAddress if applicable.
+ */
+PNMI_STATIC const SK_PNMI_TAB_ENTRY IdTable[] = {
+	{OID_GEN_XMIT_OK,
+		0,
+		0,
+		0,
+		SK_PNMI_RO, Mac8023Stat, SK_PNMI_HTX},
+	{OID_GEN_RCV_OK,
+		0,
+		0,
+		0,
+		SK_PNMI_RO, Mac8023Stat, SK_PNMI_HRX},
+	{OID_GEN_XMIT_ERROR,
+		0,
+		0,
+		0,
+		SK_PNMI_RO, General, 0},
+	{OID_GEN_RCV_ERROR,
+		0,
+		0,
+		0,
+		SK_PNMI_RO, General, 0},
+	{OID_GEN_RCV_NO_BUFFER,
+		0,
+		0,
+		0,
+		SK_PNMI_RO, General, 0},
+	{OID_GEN_DIRECTED_FRAMES_XMIT,
+		0,
+		0,
+		0,
+		SK_PNMI_RO, Mac8023Stat, SK_PNMI_HTX_UNICAST},
+	{OID_GEN_MULTICAST_FRAMES_XMIT,
+		0,
+		0,
+		0,
+		SK_PNMI_RO, Mac8023Stat, SK_PNMI_HTX_MULTICAST},
+	{OID_GEN_BROADCAST_FRAMES_XMIT,
+		0,
+		0,
+		0,
+		SK_PNMI_RO, Mac8023Stat, SK_PNMI_HTX_BROADCAST},
+	{OID_GEN_DIRECTED_FRAMES_RCV,
+		0,
+		0,
+		0,
+		SK_PNMI_RO, Mac8023Stat, SK_PNMI_HRX_UNICAST},
+	{OID_GEN_MULTICAST_FRAMES_RCV,
+		0,
+		0,
+		0,
+		SK_PNMI_RO, Mac8023Stat, SK_PNMI_HRX_MULTICAST},
+	{OID_GEN_BROADCAST_FRAMES_RCV,
+		0,
+		0,
+		0,
+		SK_PNMI_RO, Mac8023Stat, SK_PNMI_HRX_BROADCAST},
+	{OID_GEN_RCV_CRC_ERROR,
+		0,
+		0,
+		0,
+		SK_PNMI_RO, Mac8023Stat, SK_PNMI_HRX_FCS},
+	{OID_GEN_TRANSMIT_QUEUE_LENGTH,
+		0,
+		0,
+		0,
+		SK_PNMI_RO, General, 0},
+	{OID_802_3_PERMANENT_ADDRESS,
+		0,
+		0,
+		0,
+		SK_PNMI_RO, Mac8023Stat, 0},
+	{OID_802_3_CURRENT_ADDRESS,
+		0,
+		0,
+		0,
+		SK_PNMI_RO, Mac8023Stat, 0},
+	{OID_802_3_RCV_ERROR_ALIGNMENT,
+		0,
+		0,
+		0,
+		SK_PNMI_RO, Mac8023Stat, SK_PNMI_HRX_FRAMING},
+	{OID_802_3_XMIT_ONE_COLLISION,
+		0,
+		0,
+		0,
+		SK_PNMI_RO, Mac8023Stat, SK_PNMI_HTX_SINGLE_COL},
+	{OID_802_3_XMIT_MORE_COLLISIONS,
+		0,
+		0,
+		0,
+		SK_PNMI_RO, Mac8023Stat, SK_PNMI_HTX_MULTI_COL},
+	{OID_802_3_XMIT_DEFERRED,
+		0,
+		0,
+		0,
+		SK_PNMI_RO, Mac8023Stat, SK_PNMI_HTX_DEFFERAL},
+	{OID_802_3_XMIT_MAX_COLLISIONS,
+		0,
+		0,
+		0,
+		SK_PNMI_RO, Mac8023Stat, SK_PNMI_HTX_EXCESS_COL},
+	{OID_802_3_RCV_OVERRUN,
+		0,
+		0,
+		0,
+		SK_PNMI_RO, Mac8023Stat, SK_PNMI_HRX_OVERFLOW},
+	{OID_802_3_XMIT_UNDERRUN,
+		0,
+		0,
+		0,
+		SK_PNMI_RO, Mac8023Stat, SK_PNMI_HTX_UNDERRUN},
+	{OID_802_3_XMIT_TIMES_CRS_LOST,
+		0,
+		0,
+		0,
+		SK_PNMI_RO, Mac8023Stat, SK_PNMI_HTX_CARRIER},
+	{OID_802_3_XMIT_LATE_COLLISIONS,
+		0,
+		0,
+		0,
+		SK_PNMI_RO, Mac8023Stat, SK_PNMI_HTX_LATE_COL},
+#ifdef SK_POWER_MGMT
+	{OID_PNP_CAPABILITIES,
+		0,
+		0,
+		0,
+		SK_PNMI_RO, PowerManagement, 0},
+	{OID_PNP_SET_POWER,
+		0,
+		0,
+		0,
+		SK_PNMI_WO, PowerManagement, 0},
+	{OID_PNP_QUERY_POWER,
+		0,
+		0,
+		0,
+		SK_PNMI_RO, PowerManagement, 0},
+	{OID_PNP_ADD_WAKE_UP_PATTERN,
+		0,
+		0,
+		0,
+		SK_PNMI_WO, PowerManagement, 0},
+	{OID_PNP_REMOVE_WAKE_UP_PATTERN,
+		0,
+		0,
+		0,
+		SK_PNMI_WO, PowerManagement, 0},
+	{OID_PNP_ENABLE_WAKE_UP,
+		0,
+		0,
+		0,
+		SK_PNMI_RW, PowerManagement, 0},
+#endif /* SK_POWER_MGMT */
+	{OID_SKGE_MDB_VERSION,
+		1,
+		0,
+		SK_PNMI_MAI_OFF(MgmtDBVersion),
+		SK_PNMI_RO, General, 0},
+	{OID_SKGE_SUPPORTED_LIST,
+		0,
+		0,
+		0,
+		SK_PNMI_RO, General, 0},
+	{OID_SKGE_ALL_DATA,
+		0,
+		0,
+		0,
+		SK_PNMI_RW, OidStruct, 0},
+	{OID_SKGE_VPD_FREE_BYTES,
+		1,
+		0,
+		SK_PNMI_MAI_OFF(VpdFreeBytes),
+		SK_PNMI_RO, Vpd, 0},
+	{OID_SKGE_VPD_ENTRIES_LIST,
+		1,
+		0,
+		SK_PNMI_MAI_OFF(VpdEntriesList),
+		SK_PNMI_RO, Vpd, 0},
+	{OID_SKGE_VPD_ENTRIES_NUMBER,
+		1,
+		0,
+		SK_PNMI_MAI_OFF(VpdEntriesNumber),
+		SK_PNMI_RO, Vpd, 0},
+	{OID_SKGE_VPD_KEY,
+		SK_PNMI_VPD_ENTRIES,
+		sizeof(SK_PNMI_VPD),
+		SK_PNMI_OFF(Vpd) + SK_PNMI_VPD_OFF(VpdKey),
+		SK_PNMI_RO, Vpd, 0},
+	{OID_SKGE_VPD_VALUE,
+		SK_PNMI_VPD_ENTRIES,
+		sizeof(SK_PNMI_VPD),
+		SK_PNMI_OFF(Vpd) + SK_PNMI_VPD_OFF(VpdValue),
+		SK_PNMI_RO, Vpd, 0},
+	{OID_SKGE_VPD_ACCESS,
+		SK_PNMI_VPD_ENTRIES,
+		sizeof(SK_PNMI_VPD),
+		SK_PNMI_OFF(Vpd) + SK_PNMI_VPD_OFF(VpdAccess),
+		SK_PNMI_RO, Vpd, 0},
+	{OID_SKGE_VPD_ACTION,
+		SK_PNMI_VPD_ENTRIES,
+		sizeof(SK_PNMI_VPD),
+		SK_PNMI_OFF(Vpd) + SK_PNMI_VPD_OFF(VpdAction),
+		SK_PNMI_RW, Vpd, 0},
+	{OID_SKGE_PORT_NUMBER,		
+		1,
+		0,
+		SK_PNMI_MAI_OFF(PortNumber),
+		SK_PNMI_RO, General, 0},
+	{OID_SKGE_DEVICE_TYPE,
+		1,
+		0,
+		SK_PNMI_MAI_OFF(DeviceType),
+		SK_PNMI_RO, General, 0},
+	{OID_SKGE_DRIVER_DESCR,
+		1,
+		0,
+		SK_PNMI_MAI_OFF(DriverDescr),
+		SK_PNMI_RO, General, 0},
+	{OID_SKGE_DRIVER_VERSION,
+		1,
+		0,
+		SK_PNMI_MAI_OFF(DriverVersion),
+		SK_PNMI_RO, General, 0},
+	{OID_SKGE_HW_DESCR,
+		1,
+		0,
+		SK_PNMI_MAI_OFF(HwDescr),
+		SK_PNMI_RO, General, 0},
+	{OID_SKGE_HW_VERSION,
+		1,
+		0,
+		SK_PNMI_MAI_OFF(HwVersion),
+		SK_PNMI_RO, General, 0},
+	{OID_SKGE_CHIPSET,
+		1,
+		0,
+		SK_PNMI_MAI_OFF(Chipset),
+		SK_PNMI_RO, General, 0},
+	{OID_SKGE_ACTION,
+		1,
+		0,
+		SK_PNMI_MAI_OFF(Action),
+		SK_PNMI_RW, Perform, 0},
+	{OID_SKGE_RESULT,
+		1,
+		0,
+		SK_PNMI_MAI_OFF(TestResult),
+		SK_PNMI_RO, General, 0},
+	{OID_SKGE_BUS_TYPE,
+		1,
+		0,
+		SK_PNMI_MAI_OFF(BusType),
+		SK_PNMI_RO, General, 0},
+	{OID_SKGE_BUS_SPEED,
+		1,
+		0,
+		SK_PNMI_MAI_OFF(BusSpeed),
+		SK_PNMI_RO, General, 0},
+	{OID_SKGE_BUS_WIDTH,
+		1,
+		0,
+		SK_PNMI_MAI_OFF(BusWidth),
+		SK_PNMI_RO, General, 0},
+	{OID_SKGE_TX_SW_QUEUE_LEN,
+		1,
+		0,
+		SK_PNMI_MAI_OFF(TxSwQueueLen),
+		SK_PNMI_RO, General, 0},
+	{OID_SKGE_TX_SW_QUEUE_MAX,
+		1,
+		0,
+		SK_PNMI_MAI_OFF(TxSwQueueMax),
+		SK_PNMI_RO, General, 0},
+	{OID_SKGE_TX_RETRY,
+		1,
+		0,
+		SK_PNMI_MAI_OFF(TxRetryCts),
+		SK_PNMI_RO, General, 0},
+	{OID_SKGE_RX_INTR_CTS,
+		1,
+		0,
+		SK_PNMI_MAI_OFF(RxIntrCts),
+		SK_PNMI_RO, General, 0},
+	{OID_SKGE_TX_INTR_CTS,
+		1,
+		0,
+		SK_PNMI_MAI_OFF(TxIntrCts),
+		SK_PNMI_RO, General, 0},
+	{OID_SKGE_RX_NO_BUF_CTS,
+		1,
+		0,
+		SK_PNMI_MAI_OFF(RxNoBufCts),
+		SK_PNMI_RO, General, 0},
+	{OID_SKGE_TX_NO_BUF_CTS,
+		1,
+		0,
+		SK_PNMI_MAI_OFF(TxNoBufCts),
+		SK_PNMI_RO, General, 0},
+	{OID_SKGE_TX_USED_DESCR_NO,
+		1,
+		0,
+		SK_PNMI_MAI_OFF(TxUsedDescrNo),
+		SK_PNMI_RO, General, 0},
+	{OID_SKGE_RX_DELIVERED_CTS,
+		1,
+		0,
+		SK_PNMI_MAI_OFF(RxDeliveredCts),
+		SK_PNMI_RO, General, 0},
+	{OID_SKGE_RX_OCTETS_DELIV_CTS,
+		1,
+		0,
+		SK_PNMI_MAI_OFF(RxOctetsDeliveredCts),
+		SK_PNMI_RO, General, 0},
+	{OID_SKGE_RX_HW_ERROR_CTS,
+		1,
+		0,
+		SK_PNMI_MAI_OFF(RxHwErrorsCts),
+		SK_PNMI_RO, General, 0},
+	{OID_SKGE_TX_HW_ERROR_CTS,
+		1,
+		0,
+		SK_PNMI_MAI_OFF(TxHwErrorsCts),
+		SK_PNMI_RO, General, 0},
+	{OID_SKGE_IN_ERRORS_CTS,
+		1,
+		0,
+		SK_PNMI_MAI_OFF(InErrorsCts),
+		SK_PNMI_RO, General, 0},
+	{OID_SKGE_OUT_ERROR_CTS,
+		1,
+		0,
+		SK_PNMI_MAI_OFF(OutErrorsCts),
+		SK_PNMI_RO, General, 0},
+	{OID_SKGE_ERR_RECOVERY_CTS,
+		1,
+		0,
+		SK_PNMI_MAI_OFF(ErrRecoveryCts),
+		SK_PNMI_RO, General, 0},
+	{OID_SKGE_SYSUPTIME,
+		1,
+		0,
+		SK_PNMI_MAI_OFF(SysUpTime),
+		SK_PNMI_RO, General, 0},
+	{OID_SKGE_SENSOR_NUMBER,
+		1,
+		0,
+		SK_PNMI_MAI_OFF(SensorNumber),
+		SK_PNMI_RO, General, 0},
+	{OID_SKGE_SENSOR_INDEX,
+		SK_PNMI_SENSOR_ENTRIES,
+		sizeof(SK_PNMI_SENSOR),
+		SK_PNMI_OFF(Sensor) + SK_PNMI_SEN_OFF(SensorIndex),
+		SK_PNMI_RO, SensorStat, 0},
+	{OID_SKGE_SENSOR_DESCR,
+		SK_PNMI_SENSOR_ENTRIES,
+		sizeof(SK_PNMI_SENSOR),
+		SK_PNMI_OFF(Sensor) + SK_PNMI_SEN_OFF(SensorDescr),
+		SK_PNMI_RO, SensorStat, 0},
+	{OID_SKGE_SENSOR_TYPE,
+		SK_PNMI_SENSOR_ENTRIES,
+		sizeof(SK_PNMI_SENSOR),
+		SK_PNMI_OFF(Sensor) + SK_PNMI_SEN_OFF(SensorType),
+		SK_PNMI_RO, SensorStat, 0},
+	{OID_SKGE_SENSOR_VALUE,
+		SK_PNMI_SENSOR_ENTRIES,
+		sizeof(SK_PNMI_SENSOR),
+		SK_PNMI_OFF(Sensor) + SK_PNMI_SEN_OFF(SensorValue),
+		SK_PNMI_RO, SensorStat, 0},
+	{OID_SKGE_SENSOR_WAR_THRES_LOW,
+		SK_PNMI_SENSOR_ENTRIES,
+		sizeof(SK_PNMI_SENSOR),
+		SK_PNMI_OFF(Sensor) + SK_PNMI_SEN_OFF(SensorWarningThresholdLow),
+		SK_PNMI_RO, SensorStat, 0},
+	{OID_SKGE_SENSOR_WAR_THRES_UPP,
+		SK_PNMI_SENSOR_ENTRIES,
+		sizeof(SK_PNMI_SENSOR),
+		SK_PNMI_OFF(Sensor) + SK_PNMI_SEN_OFF(SensorWarningThresholdHigh),
+		SK_PNMI_RO, SensorStat, 0},
+	{OID_SKGE_SENSOR_ERR_THRES_LOW,
+		SK_PNMI_SENSOR_ENTRIES,
+		sizeof(SK_PNMI_SENSOR),
+		SK_PNMI_OFF(Sensor) + SK_PNMI_SEN_OFF(SensorErrorThresholdLow),
+		SK_PNMI_RO, SensorStat, 0},
+	{OID_SKGE_SENSOR_ERR_THRES_UPP,
+		SK_PNMI_SENSOR_ENTRIES,
+		sizeof(SK_PNMI_SENSOR),
+		SK_PNMI_OFF(Sensor) + SK_PNMI_SEN_OFF(SensorErrorThresholdHigh),
+		SK_PNMI_RO, SensorStat, 0},
+	{OID_SKGE_SENSOR_STATUS,
+		SK_PNMI_SENSOR_ENTRIES,
+		sizeof(SK_PNMI_SENSOR),
+		SK_PNMI_OFF(Sensor) + SK_PNMI_SEN_OFF(SensorStatus),
+		SK_PNMI_RO, SensorStat, 0},
+	{OID_SKGE_SENSOR_WAR_CTS,
+		SK_PNMI_SENSOR_ENTRIES,
+		sizeof(SK_PNMI_SENSOR),
+		SK_PNMI_OFF(Sensor) + SK_PNMI_SEN_OFF(SensorWarningCts),
+		SK_PNMI_RO, SensorStat, 0},
+	{OID_SKGE_SENSOR_ERR_CTS,
+		SK_PNMI_SENSOR_ENTRIES,
+		sizeof(SK_PNMI_SENSOR),
+		SK_PNMI_OFF(Sensor) + SK_PNMI_SEN_OFF(SensorErrorCts),
+		SK_PNMI_RO, SensorStat, 0},
+	{OID_SKGE_SENSOR_WAR_TIME,
+		SK_PNMI_SENSOR_ENTRIES,
+		sizeof(SK_PNMI_SENSOR),
+		SK_PNMI_OFF(Sensor) + SK_PNMI_SEN_OFF(SensorWarningTimestamp),
+		SK_PNMI_RO, SensorStat, 0},
+	{OID_SKGE_SENSOR_ERR_TIME,
+		SK_PNMI_SENSOR_ENTRIES,
+		sizeof(SK_PNMI_SENSOR),
+		SK_PNMI_OFF(Sensor) + SK_PNMI_SEN_OFF(SensorErrorTimestamp),
+		SK_PNMI_RO, SensorStat, 0},
+	{OID_SKGE_CHKSM_NUMBER,
+		1,
+		0,
+		SK_PNMI_MAI_OFF(ChecksumNumber),
+		SK_PNMI_RO, General, 0},
+	{OID_SKGE_CHKSM_RX_OK_CTS,
+		SKCS_NUM_PROTOCOLS,
+		sizeof(SK_PNMI_CHECKSUM),
+		SK_PNMI_OFF(Checksum) + SK_PNMI_CHK_OFF(ChecksumRxOkCts),
+		SK_PNMI_RO, CsumStat, 0},
+	{OID_SKGE_CHKSM_RX_UNABLE_CTS,
+		SKCS_NUM_PROTOCOLS,
+		sizeof(SK_PNMI_CHECKSUM),
+		SK_PNMI_OFF(Checksum) + SK_PNMI_CHK_OFF(ChecksumRxUnableCts),
+		SK_PNMI_RO, CsumStat, 0},
+	{OID_SKGE_CHKSM_RX_ERR_CTS,
+		SKCS_NUM_PROTOCOLS,
+		sizeof(SK_PNMI_CHECKSUM),
+		SK_PNMI_OFF(Checksum) + SK_PNMI_CHK_OFF(ChecksumRxErrCts),
+		SK_PNMI_RO, CsumStat, 0},
+	{OID_SKGE_CHKSM_TX_OK_CTS,
+		SKCS_NUM_PROTOCOLS,
+		sizeof(SK_PNMI_CHECKSUM),
+		SK_PNMI_OFF(Checksum) + SK_PNMI_CHK_OFF(ChecksumTxOkCts),
+		SK_PNMI_RO, CsumStat, 0},
+	{OID_SKGE_CHKSM_TX_UNABLE_CTS,
+		SKCS_NUM_PROTOCOLS,
+		sizeof(SK_PNMI_CHECKSUM),
+		SK_PNMI_OFF(Checksum) + SK_PNMI_CHK_OFF(ChecksumTxUnableCts),
+		SK_PNMI_RO, CsumStat, 0},
+	{OID_SKGE_STAT_TX,
+		SK_PNMI_MAC_ENTRIES,
+		sizeof(SK_PNMI_STAT),
+		SK_PNMI_OFF(Stat) + SK_PNMI_STA_OFF(StatTxOkCts),
+		SK_PNMI_RO, MacPrivateStat, SK_PNMI_HTX},
+	{OID_SKGE_STAT_TX_OCTETS,
+		SK_PNMI_MAC_ENTRIES,
+		sizeof(SK_PNMI_STAT),
+		SK_PNMI_OFF(Stat) + SK_PNMI_STA_OFF(StatTxOctetsOkCts),
+		SK_PNMI_RO, MacPrivateStat, SK_PNMI_HTX_OCTET},
+	{OID_SKGE_STAT_TX_BROADCAST,
+		SK_PNMI_MAC_ENTRIES,
+		sizeof(SK_PNMI_STAT),
+		SK_PNMI_OFF(Stat) + SK_PNMI_STA_OFF(StatTxBroadcastOkCts),
+		SK_PNMI_RO, MacPrivateStat, SK_PNMI_HTX_BROADCAST},
+	{OID_SKGE_STAT_TX_MULTICAST,
+		SK_PNMI_MAC_ENTRIES,
+		sizeof(SK_PNMI_STAT),
+		SK_PNMI_OFF(Stat) + SK_PNMI_STA_OFF(StatTxMulticastOkCts),
+		SK_PNMI_RO, MacPrivateStat, SK_PNMI_HTX_MULTICAST},
+	{OID_SKGE_STAT_TX_UNICAST,
+		SK_PNMI_MAC_ENTRIES,
+		sizeof(SK_PNMI_STAT),
+		SK_PNMI_OFF(Stat) + SK_PNMI_STA_OFF(StatTxUnicastOkCts),
+		SK_PNMI_RO, MacPrivateStat, SK_PNMI_HTX_UNICAST},
+	{OID_SKGE_STAT_TX_LONGFRAMES,
+		SK_PNMI_MAC_ENTRIES,
+		sizeof(SK_PNMI_STAT),
+		SK_PNMI_OFF(Stat) + SK_PNMI_STA_OFF(StatTxLongFramesCts),
+		SK_PNMI_RO, MacPrivateStat, SK_PNMI_HTX_LONGFRAMES},
+	{OID_SKGE_STAT_TX_BURST,
+		SK_PNMI_MAC_ENTRIES,
+		sizeof(SK_PNMI_STAT),
+		SK_PNMI_OFF(Stat) + SK_PNMI_STA_OFF(StatTxBurstCts),
+		SK_PNMI_RO, MacPrivateStat, SK_PNMI_HTX_BURST},
+	{OID_SKGE_STAT_TX_PFLOWC,
+		SK_PNMI_MAC_ENTRIES,
+		sizeof(SK_PNMI_STAT),
+		SK_PNMI_OFF(Stat) + SK_PNMI_STA_OFF(StatTxPauseMacCtrlCts),
+		SK_PNMI_RO, MacPrivateStat, SK_PNMI_HTX_PMACC},
+	{OID_SKGE_STAT_TX_FLOWC,
+		SK_PNMI_MAC_ENTRIES,
+		sizeof(SK_PNMI_STAT),
+		SK_PNMI_OFF(Stat) + SK_PNMI_STA_OFF(StatTxMacCtrlCts),
+		SK_PNMI_RO, MacPrivateStat, SK_PNMI_HTX_MACC},
+	{OID_SKGE_STAT_TX_SINGLE_COL,
+		SK_PNMI_MAC_ENTRIES,
+		sizeof(SK_PNMI_STAT),
+		SK_PNMI_OFF(Stat) + SK_PNMI_STA_OFF(StatTxSingleCollisionCts),
+		SK_PNMI_RO, MacPrivateStat, SK_PNMI_HTX_SINGLE_COL},
+	{OID_SKGE_STAT_TX_MULTI_COL,
+		SK_PNMI_MAC_ENTRIES,
+		sizeof(SK_PNMI_STAT),
+		SK_PNMI_OFF(Stat) + SK_PNMI_STA_OFF(StatTxMultipleCollisionCts),
+		SK_PNMI_RO, MacPrivateStat, SK_PNMI_HTX_MULTI_COL},
+	{OID_SKGE_STAT_TX_EXCESS_COL,
+		SK_PNMI_MAC_ENTRIES,
+		sizeof(SK_PNMI_STAT),
+		SK_PNMI_OFF(Stat) + SK_PNMI_STA_OFF(StatTxExcessiveCollisionCts),
+		SK_PNMI_RO, MacPrivateStat, SK_PNMI_HTX_EXCESS_COL},
+	{OID_SKGE_STAT_TX_LATE_COL,
+		SK_PNMI_MAC_ENTRIES,
+		sizeof(SK_PNMI_STAT),
+		SK_PNMI_OFF(Stat) + SK_PNMI_STA_OFF(StatTxLateCollisionCts),
+		SK_PNMI_RO, MacPrivateStat, SK_PNMI_HTX_LATE_COL},
+	{OID_SKGE_STAT_TX_DEFFERAL,
+		SK_PNMI_MAC_ENTRIES,
+		sizeof(SK_PNMI_STAT),
+		SK_PNMI_OFF(Stat) + SK_PNMI_STA_OFF(StatTxDeferralCts),
+		SK_PNMI_RO, MacPrivateStat, SK_PNMI_HTX_DEFFERAL},
+	{OID_SKGE_STAT_TX_EXCESS_DEF,
+		SK_PNMI_MAC_ENTRIES,
+		sizeof(SK_PNMI_STAT),
+		SK_PNMI_OFF(Stat) + SK_PNMI_STA_OFF(StatTxExcessiveDeferralCts),
+		SK_PNMI_RO, MacPrivateStat, SK_PNMI_HTX_EXCESS_DEF},
+	{OID_SKGE_STAT_TX_UNDERRUN,
+		SK_PNMI_MAC_ENTRIES,
+		sizeof(SK_PNMI_STAT),
+		SK_PNMI_OFF(Stat) + SK_PNMI_STA_OFF(StatTxFifoUnderrunCts),
+		SK_PNMI_RO, MacPrivateStat, SK_PNMI_HTX_UNDERRUN},
+	{OID_SKGE_STAT_TX_CARRIER,
+		SK_PNMI_MAC_ENTRIES,
+		sizeof(SK_PNMI_STAT),
+		SK_PNMI_OFF(Stat) + SK_PNMI_STA_OFF(StatTxCarrierCts),
+		SK_PNMI_RO, MacPrivateStat, SK_PNMI_HTX_CARRIER},
+/*	{OID_SKGE_STAT_TX_UTIL,
+		SK_PNMI_MAC_ENTRIES,
+		sizeof(SK_PNMI_STAT),
+		SK_PNMI_OFF(Stat) + SK_PNMI_STA_OFF(StatTxUtilization),
+		SK_PNMI_RO, MacPrivateStat, (SK_U16)(-1)}, */
+	{OID_SKGE_STAT_TX_64,
+		SK_PNMI_MAC_ENTRIES,
+		sizeof(SK_PNMI_STAT),
+		SK_PNMI_OFF(Stat) + SK_PNMI_STA_OFF(StatTx64Cts),
+		SK_PNMI_RO, MacPrivateStat, SK_PNMI_HTX_64},
+	{OID_SKGE_STAT_TX_127,
+		SK_PNMI_MAC_ENTRIES,
+		sizeof(SK_PNMI_STAT),
+		SK_PNMI_OFF(Stat) + SK_PNMI_STA_OFF(StatTx127Cts),
+		SK_PNMI_RO, MacPrivateStat, SK_PNMI_HTX_127},
+	{OID_SKGE_STAT_TX_255,
+		SK_PNMI_MAC_ENTRIES,
+		sizeof(SK_PNMI_STAT),
+		SK_PNMI_OFF(Stat) + SK_PNMI_STA_OFF(StatTx255Cts),
+		SK_PNMI_RO, MacPrivateStat, SK_PNMI_HTX_255},
+	{OID_SKGE_STAT_TX_511,
+		SK_PNMI_MAC_ENTRIES,
+		sizeof(SK_PNMI_STAT),
+		SK_PNMI_OFF(Stat) + SK_PNMI_STA_OFF(StatTx511Cts),
+		SK_PNMI_RO, MacPrivateStat, SK_PNMI_HTX_511},
+	{OID_SKGE_STAT_TX_1023,
+		SK_PNMI_MAC_ENTRIES,
+		sizeof(SK_PNMI_STAT),
+		SK_PNMI_OFF(Stat) + SK_PNMI_STA_OFF(StatTx1023Cts),
+		SK_PNMI_RO, MacPrivateStat, SK_PNMI_HTX_1023},
+	{OID_SKGE_STAT_TX_MAX,
+		SK_PNMI_MAC_ENTRIES,
+		sizeof(SK_PNMI_STAT),
+		SK_PNMI_OFF(Stat) + SK_PNMI_STA_OFF(StatTxMaxCts),
+		SK_PNMI_RO, MacPrivateStat, SK_PNMI_HTX_MAX},
+	{OID_SKGE_STAT_TX_SYNC,
+		SK_PNMI_MAC_ENTRIES,
+		sizeof(SK_PNMI_STAT),
+		SK_PNMI_OFF(Stat) + SK_PNMI_STA_OFF(StatTxSyncCts),
+		SK_PNMI_RO, MacPrivateStat, SK_PNMI_HTX_SYNC},
+	{OID_SKGE_STAT_TX_SYNC_OCTETS,
+		SK_PNMI_MAC_ENTRIES,
+		sizeof(SK_PNMI_STAT),
+		SK_PNMI_OFF(Stat) + SK_PNMI_STA_OFF(StatTxSyncOctetsCts),
+		SK_PNMI_RO, MacPrivateStat, SK_PNMI_HTX_SYNC_OCTET},
+	{OID_SKGE_STAT_RX,
+		SK_PNMI_MAC_ENTRIES,
+		sizeof(SK_PNMI_STAT),
+		SK_PNMI_OFF(Stat) + SK_PNMI_STA_OFF(StatRxOkCts),
+		SK_PNMI_RO, MacPrivateStat, SK_PNMI_HRX},
+	{OID_SKGE_STAT_RX_OCTETS,
+		SK_PNMI_MAC_ENTRIES,
+		sizeof(SK_PNMI_STAT),
+		SK_PNMI_OFF(Stat) + SK_PNMI_STA_OFF(StatRxOctetsOkCts),
+		SK_PNMI_RO, MacPrivateStat, SK_PNMI_HRX_OCTET},
+	{OID_SKGE_STAT_RX_BROADCAST,
+		SK_PNMI_MAC_ENTRIES,
+		sizeof(SK_PNMI_STAT),
+		SK_PNMI_OFF(Stat) + SK_PNMI_STA_OFF(StatRxBroadcastOkCts),
+		SK_PNMI_RO, MacPrivateStat, SK_PNMI_HRX_BROADCAST},
+	{OID_SKGE_STAT_RX_MULTICAST,
+		SK_PNMI_MAC_ENTRIES,
+		sizeof(SK_PNMI_STAT),
+		SK_PNMI_OFF(Stat) + SK_PNMI_STA_OFF(StatRxMulticastOkCts),
+		SK_PNMI_RO, MacPrivateStat, SK_PNMI_HRX_MULTICAST},
+	{OID_SKGE_STAT_RX_UNICAST,
+		SK_PNMI_MAC_ENTRIES,
+		sizeof(SK_PNMI_STAT),
+		SK_PNMI_OFF(Stat) + SK_PNMI_STA_OFF(StatRxUnicastOkCts),
+		SK_PNMI_RO, MacPrivateStat, SK_PNMI_HRX_UNICAST},
+	{OID_SKGE_STAT_RX_LONGFRAMES,
+		SK_PNMI_MAC_ENTRIES,
+		sizeof(SK_PNMI_STAT),
+		SK_PNMI_OFF(Stat) + SK_PNMI_STA_OFF(StatRxLongFramesCts),
+		SK_PNMI_RO, MacPrivateStat, SK_PNMI_HRX_LONGFRAMES},
+	{OID_SKGE_STAT_RX_PFLOWC,
+		SK_PNMI_MAC_ENTRIES,
+		sizeof(SK_PNMI_STAT),
+		SK_PNMI_OFF(Stat) + SK_PNMI_STA_OFF(StatRxPauseMacCtrlCts),
+		SK_PNMI_RO, MacPrivateStat, SK_PNMI_HRX_PMACC},
+	{OID_SKGE_STAT_RX_FLOWC,
+		SK_PNMI_MAC_ENTRIES,
+		sizeof(SK_PNMI_STAT),
+		SK_PNMI_OFF(Stat) + SK_PNMI_STA_OFF(StatRxMacCtrlCts),
+		SK_PNMI_RO, MacPrivateStat, SK_PNMI_HRX_MACC},
+	{OID_SKGE_STAT_RX_PFLOWC_ERR,
+		SK_PNMI_MAC_ENTRIES,
+		sizeof(SK_PNMI_STAT),
+		SK_PNMI_OFF(Stat) + SK_PNMI_STA_OFF(StatRxPauseMacCtrlErrorCts),
+		SK_PNMI_RO, MacPrivateStat, SK_PNMI_HRX_PMACC_ERR},
+	{OID_SKGE_STAT_RX_FLOWC_UNKWN,
+		SK_PNMI_MAC_ENTRIES,
+		sizeof(SK_PNMI_STAT),
+		SK_PNMI_OFF(Stat) + SK_PNMI_STA_OFF(StatRxMacCtrlUnknownCts),
+		SK_PNMI_RO, MacPrivateStat, SK_PNMI_HRX_MACC_UNKWN},
+	{OID_SKGE_STAT_RX_BURST,
+		SK_PNMI_MAC_ENTRIES,
+		sizeof(SK_PNMI_STAT),
+		SK_PNMI_OFF(Stat) + SK_PNMI_STA_OFF(StatRxBurstCts),
+		SK_PNMI_RO, MacPrivateStat, SK_PNMI_HRX_BURST},
+	{OID_SKGE_STAT_RX_MISSED,
+		SK_PNMI_MAC_ENTRIES,
+		sizeof(SK_PNMI_STAT),
+		SK_PNMI_OFF(Stat) + SK_PNMI_STA_OFF(StatRxMissedCts),
+		SK_PNMI_RO, MacPrivateStat, SK_PNMI_HRX_MISSED},
+	{OID_SKGE_STAT_RX_FRAMING,
+		SK_PNMI_MAC_ENTRIES,
+		sizeof(SK_PNMI_STAT),
+		SK_PNMI_OFF(Stat) + SK_PNMI_STA_OFF(StatRxFramingCts),
+		SK_PNMI_RO, MacPrivateStat, SK_PNMI_HRX_FRAMING},
+	{OID_SKGE_STAT_RX_OVERFLOW,
+		SK_PNMI_MAC_ENTRIES,
+		sizeof(SK_PNMI_STAT),
+		SK_PNMI_OFF(Stat) + SK_PNMI_STA_OFF(StatRxFifoOverflowCts),
+		SK_PNMI_RO, MacPrivateStat, SK_PNMI_HRX_OVERFLOW},
+	{OID_SKGE_STAT_RX_JABBER,
+		SK_PNMI_MAC_ENTRIES,
+		sizeof(SK_PNMI_STAT),
+		SK_PNMI_OFF(Stat) + SK_PNMI_STA_OFF(StatRxJabberCts),
+		SK_PNMI_RO, MacPrivateStat, SK_PNMI_HRX_JABBER},
+	{OID_SKGE_STAT_RX_CARRIER,
+		SK_PNMI_MAC_ENTRIES,
+		sizeof(SK_PNMI_STAT),
+		SK_PNMI_OFF(Stat) + SK_PNMI_STA_OFF(StatRxCarrierCts),
+		SK_PNMI_RO, MacPrivateStat, SK_PNMI_HRX_CARRIER},
+	{OID_SKGE_STAT_RX_IR_LENGTH,
+		SK_PNMI_MAC_ENTRIES,
+		sizeof(SK_PNMI_STAT),
+		SK_PNMI_OFF(Stat) + SK_PNMI_STA_OFF(StatRxIRLengthCts),
+		SK_PNMI_RO, MacPrivateStat, SK_PNMI_HRX_IRLENGTH},
+	{OID_SKGE_STAT_RX_SYMBOL,
+		SK_PNMI_MAC_ENTRIES,
+		sizeof(SK_PNMI_STAT),
+		SK_PNMI_OFF(Stat) + SK_PNMI_STA_OFF(StatRxSymbolCts),
+		SK_PNMI_RO, MacPrivateStat, SK_PNMI_HRX_SYMBOL},
+	{OID_SKGE_STAT_RX_SHORTS,
+		SK_PNMI_MAC_ENTRIES,
+		sizeof(SK_PNMI_STAT),
+		SK_PNMI_OFF(Stat) + SK_PNMI_STA_OFF(StatRxShortsCts),
+		SK_PNMI_RO, MacPrivateStat, SK_PNMI_HRX_SHORTS},
+	{OID_SKGE_STAT_RX_RUNT,
+		SK_PNMI_MAC_ENTRIES,
+		sizeof(SK_PNMI_STAT),
+		SK_PNMI_OFF(Stat) + SK_PNMI_STA_OFF(StatRxRuntCts),
+		SK_PNMI_RO, MacPrivateStat, SK_PNMI_HRX_RUNT},
+	{OID_SKGE_STAT_RX_CEXT,
+		SK_PNMI_MAC_ENTRIES,
+		sizeof(SK_PNMI_STAT),
+		SK_PNMI_OFF(Stat) + SK_PNMI_STA_OFF(StatRxCextCts),
+		SK_PNMI_RO, MacPrivateStat, SK_PNMI_HRX_CEXT},
+	{OID_SKGE_STAT_RX_TOO_LONG,
+		SK_PNMI_MAC_ENTRIES,
+		sizeof(SK_PNMI_STAT),
+		SK_PNMI_OFF(Stat) + SK_PNMI_STA_OFF(StatRxTooLongCts),
+		SK_PNMI_RO, MacPrivateStat, SK_PNMI_HRX_TOO_LONG},
+	{OID_SKGE_STAT_RX_FCS,
+		SK_PNMI_MAC_ENTRIES,
+		sizeof(SK_PNMI_STAT),
+		SK_PNMI_OFF(Stat) + SK_PNMI_STA_OFF(StatRxFcsCts),
+		SK_PNMI_RO, MacPrivateStat, SK_PNMI_HRX_FCS},
+/*	{OID_SKGE_STAT_RX_UTIL,
+		SK_PNMI_MAC_ENTRIES,
+		sizeof(SK_PNMI_STAT),
+		SK_PNMI_OFF(Stat) + SK_PNMI_STA_OFF(StatRxUtilization),
+		SK_PNMI_RO, MacPrivateStat, (SK_U16)(-1)}, */
+	{OID_SKGE_STAT_RX_64,
+		SK_PNMI_MAC_ENTRIES,
+		sizeof(SK_PNMI_STAT),
+		SK_PNMI_OFF(Stat) + SK_PNMI_STA_OFF(StatRx64Cts),
+		SK_PNMI_RO, MacPrivateStat, SK_PNMI_HRX_64},
+	{OID_SKGE_STAT_RX_127,
+		SK_PNMI_MAC_ENTRIES,
+		sizeof(SK_PNMI_STAT),
+		SK_PNMI_OFF(Stat) + SK_PNMI_STA_OFF(StatRx127Cts),
+		SK_PNMI_RO, MacPrivateStat, SK_PNMI_HRX_127},
+	{OID_SKGE_STAT_RX_255,
+		SK_PNMI_MAC_ENTRIES,
+		sizeof(SK_PNMI_STAT),
+		SK_PNMI_OFF(Stat) + SK_PNMI_STA_OFF(StatRx255Cts),
+		SK_PNMI_RO, MacPrivateStat, SK_PNMI_HRX_255},
+	{OID_SKGE_STAT_RX_511,
+		SK_PNMI_MAC_ENTRIES,
+		sizeof(SK_PNMI_STAT),
+		SK_PNMI_OFF(Stat) + SK_PNMI_STA_OFF(StatRx511Cts),
+		SK_PNMI_RO, MacPrivateStat, SK_PNMI_HRX_511},
+	{OID_SKGE_STAT_RX_1023,
+		SK_PNMI_MAC_ENTRIES,
+		sizeof(SK_PNMI_STAT),
+		SK_PNMI_OFF(Stat) + SK_PNMI_STA_OFF(StatRx1023Cts),
+		SK_PNMI_RO, MacPrivateStat, SK_PNMI_HRX_1023},
+	{OID_SKGE_STAT_RX_MAX,
+		SK_PNMI_MAC_ENTRIES,
+		sizeof(SK_PNMI_STAT),
+		SK_PNMI_OFF(Stat) + SK_PNMI_STA_OFF(StatRxMaxCts),
+		SK_PNMI_RO, MacPrivateStat, SK_PNMI_HRX_MAX},
+	{OID_SKGE_PHYS_CUR_ADDR,
+		SK_PNMI_MAC_ENTRIES,
+		sizeof(SK_PNMI_CONF),
+		SK_PNMI_OFF(Conf) + SK_PNMI_CNF_OFF(ConfMacCurrentAddr),
+		SK_PNMI_RW, Addr, 0},
+	{OID_SKGE_PHYS_FAC_ADDR,
+		SK_PNMI_MAC_ENTRIES,
+		sizeof(SK_PNMI_CONF),
+		SK_PNMI_OFF(Conf) + SK_PNMI_CNF_OFF(ConfMacFactoryAddr),
+		SK_PNMI_RO, Addr, 0},
+	{OID_SKGE_PMD,
+		SK_PNMI_MAC_ENTRIES,
+		sizeof(SK_PNMI_CONF),
+		SK_PNMI_OFF(Conf) + SK_PNMI_CNF_OFF(ConfPMD),
+		SK_PNMI_RO, MacPrivateConf, 0},
+	{OID_SKGE_CONNECTOR,
+		SK_PNMI_MAC_ENTRIES,
+		sizeof(SK_PNMI_CONF),
+		SK_PNMI_OFF(Conf) + SK_PNMI_CNF_OFF(ConfConnector),
+		SK_PNMI_RO, MacPrivateConf, 0},
+	{OID_SKGE_LINK_CAP,
+		SK_PNMI_MAC_ENTRIES,
+		sizeof(SK_PNMI_CONF),
+		SK_PNMI_OFF(Conf) + SK_PNMI_CNF_OFF(ConfLinkCapability),
+		SK_PNMI_RO, MacPrivateConf, 0},
+	{OID_SKGE_LINK_MODE,
+		SK_PNMI_MAC_ENTRIES,
+		sizeof(SK_PNMI_CONF),
+		SK_PNMI_OFF(Conf) + SK_PNMI_CNF_OFF(ConfLinkMode),
+		SK_PNMI_RW, MacPrivateConf, 0},
+	{OID_SKGE_LINK_MODE_STATUS,
+		SK_PNMI_MAC_ENTRIES,
+		sizeof(SK_PNMI_CONF),
+		SK_PNMI_OFF(Conf) + SK_PNMI_CNF_OFF(ConfLinkModeStatus),
+		SK_PNMI_RO, MacPrivateConf, 0},
+	{OID_SKGE_LINK_STATUS,
+		SK_PNMI_MAC_ENTRIES,
+		sizeof(SK_PNMI_CONF),
+		SK_PNMI_OFF(Conf) + SK_PNMI_CNF_OFF(ConfLinkStatus),
+		SK_PNMI_RO, MacPrivateConf, 0},
+	{OID_SKGE_FLOWCTRL_CAP,
+		SK_PNMI_MAC_ENTRIES,
+		sizeof(SK_PNMI_CONF),
+		SK_PNMI_OFF(Conf) + SK_PNMI_CNF_OFF(ConfFlowCtrlCapability),
+		SK_PNMI_RO, MacPrivateConf, 0},
+	{OID_SKGE_FLOWCTRL_MODE,
+		SK_PNMI_MAC_ENTRIES,
+		sizeof(SK_PNMI_CONF),
+		SK_PNMI_OFF(Conf) + SK_PNMI_CNF_OFF(ConfFlowCtrlMode),
+		SK_PNMI_RW, MacPrivateConf, 0},
+	{OID_SKGE_FLOWCTRL_STATUS,
+		SK_PNMI_MAC_ENTRIES,
+		sizeof(SK_PNMI_CONF),
+		SK_PNMI_OFF(Conf) + SK_PNMI_CNF_OFF(ConfFlowCtrlStatus),
+		SK_PNMI_RO, MacPrivateConf, 0},
+	{OID_SKGE_PHY_OPERATION_CAP,
+		SK_PNMI_MAC_ENTRIES,
+		sizeof(SK_PNMI_CONF),
+		SK_PNMI_OFF(Conf) + SK_PNMI_CNF_OFF(ConfPhyOperationCapability),
+		SK_PNMI_RO, MacPrivateConf, 0},
+	{OID_SKGE_PHY_OPERATION_MODE,
+		SK_PNMI_MAC_ENTRIES,
+		sizeof(SK_PNMI_CONF),
+		SK_PNMI_OFF(Conf) + SK_PNMI_CNF_OFF(ConfPhyOperationMode),
+		SK_PNMI_RW, MacPrivateConf, 0},
+	{OID_SKGE_PHY_OPERATION_STATUS,
+		SK_PNMI_MAC_ENTRIES,
+		sizeof(SK_PNMI_CONF),
+		SK_PNMI_OFF(Conf) + SK_PNMI_CNF_OFF(ConfPhyOperationStatus),
+		SK_PNMI_RO, MacPrivateConf, 0},
+	{OID_SKGE_SPEED_CAP,
+		SK_PNMI_MAC_ENTRIES,
+		sizeof(SK_PNMI_CONF),
+		SK_PNMI_OFF(Conf) + SK_PNMI_CNF_OFF(ConfSpeedCapability),
+		SK_PNMI_RO, MacPrivateConf, 0},
+	{OID_SKGE_SPEED_MODE,
+		SK_PNMI_MAC_ENTRIES,
+		sizeof(SK_PNMI_CONF),
+		SK_PNMI_OFF(Conf) + SK_PNMI_CNF_OFF(ConfSpeedMode),
+		SK_PNMI_RW, MacPrivateConf, 0},
+	{OID_SKGE_SPEED_STATUS,
+		SK_PNMI_MAC_ENTRIES,
+		sizeof(SK_PNMI_CONF),
+		SK_PNMI_OFF(Conf) + SK_PNMI_CNF_OFF(ConfSpeedStatus),
+		SK_PNMI_RO, MacPrivateConf, 0},
+	{OID_SKGE_TRAP,
+		1,
+		0,
+		SK_PNMI_MAI_OFF(Trap),
+		SK_PNMI_RO, General, 0},
+	{OID_SKGE_TRAP_NUMBER,
+		1,
+		0,
+		SK_PNMI_MAI_OFF(TrapNumber),
+		SK_PNMI_RO, General, 0},
+	{OID_SKGE_RLMT_MODE,
+		1,
+		0,
+		SK_PNMI_MAI_OFF(RlmtMode),
+		SK_PNMI_RW, Rlmt, 0},
+	{OID_SKGE_RLMT_PORT_NUMBER,
+		1,
+		0,
+		SK_PNMI_MAI_OFF(RlmtPortNumber),
+		SK_PNMI_RO, Rlmt, 0},
+	{OID_SKGE_RLMT_PORT_ACTIVE,
+		1,
+		0,
+		SK_PNMI_MAI_OFF(RlmtPortActive),
+		SK_PNMI_RO, Rlmt, 0},
+	{OID_SKGE_RLMT_PORT_PREFERRED,
+		1,
+		0,
+		SK_PNMI_MAI_OFF(RlmtPortPreferred),
+		SK_PNMI_RW, Rlmt, 0},
+	{OID_SKGE_RLMT_CHANGE_CTS,
+		1,
+		0,
+		SK_PNMI_MAI_OFF(RlmtChangeCts),
+		SK_PNMI_RO, Rlmt, 0},
+	{OID_SKGE_RLMT_CHANGE_TIME,
+		1,
+		0,
+		SK_PNMI_MAI_OFF(RlmtChangeTime),
+		SK_PNMI_RO, Rlmt, 0},
+	{OID_SKGE_RLMT_CHANGE_ESTIM,
+		1,
+		0,
+		SK_PNMI_MAI_OFF(RlmtChangeEstimate),
+		SK_PNMI_RO, Rlmt, 0},
+	{OID_SKGE_RLMT_CHANGE_THRES,
+		1,
+		0,
+		SK_PNMI_MAI_OFF(RlmtChangeThreshold),
+		SK_PNMI_RW, Rlmt, 0},
+	{OID_SKGE_RLMT_PORT_INDEX,
+		SK_PNMI_MAC_ENTRIES,
+		sizeof(SK_PNMI_RLMT),
+		SK_PNMI_OFF(Rlmt) + SK_PNMI_RLM_OFF(RlmtIndex),
+		SK_PNMI_RO, RlmtStat, 0},
+	{OID_SKGE_RLMT_STATUS,
+		SK_PNMI_MAC_ENTRIES,
+		sizeof(SK_PNMI_RLMT),
+		SK_PNMI_OFF(Rlmt) + SK_PNMI_RLM_OFF(RlmtStatus),
+		SK_PNMI_RO, RlmtStat, 0},
+	{OID_SKGE_RLMT_TX_HELLO_CTS,
+		SK_PNMI_MAC_ENTRIES,
+		sizeof(SK_PNMI_RLMT),
+		SK_PNMI_OFF(Rlmt) + SK_PNMI_RLM_OFF(RlmtTxHelloCts),
+		SK_PNMI_RO, RlmtStat, 0},
+	{OID_SKGE_RLMT_RX_HELLO_CTS,
+		SK_PNMI_MAC_ENTRIES,
+		sizeof(SK_PNMI_RLMT),
+		SK_PNMI_OFF(Rlmt) + SK_PNMI_RLM_OFF(RlmtRxHelloCts),
+		SK_PNMI_RO, RlmtStat, 0},
+	{OID_SKGE_RLMT_TX_SP_REQ_CTS,
+		SK_PNMI_MAC_ENTRIES,
+		sizeof(SK_PNMI_RLMT),
+		SK_PNMI_OFF(Rlmt) + SK_PNMI_RLM_OFF(RlmtTxSpHelloReqCts),
+		SK_PNMI_RO, RlmtStat, 0},
+	{OID_SKGE_RLMT_RX_SP_CTS,
+		SK_PNMI_MAC_ENTRIES,
+		sizeof(SK_PNMI_RLMT),
+		SK_PNMI_OFF(Rlmt) + SK_PNMI_RLM_OFF(RlmtRxSpHelloCts),
+		SK_PNMI_RO, RlmtStat, 0},
+	{OID_SKGE_RLMT_MONITOR_NUMBER,
+		1,
+		0,
+		SK_PNMI_MAI_OFF(RlmtMonitorNumber),
+		SK_PNMI_RO, General, 0},
+	{OID_SKGE_RLMT_MONITOR_INDEX,
+		SK_PNMI_MONITOR_ENTRIES,
+		sizeof(SK_PNMI_RLMT_MONITOR),
+		SK_PNMI_OFF(RlmtMonitor) + SK_PNMI_MON_OFF(RlmtMonitorIndex),
+		SK_PNMI_RO, Monitor, 0},
+	{OID_SKGE_RLMT_MONITOR_ADDR,
+		SK_PNMI_MONITOR_ENTRIES,
+		sizeof(SK_PNMI_RLMT_MONITOR),
+		SK_PNMI_OFF(RlmtMonitor) + SK_PNMI_MON_OFF(RlmtMonitorAddr),
+		SK_PNMI_RO, Monitor, 0},
+	{OID_SKGE_RLMT_MONITOR_ERRS,
+		SK_PNMI_MONITOR_ENTRIES,
+		sizeof(SK_PNMI_RLMT_MONITOR),
+		SK_PNMI_OFF(RlmtMonitor) + SK_PNMI_MON_OFF(RlmtMonitorErrorCts),
+		SK_PNMI_RO, Monitor, 0},
+	{OID_SKGE_RLMT_MONITOR_TIMESTAMP,
+		SK_PNMI_MONITOR_ENTRIES,
+		sizeof(SK_PNMI_RLMT_MONITOR),
+		SK_PNMI_OFF(RlmtMonitor) + SK_PNMI_MON_OFF(RlmtMonitorTimestamp),
+		SK_PNMI_RO, Monitor, 0},
+	{OID_SKGE_RLMT_MONITOR_ADMIN,
+		SK_PNMI_MONITOR_ENTRIES,
+		sizeof(SK_PNMI_RLMT_MONITOR),
+		SK_PNMI_OFF(RlmtMonitor) + SK_PNMI_MON_OFF(RlmtMonitorAdmin),
+		SK_PNMI_RW, Monitor, 0},
+	{OID_SKGE_MTU,
+		1,
+		0,
+		SK_PNMI_MAI_OFF(MtuSize),
+		SK_PNMI_RW, MacPrivateConf, 0},
+	{OID_SKGE_VCT_GET,
+		0,
+		0,
+		0,
+		SK_PNMI_RO, Vct, 0},
+	{OID_SKGE_VCT_SET,
+		0,
+		0,
+		0,
+		SK_PNMI_WO, Vct, 0},
+	{OID_SKGE_VCT_STATUS,
+		0,
+		0,
+		0,
+		SK_PNMI_RO, Vct, 0},
+};
+
diff -ruN linux/drivers/net/sk98lin/skgepnmi.c linuxn/drivers/net/sk98lin/skgepnmi.c
--- linux/drivers/net/sk98lin/skgepnmi.c	Wed Jul  4 20:50:39 2001
+++ linuxn/drivers/net/sk98lin/skgepnmi.c	Tue May 20 12:17:40 2003
@@ -2,15 +2,16 @@
  *
  * Name:	skgepnmi.c
  * Project:	GEnesis, PCI Gigabit Ethernet Adapter
- * Version:	$Revision: 1.87 $
- * Date:	$Date: 2001/04/06 13:35:09 $
+ * Version:	$Revision: 1.106 $
+ * Date:	$Date: 2003/04/10 14:47:31 $
  * Purpose:	Private Network Management Interface
  *
  ****************************************************************************/
 
 /******************************************************************************
  *
- *	(C)Copyright 1998-2001 SysKonnect GmbH.
+ *	(C)Copyright 1998-2002 SysKonnect GmbH.
+ *	(C)Copyright 2002-2003 Marvell.
  *
  *	This program is free software; you can redistribute it and/or modify
  *	it under the terms of the GNU General Public License as published by
@@ -26,6 +27,99 @@
  * History:
  *
  *	$Log: skgepnmi.c,v $
+ *	Revision 1.106  2003/04/10 14:47:31  rschmidt
+ *	Fixed handling for OID_GEN_RCV_OK and OID_GEN_XMIT_OK for YUKON's GMAC
+ *	in GetPhysStatVal().
+ *	Replaced macro PHY_READ() with function call SkXmPhyRead().
+ *	Made optimisations for readability and code size.
+ *	Editorial changes.
+ *	
+ *	Revision 1.105  2003/04/09 12:51:32  rschmidt
+ *	Fixed XMAC only handling for some events in SkPnmiEvent().
+ *	Fixed return value for OID_GEN_RCV_OK (SK_PNMI_HRX) in GetPhysStatVal().
+ *	Editorial changes.
+ *	
+ *	Revision 1.104  2003/03/27 11:18:21  tschilli
+ *	BRK statements from DEBUG code removed.
+ *	OID_GEN_XMIT_OK and OID_GEN_RCV_OK work with Yukon now.
+ *	Copyright messages changed.
+ *	
+ *	Revision 1.103  2002/12/20 09:57:13  tschilli
+ *	SK_PNMI_EVT_VCT_RESET event code changed.
+ *	Unused variable from Vct() removed.
+ *	
+ *	Revision 1.102  2002/12/16 14:03:24  tschilli
+ *	VCT code in Vct() changed.
+ *	
+ *	Revision 1.101  2002/12/16 09:04:10  tschilli
+ *	Code for VCT handling added.
+ *	
+ *	Revision 1.100  2002/09/26 14:28:13  tschilli
+ *	For XMAC the values in the SK_PNMI_PORT Port struct are copied to
+ *	the new SK_PNMI_PORT BufPort struct during a MacUpdate() call.
+ *	These values are used when GetPhysStatVal() is called. With this
+ *	mechanism you get the best results when software corrections for
+ *	counters are needed. Example: RX_LONGFRAMES.
+ *	
+ *	Revision 1.99  2002/09/17 12:31:19  tschilli
+ *	OID_SKGE_TX_HW_ERROR_CTS, OID_SKGE_OUT_ERROR_CTS, OID_GEN_XMIT_ERROR:
+ *	Double count of SK_PNMI_HTX_EXCESS_COL in function General() removed.
+ *	OID_PNP_CAPABILITIES: sizeof(SK_PM_WAKE_UP_CAPABILITIES) changed to
+ *	sizeof(SK_PNP_CAPABILITIES) in function PowerManagement().
+ *	
+ *	Revision 1.98  2002/09/10 09:00:03  rwahl
+ *	Adapted boolean definitions according sktypes.
+ *	
+ *	Revision 1.97  2002/09/05 15:07:03  rwahl
+ *	Editorial changes.
+ *	
+ *	Revision 1.96  2002/09/05 11:04:14  rwahl
+ *	- Rx/Tx packets statistics of virtual port were zero on link down (#10750)
+ *	- For GMAC the overflow IRQ for Rx longframe counter was not counted.
+ *	- Incorrect calculation for oids OID_SKGE_RX_HW_ERROR_CTS,
+ *	  OID_SKGE_IN_ERRORS_CTS,  OID_GEN_RCV_ERROR.
+ *	- Moved correction for OID_SKGE_STAT_RX_TOO_LONG to GetPhysStatVal().
+ *	- Editorial changes.
+ *	
+ *	Revision 1.95  2002/09/04 08:53:37  rwahl
+ *	- Incorrect statistics for Rx_too_long counter with jumbo frame (#10751)
+ *	- StatRxFrameTooLong & StatRxPMaccErr counters were not reset.
+ *	- Fixed compiler warning for debug msg arg types.
+ *	
+ *	Revision 1.94  2002/08/09 15:42:14  rwahl
+ *	- Fixed StatAddr table for GMAC.
+ *	- VirtualConf(): returned indeterminated status for speed oids if no
+ *	  active port.
+ *	
+ *	Revision 1.93  2002/08/09 11:04:59  rwahl
+ *	Added handler for link speed caps.
+ *	
+ *	Revision 1.92  2002/08/09 09:43:03  rwahl
+ *	- Added handler for NDIS OID_PNP_xxx ids.
+ *	
+ *	Revision 1.91  2002/07/17 19:53:03  rwahl
+ *	- Added StatOvrflwBit table for XMAC & GMAC.
+ *	- Extended StatAddr table for GMAC. Added check of number of counters
+ *	  in enumeration and size of StatAddr table on init level.
+ *	- Added use of GIFunc table.
+ *	- ChipSet is not static anymore,
+ *	- Extended SIRQ event handler for both mac types.
+ *	- Fixed rx short counter bug (#10620)
+ *	- Added handler for oids SKGE_SPEED_MODE & SKGE_SPEED_STATUS.
+ *	- Extended GetPhysStatVal() for GMAC.
+ *	- Editorial changes.
+ *	
+ *	Revision 1.90  2002/05/22 08:56:25  rwahl
+ *	- Moved OID table to separate source file.
+ *	- Fix: TX_DEFFERAL counter incremented in full-duplex mode.
+ *	- Use string definitions for error msgs.
+ *	
+ *	Revision 1.89  2001/09/18 10:01:30  mkunz
+ *	some OID's fixed for dualnetmode
+ *	
+ *	Revision 1.88  2001/08/02 07:58:08  rwahl
+ *	- Fixed NetIndex to csum module at ResetCounter().
+ *	
  *	Revision 1.87  2001/04/06 13:35:09  mkunz
  *	-Bugs fixed in handling of OID_SKGE_MTU and the VPD OID's
  *	
@@ -37,7 +131,6 @@
  *	
  *	Revision 1.84  2001/03/06 09:04:55  mkunz
  *	Made some changes in instance calculation
- *	C	^VS:
  *	
  *	Revision 1.83  2001/02/15 09:15:32  mkunz
  *	Necessary changes for dual net mode added
@@ -101,7 +194,7 @@
  *	Added state check to PHY_READ call (hanged if called during startup).
  *	
  *	Revision 1.67  1999/09/22 09:53:20  rwahl
- *	- Read Broadcom register for updating fcs error counter (1000Base-T).
+ *	- Read Broadcom register for updating FCS error counter (1000Base-T).
  *
  *	Revision 1.66  1999/08/26 13:47:56  rwahl
  *	Added SK_DRIVER_SENDEVENT when queueing RLMT_CHANGE_THRES trap.
@@ -361,14 +454,14 @@
  ****************************************************************************/
 
 
+#ifndef _lint
 static const char SysKonnectFileId[] =
-	"@(#) $Id: skgepnmi.c,v 1.87 2001/04/06 13:35:09 mkunz Exp $"
-	" (C) SysKonnect.";
+	"@(#) $Id: skgepnmi.c,v 1.106 2003/04/10 14:47:31 rschmidt Exp $ (C) Marvell.";
+#endif /* !_lint */
 
 #include "h/skdrv1st.h"
 #include "h/sktypes.h"
 #include "h/xmac_ii.h"
-
 #include "h/skdebug.h"
 #include "h/skqueue.h"
 #include "h/skgepnmi.h"
@@ -379,7 +472,16 @@
 #include "h/skgeinit.h"
 #include "h/skdrv2nd.h"
 #include "h/skgepnm2.h"
+#ifdef SK_POWER_MGMT
+#include "h/skgepmgt.h"
+#endif
+/* defines *******************************************************************/
 
+#ifndef DEBUG
+#define PNMI_STATIC	static
+#else	/* DEBUG */
+#define PNMI_STATIC
+#endif /* DEBUG */
 
 /*
  * Public Function prototypes
@@ -393,9 +495,9 @@
 	unsigned int *pLen, SK_U32 Instance, SK_U32 NetIndex);
 int SkPnmiGetStruct(SK_AC *pAC, SK_IOC IoC, void *pBuf,
 	unsigned int *pLen, SK_U32 NetIndex);
-int SkPnmiPreSetStruct(SK_AC *pAC, SK_IOC IoC, void *pBuf, 
+int SkPnmiPreSetStruct(SK_AC *pAC, SK_IOC IoC, void *pBuf,
 	unsigned int *pLen, SK_U32 NetIndex);
-int SkPnmiSetStruct(SK_AC *pAC, SK_IOC IoC, void *pBuf, 
+int SkPnmiSetStruct(SK_AC *pAC, SK_IOC IoC, void *pBuf,
 	unsigned int *pLen, SK_U32 NetIndex);
 int SkPnmiEvent(SK_AC *pAC, SK_IOC IoC, SK_U32 Event, SK_EVPARA Param);
 
@@ -403,1037 +505,259 @@
 /*
  * Private Function prototypes
  */
-static int Addr(SK_AC *pAC, SK_IOC IoC, int action,
-	SK_U32 Id, char *pBuf, unsigned int *pLen, SK_U32 Instance,
-	unsigned int TableIndex, SK_U32 NetIndex);
-static SK_U8 CalculateLinkModeStatus(SK_AC *pAC, SK_IOC IoC, unsigned int
+
+PNMI_STATIC SK_U8 CalculateLinkModeStatus(SK_AC *pAC, SK_IOC IoC, unsigned int
 	PhysPortIndex);
-static SK_U8 CalculateLinkStatus(SK_AC *pAC, SK_IOC IoC, unsigned int
+PNMI_STATIC SK_U8 CalculateLinkStatus(SK_AC *pAC, SK_IOC IoC, unsigned int
 	PhysPortIndex);
-static void CopyMac(char *pDst, SK_MAC_ADDR *pMac);
-static void CopyTrapQueue(SK_AC *pAC, char *pDstBuf);
-static int CsumStat(SK_AC *pAC, SK_IOC IoC, int action, SK_U32 Id,
-	char *pBuf, unsigned int *pLen, SK_U32 Instance,
-	unsigned int TableIndex, SK_U32 NetIndex);
-static int General(SK_AC *pAC, SK_IOC IoC, int action, SK_U32 Id,
-	char *pBuf, unsigned int *pLen, SK_U32 Instance,
-	unsigned int TableIndex, SK_U32 NetIndex);
-static SK_U64 GetPhysStatVal(SK_AC *pAC, SK_IOC IoC,
+PNMI_STATIC void CopyMac(char *pDst, SK_MAC_ADDR *pMac);
+PNMI_STATIC void CopyTrapQueue(SK_AC *pAC, char *pDstBuf);
+PNMI_STATIC SK_U64 GetPhysStatVal(SK_AC *pAC, SK_IOC IoC,
 	unsigned int PhysPortIndex, unsigned int StatIndex);
-static SK_U64 GetStatVal(SK_AC *pAC, SK_IOC IoC, unsigned int LogPortIndex,
+PNMI_STATIC SK_U64 GetStatVal(SK_AC *pAC, SK_IOC IoC, unsigned int LogPortIndex,
 	unsigned int StatIndex, SK_U32 NetIndex);
-static char* GetTrapEntry(SK_AC *pAC, SK_U32 TrapId, unsigned int Size);
-static void GetTrapQueueLen(SK_AC *pAC, unsigned int *pLen,
+PNMI_STATIC char* GetTrapEntry(SK_AC *pAC, SK_U32 TrapId, unsigned int Size);
+PNMI_STATIC void GetTrapQueueLen(SK_AC *pAC, unsigned int *pLen,
 	unsigned int *pEntries);
-static int GetVpdKeyArr(SK_AC *pAC, SK_IOC IoC, char *pKeyArr,
+PNMI_STATIC int GetVpdKeyArr(SK_AC *pAC, SK_IOC IoC, char *pKeyArr,
 	unsigned int KeyArrLen, unsigned int *pKeyNo);
-static int LookupId(SK_U32 Id);
-static int Mac8023Stat(SK_AC *pAC, SK_IOC IoC, int action, SK_U32 Id,
-	char *pBuf, unsigned int *pLen, SK_U32 Instance,
-	unsigned int TableIndex, SK_U32 NetIndex);
-static int MacPrivateConf(SK_AC *pAC, SK_IOC IoC, int action, SK_U32 Id,
-	char *pBuf, unsigned int *pLen, SK_U32 Instance,
-	unsigned int TableIndex, SK_U32 NetIndex);
-static int MacPrivateStat(SK_AC *pAC, SK_IOC IoC, int action, SK_U32 Id,
-	char *pBuf, unsigned int *pLen, SK_U32 Instance,
-	unsigned int TableIndex, SK_U32 NetIndex);
-static int MacUpdate(SK_AC *pAC, SK_IOC IoC, unsigned int FirstMac,
+PNMI_STATIC int LookupId(SK_U32 Id);
+PNMI_STATIC int MacUpdate(SK_AC *pAC, SK_IOC IoC, unsigned int FirstMac,
 	unsigned int LastMac);
-static int Monitor(SK_AC *pAC, SK_IOC IoC, int action,
-	SK_U32 Id, char *pBuf, unsigned int *pLen, SK_U32 Instance,
-	unsigned int TableIndex, SK_U32 NetIndex);
-static int OidStruct(SK_AC *pAC, SK_IOC IoC, int action, SK_U32 Id,
-	char *pBuf, unsigned int *pLen, SK_U32 Instance,
-	unsigned int TableIndex, SK_U32 NetIndex);
-static int Perform(SK_AC *pAC, SK_IOC IoC, int action, SK_U32 Id,
-	char *pBuf, unsigned int* pLen, SK_U32 Instance,
-	unsigned int TableIndex, SK_U32 NetIndex);
-static int PnmiStruct(SK_AC *pAC, SK_IOC IoC, int Action, char *pBuf,
+PNMI_STATIC int PnmiStruct(SK_AC *pAC, SK_IOC IoC, int Action, char *pBuf,
 	unsigned int *pLen, SK_U32 NetIndex);
-static int PnmiVar(SK_AC *pAC, SK_IOC IoC, int Action, SK_U32 Id,
+PNMI_STATIC int PnmiVar(SK_AC *pAC, SK_IOC IoC, int Action, SK_U32 Id,
 	char *pBuf, unsigned int *pLen, SK_U32 Instance, SK_U32 NetIndex);
-static void QueueRlmtNewMacTrap(SK_AC *pAC, unsigned int ActiveMac);
-static void QueueRlmtPortTrap(SK_AC *pAC, SK_U32 TrapId,
+PNMI_STATIC void QueueRlmtNewMacTrap(SK_AC *pAC, unsigned int ActiveMac);
+PNMI_STATIC void QueueRlmtPortTrap(SK_AC *pAC, SK_U32 TrapId,
 	unsigned int PortIndex);
-static void QueueSensorTrap(SK_AC *pAC, SK_U32 TrapId,
+PNMI_STATIC void QueueSensorTrap(SK_AC *pAC, SK_U32 TrapId,
 	unsigned int SensorIndex);
-static void QueueSimpleTrap(SK_AC *pAC, SK_U32 TrapId);
-static void ResetCounter(SK_AC *pAC, SK_IOC IoC, SK_U32 NetIndex);
-static int Rlmt(SK_AC *pAC, SK_IOC IoC, int action, SK_U32 Id,
-	char *pBuf, unsigned int *pLen, SK_U32 Instance,
-	unsigned int TableIndex, SK_U32 NetIndex);
-static int RlmtStat(SK_AC *pAC, SK_IOC IoC, int action, SK_U32 Id,
-	char *pBuf, unsigned int *pLen, SK_U32 Instance,
-	unsigned int TableIndex, SK_U32 NetIndex);
-static int RlmtUpdate(SK_AC *pAC, SK_IOC IoC, SK_U32 NetIndex);
-static int SensorStat(SK_AC *pAC, SK_IOC IoC, int action, SK_U32 Id,
-	char *pBuf, unsigned int *pLen, SK_U32 Instance,
-	unsigned int TableIndex, SK_U32 NetIndex);
-static int SirqUpdate(SK_AC *pAC, SK_IOC IoC);
-static void VirtualConf(SK_AC *pAC, SK_IOC IoC, SK_U32 Id, char *pBuf);
-static int Vpd(SK_AC *pAC, SK_IOC IoC, int action, SK_U32 Id,
-	char *pBuf, unsigned int *pLen, SK_U32 Instance,
-	unsigned int TableIndex, SK_U32 NetIndex);
-
-
-/******************************************************************************
- *
- * Global variables
- */
+PNMI_STATIC void QueueSimpleTrap(SK_AC *pAC, SK_U32 TrapId);
+PNMI_STATIC void ResetCounter(SK_AC *pAC, SK_IOC IoC, SK_U32 NetIndex);
+PNMI_STATIC int RlmtUpdate(SK_AC *pAC, SK_IOC IoC, SK_U32 NetIndex);
+PNMI_STATIC int SirqUpdate(SK_AC *pAC, SK_IOC IoC);
+PNMI_STATIC void VirtualConf(SK_AC *pAC, SK_IOC IoC, SK_U32 Id, char *pBuf);
+PNMI_STATIC int Vct(SK_AC *pAC, SK_IOC IoC, int Action, SK_U32 Id, char *pBuf,
+	unsigned int *pLen, SK_U32 Instance, unsigned int TableIndex, SK_U32 NetIndex);
+PNMI_STATIC void CheckVctStatus(SK_AC *, SK_IOC, char *, SK_U32, SK_U32);
 
 /*
  * Table to correlate OID with handler function and index to
  * hardware register stored in StatAddress if applicable.
  */
-static const SK_PNMI_TAB_ENTRY IdTable[] = {
-	{OID_GEN_XMIT_OK,
-		0,
-		0,
-		0,
-		SK_PNMI_RO, Mac8023Stat, SK_PNMI_HTX},
-	{OID_GEN_RCV_OK,
-		0,
-		0,
-		0,
-		SK_PNMI_RO, Mac8023Stat, SK_PNMI_HRX},
-	{OID_GEN_XMIT_ERROR,
-		0,
-		0,
-		0,
-		SK_PNMI_RO, General, 0},
-	{OID_GEN_RCV_ERROR,
-		0,
-		0,
-		0,
-		SK_PNMI_RO, General, 0},
-	{OID_GEN_RCV_NO_BUFFER,
-		0,
-		0,
-		0,
-		SK_PNMI_RO, General, 0},
-	{OID_GEN_DIRECTED_FRAMES_XMIT,
-		0,
-		0,
-		0,
-		SK_PNMI_RO, Mac8023Stat, SK_PNMI_HTX_UNICAST},
-	{OID_GEN_MULTICAST_FRAMES_XMIT,
-		0,
-		0,
-		0,
-		SK_PNMI_RO, Mac8023Stat, SK_PNMI_HTX_MULTICAST},
-	{OID_GEN_BROADCAST_FRAMES_XMIT,
-		0,
-		0,
-		0,
-		SK_PNMI_RO, Mac8023Stat, SK_PNMI_HTX_BROADCAST},
-	{OID_GEN_DIRECTED_FRAMES_RCV,
-		0,
-		0,
-		0,
-		SK_PNMI_RO, Mac8023Stat, SK_PNMI_HRX_UNICAST},
-	{OID_GEN_MULTICAST_FRAMES_RCV,
-		0,
-		0,
-		0,
-		SK_PNMI_RO, Mac8023Stat, SK_PNMI_HRX_MULTICAST},
-	{OID_GEN_BROADCAST_FRAMES_RCV,
-		0,
-		0,
-		0,
-		SK_PNMI_RO, Mac8023Stat, SK_PNMI_HRX_BROADCAST},
-	{OID_GEN_RCV_CRC_ERROR,
-		0,
-		0,
-		0,
-		SK_PNMI_RO, Mac8023Stat, SK_PNMI_HRX_FCS},
-	{OID_GEN_TRANSMIT_QUEUE_LENGTH,
-		0,
-		0,
-		0,
-		SK_PNMI_RO, General, 0},
-	{OID_802_3_PERMANENT_ADDRESS,
-		0,
-		0,
-		0,
-		SK_PNMI_RO, Mac8023Stat, 0},
-	{OID_802_3_CURRENT_ADDRESS,
-		0,
-		0,
-		0,
-		SK_PNMI_RO, Mac8023Stat, 0},
-	{OID_802_3_RCV_ERROR_ALIGNMENT,
-		0,
-		0,
-		0,
-		SK_PNMI_RO, Mac8023Stat, SK_PNMI_HRX_FRAMING},
-	{OID_802_3_XMIT_ONE_COLLISION,
-		0,
-		0,
-		0,
-		SK_PNMI_RO, Mac8023Stat, SK_PNMI_HTX_SINGLE_COL},
-	{OID_802_3_XMIT_MORE_COLLISIONS,
-		0,
-		0,
-		0,
-		SK_PNMI_RO, Mac8023Stat, SK_PNMI_HTX_MULTI_COL},
-	{OID_802_3_XMIT_DEFERRED,
-		0,
-		0,
-		0,
-		SK_PNMI_RO, Mac8023Stat, SK_PNMI_HTX_DEFFERAL},
-	{OID_802_3_XMIT_MAX_COLLISIONS,
-		0,
-		0,
-		0,
-		SK_PNMI_RO, Mac8023Stat, SK_PNMI_HTX_EXCESS_COL},
-	{OID_802_3_RCV_OVERRUN,
-		0,
-		0,
-		0,
-		SK_PNMI_RO, Mac8023Stat, SK_PNMI_HRX_OVERFLOW},
-	{OID_802_3_XMIT_UNDERRUN,
-		0,
-		0,
-		0,
-		SK_PNMI_RO, Mac8023Stat, SK_PNMI_HTX_UNDERRUN},
-	{OID_802_3_XMIT_TIMES_CRS_LOST,
-		0,
-		0,
-		0,
-		SK_PNMI_RO, Mac8023Stat, SK_PNMI_HTX_CARRIER},
-	{OID_802_3_XMIT_LATE_COLLISIONS,
-		0,
-		0,
-		0,
-		SK_PNMI_RO, Mac8023Stat, SK_PNMI_HTX_LATE_COL},
-	{OID_SKGE_MDB_VERSION,
-		1,
-		0,
-		SK_PNMI_MAI_OFF(MgmtDBVersion),
-		SK_PNMI_RO, General, 0},
-	{OID_SKGE_SUPPORTED_LIST,
-		0,
-		0,
-		0,
-		SK_PNMI_RO, General, 0},
-	{OID_SKGE_ALL_DATA,
-		0,
-		0,
-		0,
-		SK_PNMI_RW, OidStruct, 0},
-	{OID_SKGE_VPD_FREE_BYTES,
-		1,
-		0,
-		SK_PNMI_MAI_OFF(VpdFreeBytes),
-		SK_PNMI_RO, Vpd, 0},
-	{OID_SKGE_VPD_ENTRIES_LIST,
-		1,
-		0,
-		SK_PNMI_MAI_OFF(VpdEntriesList),
-		SK_PNMI_RO, Vpd, 0},
-	{OID_SKGE_VPD_ENTRIES_NUMBER,
-		1,
-		0,
-		SK_PNMI_MAI_OFF(VpdEntriesNumber),
-		SK_PNMI_RO, Vpd, 0},
-	{OID_SKGE_VPD_KEY,
-		SK_PNMI_VPD_ENTRIES,
-		sizeof(SK_PNMI_VPD),
-		SK_PNMI_OFF(Vpd) + SK_PNMI_VPD_OFF(VpdKey),
-		SK_PNMI_RO, Vpd, 0},
-	{OID_SKGE_VPD_VALUE,
-		SK_PNMI_VPD_ENTRIES,
-		sizeof(SK_PNMI_VPD),
-		SK_PNMI_OFF(Vpd) + SK_PNMI_VPD_OFF(VpdValue),
-		SK_PNMI_RO, Vpd, 0},
-	{OID_SKGE_VPD_ACCESS,
-		SK_PNMI_VPD_ENTRIES,
-		sizeof(SK_PNMI_VPD),
-		SK_PNMI_OFF(Vpd) + SK_PNMI_VPD_OFF(VpdAccess),
-		SK_PNMI_RO, Vpd, 0},
-	{OID_SKGE_VPD_ACTION,
-		SK_PNMI_VPD_ENTRIES,
-		sizeof(SK_PNMI_VPD),
-		SK_PNMI_OFF(Vpd) + SK_PNMI_VPD_OFF(VpdAction),
-		SK_PNMI_RW, Vpd, 0},
-	{OID_SKGE_PORT_NUMBER,		
-		1,
-		0,
-		SK_PNMI_MAI_OFF(PortNumber),
-		SK_PNMI_RO, General, 0},
-	{OID_SKGE_DEVICE_TYPE,
-		1,
-		0,
-		SK_PNMI_MAI_OFF(DeviceType),
-		SK_PNMI_RO, General, 0},
-	{OID_SKGE_DRIVER_DESCR,
-		1,
-		0,
-		SK_PNMI_MAI_OFF(DriverDescr),
-		SK_PNMI_RO, General, 0},
-	{OID_SKGE_DRIVER_VERSION,
-		1,
-		0,
-		SK_PNMI_MAI_OFF(DriverVersion),
-		SK_PNMI_RO, General, 0},
-	{OID_SKGE_HW_DESCR,
-		1,
-		0,
-		SK_PNMI_MAI_OFF(HwDescr),
-		SK_PNMI_RO, General, 0},
-	{OID_SKGE_HW_VERSION,
-		1,
-		0,
-		SK_PNMI_MAI_OFF(HwVersion),
-		SK_PNMI_RO, General, 0},
-	{OID_SKGE_CHIPSET,
-		1,
-		0,
-		SK_PNMI_MAI_OFF(Chipset),
-		SK_PNMI_RO, General, 0},
-	{OID_SKGE_ACTION,
-		1,
-		0,
-		SK_PNMI_MAI_OFF(Action),
-		SK_PNMI_RW, Perform, 0},
-	{OID_SKGE_RESULT,
-		1,
-		0,
-		SK_PNMI_MAI_OFF(TestResult),
-		SK_PNMI_RO, General, 0},
-	{OID_SKGE_BUS_TYPE,
-		1,
-		0,
-		SK_PNMI_MAI_OFF(BusType),
-		SK_PNMI_RO, General, 0},
-	{OID_SKGE_BUS_SPEED,
-		1,
-		0,
-		SK_PNMI_MAI_OFF(BusSpeed),
-		SK_PNMI_RO, General, 0},
-	{OID_SKGE_BUS_WIDTH,
-		1,
-		0,
-		SK_PNMI_MAI_OFF(BusWidth),
-		SK_PNMI_RO, General, 0},
-	{OID_SKGE_TX_SW_QUEUE_LEN,
-		1,
-		0,
-		SK_PNMI_MAI_OFF(TxSwQueueLen),
-		SK_PNMI_RO, General, 0},
-	{OID_SKGE_TX_SW_QUEUE_MAX,
-		1,
-		0,
-		SK_PNMI_MAI_OFF(TxSwQueueMax),
-		SK_PNMI_RO, General, 0},
-	{OID_SKGE_TX_RETRY,
-		1,
-		0,
-		SK_PNMI_MAI_OFF(TxRetryCts),
-		SK_PNMI_RO, General, 0},
-	{OID_SKGE_RX_INTR_CTS,
-		1,
-		0,
-		SK_PNMI_MAI_OFF(RxIntrCts),
-		SK_PNMI_RO, General, 0},
-	{OID_SKGE_TX_INTR_CTS,
-		1,
-		0,
-		SK_PNMI_MAI_OFF(TxIntrCts),
-		SK_PNMI_RO, General, 0},
-	{OID_SKGE_RX_NO_BUF_CTS,
-		1,
-		0,
-		SK_PNMI_MAI_OFF(RxNoBufCts),
-		SK_PNMI_RO, General, 0},
-	{OID_SKGE_TX_NO_BUF_CTS,
-		1,
-		0,
-		SK_PNMI_MAI_OFF(TxNoBufCts),
-		SK_PNMI_RO, General, 0},
-	{OID_SKGE_TX_USED_DESCR_NO,
-		1,
-		0,
-		SK_PNMI_MAI_OFF(TxUsedDescrNo),
-		SK_PNMI_RO, General, 0},
-	{OID_SKGE_RX_DELIVERED_CTS,
-		1,
-		0,
-		SK_PNMI_MAI_OFF(RxDeliveredCts),
-		SK_PNMI_RO, General, 0},
-	{OID_SKGE_RX_OCTETS_DELIV_CTS,
-		1,
-		0,
-		SK_PNMI_MAI_OFF(RxOctetsDeliveredCts),
-		SK_PNMI_RO, General, 0},
-	{OID_SKGE_RX_HW_ERROR_CTS,
-		1,
-		0,
-		SK_PNMI_MAI_OFF(RxHwErrorsCts),
-		SK_PNMI_RO, General, 0},
-	{OID_SKGE_TX_HW_ERROR_CTS,
-		1,
-		0,
-		SK_PNMI_MAI_OFF(TxHwErrorsCts),
-		SK_PNMI_RO, General, 0},
-	{OID_SKGE_IN_ERRORS_CTS,
-		1,
-		0,
-		SK_PNMI_MAI_OFF(InErrorsCts),
-		SK_PNMI_RO, General, 0},
-	{OID_SKGE_OUT_ERROR_CTS,
-		1,
-		0,
-		SK_PNMI_MAI_OFF(OutErrorsCts),
-		SK_PNMI_RO, General, 0},
-	{OID_SKGE_ERR_RECOVERY_CTS,
-		1,
-		0,
-		SK_PNMI_MAI_OFF(ErrRecoveryCts),
-		SK_PNMI_RO, General, 0},
-	{OID_SKGE_SYSUPTIME,
-		1,
-		0,
-		SK_PNMI_MAI_OFF(SysUpTime),
-		SK_PNMI_RO, General, 0},
-	{OID_SKGE_SENSOR_NUMBER,
-		1,
-		0,
-		SK_PNMI_MAI_OFF(SensorNumber),
-		SK_PNMI_RO, General, 0},
-	{OID_SKGE_SENSOR_INDEX,
-		SK_PNMI_SENSOR_ENTRIES,
-		sizeof(SK_PNMI_SENSOR),
-		SK_PNMI_OFF(Sensor) + SK_PNMI_SEN_OFF(SensorIndex),
-		SK_PNMI_RO, SensorStat, 0},
-	{OID_SKGE_SENSOR_DESCR,
-		SK_PNMI_SENSOR_ENTRIES,
-		sizeof(SK_PNMI_SENSOR),
-		SK_PNMI_OFF(Sensor) + SK_PNMI_SEN_OFF(SensorDescr),
-		SK_PNMI_RO, SensorStat, 0},
-	{OID_SKGE_SENSOR_TYPE,
-		SK_PNMI_SENSOR_ENTRIES,
-		sizeof(SK_PNMI_SENSOR),
-		SK_PNMI_OFF(Sensor) + SK_PNMI_SEN_OFF(SensorType),
-		SK_PNMI_RO, SensorStat, 0},
-	{OID_SKGE_SENSOR_VALUE,
-		SK_PNMI_SENSOR_ENTRIES,
-		sizeof(SK_PNMI_SENSOR),
-		SK_PNMI_OFF(Sensor) + SK_PNMI_SEN_OFF(SensorValue),
-		SK_PNMI_RO, SensorStat, 0},
-	{OID_SKGE_SENSOR_WAR_THRES_LOW,
-		SK_PNMI_SENSOR_ENTRIES,
-		sizeof(SK_PNMI_SENSOR),
-		SK_PNMI_OFF(Sensor) + SK_PNMI_SEN_OFF(SensorWarningThresholdLow),
-		SK_PNMI_RO, SensorStat, 0},
-	{OID_SKGE_SENSOR_WAR_THRES_UPP,
-		SK_PNMI_SENSOR_ENTRIES,
-		sizeof(SK_PNMI_SENSOR),
-		SK_PNMI_OFF(Sensor) + SK_PNMI_SEN_OFF(SensorWarningThresholdHigh),
-		SK_PNMI_RO, SensorStat, 0},
-	{OID_SKGE_SENSOR_ERR_THRES_LOW,
-		SK_PNMI_SENSOR_ENTRIES,
-		sizeof(SK_PNMI_SENSOR),
-		SK_PNMI_OFF(Sensor) + SK_PNMI_SEN_OFF(SensorErrorThresholdLow),
-		SK_PNMI_RO, SensorStat, 0},
-	{OID_SKGE_SENSOR_ERR_THRES_UPP,
-		SK_PNMI_SENSOR_ENTRIES,
-		sizeof(SK_PNMI_SENSOR),
-		SK_PNMI_OFF(Sensor) + SK_PNMI_SEN_OFF(SensorErrorThresholdHigh),
-		SK_PNMI_RO, SensorStat, 0},
-	{OID_SKGE_SENSOR_STATUS,
-		SK_PNMI_SENSOR_ENTRIES,
-		sizeof(SK_PNMI_SENSOR),
-		SK_PNMI_OFF(Sensor) + SK_PNMI_SEN_OFF(SensorStatus),
-		SK_PNMI_RO, SensorStat, 0},
-	{OID_SKGE_SENSOR_WAR_CTS,
-		SK_PNMI_SENSOR_ENTRIES,
-		sizeof(SK_PNMI_SENSOR),
-		SK_PNMI_OFF(Sensor) + SK_PNMI_SEN_OFF(SensorWarningCts),
-		SK_PNMI_RO, SensorStat, 0},
-	{OID_SKGE_SENSOR_ERR_CTS,
-		SK_PNMI_SENSOR_ENTRIES,
-		sizeof(SK_PNMI_SENSOR),
-		SK_PNMI_OFF(Sensor) + SK_PNMI_SEN_OFF(SensorErrorCts),
-		SK_PNMI_RO, SensorStat, 0},
-	{OID_SKGE_SENSOR_WAR_TIME,
-		SK_PNMI_SENSOR_ENTRIES,
-		sizeof(SK_PNMI_SENSOR),
-		SK_PNMI_OFF(Sensor) + SK_PNMI_SEN_OFF(SensorWarningTimestamp),
-		SK_PNMI_RO, SensorStat, 0},
-	{OID_SKGE_SENSOR_ERR_TIME,
-		SK_PNMI_SENSOR_ENTRIES,
-		sizeof(SK_PNMI_SENSOR),
-		SK_PNMI_OFF(Sensor) + SK_PNMI_SEN_OFF(SensorErrorTimestamp),
-		SK_PNMI_RO, SensorStat, 0},
-	{OID_SKGE_CHKSM_NUMBER,
-		1,
-		0,
-		SK_PNMI_MAI_OFF(ChecksumNumber),
-		SK_PNMI_RO, General, 0},
-	{OID_SKGE_CHKSM_RX_OK_CTS,
-		SKCS_NUM_PROTOCOLS,
-		sizeof(SK_PNMI_CHECKSUM),
-		SK_PNMI_OFF(Checksum) + SK_PNMI_CHK_OFF(ChecksumRxOkCts),
-		SK_PNMI_RO, CsumStat, 0},
-	{OID_SKGE_CHKSM_RX_UNABLE_CTS,
-		SKCS_NUM_PROTOCOLS,
-		sizeof(SK_PNMI_CHECKSUM),
-		SK_PNMI_OFF(Checksum) + SK_PNMI_CHK_OFF(ChecksumRxUnableCts),
-		SK_PNMI_RO, CsumStat, 0},
-	{OID_SKGE_CHKSM_RX_ERR_CTS,
-		SKCS_NUM_PROTOCOLS,
-		sizeof(SK_PNMI_CHECKSUM),
-		SK_PNMI_OFF(Checksum) + SK_PNMI_CHK_OFF(ChecksumRxErrCts),
-		SK_PNMI_RO, CsumStat, 0},
-	{OID_SKGE_CHKSM_TX_OK_CTS,
-		SKCS_NUM_PROTOCOLS,
-		sizeof(SK_PNMI_CHECKSUM),
-		SK_PNMI_OFF(Checksum) + SK_PNMI_CHK_OFF(ChecksumTxOkCts),
-		SK_PNMI_RO, CsumStat, 0},
-	{OID_SKGE_CHKSM_TX_UNABLE_CTS,
-		SKCS_NUM_PROTOCOLS,
-		sizeof(SK_PNMI_CHECKSUM),
-		SK_PNMI_OFF(Checksum) + SK_PNMI_CHK_OFF(ChecksumTxUnableCts),
-		SK_PNMI_RO, CsumStat, 0},
-	{OID_SKGE_STAT_TX,
-		SK_PNMI_MAC_ENTRIES,
-		sizeof(SK_PNMI_STAT),
-		SK_PNMI_OFF(Stat) + SK_PNMI_STA_OFF(StatTxOkCts),
-		SK_PNMI_RO, MacPrivateStat, SK_PNMI_HTX},
-	{OID_SKGE_STAT_TX_OCTETS,
-		SK_PNMI_MAC_ENTRIES,
-		sizeof(SK_PNMI_STAT),
-		SK_PNMI_OFF(Stat) + SK_PNMI_STA_OFF(StatTxOctetsOkCts),
-		SK_PNMI_RO, MacPrivateStat, SK_PNMI_HTX_OCTET},
-	{OID_SKGE_STAT_TX_BROADCAST,
-		SK_PNMI_MAC_ENTRIES,
-		sizeof(SK_PNMI_STAT),
-		SK_PNMI_OFF(Stat) + SK_PNMI_STA_OFF(StatTxBroadcastOkCts),
-		SK_PNMI_RO, MacPrivateStat, SK_PNMI_HTX_BROADCAST},
-	{OID_SKGE_STAT_TX_MULTICAST,
-		SK_PNMI_MAC_ENTRIES,
-		sizeof(SK_PNMI_STAT),
-		SK_PNMI_OFF(Stat) + SK_PNMI_STA_OFF(StatTxMulticastOkCts),
-		SK_PNMI_RO, MacPrivateStat, SK_PNMI_HTX_MULTICAST},
-	{OID_SKGE_STAT_TX_UNICAST,
-		SK_PNMI_MAC_ENTRIES,
-		sizeof(SK_PNMI_STAT),
-		SK_PNMI_OFF(Stat) + SK_PNMI_STA_OFF(StatTxUnicastOkCts),
-		SK_PNMI_RO, MacPrivateStat, SK_PNMI_HTX_UNICAST},
-	{OID_SKGE_STAT_TX_LONGFRAMES,
-		SK_PNMI_MAC_ENTRIES,
-		sizeof(SK_PNMI_STAT),
-		SK_PNMI_OFF(Stat) + SK_PNMI_STA_OFF(StatTxLongFramesCts),
-		SK_PNMI_RO, MacPrivateStat, SK_PNMI_HTX_LONGFRAMES},
-	{OID_SKGE_STAT_TX_BURST,
-		SK_PNMI_MAC_ENTRIES,
-		sizeof(SK_PNMI_STAT),
-		SK_PNMI_OFF(Stat) + SK_PNMI_STA_OFF(StatTxBurstCts),
-		SK_PNMI_RO, MacPrivateStat, SK_PNMI_HTX_BURST},
-	{OID_SKGE_STAT_TX_PFLOWC,
-		SK_PNMI_MAC_ENTRIES,
-		sizeof(SK_PNMI_STAT),
-		SK_PNMI_OFF(Stat) + SK_PNMI_STA_OFF(StatTxPauseMacCtrlCts),
-		SK_PNMI_RO, MacPrivateStat, SK_PNMI_HTX_PMACC},
-	{OID_SKGE_STAT_TX_FLOWC,
-		SK_PNMI_MAC_ENTRIES,
-		sizeof(SK_PNMI_STAT),
-		SK_PNMI_OFF(Stat) + SK_PNMI_STA_OFF(StatTxMacCtrlCts),
-		SK_PNMI_RO, MacPrivateStat, SK_PNMI_HTX_MACC},
-	{OID_SKGE_STAT_TX_SINGLE_COL,
-		SK_PNMI_MAC_ENTRIES,
-		sizeof(SK_PNMI_STAT),
-		SK_PNMI_OFF(Stat) + SK_PNMI_STA_OFF(StatTxSingleCollisionCts),
-		SK_PNMI_RO, MacPrivateStat, SK_PNMI_HTX_SINGLE_COL},
-	{OID_SKGE_STAT_TX_MULTI_COL,
-		SK_PNMI_MAC_ENTRIES,
-		sizeof(SK_PNMI_STAT),
-		SK_PNMI_OFF(Stat) + SK_PNMI_STA_OFF(StatTxMultipleCollisionCts),
-		SK_PNMI_RO, MacPrivateStat, SK_PNMI_HTX_MULTI_COL},
-	{OID_SKGE_STAT_TX_EXCESS_COL,
-		SK_PNMI_MAC_ENTRIES,
-		sizeof(SK_PNMI_STAT),
-		SK_PNMI_OFF(Stat) + SK_PNMI_STA_OFF(StatTxExcessiveCollisionCts),
-		SK_PNMI_RO, MacPrivateStat, SK_PNMI_HTX_EXCESS_COL},
-	{OID_SKGE_STAT_TX_LATE_COL,
-		SK_PNMI_MAC_ENTRIES,
-		sizeof(SK_PNMI_STAT),
-		SK_PNMI_OFF(Stat) + SK_PNMI_STA_OFF(StatTxLateCollisionCts),
-		SK_PNMI_RO, MacPrivateStat, SK_PNMI_HTX_LATE_COL},
-	{OID_SKGE_STAT_TX_DEFFERAL,
-		SK_PNMI_MAC_ENTRIES,
-		sizeof(SK_PNMI_STAT),
-		SK_PNMI_OFF(Stat) + SK_PNMI_STA_OFF(StatTxDeferralCts),
-		SK_PNMI_RO, MacPrivateStat, SK_PNMI_HTX_DEFFERAL},
-	{OID_SKGE_STAT_TX_EXCESS_DEF,
-		SK_PNMI_MAC_ENTRIES,
-		sizeof(SK_PNMI_STAT),
-		SK_PNMI_OFF(Stat) + SK_PNMI_STA_OFF(StatTxExcessiveDeferralCts),
-		SK_PNMI_RO, MacPrivateStat, SK_PNMI_HTX_EXCESS_DEF},
-	{OID_SKGE_STAT_TX_UNDERRUN,
-		SK_PNMI_MAC_ENTRIES,
-		sizeof(SK_PNMI_STAT),
-		SK_PNMI_OFF(Stat) + SK_PNMI_STA_OFF(StatTxFifoUnderrunCts),
-		SK_PNMI_RO, MacPrivateStat, SK_PNMI_HTX_UNDERRUN},
-	{OID_SKGE_STAT_TX_CARRIER,
-		SK_PNMI_MAC_ENTRIES,
-		sizeof(SK_PNMI_STAT),
-		SK_PNMI_OFF(Stat) + SK_PNMI_STA_OFF(StatTxCarrierCts),
-		SK_PNMI_RO, MacPrivateStat, SK_PNMI_HTX_CARRIER},
-/*	{OID_SKGE_STAT_TX_UTIL,
-		SK_PNMI_MAC_ENTRIES,
-		sizeof(SK_PNMI_STAT),
-		SK_PNMI_OFF(Stat) + SK_PNMI_STA_OFF(StatTxUtilization),
-		SK_PNMI_RO, MacPrivateStat, (SK_U16)(-1)}, */
-	{OID_SKGE_STAT_TX_64,
-		SK_PNMI_MAC_ENTRIES,
-		sizeof(SK_PNMI_STAT),
-		SK_PNMI_OFF(Stat) + SK_PNMI_STA_OFF(StatTx64Cts),
-		SK_PNMI_RO, MacPrivateStat, SK_PNMI_HTX_64},
-	{OID_SKGE_STAT_TX_127,
-		SK_PNMI_MAC_ENTRIES,
-		sizeof(SK_PNMI_STAT),
-		SK_PNMI_OFF(Stat) + SK_PNMI_STA_OFF(StatTx127Cts),
-		SK_PNMI_RO, MacPrivateStat, SK_PNMI_HTX_127},
-	{OID_SKGE_STAT_TX_255,
-		SK_PNMI_MAC_ENTRIES,
-		sizeof(SK_PNMI_STAT),
-		SK_PNMI_OFF(Stat) + SK_PNMI_STA_OFF(StatTx255Cts),
-		SK_PNMI_RO, MacPrivateStat, SK_PNMI_HTX_255},
-	{OID_SKGE_STAT_TX_511,
-		SK_PNMI_MAC_ENTRIES,
-		sizeof(SK_PNMI_STAT),
-		SK_PNMI_OFF(Stat) + SK_PNMI_STA_OFF(StatTx511Cts),
-		SK_PNMI_RO, MacPrivateStat, SK_PNMI_HTX_511},
-	{OID_SKGE_STAT_TX_1023,
-		SK_PNMI_MAC_ENTRIES,
-		sizeof(SK_PNMI_STAT),
-		SK_PNMI_OFF(Stat) + SK_PNMI_STA_OFF(StatTx1023Cts),
-		SK_PNMI_RO, MacPrivateStat, SK_PNMI_HTX_1023},
-	{OID_SKGE_STAT_TX_MAX,
-		SK_PNMI_MAC_ENTRIES,
-		sizeof(SK_PNMI_STAT),
-		SK_PNMI_OFF(Stat) + SK_PNMI_STA_OFF(StatTxMaxCts),
-		SK_PNMI_RO, MacPrivateStat, SK_PNMI_HTX_MAX},
-	{OID_SKGE_STAT_TX_SYNC,
-		SK_PNMI_MAC_ENTRIES,
-		sizeof(SK_PNMI_STAT),
-		SK_PNMI_OFF(Stat) + SK_PNMI_STA_OFF(StatTxSyncCts),
-		SK_PNMI_RO, MacPrivateStat, SK_PNMI_HTX_SYNC},
-	{OID_SKGE_STAT_TX_SYNC_OCTETS,
-		SK_PNMI_MAC_ENTRIES,
-		sizeof(SK_PNMI_STAT),
-		SK_PNMI_OFF(Stat) + SK_PNMI_STA_OFF(StatTxSyncOctetsCts),
-		SK_PNMI_RO, MacPrivateStat, SK_PNMI_HTX_SYNC_OCTET},
-	{OID_SKGE_STAT_RX,
-		SK_PNMI_MAC_ENTRIES,
-		sizeof(SK_PNMI_STAT),
-		SK_PNMI_OFF(Stat) + SK_PNMI_STA_OFF(StatRxOkCts),
-		SK_PNMI_RO, MacPrivateStat, SK_PNMI_HRX},
-	{OID_SKGE_STAT_RX_OCTETS,
-		SK_PNMI_MAC_ENTRIES,
-		sizeof(SK_PNMI_STAT),
-		SK_PNMI_OFF(Stat) + SK_PNMI_STA_OFF(StatRxOctetsOkCts),
-		SK_PNMI_RO, MacPrivateStat, SK_PNMI_HRX_OCTET},
-	{OID_SKGE_STAT_RX_BROADCAST,
-		SK_PNMI_MAC_ENTRIES,
-		sizeof(SK_PNMI_STAT),
-		SK_PNMI_OFF(Stat) + SK_PNMI_STA_OFF(StatRxBroadcastOkCts),
-		SK_PNMI_RO, MacPrivateStat, SK_PNMI_HRX_BROADCAST},
-	{OID_SKGE_STAT_RX_MULTICAST,
-		SK_PNMI_MAC_ENTRIES,
-		sizeof(SK_PNMI_STAT),
-		SK_PNMI_OFF(Stat) + SK_PNMI_STA_OFF(StatRxMulticastOkCts),
-		SK_PNMI_RO, MacPrivateStat, SK_PNMI_HRX_MULTICAST},
-	{OID_SKGE_STAT_RX_UNICAST,
-		SK_PNMI_MAC_ENTRIES,
-		sizeof(SK_PNMI_STAT),
-		SK_PNMI_OFF(Stat) + SK_PNMI_STA_OFF(StatRxUnicastOkCts),
-		SK_PNMI_RO, MacPrivateStat, SK_PNMI_HRX_UNICAST},
-	{OID_SKGE_STAT_RX_LONGFRAMES,
-		SK_PNMI_MAC_ENTRIES,
-		sizeof(SK_PNMI_STAT),
-		SK_PNMI_OFF(Stat) + SK_PNMI_STA_OFF(StatRxLongFramesCts),
-		SK_PNMI_RO, MacPrivateStat, SK_PNMI_HRX_LONGFRAMES},
-	{OID_SKGE_STAT_RX_PFLOWC,
-		SK_PNMI_MAC_ENTRIES,
-		sizeof(SK_PNMI_STAT),
-		SK_PNMI_OFF(Stat) + SK_PNMI_STA_OFF(StatRxPauseMacCtrlCts),
-		SK_PNMI_RO, MacPrivateStat, SK_PNMI_HRX_PMACC},
-	{OID_SKGE_STAT_RX_FLOWC,
-		SK_PNMI_MAC_ENTRIES,
-		sizeof(SK_PNMI_STAT),
-		SK_PNMI_OFF(Stat) + SK_PNMI_STA_OFF(StatRxMacCtrlCts),
-		SK_PNMI_RO, MacPrivateStat, SK_PNMI_HRX_MACC},
-	{OID_SKGE_STAT_RX_PFLOWC_ERR,
-		SK_PNMI_MAC_ENTRIES,
-		sizeof(SK_PNMI_STAT),
-		SK_PNMI_OFF(Stat) + SK_PNMI_STA_OFF(StatRxPauseMacCtrlErrorCts),
-		SK_PNMI_RO, MacPrivateStat, SK_PNMI_HRX_PMACC_ERR},
-	{OID_SKGE_STAT_RX_FLOWC_UNKWN,
-		SK_PNMI_MAC_ENTRIES,
-		sizeof(SK_PNMI_STAT),
-		SK_PNMI_OFF(Stat) + SK_PNMI_STA_OFF(StatRxMacCtrlUnknownCts),
-		SK_PNMI_RO, MacPrivateStat, SK_PNMI_HRX_MACC_UNKWN},
-	{OID_SKGE_STAT_RX_BURST,
-		SK_PNMI_MAC_ENTRIES,
-		sizeof(SK_PNMI_STAT),
-		SK_PNMI_OFF(Stat) + SK_PNMI_STA_OFF(StatRxBurstCts),
-		SK_PNMI_RO, MacPrivateStat, SK_PNMI_HRX_BURST},
-	{OID_SKGE_STAT_RX_MISSED,
-		SK_PNMI_MAC_ENTRIES,
-		sizeof(SK_PNMI_STAT),
-		SK_PNMI_OFF(Stat) + SK_PNMI_STA_OFF(StatRxMissedCts),
-		SK_PNMI_RO, MacPrivateStat, SK_PNMI_HRX_MISSED},
-	{OID_SKGE_STAT_RX_FRAMING,
-		SK_PNMI_MAC_ENTRIES,
-		sizeof(SK_PNMI_STAT),
-		SK_PNMI_OFF(Stat) + SK_PNMI_STA_OFF(StatRxFramingCts),
-		SK_PNMI_RO, MacPrivateStat, SK_PNMI_HRX_FRAMING},
-	{OID_SKGE_STAT_RX_OVERFLOW,
-		SK_PNMI_MAC_ENTRIES,
-		sizeof(SK_PNMI_STAT),
-		SK_PNMI_OFF(Stat) + SK_PNMI_STA_OFF(StatRxFifoOverflowCts),
-		SK_PNMI_RO, MacPrivateStat, SK_PNMI_HRX_OVERFLOW},
-	{OID_SKGE_STAT_RX_JABBER,
-		SK_PNMI_MAC_ENTRIES,
-		sizeof(SK_PNMI_STAT),
-		SK_PNMI_OFF(Stat) + SK_PNMI_STA_OFF(StatRxJabberCts),
-		SK_PNMI_RO, MacPrivateStat, SK_PNMI_HRX_JABBER},
-	{OID_SKGE_STAT_RX_CARRIER,
-		SK_PNMI_MAC_ENTRIES,
-		sizeof(SK_PNMI_STAT),
-		SK_PNMI_OFF(Stat) + SK_PNMI_STA_OFF(StatRxCarrierCts),
-		SK_PNMI_RO, MacPrivateStat, SK_PNMI_HRX_CARRIER},
-	{OID_SKGE_STAT_RX_IR_LENGTH,
-		SK_PNMI_MAC_ENTRIES,
-		sizeof(SK_PNMI_STAT),
-		SK_PNMI_OFF(Stat) + SK_PNMI_STA_OFF(StatRxIRLengthCts),
-		SK_PNMI_RO, MacPrivateStat, SK_PNMI_HRX_IRLENGTH},
-	{OID_SKGE_STAT_RX_SYMBOL,
-		SK_PNMI_MAC_ENTRIES,
-		sizeof(SK_PNMI_STAT),
-		SK_PNMI_OFF(Stat) + SK_PNMI_STA_OFF(StatRxSymbolCts),
-		SK_PNMI_RO, MacPrivateStat, SK_PNMI_HRX_SYMBOL},
-	{OID_SKGE_STAT_RX_SHORTS,
-		SK_PNMI_MAC_ENTRIES,
-		sizeof(SK_PNMI_STAT),
-		SK_PNMI_OFF(Stat) + SK_PNMI_STA_OFF(StatRxShortsCts),
-		SK_PNMI_RO, MacPrivateStat, SK_PNMI_HRX_SHORTS},
-	{OID_SKGE_STAT_RX_RUNT,
-		SK_PNMI_MAC_ENTRIES,
-		sizeof(SK_PNMI_STAT),
-		SK_PNMI_OFF(Stat) + SK_PNMI_STA_OFF(StatRxRuntCts),
-		SK_PNMI_RO, MacPrivateStat, SK_PNMI_HRX_RUNT},
-	{OID_SKGE_STAT_RX_CEXT,
-		SK_PNMI_MAC_ENTRIES,
-		sizeof(SK_PNMI_STAT),
-		SK_PNMI_OFF(Stat) + SK_PNMI_STA_OFF(StatRxCextCts),
-		SK_PNMI_RO, MacPrivateStat, SK_PNMI_HRX_CEXT},
-	{OID_SKGE_STAT_RX_TOO_LONG,
-		SK_PNMI_MAC_ENTRIES,
-		sizeof(SK_PNMI_STAT),
-		SK_PNMI_OFF(Stat) + SK_PNMI_STA_OFF(StatRxTooLongCts),
-		SK_PNMI_RO, MacPrivateStat, SK_PNMI_HRX_TOO_LONG},
-	{OID_SKGE_STAT_RX_FCS,
-		SK_PNMI_MAC_ENTRIES,
-		sizeof(SK_PNMI_STAT),
-		SK_PNMI_OFF(Stat) + SK_PNMI_STA_OFF(StatRxFcsCts),
-		SK_PNMI_RO, MacPrivateStat, SK_PNMI_HRX_FCS},
-/*	{OID_SKGE_STAT_RX_UTIL,
-		SK_PNMI_MAC_ENTRIES,
-		sizeof(SK_PNMI_STAT),
-		SK_PNMI_OFF(Stat) + SK_PNMI_STA_OFF(StatRxUtilization),
-		SK_PNMI_RO, MacPrivateStat, (SK_U16)(-1)}, */
-	{OID_SKGE_STAT_RX_64,
-		SK_PNMI_MAC_ENTRIES,
-		sizeof(SK_PNMI_STAT),
-		SK_PNMI_OFF(Stat) + SK_PNMI_STA_OFF(StatRx64Cts),
-		SK_PNMI_RO, MacPrivateStat, SK_PNMI_HRX_64},
-	{OID_SKGE_STAT_RX_127,
-		SK_PNMI_MAC_ENTRIES,
-		sizeof(SK_PNMI_STAT),
-		SK_PNMI_OFF(Stat) + SK_PNMI_STA_OFF(StatRx127Cts),
-		SK_PNMI_RO, MacPrivateStat, SK_PNMI_HRX_127},
-	{OID_SKGE_STAT_RX_255,
-		SK_PNMI_MAC_ENTRIES,
-		sizeof(SK_PNMI_STAT),
-		SK_PNMI_OFF(Stat) + SK_PNMI_STA_OFF(StatRx255Cts),
-		SK_PNMI_RO, MacPrivateStat, SK_PNMI_HRX_255},
-	{OID_SKGE_STAT_RX_511,
-		SK_PNMI_MAC_ENTRIES,
-		sizeof(SK_PNMI_STAT),
-		SK_PNMI_OFF(Stat) + SK_PNMI_STA_OFF(StatRx511Cts),
-		SK_PNMI_RO, MacPrivateStat, SK_PNMI_HRX_511},
-	{OID_SKGE_STAT_RX_1023,
-		SK_PNMI_MAC_ENTRIES,
-		sizeof(SK_PNMI_STAT),
-		SK_PNMI_OFF(Stat) + SK_PNMI_STA_OFF(StatRx1023Cts),
-		SK_PNMI_RO, MacPrivateStat, SK_PNMI_HRX_1023},
-	{OID_SKGE_STAT_RX_MAX,
-		SK_PNMI_MAC_ENTRIES,
-		sizeof(SK_PNMI_STAT),
-		SK_PNMI_OFF(Stat) + SK_PNMI_STA_OFF(StatRxMaxCts),
-		SK_PNMI_RO, MacPrivateStat, SK_PNMI_HRX_MAX},
-	{OID_SKGE_PHYS_CUR_ADDR,
-		SK_PNMI_MAC_ENTRIES,
-		sizeof(SK_PNMI_CONF),
-		SK_PNMI_OFF(Conf) + SK_PNMI_CNF_OFF(ConfMacCurrentAddr),
-		SK_PNMI_RW, Addr, 0},
-	{OID_SKGE_PHYS_FAC_ADDR,
-		SK_PNMI_MAC_ENTRIES,
-		sizeof(SK_PNMI_CONF),
-		SK_PNMI_OFF(Conf) + SK_PNMI_CNF_OFF(ConfMacFactoryAddr),
-		SK_PNMI_RO, Addr, 0},
-	{OID_SKGE_PMD,
-		SK_PNMI_MAC_ENTRIES,
-		sizeof(SK_PNMI_CONF),
-		SK_PNMI_OFF(Conf) + SK_PNMI_CNF_OFF(ConfPMD),
-		SK_PNMI_RO, MacPrivateConf, 0},
-	{OID_SKGE_CONNECTOR,
-		SK_PNMI_MAC_ENTRIES,
-		sizeof(SK_PNMI_CONF),
-		SK_PNMI_OFF(Conf) + SK_PNMI_CNF_OFF(ConfConnector),
-		SK_PNMI_RO, MacPrivateConf, 0},
-	{OID_SKGE_LINK_CAP,
-		SK_PNMI_MAC_ENTRIES,
-		sizeof(SK_PNMI_CONF),
-		SK_PNMI_OFF(Conf) + SK_PNMI_CNF_OFF(ConfLinkCapability),
-		SK_PNMI_RO, MacPrivateConf, 0},
-	{OID_SKGE_LINK_MODE,
-		SK_PNMI_MAC_ENTRIES,
-		sizeof(SK_PNMI_CONF),
-		SK_PNMI_OFF(Conf) + SK_PNMI_CNF_OFF(ConfLinkMode),
-		SK_PNMI_RW, MacPrivateConf, 0},
-	{OID_SKGE_LINK_MODE_STATUS,
-		SK_PNMI_MAC_ENTRIES,
-		sizeof(SK_PNMI_CONF),
-		SK_PNMI_OFF(Conf) + SK_PNMI_CNF_OFF(ConfLinkModeStatus),
-		SK_PNMI_RO, MacPrivateConf, 0},
-	{OID_SKGE_LINK_STATUS,
-		SK_PNMI_MAC_ENTRIES,
-		sizeof(SK_PNMI_CONF),
-		SK_PNMI_OFF(Conf) + SK_PNMI_CNF_OFF(ConfLinkStatus),
-		SK_PNMI_RO, MacPrivateConf, 0},
-	{OID_SKGE_FLOWCTRL_CAP,
-		SK_PNMI_MAC_ENTRIES,
-		sizeof(SK_PNMI_CONF),
-		SK_PNMI_OFF(Conf) + SK_PNMI_CNF_OFF(ConfFlowCtrlCapability),
-		SK_PNMI_RO, MacPrivateConf, 0},
-	{OID_SKGE_FLOWCTRL_MODE,
-		SK_PNMI_MAC_ENTRIES,
-		sizeof(SK_PNMI_CONF),
-		SK_PNMI_OFF(Conf) + SK_PNMI_CNF_OFF(ConfFlowCtrlMode),
-		SK_PNMI_RW, MacPrivateConf, 0},
-	{OID_SKGE_FLOWCTRL_STATUS,
-		SK_PNMI_MAC_ENTRIES,
-		sizeof(SK_PNMI_CONF),
-		SK_PNMI_OFF(Conf) + SK_PNMI_CNF_OFF(ConfFlowCtrlStatus),
-		SK_PNMI_RO, MacPrivateConf, 0},
-	{OID_SKGE_PHY_OPERATION_CAP,
-		SK_PNMI_MAC_ENTRIES,
-		sizeof(SK_PNMI_CONF),
-		SK_PNMI_OFF(Conf) + SK_PNMI_CNF_OFF(ConfPhyOperationCapability),
-		SK_PNMI_RO, MacPrivateConf, 0},
-	{OID_SKGE_PHY_OPERATION_MODE,
-		SK_PNMI_MAC_ENTRIES,
-		sizeof(SK_PNMI_CONF),
-		SK_PNMI_OFF(Conf) + SK_PNMI_CNF_OFF(ConfPhyOperationMode),
-		SK_PNMI_RW, MacPrivateConf, 0},
-	{OID_SKGE_PHY_OPERATION_STATUS,
-		SK_PNMI_MAC_ENTRIES,
-		sizeof(SK_PNMI_CONF),
-		SK_PNMI_OFF(Conf) + SK_PNMI_CNF_OFF(ConfPhyOperationStatus),
-		SK_PNMI_RO, MacPrivateConf, 0},
-	{OID_SKGE_TRAP,
-		1,
-		0,
-		SK_PNMI_MAI_OFF(Trap),
-		SK_PNMI_RO, General, 0},
-	{OID_SKGE_TRAP_NUMBER,
-		1,
-		0,
-		SK_PNMI_MAI_OFF(TrapNumber),
-		SK_PNMI_RO, General, 0},
-	{OID_SKGE_RLMT_MODE,
-		1,
-		0,
-		SK_PNMI_MAI_OFF(RlmtMode),
-		SK_PNMI_RW, Rlmt, 0},
-	{OID_SKGE_RLMT_PORT_NUMBER,
-		1,
-		0,
-		SK_PNMI_MAI_OFF(RlmtPortNumber),
-		SK_PNMI_RO, Rlmt, 0},
-	{OID_SKGE_RLMT_PORT_ACTIVE,
-		1,
-		0,
-		SK_PNMI_MAI_OFF(RlmtPortActive),
-		SK_PNMI_RO, Rlmt, 0},
-	{OID_SKGE_RLMT_PORT_PREFERRED,
-		1,
-		0,
-		SK_PNMI_MAI_OFF(RlmtPortPreferred),
-		SK_PNMI_RW, Rlmt, 0},
-	{OID_SKGE_RLMT_CHANGE_CTS,
-		1,
-		0,
-		SK_PNMI_MAI_OFF(RlmtChangeCts),
-		SK_PNMI_RO, Rlmt, 0},
-	{OID_SKGE_RLMT_CHANGE_TIME,
-		1,
-		0,
-		SK_PNMI_MAI_OFF(RlmtChangeTime),
-		SK_PNMI_RO, Rlmt, 0},
-	{OID_SKGE_RLMT_CHANGE_ESTIM,
-		1,
-		0,
-		SK_PNMI_MAI_OFF(RlmtChangeEstimate),
-		SK_PNMI_RO, Rlmt, 0},
-	{OID_SKGE_RLMT_CHANGE_THRES,
-		1,
-		0,
-		SK_PNMI_MAI_OFF(RlmtChangeThreshold),
-		SK_PNMI_RW, Rlmt, 0},
-	{OID_SKGE_RLMT_PORT_INDEX,
-		SK_PNMI_MAC_ENTRIES,
-		sizeof(SK_PNMI_RLMT),
-		SK_PNMI_OFF(Rlmt) + SK_PNMI_RLM_OFF(RlmtIndex),
-		SK_PNMI_RO, RlmtStat, 0},
-	{OID_SKGE_RLMT_STATUS,
-		SK_PNMI_MAC_ENTRIES,
-		sizeof(SK_PNMI_RLMT),
-		SK_PNMI_OFF(Rlmt) + SK_PNMI_RLM_OFF(RlmtStatus),
-		SK_PNMI_RO, RlmtStat, 0},
-	{OID_SKGE_RLMT_TX_HELLO_CTS,
-		SK_PNMI_MAC_ENTRIES,
-		sizeof(SK_PNMI_RLMT),
-		SK_PNMI_OFF(Rlmt) + SK_PNMI_RLM_OFF(RlmtTxHelloCts),
-		SK_PNMI_RO, RlmtStat, 0},
-	{OID_SKGE_RLMT_RX_HELLO_CTS,
-		SK_PNMI_MAC_ENTRIES,
-		sizeof(SK_PNMI_RLMT),
-		SK_PNMI_OFF(Rlmt) + SK_PNMI_RLM_OFF(RlmtRxHelloCts),
-		SK_PNMI_RO, RlmtStat, 0},
-	{OID_SKGE_RLMT_TX_SP_REQ_CTS,
-		SK_PNMI_MAC_ENTRIES,
-		sizeof(SK_PNMI_RLMT),
-		SK_PNMI_OFF(Rlmt) + SK_PNMI_RLM_OFF(RlmtTxSpHelloReqCts),
-		SK_PNMI_RO, RlmtStat, 0},
-	{OID_SKGE_RLMT_RX_SP_CTS,
-		SK_PNMI_MAC_ENTRIES,
-		sizeof(SK_PNMI_RLMT),
-		SK_PNMI_OFF(Rlmt) + SK_PNMI_RLM_OFF(RlmtRxSpHelloCts),
-		SK_PNMI_RO, RlmtStat, 0},
-	{OID_SKGE_RLMT_MONITOR_NUMBER,
-		1,
-		0,
-		SK_PNMI_MAI_OFF(RlmtMonitorNumber),
-		SK_PNMI_RO, General, 0},
-	{OID_SKGE_RLMT_MONITOR_INDEX,
-		SK_PNMI_MONITOR_ENTRIES,
-		sizeof(SK_PNMI_RLMT_MONITOR),
-		SK_PNMI_OFF(RlmtMonitor) + SK_PNMI_MON_OFF(RlmtMonitorIndex),
-		SK_PNMI_RO, Monitor, 0},
-	{OID_SKGE_RLMT_MONITOR_ADDR,
-		SK_PNMI_MONITOR_ENTRIES,
-		sizeof(SK_PNMI_RLMT_MONITOR),
-		SK_PNMI_OFF(RlmtMonitor) + SK_PNMI_MON_OFF(RlmtMonitorAddr),
-		SK_PNMI_RO, Monitor, 0},
-	{OID_SKGE_RLMT_MONITOR_ERRS,
-		SK_PNMI_MONITOR_ENTRIES,
-		sizeof(SK_PNMI_RLMT_MONITOR),
-		SK_PNMI_OFF(RlmtMonitor) + SK_PNMI_MON_OFF(RlmtMonitorErrorCts),
-		SK_PNMI_RO, Monitor, 0},
-	{OID_SKGE_RLMT_MONITOR_TIMESTAMP,
-		SK_PNMI_MONITOR_ENTRIES,
-		sizeof(SK_PNMI_RLMT_MONITOR),
-		SK_PNMI_OFF(RlmtMonitor) + SK_PNMI_MON_OFF(RlmtMonitorTimestamp),
-		SK_PNMI_RO, Monitor, 0},
-	{OID_SKGE_RLMT_MONITOR_ADMIN,
-		SK_PNMI_MONITOR_ENTRIES,
-		sizeof(SK_PNMI_RLMT_MONITOR),
-		SK_PNMI_OFF(RlmtMonitor) + SK_PNMI_MON_OFF(RlmtMonitorAdmin),
-		SK_PNMI_RW, Monitor, 0},
-	{OID_SKGE_MTU,
-		1,
-		0,
-		SK_PNMI_MAI_OFF(MtuSize),
-		SK_PNMI_RW, MacPrivateConf, 0},
+#include "skgemib.c"
+
+/* global variables **********************************************************/
+
+/*
+ * Overflow status register bit table and corresponding counter
+ * dependent on MAC type - the number relates to the size of overflow
+ * mask returned by the pFnMacOverflow function
+ */
+PNMI_STATIC const SK_U16 StatOvrflwBit[][SK_PNMI_MAC_TYPES] = {
+/* Bit0  */	{ SK_PNMI_HTX, 				SK_PNMI_HTX_UNICAST},
+/* Bit1  */	{ SK_PNMI_HTX_OCTETHIGH, 	SK_PNMI_HTX_BROADCAST},
+/* Bit2  */	{ SK_PNMI_HTX_OCTETLOW, 	SK_PNMI_HTX_PMACC},
+/* Bit3  */	{ SK_PNMI_HTX_BROADCAST, 	SK_PNMI_HTX_MULTICAST},
+/* Bit4  */	{ SK_PNMI_HTX_MULTICAST, 	SK_PNMI_HTX_OCTETLOW},
+/* Bit5  */	{ SK_PNMI_HTX_UNICAST, 		SK_PNMI_HTX_OCTETHIGH},
+/* Bit6  */	{ SK_PNMI_HTX_LONGFRAMES, 	SK_PNMI_HTX_64},
+/* Bit7  */	{ SK_PNMI_HTX_BURST, 		SK_PNMI_HTX_127},
+/* Bit8  */	{ SK_PNMI_HTX_PMACC, 		SK_PNMI_HTX_255},
+/* Bit9  */	{ SK_PNMI_HTX_MACC, 		SK_PNMI_HTX_511},
+/* Bit10 */	{ SK_PNMI_HTX_SINGLE_COL, 	SK_PNMI_HTX_1023},
+/* Bit11 */	{ SK_PNMI_HTX_MULTI_COL, 	SK_PNMI_HTX_MAX},
+/* Bit12 */	{ SK_PNMI_HTX_EXCESS_COL, 	SK_PNMI_HTX_LONGFRAMES},
+/* Bit13 */	{ SK_PNMI_HTX_LATE_COL, 	SK_PNMI_HTX_RESERVED},
+/* Bit14 */	{ SK_PNMI_HTX_DEFFERAL, 	SK_PNMI_HTX_COL},
+/* Bit15 */	{ SK_PNMI_HTX_EXCESS_DEF, 	SK_PNMI_HTX_LATE_COL},
+/* Bit16 */	{ SK_PNMI_HTX_UNDERRUN, 	SK_PNMI_HTX_EXCESS_COL},
+/* Bit17 */	{ SK_PNMI_HTX_CARRIER, 		SK_PNMI_HTX_MULTI_COL},
+/* Bit18 */	{ SK_PNMI_HTX_UTILUNDER, 	SK_PNMI_HTX_SINGLE_COL},
+/* Bit19 */	{ SK_PNMI_HTX_UTILOVER, 	SK_PNMI_HTX_UNDERRUN},
+/* Bit20 */	{ SK_PNMI_HTX_64, 			SK_PNMI_HTX_RESERVED},
+/* Bit21 */	{ SK_PNMI_HTX_127, 			SK_PNMI_HTX_RESERVED},
+/* Bit22 */	{ SK_PNMI_HTX_255, 			SK_PNMI_HTX_RESERVED},
+/* Bit23 */	{ SK_PNMI_HTX_511, 			SK_PNMI_HTX_RESERVED},
+/* Bit24 */	{ SK_PNMI_HTX_1023, 		SK_PNMI_HTX_RESERVED},
+/* Bit25 */	{ SK_PNMI_HTX_MAX, 			SK_PNMI_HTX_RESERVED},
+/* Bit26 */	{ SK_PNMI_HTX_RESERVED, 	SK_PNMI_HTX_RESERVED},
+/* Bit27 */	{ SK_PNMI_HTX_RESERVED, 	SK_PNMI_HTX_RESERVED},
+/* Bit28 */	{ SK_PNMI_HTX_RESERVED, 	SK_PNMI_HTX_RESERVED},
+/* Bit29 */	{ SK_PNMI_HTX_RESERVED, 	SK_PNMI_HTX_RESERVED},
+/* Bit30 */	{ SK_PNMI_HTX_RESERVED, 	SK_PNMI_HTX_RESERVED},
+/* Bit31 */	{ SK_PNMI_HTX_RESERVED, 	SK_PNMI_HTX_RESERVED},
+/* Bit32 */	{ SK_PNMI_HRX, 				SK_PNMI_HRX_UNICAST},
+/* Bit33 */	{ SK_PNMI_HRX_OCTETHIGH, 	SK_PNMI_HRX_BROADCAST},
+/* Bit34 */	{ SK_PNMI_HRX_OCTETLOW, 	SK_PNMI_HRX_PMACC},
+/* Bit35 */	{ SK_PNMI_HRX_BROADCAST, 	SK_PNMI_HRX_MULTICAST},
+/* Bit36 */	{ SK_PNMI_HRX_MULTICAST, 	SK_PNMI_HRX_FCS},
+/* Bit37 */	{ SK_PNMI_HRX_UNICAST, 		SK_PNMI_HRX_RESERVED},
+/* Bit38 */	{ SK_PNMI_HRX_PMACC, 		SK_PNMI_HRX_OCTETLOW},
+/* Bit39 */	{ SK_PNMI_HRX_MACC, 		SK_PNMI_HRX_OCTETHIGH},
+/* Bit40 */	{ SK_PNMI_HRX_PMACC_ERR, 	SK_PNMI_HRX_BADOCTETLOW},
+/* Bit41 */	{ SK_PNMI_HRX_MACC_UNKWN,	SK_PNMI_HRX_BADOCTETHIGH},
+/* Bit42 */	{ SK_PNMI_HRX_BURST, 		SK_PNMI_HRX_UNDERSIZE},
+/* Bit43 */	{ SK_PNMI_HRX_MISSED, 		SK_PNMI_HRX_RUNT},
+/* Bit44 */	{ SK_PNMI_HRX_FRAMING, 		SK_PNMI_HRX_64},
+/* Bit45 */	{ SK_PNMI_HRX_OVERFLOW, 	SK_PNMI_HRX_127},
+/* Bit46 */	{ SK_PNMI_HRX_JABBER, 		SK_PNMI_HRX_255},
+/* Bit47 */	{ SK_PNMI_HRX_CARRIER, 		SK_PNMI_HRX_511},
+/* Bit48 */	{ SK_PNMI_HRX_IRLENGTH, 	SK_PNMI_HRX_1023},
+/* Bit49 */	{ SK_PNMI_HRX_SYMBOL, 		SK_PNMI_HRX_MAX},
+/* Bit50 */	{ SK_PNMI_HRX_SHORTS, 		SK_PNMI_HRX_LONGFRAMES},
+/* Bit51 */	{ SK_PNMI_HRX_RUNT, 		SK_PNMI_HRX_TOO_LONG},
+/* Bit52 */	{ SK_PNMI_HRX_TOO_LONG, 	SK_PNMI_HRX_JABBER},
+/* Bit53 */	{ SK_PNMI_HRX_FCS, 			SK_PNMI_HRX_RESERVED},
+/* Bit54 */	{ SK_PNMI_HRX_RESERVED, 	SK_PNMI_HRX_OVERFLOW},
+/* Bit55 */	{ SK_PNMI_HRX_CEXT, 		SK_PNMI_HRX_RESERVED},
+/* Bit56 */	{ SK_PNMI_HRX_UTILUNDER, 	SK_PNMI_HRX_RESERVED},
+/* Bit57 */	{ SK_PNMI_HRX_UTILOVER, 	SK_PNMI_HRX_RESERVED},
+/* Bit58 */	{ SK_PNMI_HRX_64, 			SK_PNMI_HRX_RESERVED},
+/* Bit59 */	{ SK_PNMI_HRX_127, 			SK_PNMI_HRX_RESERVED},
+/* Bit60 */	{ SK_PNMI_HRX_255, 			SK_PNMI_HRX_RESERVED},
+/* Bit61 */	{ SK_PNMI_HRX_511, 			SK_PNMI_HRX_RESERVED},
+/* Bit62 */	{ SK_PNMI_HRX_1023, 		SK_PNMI_HRX_RESERVED},
+/* Bit63 */	{ SK_PNMI_HRX_MAX, 			SK_PNMI_HRX_RESERVED}
 };
 
 /*
  * Table for hardware register saving on resets and port switches
  */
-static const SK_PNMI_STATADDR StatAddress[SK_PNMI_MAX_IDX] = {
-	/*  0 */	{TRUE, XM_TXF_OK},
-	/*  1 */	{TRUE, 0},
-	/*  2 */	{FALSE, 0},
-	/*  3 */	{TRUE, XM_TXF_BC_OK},
-	/*  4 */	{TRUE, XM_TXF_MC_OK},
-	/*  5 */	{TRUE, XM_TXF_UC_OK},
-	/*  6 */	{TRUE, XM_TXF_LONG},
-	/*  7 */	{TRUE, XM_TXE_BURST},
-	/*  8 */	{TRUE, XM_TXF_MPAUSE},
-	/*  9 */	{TRUE, XM_TXF_MCTRL},
-	/* 10 */	{TRUE, XM_TXF_SNG_COL},
-	/* 11 */	{TRUE, XM_TXF_MUL_COL},
-	/* 12 */	{TRUE, XM_TXF_ABO_COL},
-	/* 13 */	{TRUE, XM_TXF_LAT_COL},
-	/* 14 */	{TRUE, XM_TXF_DEF},
-	/* 15 */	{TRUE, XM_TXF_EX_DEF},
-	/* 16 */	{TRUE, XM_TXE_FIFO_UR},
-	/* 17 */	{TRUE, XM_TXE_CS_ERR},
-	/* 18 */	{FALSE, 0},
-	/* 19 */	{FALSE, 0},
-	/* 20 */	{TRUE, XM_TXF_64B},
-	/* 21 */	{TRUE, XM_TXF_127B},
-	/* 22 */	{TRUE, XM_TXF_255B},
-	/* 23 */	{TRUE, XM_TXF_511B},
-	/* 24 */	{TRUE, XM_TXF_1023B},
-	/* 25 */	{TRUE, XM_TXF_MAX_SZ},
-	/* 26 */	{FALSE, 0},
-	/* 27 */	{FALSE, 0},
-	/* 28 */	{FALSE, 0},
-	/* 29 */	{FALSE, 0},
-	/* 30 */	{FALSE, 0},
-	/* 31 */	{FALSE, 0},
-	/* 32 */	{TRUE, XM_RXF_OK},
-	/* 33 */	{TRUE, 0},
-	/* 34 */	{FALSE, 0},
-	/* 35 */	{TRUE, XM_RXF_BC_OK},
-	/* 36 */	{TRUE, XM_RXF_MC_OK},
-	/* 37 */	{TRUE, XM_RXF_UC_OK},
-	/* 38 */	{TRUE, XM_RXF_MPAUSE},
-	/* 39 */	{TRUE, XM_RXF_MCTRL},
-	/* 40 */	{TRUE, XM_RXF_INV_MP},
-	/* 41 */	{TRUE, XM_RXF_INV_MOC},
-	/* 42 */	{TRUE, XM_RXE_BURST},
-	/* 43 */	{TRUE, XM_RXE_FMISS},
-	/* 44 */	{TRUE, XM_RXF_FRA_ERR},
-	/* 45 */	{TRUE, XM_RXE_FIFO_OV},
-	/* 46 */	{TRUE, XM_RXF_JAB_PKT},
-	/* 47 */	{TRUE, XM_RXE_CAR_ERR},
-	/* 48 */	{TRUE, XM_RXF_LEN_ERR},
-	/* 49 */	{TRUE, XM_RXE_SYM_ERR},
-	/* 50 */	{TRUE, XM_RXE_SHT_ERR},
-	/* 51 */	{TRUE, XM_RXE_RUNT},
-	/* 52 */	{TRUE, XM_RXF_LNG_ERR},
-	/* 53 */	{TRUE, XM_RXF_FCS_ERR},
-	/* 54 */	{FALSE, 0},
-	/* 55 */	{TRUE, XM_RXF_CEX_ERR},
-	/* 56 */	{FALSE, 0},
-	/* 57 */	{FALSE, 0},
-	/* 58 */	{TRUE, XM_RXF_64B},
-	/* 59 */	{TRUE, XM_RXF_127B},
-	/* 60 */	{TRUE, XM_RXF_255B},
-	/* 61 */	{TRUE, XM_RXF_511B},
-	/* 62 */	{TRUE, XM_RXF_1023B},
-	/* 63 */	{TRUE, XM_RXF_MAX_SZ},
-	/* 64 */	{FALSE, 0},
-	/* 65 */	{FALSE, 0},
-	/* 66 */	{TRUE, 0}
+PNMI_STATIC const SK_PNMI_STATADDR StatAddr[SK_PNMI_MAX_IDX][SK_PNMI_MAC_TYPES] = {
+	/* SK_PNMI_HTX */
+	{{XM_TXF_OK, SK_TRUE}, {0, SK_FALSE}},
+	/* SK_PNMI_HTX_OCTETHIGH */
+	{{XM_TXO_OK_HI, SK_TRUE}, {GM_TXO_OK_HI, SK_TRUE}},
+	/* SK_PNMI_HTX_OCTETLOW */
+	{{XM_TXO_OK_LO, SK_FALSE}, {GM_TXO_OK_LO, SK_FALSE}},
+	/* SK_PNMI_HTX_BROADCAST */
+	{{XM_TXF_BC_OK, SK_TRUE}, {GM_TXF_BC_OK, SK_TRUE}},
+	/* SK_PNMI_HTX_MULTICAST */
+	{{XM_TXF_MC_OK, SK_TRUE}, {GM_TXF_MC_OK, SK_TRUE}},
+	/* SK_PNMI_HTX_UNICAST */
+	{{XM_TXF_UC_OK, SK_TRUE}, {GM_TXF_UC_OK, SK_TRUE}},
+	/* SK_PNMI_HTX_BURST */
+	{{XM_TXE_BURST, SK_TRUE}, {0, SK_FALSE}},
+	/* SK_PNMI_HTX_PMACC */
+	{{XM_TXF_MPAUSE, SK_TRUE}, {GM_TXF_MPAUSE, SK_TRUE}},
+	/* SK_PNMI_HTX_MACC */
+	{{XM_TXF_MCTRL, SK_TRUE}, {0, SK_FALSE}},
+	/* SK_PNMI_HTX_COL */
+	{{0, SK_FALSE}, {GM_TXF_COL, SK_TRUE}},
+	/* SK_PNMI_HTX_SINGLE_COL */
+	{{XM_TXF_SNG_COL, SK_TRUE}, {GM_TXF_SNG_COL, SK_TRUE}},
+	/* SK_PNMI_HTX_MULTI_COL */
+	{{XM_TXF_MUL_COL, SK_TRUE}, {GM_TXF_MUL_COL, SK_TRUE}},
+	/* SK_PNMI_HTX_EXCESS_COL */
+	{{XM_TXF_ABO_COL, SK_TRUE}, {GM_TXF_ABO_COL, SK_TRUE}},
+	/* SK_PNMI_HTX_LATE_COL */
+	{{XM_TXF_LAT_COL, SK_TRUE}, {GM_TXF_LAT_COL, SK_TRUE}},
+	/* SK_PNMI_HTX_DEFFERAL */
+	{{XM_TXF_DEF, SK_TRUE}, {0, SK_FALSE}},
+	/* SK_PNMI_HTX_EXCESS_DEF */
+	{{XM_TXF_EX_DEF, SK_TRUE}, {0, SK_FALSE}},
+	/* SK_PNMI_HTX_UNDERRUN */
+	{{XM_TXE_FIFO_UR, SK_TRUE}, {GM_TXE_FIFO_UR, SK_TRUE}},
+	/* SK_PNMI_HTX_CARRIER */
+	{{XM_TXE_CS_ERR, SK_TRUE}, {0, SK_FALSE}},
+	/* SK_PNMI_HTX_UTILUNDER */
+	{{0, SK_FALSE}, {0, SK_FALSE}},
+	/* SK_PNMI_HTX_UTILOVER */
+	{{0, SK_FALSE}, {0, SK_FALSE}},
+	/* SK_PNMI_HTX_64 */
+	{{XM_TXF_64B, SK_TRUE}, {GM_TXF_64B, SK_TRUE}},
+	/* SK_PNMI_HTX_127 */
+	{{XM_TXF_127B, SK_TRUE}, {GM_TXF_127B, SK_TRUE}},
+	/* SK_PNMI_HTX_255 */
+	{{XM_TXF_255B, SK_TRUE}, {GM_TXF_255B, SK_TRUE}},
+	/* SK_PNMI_HTX_511 */
+	{{XM_TXF_511B, SK_TRUE}, {GM_TXF_511B, SK_TRUE}},
+	/* SK_PNMI_HTX_1023 */
+	{{XM_TXF_1023B, SK_TRUE}, {GM_TXF_1023B, SK_TRUE}},
+	/* SK_PNMI_HTX_MAX */
+	{{XM_TXF_MAX_SZ, SK_TRUE}, {GM_TXF_1518B, SK_TRUE}},
+	/* SK_PNMI_HTX_LONGFRAMES  */
+	{{XM_TXF_LONG, SK_TRUE}, {GM_TXF_MAX_SZ, SK_TRUE}},
+	/* SK_PNMI_HTX_SYNC */
+	{{0, SK_FALSE}, {0, SK_FALSE}},
+	/* SK_PNMI_HTX_SYNC_OCTET */
+	{{0, SK_FALSE}, {0, SK_FALSE}},
+	/* SK_PNMI_HTX_RESERVED */
+	{{0, SK_FALSE}, {0, SK_FALSE}},
+	/* SK_PNMI_HRX */
+	{{XM_RXF_OK, SK_TRUE}, {0, SK_FALSE}},
+	/* SK_PNMI_HRX_OCTETHIGH */
+	{{XM_RXO_OK_HI, SK_TRUE}, {GM_RXO_OK_HI, SK_TRUE}},
+	/* SK_PNMI_HRX_OCTETLOW */
+	{{XM_RXO_OK_LO, SK_FALSE}, {GM_RXO_OK_LO, SK_FALSE}},
+	/* SK_PNMI_HRX_BADOCTETHIGH */
+	{{0, SK_FALSE}, {GM_RXO_ERR_HI, SK_TRUE}},
+	/* SK_PNMI_HRX_BADOCTETLOW */
+	{{0, SK_FALSE}, {GM_RXO_ERR_LO, SK_TRUE}},
+	/* SK_PNMI_HRX_BROADCAST */
+	{{XM_RXF_BC_OK, SK_TRUE}, {GM_RXF_BC_OK, SK_TRUE}},
+	/* SK_PNMI_HRX_MULTICAST */
+	{{XM_RXF_MC_OK, SK_TRUE}, {GM_RXF_MC_OK, SK_TRUE}},
+	/* SK_PNMI_HRX_UNICAST */
+	{{XM_RXF_UC_OK, SK_TRUE}, {GM_RXF_UC_OK, SK_TRUE}},
+	/* SK_PNMI_HRX_PMACC */
+	{{XM_RXF_MPAUSE, SK_TRUE}, {GM_RXF_MPAUSE, SK_TRUE}},
+	/* SK_PNMI_HRX_MACC */
+	{{XM_RXF_MCTRL, SK_TRUE}, {0, SK_FALSE}},
+	/* SK_PNMI_HRX_PMACC_ERR */
+	{{XM_RXF_INV_MP, SK_TRUE}, {0, SK_FALSE}},
+	/* SK_PNMI_HRX_MACC_UNKWN */
+	{{XM_RXF_INV_MOC, SK_TRUE}, {0, SK_FALSE}},
+	/* SK_PNMI_HRX_BURST */
+	{{XM_RXE_BURST, SK_TRUE}, {0, SK_FALSE}},
+	/* SK_PNMI_HRX_MISSED */
+	{{XM_RXE_FMISS, SK_TRUE}, {0, SK_FALSE}},
+	/* SK_PNMI_HRX_FRAMING */
+	{{XM_RXF_FRA_ERR, SK_TRUE}, {0, SK_FALSE}},
+	/* SK_PNMI_HRX_UNDERSIZE */
+	{{0, SK_FALSE}, {GM_RXF_SHT, SK_TRUE}},
+	/* SK_PNMI_HRX_OVERFLOW */
+	{{XM_RXE_FIFO_OV, SK_TRUE}, {GM_RXE_FIFO_OV, SK_TRUE}},
+	/* SK_PNMI_HRX_JABBER */
+	{{XM_RXF_JAB_PKT, SK_TRUE}, {GM_RXF_JAB_PKT, SK_TRUE}},
+	/* SK_PNMI_HRX_CARRIER */
+	{{XM_RXE_CAR_ERR, SK_TRUE}, {0, SK_FALSE}},
+	/* SK_PNMI_HRX_IRLENGTH */
+	{{XM_RXF_LEN_ERR, SK_TRUE}, {0, SK_FALSE}},
+	/* SK_PNMI_HRX_SYMBOL */
+	{{XM_RXE_SYM_ERR, SK_TRUE}, {0, SK_FALSE}},
+	/* SK_PNMI_HRX_SHORTS */
+	{{XM_RXE_SHT_ERR, SK_TRUE}, {0, SK_FALSE}},
+	/* SK_PNMI_HRX_RUNT */
+	{{XM_RXE_RUNT, SK_TRUE}, {GM_RXE_FRAG, SK_TRUE}},
+	/* SK_PNMI_HRX_TOO_LONG */
+	{{XM_RXF_LNG_ERR, SK_TRUE}, {GM_RXF_LNG_ERR, SK_TRUE}},
+	/* SK_PNMI_HRX_FCS */
+	{{XM_RXF_FCS_ERR, SK_TRUE}, {GM_RXF_FCS_ERR, SK_TRUE}},
+	/* SK_PNMI_HRX_CEXT */
+	{{XM_RXF_CEX_ERR, SK_TRUE}, {0, SK_FALSE}},
+	/* SK_PNMI_HRX_UTILUNDER */
+	{{0, SK_FALSE}, {0, SK_FALSE}},
+	/* SK_PNMI_HRX_UTILOVER */
+	{{0, SK_FALSE}, {0, SK_FALSE}},
+	/* SK_PNMI_HRX_64 */
+	{{XM_RXF_64B, SK_TRUE}, {GM_RXF_64B, SK_TRUE}},
+	/* SK_PNMI_HRX_127 */
+	{{XM_RXF_127B, SK_TRUE}, {GM_RXF_127B, SK_TRUE}},
+	/* SK_PNMI_HRX_255 */
+	{{XM_RXF_255B, SK_TRUE}, {GM_RXF_255B, SK_TRUE}},
+	/* SK_PNMI_HRX_511 */
+	{{XM_RXF_511B, SK_TRUE}, {GM_RXF_511B, SK_TRUE}},
+	/* SK_PNMI_HRX_1023 */
+	{{XM_RXF_1023B, SK_TRUE}, {GM_RXF_1023B, SK_TRUE}},
+	/* SK_PNMI_HRX_MAX */
+	{{XM_RXF_MAX_SZ, SK_TRUE}, {GM_RXF_1518B, SK_TRUE}},
+	/* SK_PNMI_HRX_LONGFRAMES */
+	{{0, SK_FALSE}, {GM_RXF_MAX_SZ, SK_TRUE}},
+	/* SK_PNMI_HRX_RESERVED */
+	{{0, SK_FALSE}, {0, SK_FALSE}}
 };
 
 
@@ -1457,7 +781,6 @@
  * Returns:
  *	Always 0
  */
-
 int SkPnmiInit(
 SK_AC *pAC,		/* Pointer to adapter context */
 SK_IOC IoC,		/* IO context handle */
@@ -1468,6 +791,7 @@
 	SK_U16		Val16;		/* Multiple purpose 16 bit variable */
 	SK_U8		Val8;		/* Mulitple purpose 8 bit variable */
 	SK_EVPARA	EventParam;	/* Event struct for timer event */
+	SK_PNMI_VCT	*pVctBackupData;
 
 
 	SK_DBG_MSG(pAC, SK_DBGMOD_PNMI, SK_DBGCAT_CTRL,
@@ -1485,6 +809,31 @@
 			pAC->Pnmi.Port[PortIndex].ActiveFlag = SK_FALSE;
 			pAC->Pnmi.DualNetActiveFlag = SK_FALSE;
 		}
+
+#ifdef SK_PNMI_CHECK
+		if (SK_PNMI_MAX_IDX != SK_PNMI_CNT_NO) {
+			
+			SK_ERR_LOG(pAC, SK_ERRCL_SW, SK_PNMI_ERR049, SK_PNMI_ERR049MSG);
+
+			SK_DBG_MSG(pAC, SK_DBGMOD_PNMI, SK_DBGCAT_INIT | SK_DBGCAT_FATAL,
+					   ("CounterOffset struct size (%d) differs from"
+						"SK_PNMI_MAX_IDX (%d)\n",
+						SK_PNMI_CNT_NO, SK_PNMI_MAX_IDX));
+		}
+
+		if (SK_PNMI_MAX_IDX !=
+			(sizeof(StatAddr) / (sizeof(SK_PNMI_STATADDR) * SK_PNMI_MAC_TYPES))) {
+			
+			SK_ERR_LOG(pAC, SK_ERRCL_SW, SK_PNMI_ERR050, SK_PNMI_ERR050MSG);
+
+			SK_DBG_MSG(pAC, SK_DBGMOD_PNMI, SK_DBGCAT_INIT | SK_DBGCAT_FATAL,
+					   ("StatAddr table size (%d) differs from "
+						"SK_PNMI_MAX_IDX (%d)\n",
+						(sizeof(StatAddr) /
+						 (sizeof(SK_PNMI_STATADDR) * SK_PNMI_MAC_TYPES)),
+						 SK_PNMI_MAX_IDX));
+		}
+#endif /* SK_PNMI_CHECK */
 		break;
 
 	case SK_INIT_IO:
@@ -1495,12 +844,16 @@
 
 		for (PortIndex = 0; PortIndex < PortMax; PortIndex ++) {
 
-			Val16 = XM_SC_CLR_RXC | XM_SC_CLR_TXC;
-			XM_OUT16(IoC, PortIndex, XM_STAT_CMD, Val16);
-			/* Clear two times according to Errata #3 */
-			XM_OUT16(IoC, PortIndex, XM_STAT_CMD, Val16);
+			pAC->GIni.GIFunc.pFnMacResetCounter(pAC, IoC, PortIndex);
 		}
-
+		
+		/* Initialize DSP variables for Vct() to 0xff => Never written! */		
+		for (PortIndex = 0; PortIndex < PortMax; PortIndex ++) {
+			pAC->GIni.GP[PortIndex].PCableLen = 0xff;
+			pVctBackupData = &pAC->Pnmi.VctBackup[PortIndex];
+			pVctBackupData->PCableLen = 0xff;
+		}
+		
 		/*
 		 * Get pci bus speed
 		 */
@@ -1526,6 +879,22 @@
 		}
 
 		/*
+		 * Get chipset
+		 */
+		switch (pAC->GIni.GIChipId) {
+		case CHIP_ID_GENESIS:
+			pAC->Pnmi.Chipset = SK_PNMI_CHIPSET_XMAC;
+			break;
+
+		case CHIP_ID_YUKON:
+			pAC->Pnmi.Chipset = SK_PNMI_CHIPSET_YUKON;
+			break;
+
+		default:
+			break;
+		}
+
+		/*
 		 * Get PMD and DeviceType
 		 */
 		SK_IN8(IoC, B2_PMD_TYP, &Val8);
@@ -1647,7 +1016,6 @@
  *                               exist (e.g. port instance 3 on a two port
  *	                         adapter.
  */
-
 int SkPnmiGetVar(
 SK_AC *pAC,		/* Pointer to adapter context */
 SK_IOC IoC,		/* IO context handle */
@@ -1690,7 +1058,6 @@
  *                               exist (e.g. port instance 3 on a two port
  *	                         adapter.
  */
-
 int SkPnmiPreSetVar(
 SK_AC *pAC,		/* Pointer to adapter context */
 SK_IOC IoC,		/* IO context handle */
@@ -1734,7 +1101,6 @@
  *                               exist (e.g. port instance 3 on a two port
  *	                         adapter.
  */
-
 int SkPnmiSetVar(
 SK_AC *pAC,		/* Pointer to adapter context */
 SK_IOC IoC,		/* IO context handle */
@@ -1769,9 +1135,8 @@
  *	SK_PNMI_ERR_GENERAL      A general severe internal error occured
  *	SK_PNMI_ERR_TOO_SHORT    The passed buffer is too short to take
  *	                         the data.
- *	SK_PNMI_ERR_UNKNOWN_NET  The requested NetIndex doesn't exist 
+ *	SK_PNMI_ERR_UNKNOWN_NET  The requested NetIndex doesn't exist
  */
-
 int SkPnmiGetStruct(
 SK_AC *pAC,		/* Pointer to adapter context */
 SK_IOC IoC,		/* IO context handle */
@@ -1861,8 +1226,7 @@
 
 	/* Retrieve values */
 	SK_MEMSET((char *)pBuf, 0, SK_PNMI_STRUCT_SIZE);
-	for (TableIndex = 0; TableIndex < sizeof(IdTable)/sizeof(IdTable[0]);
-		TableIndex ++) {
+	for (TableIndex = 0; TableIndex < ID_TABLE_SIZE; TableIndex ++) {
 
 		InstanceNo = IdTable[TableIndex].InstanceNo;
 		for (InstanceCnt = 1; InstanceCnt <= InstanceNo;
@@ -1951,7 +1315,6 @@
  *	SK_PNMI_ERR_BAD_VALUE    The passed value is not in the valid
  *	                         value range.
  */
-
 int SkPnmiPreSetStruct(
 SK_AC *pAC,		/* Pointer to adapter context */
 SK_IOC IoC,		/* IO context handle */
@@ -1963,7 +1326,7 @@
 		("PNMI: SkPnmiPreSetStruct: Called, BufLen=%d, NetIndex=%d\n",
 			*pLen, NetIndex));
 
-	return (PnmiStruct(pAC, IoC, SK_PNMI_PRESET, (char *)pBuf, 
+	return (PnmiStruct(pAC, IoC, SK_PNMI_PRESET, (char *)pBuf,
     					pLen, NetIndex));
 }
 
@@ -1990,7 +1353,6 @@
  *	SK_PNMI_ERR_BAD_VALUE    The passed value is not in the valid
  *	                         value range.
  */
-
 int SkPnmiSetStruct(
 SK_AC *pAC,		/* Pointer to adapter context */
 SK_IOC IoC,		/* IO context handle */
@@ -2002,7 +1364,7 @@
 		("PNMI: SkPnmiSetStruct: Called, BufLen=%d, NetIndex=%d\n",
 			*pLen, NetIndex));
 
-	return (PnmiStruct(pAC, IoC, SK_PNMI_SET, (char *)pBuf, 
+	return (PnmiStruct(pAC, IoC, SK_PNMI_SET, (char *)pBuf,
     					pLen, NetIndex));
 }
 
@@ -2056,7 +1418,6 @@
  * Returns:
  *	Always 0
  */
-
 int SkPnmiEvent(
 SK_AC *pAC,		/* Pointer to adapter context */
 SK_IOC IoC,		/* IO context handle */
@@ -2065,13 +1426,14 @@
 {
 	unsigned int	PhysPortIndex;
     unsigned int	MaxNetNumber;
-	int		CounterIndex;
-	int		Ret;
+	int			CounterIndex;
+	int			Ret;
 	SK_U16		MacStatus;
 	SK_U64		OverflowStatus;
 	SK_U64		Mask;
-	SK_U32		MacCntEvent;
+	int			MacType;
 	SK_U64		Value;
+	SK_U32		Val32;
 	SK_U16		Register;
 	SK_EVPARA	EventParam;
 	SK_U64		NewestValue;
@@ -2079,6 +1441,11 @@
 	SK_U64		Delta;
 	SK_PNMI_ESTIMATE *pEst;
 	SK_U32		NetIndex;
+	SK_GEPORT	*pPrt;
+	SK_PNMI_VCT	*pVctBackupData;
+	SK_U32		RetCode;
+	int		i;
+	SK_U32		CableLength;
 
 
 #ifdef DEBUG
@@ -2086,11 +1453,13 @@
 
 		SK_DBG_MSG(pAC, SK_DBGMOD_PNMI, SK_DBGCAT_CTRL,
 			("PNMI: SkPnmiEvent: Called, Event=0x%x, Param=0x%x\n",
-			(unsigned long)Event, (unsigned long)Param.Para64));
+			(unsigned int)Event, (unsigned int)Param.Para64));
 	}
 #endif
 	SK_PNMI_CHECKFLAGS("SkPnmiEvent: On call");
 
+	MacType = pAC->GIni.GIMacType;
+	
 	switch (Event) {
 
 	case SK_PNMI_EVT_SIRQ_OVERFLOW:
@@ -2100,7 +1469,8 @@
 		if (PhysPortIndex >= SK_MAX_MACS) {
 
 			SK_DBG_MSG(pAC, SK_DBGMOD_PNMI, SK_DBGCAT_CTRL,
-				("PNMI: ERR: SkPnmiEvent: SK_PNMI_EVT_SIRQ_OVERFLOW parameter wrong, PhysPortIndex=0x%x\n",
+				("PNMI: ERR: SkPnmiEvent: SK_PNMI_EVT_SIRQ_OVERFLOW parameter"
+				 " wrong, PhysPortIndex=0x%x\n",
 				PhysPortIndex));
 			return (0);
 		}
@@ -2108,25 +1478,11 @@
 		OverflowStatus = 0;
 
 		/*
-		 * Check which source caused an overflow interrupt. The
-		 * interrupt source is a self-clearing register. We only
-		 * need to check the interrupt source once. Another check
-		 * will be done by the SIRQ module to be sure that no
-		 * interrupt get lost during process time.
+		 * Check which source caused an overflow interrupt.
 		 */
-		if ((MacStatus & XM_IS_RXC_OV) == XM_IS_RXC_OV) {
-
-			XM_IN32(IoC, PhysPortIndex, XM_RX_CNT_EV,
-				&MacCntEvent);
-			OverflowStatus |= (SK_U64)MacCntEvent << 32;
-		}
-		if ((MacStatus & XM_IS_TXC_OV) == XM_IS_TXC_OV) {
-
-			XM_IN32(IoC, PhysPortIndex, XM_TX_CNT_EV,
-				&MacCntEvent);
-			OverflowStatus |= (SK_U64)MacCntEvent;
-		}
-		if (OverflowStatus == 0) {
+		if ((pAC->GIni.GIFunc.pFnMacOverflow(pAC, IoC, PhysPortIndex,
+				MacStatus, &OverflowStatus) != 0) ||
+			(OverflowStatus == 0)) {
 
 			SK_PNMI_CHECKFLAGS("SkPnmiEvent: On return");
 			return (0);
@@ -2145,45 +1501,46 @@
 				continue;
 			}
 
-			switch (CounterIndex) {
+			switch (StatOvrflwBit[CounterIndex][MacType]) {
 
 			case SK_PNMI_HTX_UTILUNDER:
 			case SK_PNMI_HTX_UTILOVER:
-				XM_IN16(IoC, PhysPortIndex, XM_TX_CMD,
-					&Register);
-				Register |= XM_TX_SAM_LINE;
-				XM_OUT16(IoC, PhysPortIndex, XM_TX_CMD,
-					Register);
+				if (MacType == SK_MAC_XMAC) {
+					XM_IN16(IoC, PhysPortIndex, XM_TX_CMD, &Register);
+					Register |= XM_TX_SAM_LINE;
+					XM_OUT16(IoC, PhysPortIndex, XM_TX_CMD, Register);
+				}
 				break;
 
 			case SK_PNMI_HRX_UTILUNDER:
 			case SK_PNMI_HRX_UTILOVER:
-				XM_IN16(IoC, PhysPortIndex, XM_RX_CMD,
-					&Register);
-				Register |= XM_RX_SAM_LINE;
-				XM_OUT16(IoC, PhysPortIndex, XM_RX_CMD,
-					Register);
+				if (MacType == SK_MAC_XMAC) {
+					XM_IN16(IoC, PhysPortIndex, XM_RX_CMD, &Register);
+					Register |= XM_RX_SAM_LINE;
+					XM_OUT16(IoC, PhysPortIndex, XM_RX_CMD, Register);
+				}
 				break;
 
 			case SK_PNMI_HTX_OCTETHIGH:
 			case SK_PNMI_HTX_OCTETLOW:
-			case SK_PNMI_HTX_RESERVED26:
-			case SK_PNMI_HTX_RESERVED27:
-			case SK_PNMI_HTX_RESERVED28:
-			case SK_PNMI_HTX_RESERVED29:
-			case SK_PNMI_HTX_RESERVED30:
-			case SK_PNMI_HTX_RESERVED31:
+			case SK_PNMI_HTX_RESERVED:
 			case SK_PNMI_HRX_OCTETHIGH:
 			case SK_PNMI_HRX_OCTETLOW:
 			case SK_PNMI_HRX_IRLENGTH:
-			case SK_PNMI_HRX_RESERVED22:
+			case SK_PNMI_HRX_RESERVED:
 			
 			/*
 			 * the following counters aren't be handled (id > 63)
 			 */
 			case SK_PNMI_HTX_SYNC:
 			case SK_PNMI_HTX_SYNC_OCTET:
+				break;
+
 			case SK_PNMI_HRX_LONGFRAMES:
+				if (MacType == SK_MAC_GMAC) {
+					pAC->Pnmi.Port[PhysPortIndex].
+						CounterHigh[CounterIndex] ++;
+				}
 				break;
 
 			default:
@@ -2218,7 +1575,7 @@
 		if ((unsigned int)Param.Para64 >= (unsigned int)pAC->I2c.MaxSens) {
 
 			SK_DBG_MSG(pAC, SK_DBGMOD_PNMI, SK_DBGCAT_CTRL,
-				("PNMI: ERR:SkPnmiEvent: SK_PNMI_EVT_SEN_WAR_UPP parameter wrong, SensorIndex=%d\n",
+				("PNMI: ERR: SkPnmiEvent: SK_PNMI_EVT_SEN_WAR_UPP parameter wrong, SensorIndex=%d\n",
 				(unsigned int)Param.Para64));
 			return (0);
 		}
@@ -2282,7 +1639,7 @@
 		 * Be careful in changing these values, on change check
 		 *   - typedef of SK_PNMI_ESTIMATE (Size of EstValue
 		 *     array one less than value number)
-		 *   - Timer initilization SkTimerStart() in SkPnmiInit
+		 *   - Timer initialization SkTimerStart() in SkPnmiInit
 		 *   - Delta value below must be multiplicated with
 		 *     power of 2
 		 *
@@ -2361,14 +1718,14 @@
 		 * Set all counters and timestamps to zero
 		 */
 		ResetCounter(pAC, IoC, NetIndex); /* the according NetIndex is required
-												as a Parameter of the Event */ 
+												as a Parameter of the Event */
 		break;
 
 	case SK_PNMI_EVT_XMAC_RESET:
 		/*
 		 * To grant continuous counter values store the current
 		 * XMAC statistic values to the entries 1..n of the
-		 * CounterOffset array. XMAC Errata #2 
+		 * CounterOffset array. XMAC Errata #2
 		 */
 #ifdef DEBUG
 		if ((unsigned int)Param.Para64 >= SK_MAX_MACS) {
@@ -2396,31 +1753,31 @@
 		 */
 		pAC->Pnmi.MacUpdatedFlag ++;
 
-		for (CounterIndex = 0; CounterIndex < SK_PNMI_SCNT_NOT;
+		for (CounterIndex = 0; CounterIndex < SK_PNMI_MAX_IDX;
 			CounterIndex ++) {
 
-			if (!StatAddress[CounterIndex].GetOffset) {
+			if (!StatAddr[CounterIndex][MacType].GetOffset) {
 
 				continue;
 			}
 
-			pAC->Pnmi.Port[PhysPortIndex].
-				CounterOffset[CounterIndex] = GetPhysStatVal(
-				pAC, IoC, PhysPortIndex, CounterIndex);
-			pAC->Pnmi.Port[PhysPortIndex].
-				CounterHigh[CounterIndex] = 0;
+			pAC->Pnmi.Port[PhysPortIndex].CounterOffset[CounterIndex] =
+				GetPhysStatVal(pAC, IoC, PhysPortIndex, CounterIndex);
+			
+			pAC->Pnmi.Port[PhysPortIndex].CounterHigh[CounterIndex] = 0;
 		}
 
 		pAC->Pnmi.MacUpdatedFlag --;
 		break;
 
 	case SK_PNMI_EVT_RLMT_PORT_UP:
+		PhysPortIndex = (unsigned int)Param.Para32[0];
 #ifdef DEBUG
-		if ((unsigned int)Param.Para32[0] >= SK_MAX_MACS) {
+		if (PhysPortIndex >= SK_MAX_MACS) {
 
 			SK_DBG_MSG(pAC, SK_DBGMOD_PNMI, SK_DBGCAT_CTRL,
-				("PNMI: ERR: SkPnmiEvent: SK_PNMI_EVT_RLMT_PORT_UP parameter wrong, PhysPortIndex=%d\n",
-				(unsigned int)Param.Para32[0]));
+				("PNMI: ERR: SkPnmiEvent: SK_PNMI_EVT_RLMT_PORT_UP parameter"
+                 " wrong, PhysPortIndex=%d\n", PhysPortIndex));
 
 			return (0);
 		}
@@ -2429,18 +1786,34 @@
 		 * Store a trap message in the trap buffer and generate an event for
 		 * user space applications with the SK_DRIVER_SENDEVENT macro.
 		 */
-		QueueRlmtPortTrap(pAC, OID_SKGE_TRAP_RLMT_PORT_UP,
-			(unsigned int)Param.Para32[0]);
+		QueueRlmtPortTrap(pAC, OID_SKGE_TRAP_RLMT_PORT_UP, PhysPortIndex);
 		(void)SK_DRIVER_SENDEVENT(pAC, IoC);
+
+		/* Bugfix for XMAC errata (#10620)*/
+		if (MacType == SK_MAC_XMAC) {
+			/* Add incremental difference to offset (#10620)*/
+			(void)pAC->GIni.GIFunc.pFnMacStatistic(pAC, IoC, PhysPortIndex,
+				XM_RXE_SHT_ERR, &Val32);
+			
+			Value = (((SK_U64)pAC->Pnmi.Port[PhysPortIndex].
+				 CounterHigh[SK_PNMI_HRX_SHORTS] << 32) | (SK_U64)Val32);
+			pAC->Pnmi.Port[PhysPortIndex].CounterOffset[SK_PNMI_HRX_SHORTS] +=
+				Value - pAC->Pnmi.Port[PhysPortIndex].RxShortZeroMark;
+		}
+		
+		/* Tell VctStatus() that a link was up meanwhile. */
+		pAC->Pnmi.VctStatus[PhysPortIndex] |= SK_PNMI_VCT_LINK;		
 		break;
 
-	case SK_PNMI_EVT_RLMT_PORT_DOWN:
+    case SK_PNMI_EVT_RLMT_PORT_DOWN:
+		PhysPortIndex = (unsigned int)Param.Para32[0];
+
 #ifdef DEBUG
-		if ((unsigned int)Param.Para32[0] >= SK_MAX_MACS) {
+		if (PhysPortIndex >= SK_MAX_MACS) {
 
 			SK_DBG_MSG(pAC, SK_DBGMOD_PNMI, SK_DBGCAT_CTRL,
-				("PNMI: ERR: SkPnmiEvent: SK_PNMI_EVT_RLMT_PORT_DOWN parameter wrong, PhysPortIndex=%d\n",
-				(unsigned int)Param.Para32[0]));
+				("PNMI: ERR: SkPnmiEvent: SK_PNMI_EVT_RLMT_PORT_DOWN parameter"
+                 " wrong, PhysPortIndex=%d\n", PhysPortIndex));
 
 			return (0);
 		}
@@ -2449,14 +1822,25 @@
 		 * Store a trap message in the trap buffer and generate an event for
 		 * user space applications with the SK_DRIVER_SENDEVENT macro.
 		 */
-		QueueRlmtPortTrap(pAC, OID_SKGE_TRAP_RLMT_PORT_DOWN,
-			(unsigned int)Param.Para32[0]);
+		QueueRlmtPortTrap(pAC, OID_SKGE_TRAP_RLMT_PORT_DOWN, PhysPortIndex);
 		(void)SK_DRIVER_SENDEVENT(pAC, IoC);
+
+		/* Bugfix #10620 - get zero level for incremental difference */
+		if (MacType == SK_MAC_XMAC) {
+
+			(void)pAC->GIni.GIFunc.pFnMacStatistic(pAC, IoC, PhysPortIndex,
+				XM_RXE_SHT_ERR, &Val32);
+			
+			pAC->Pnmi.Port[PhysPortIndex].RxShortZeroMark =
+				(((SK_U64)pAC->Pnmi.Port[PhysPortIndex].
+				 CounterHigh[SK_PNMI_HRX_SHORTS] << 32) | (SK_U64)Val32);
+		}
 		break;
 
 	case SK_PNMI_EVT_RLMT_ACTIVE_DOWN:
 		PhysPortIndex = (unsigned int)Param.Para32[0];
 		NetIndex = (SK_U32)Param.Para32[1];
+
 #ifdef DEBUG
 		if (PhysPortIndex >= SK_MAX_MACS) {
 
@@ -2512,7 +1896,7 @@
 		for (CounterIndex = 0; CounterIndex < SK_PNMI_MAX_IDX;
 			CounterIndex ++) {
 
-			if (!StatAddress[CounterIndex].GetOffset) {
+			if (!StatAddr[CounterIndex][MacType].GetOffset) {
 
 				continue;
 			}
@@ -2533,6 +1917,7 @@
 	case SK_PNMI_EVT_RLMT_ACTIVE_UP:
 		PhysPortIndex = (unsigned int)Param.Para32[0];
 		NetIndex = (SK_U32)Param.Para32[1];
+
 #ifdef DEBUG
 		if (PhysPortIndex >= SK_MAX_MACS) {
 
@@ -2599,7 +1984,7 @@
 		for (CounterIndex = 0; CounterIndex < SK_PNMI_MAX_IDX;
 			CounterIndex ++) {
 
-			if (!StatAddress[CounterIndex].GetOffset) {
+			if (!StatAddr[CounterIndex][MacType].GetOffset) {
 
 				continue;
 			}
@@ -2609,9 +1994,7 @@
 			pAC->Pnmi.VirtualCounterOffset[CounterIndex] -= Value;
 		}
 
-		/*
-		 * Set port to active
-		 */
+		/* Set port to active */
 		pAC->Pnmi.Port[PhysPortIndex].ActiveFlag = SK_TRUE;
 
 		pAC->Pnmi.MacUpdatedFlag --;
@@ -2644,7 +2027,7 @@
 			return (SK_PNMI_ERR_UNKNOWN_NET);
 		}
 
-        if((unsigned int)Param.Para32[0] == 1){ /* single net mode */
+        if ((unsigned int)Param.Para32[0] == 1) { /* single net mode */
         	pAC->Pnmi.DualNetActiveFlag = SK_FALSE;
         }
         else { /* dual net mode */
@@ -2652,6 +2035,54 @@
         }
         break;
 
+    case SK_PNMI_EVT_VCT_RESET:
+	PhysPortIndex = Param.Para32[0];
+	pPrt = &pAC->GIni.GP[PhysPortIndex];
+	pVctBackupData = &pAC->Pnmi.VctBackup[PhysPortIndex];
+	
+	if (pAC->Pnmi.VctStatus[PhysPortIndex] & SK_PNMI_VCT_PENDING) {
+		RetCode = SkGmCableDiagStatus(pAC, IoC, PhysPortIndex, SK_FALSE);
+		if (RetCode == 2) {
+			/*
+			 * VCT test is still running.
+			 * Start VCT timer counter again.
+			 */
+			SK_MEMSET((char *) &Param, 0, sizeof(Param));
+			Param.Para32[0] = PhysPortIndex;
+			Param.Para32[1] = -1;
+			SkTimerStart(pAC, IoC, &pAC->Pnmi.VctTimeout[PhysPortIndex].VctTimer,
+				4000000, SKGE_PNMI, SK_PNMI_EVT_VCT_RESET, Param);
+			break;
+		}
+		pAC->Pnmi.VctStatus[PhysPortIndex] &= ~SK_PNMI_VCT_PENDING;
+		pAC->Pnmi.VctStatus[PhysPortIndex] |=
+			(SK_PNMI_VCT_NEW_VCT_DATA | SK_PNMI_VCT_TEST_DONE);
+		
+		/* Copy results for later use to PNMI struct. */
+		for (i = 0; i < 4; i++)  {
+			if (pPrt->PMdiPairSts[i] == SK_PNMI_VCT_NORMAL_CABLE) {
+				if ((pPrt->PMdiPairLen[i] > 35) && (pPrt->PMdiPairLen[i] < 0xff)) {
+					pPrt->PMdiPairSts[i] = SK_PNMI_VCT_IMPEDANCE_MISMATCH;
+				}
+			}
+			if ((pPrt->PMdiPairLen[i] > 35) && (pPrt->PMdiPairLen[i] != 0xff)) {
+				CableLength = 1000 * (((175 * pPrt->PMdiPairLen[i]) / 210) - 28);
+			}
+			else {
+				CableLength = 0;
+			}
+			pVctBackupData->PMdiPairLen[i] = CableLength;
+			pVctBackupData->PMdiPairSts[i] = pPrt->PMdiPairSts[i];
+		}
+		
+		Param.Para32[0] = PhysPortIndex;
+		Param.Para32[1] = -1;
+		SkEventQueue(pAC, SKGE_DRV, SK_DRV_PORT_RESET, Param);
+		SkEventDispatcher(pAC, IoC);
+	}
+	
+	break;
+
 	default:
 		break;
 	}
@@ -2680,10 +2111,9 @@
  * Returns:
  *	SK_PNMI_ERR_XXX. For details have a look to the description of the
  *	calling functions.
- *	SK_PNMI_ERR_UNKNOWN_NET  The requested NetIndex doesn't exist 
+ *	SK_PNMI_ERR_UNKNOWN_NET  The requested NetIndex doesn't exist
  */
-
-static int PnmiVar(
+PNMI_STATIC int PnmiVar(
 SK_AC *pAC,		/* Pointer to adapter context */
 SK_IOC IoC,		/* IO context handle */
 int Action,		/* Get/PreSet/Set action */
@@ -2703,9 +2133,7 @@
 		return (SK_PNMI_ERR_UNKNOWN_OID);
 	}
 	
-    /* 
-     * Check NetIndex 
-     */
+    /* Check NetIndex */
 	if (NetIndex >= pAC->Rlmt.NumNets) {
 		return (SK_PNMI_ERR_UNKNOWN_NET);
 	}
@@ -2736,10 +2164,9 @@
  *
  * Returns:
  *	SK_PNMI_ERR_XXX. The codes are described in the calling functions.
- *	SK_PNMI_ERR_UNKNOWN_NET  The requested NetIndex doesn't exist 
+ *	SK_PNMI_ERR_UNKNOWN_NET  The requested NetIndex doesn't exist
  */
-
-static int PnmiStruct(
+PNMI_STATIC int PnmiStruct(
 SK_AC *pAC,		/* Pointer to adapter context */
 SK_IOC IoC,		/* IO context handle */
 int  Action,		/* Set action to be performed */
@@ -2771,9 +2198,7 @@
 		return (SK_PNMI_ERR_TOO_SHORT);
 	}
 	
-    /* 
-     * Check NetIndex 
-     */
+    /* Check NetIndex */
 	if (NetIndex >= pAC->Rlmt.NumNets) {
 		return (SK_PNMI_ERR_UNKNOWN_NET);
 	}
@@ -2802,10 +2227,10 @@
 	pAC->Pnmi.SirqUpdatedFlag ++;
 
 	/* Preset/Set values */
-	for (TableIndex = 0; TableIndex < sizeof(IdTable)/sizeof(IdTable[0]);
-		TableIndex ++) {
+	for (TableIndex = 0; TableIndex < ID_TABLE_SIZE; TableIndex ++) {
 
-		if (IdTable[TableIndex].Access != SK_PNMI_RW) {
+		if ((IdTable[TableIndex].Access != SK_PNMI_RW) &&
+			(IdTable[TableIndex].Access != SK_PNMI_WO)) {
 
 			continue;
 		}
@@ -2906,14 +2331,12 @@
  * Returns:
  *	The table index or -1 if not found.
  */
-
-static int LookupId(
+PNMI_STATIC int LookupId(
 SK_U32 Id)		/* Object identifier to be searched */
 {
 	int i;
-	int Len = sizeof(IdTable)/sizeof(IdTable[0]);
 
-	for (i=0; i<Len; i++) {
+	for (i = 0; i < ID_TABLE_SIZE; i++) {
 
 		if (IdTable[i].Id == Id) {
 
@@ -2945,8 +2368,7 @@
  *                               exist (e.g. port instance 3 on a two port
  *	                         adapter.
  */
-
-static int OidStruct(
+PNMI_STATIC int OidStruct(
 SK_AC *pAC,		/* Pointer to adapter context */
 SK_IOC IoC,		/* IO context handle */
 int Action,		/* Get/PreSet/Set action */
@@ -3013,8 +2435,7 @@
  *                               exist (e.g. port instance 3 on a two port
  *	                         adapter.
  */
-
-static int Perform(
+PNMI_STATIC int Perform(
 SK_AC *pAC,		/* Pointer to adapter context */
 SK_IOC IoC,		/* IO context handle */
 int Action,		/* Get/PreSet/Set action */
@@ -3145,8 +2566,7 @@
  *                               exist (e.g. port instance 3 on a two port
  *	                         adapter.
  */
-
-static int Mac8023Stat(
+PNMI_STATIC int Mac8023Stat(
 SK_AC *pAC,		/* Pointer to adapter context */
 SK_IOC IoC,		/* IO context handle */
 int Action,		/* Get/PreSet/Set action */
@@ -3157,8 +2577,9 @@
 unsigned int TableIndex,	/* Index to the Id table */
 SK_U32 NetIndex)	/* NetIndex (0..n), in single net mode allways zero */
 {
-	int    Ret;
-	SK_U64 StatVal;
+	int     Ret;
+	SK_U64  StatVal;
+	SK_U32  StatVal32;
 	SK_BOOL Is64BitReq = SK_FALSE;
 
 	/*
@@ -3179,9 +2600,7 @@
 		return (SK_PNMI_ERR_READ_ONLY);
 	}
 
-	/*
-	 * Check length
-	 */
+	/* Check length */
 	switch (Id) {
 
 	case OID_802_3_PERMANENT_ADDRESS:
@@ -3202,9 +2621,7 @@
 
 #else /* SK_NDIS_64BIT_CTR */
 
-		/*
-		 * for compatibility, at least 32bit are required for oid
-		 */
+		/* for compatibility, at least 32bit are required for OID */
 		if (*pLen < sizeof(SK_U32)) {
 			/*
 			* but indicate handling for 64bit values,
@@ -3250,11 +2667,8 @@
 	default:
 		StatVal = GetStatVal(pAC, IoC, 0, IdTable[TableIndex].Param, NetIndex);
 
-		/*
-		 * by default 32bit values are evaluated
-		 */
+		/* by default 32bit values are evaluated */
 		if (!Is64BitReq) {
-			SK_U32	StatVal32;
 			StatVal32 = (SK_U32)StatVal;
 			SK_PNMI_STORE_U32(pBuf, StatVal32);
 			*pLen = sizeof(SK_U32);
@@ -3276,7 +2690,7 @@
  * MacPrivateStat - OID handler function of OID_SKGE_STAT_XXX
  *
  * Description:
- *	Retrieves the XMAC statistic data.
+ *	Retrieves the MAC statistic data.
  *
  * Returns:
  *	SK_PNMI_ERR_OK           The request was successfully performed.
@@ -3288,8 +2702,7 @@
  *                               exist (e.g. port instance 3 on a two port
  *	                         adapter.
  */
-
-static int MacPrivateStat(
+PNMI_STATIC int MacPrivateStat(
 SK_AC *pAC,		/* Pointer to adapter context */
 SK_IOC IoC,		/* IO context handle */
 int Action,		/* Get/PreSet/Set action */
@@ -3305,18 +2718,19 @@
 	unsigned int	PhysPortMax;
 	unsigned int	Limit;
 	unsigned int	Offset;
-	int		Ret;
-	SK_U64		StatVal;
-
+	int				MacType;
+	int				Ret;
+	SK_U64			StatVal;
+	
+	
 
-	/*
-	 * Calculate instance if wished. MAC index 0 is the virtual
-	 * MAC.
-	 */
+	/* Calculate instance if wished. MAC index 0 is the virtual MAC */
 	PhysPortMax = pAC->GIni.GIMacsFound;
 	LogPortMax = SK_PNMI_PORT_PHYS2LOG(PhysPortMax);
+	
+	MacType = pAC->GIni.GIMacType;
 
-	if(pAC->Pnmi.DualNetActiveFlag == SK_TRUE){ /* Dual net mode */
+	if (pAC->Pnmi.DualNetActiveFlag == SK_TRUE) { /* Dual net mode */
 		LogPortMax--;
 	}
 
@@ -3337,19 +2751,14 @@
 		Limit = LogPortMax;
 	}
 
-
-	/*
-	 * Check action
-	 */
+	/* Check action */
 	if (Action != SK_PNMI_GET) {
 
 		*pLen = 0;
 		return (SK_PNMI_ERR_READ_ONLY);
 	}
 
-	/*
-	 * Check length
-	 */
+	/* Check length */
 	if (*pLen < (Limit - LogPortIndex) * sizeof(SK_U64)) {
 
 		*pLen = (Limit - LogPortIndex) * sizeof(SK_U64);
@@ -3357,7 +2766,7 @@
 	}
 
 	/*
-	 * Update XMAC statistic and increment semaphore to indicate that
+	 * Update MAC statistic and increment semaphore to indicate that
 	 * an update was already done.
 	 */
 	Ret = MacUpdate(pAC, IoC, 0, pAC->GIni.GIMacsFound - 1);
@@ -3368,9 +2777,7 @@
 	}
 	pAC->Pnmi.MacUpdatedFlag ++;
 
-	/*
-	 * Get value
-	 */
+	/* Get value */
 	Offset = 0;
 	for (; LogPortIndex < Limit; LogPortIndex ++) {
 
@@ -3384,26 +2791,45 @@
 		case OID_SKGE_STAT_RX_UTIL:
 			return (SK_PNMI_ERR_GENERAL);
 */
-		/*
-		 * Frames longer than IEEE 802.3 frame max size are counted
-		 * by XMAC in frame_too_long counter even reception of long
-		 * frames was enabled and the frame was correct.
-		 * So correct the value by subtracting RxLongFrame counter.
-		 */
-		case OID_SKGE_STAT_RX_TOO_LONG:
-			StatVal = GetStatVal(pAC, IoC, LogPortIndex,
-					     IdTable[TableIndex].Param, NetIndex) -
-				GetStatVal(pAC, IoC, LogPortIndex,
-					   SK_PNMI_HRX_LONGFRAMES, NetIndex);
-			SK_PNMI_STORE_U64(pBuf + Offset, StatVal);
+		case OID_SKGE_STAT_RX:
+			if (MacType == SK_MAC_GMAC) {
+				StatVal =
+					GetStatVal(pAC, IoC, LogPortIndex,
+							   SK_PNMI_HRX_BROADCAST, NetIndex) +
+					GetStatVal(pAC, IoC, LogPortIndex,
+							   SK_PNMI_HRX_MULTICAST, NetIndex) +
+					GetStatVal(pAC, IoC, LogPortIndex,
+							   SK_PNMI_HRX_UNICAST, NetIndex) +
+					GetStatVal(pAC, IoC, LogPortIndex,
+							   SK_PNMI_HRX_UNDERSIZE, NetIndex);
+			}
+			else {
+				StatVal = GetStatVal(pAC, IoC, LogPortIndex,
+					IdTable[TableIndex].Param, NetIndex);
+			}
+			break;
+
+		case OID_SKGE_STAT_TX:
+			if (MacType == SK_MAC_GMAC) {
+				StatVal =
+					GetStatVal(pAC, IoC, LogPortIndex,
+							   SK_PNMI_HTX_BROADCAST, NetIndex) +
+					GetStatVal(pAC, IoC, LogPortIndex,
+							   SK_PNMI_HTX_MULTICAST, NetIndex) +
+					GetStatVal(pAC, IoC, LogPortIndex,
+							   SK_PNMI_HTX_UNICAST, NetIndex);
+			}
+			else {
+				StatVal = GetStatVal(pAC, IoC, LogPortIndex,
+					IdTable[TableIndex].Param, NetIndex);
+			}
 			break;
 
 		default:
 			StatVal = GetStatVal(pAC, IoC, LogPortIndex,
 				IdTable[TableIndex].Param, NetIndex);
-			SK_PNMI_STORE_U64(pBuf + Offset, StatVal);
-			break;
 		}
+		SK_PNMI_STORE_U64(pBuf + Offset, StatVal);
 
 		Offset += sizeof(SK_U64);
 	}
@@ -3438,8 +2864,7 @@
  *                               exist (e.g. port instance 3 on a two port
  *	                         adapter.
  */
-
-static int Addr(
+PNMI_STATIC int Addr(
 SK_AC *pAC,		/* Pointer to adapter context */
 SK_IOC IoC,		/* IO context handle */
 int Action,		/* Get/PreSet/Set action */
@@ -3458,8 +2883,6 @@
 	unsigned int	Limit;
 	unsigned int	Offset = 0;
 
-
-
 	/*
 	 * Calculate instance if wished. MAC index 0 is the virtual
 	 * MAC.
@@ -3467,7 +2890,7 @@
 	PhysPortMax = pAC->GIni.GIMacsFound;
 	LogPortMax = SK_PNMI_PORT_PHYS2LOG(PhysPortMax);
 
-	if(pAC->Pnmi.DualNetActiveFlag == SK_TRUE){ /* Dual net mode */
+	if (pAC->Pnmi.DualNetActiveFlag == SK_TRUE) { /* Dual net mode */
 		LogPortMax--;
 	}
 
@@ -3493,9 +2916,7 @@
 	 */
 	if (Action == SK_PNMI_GET) {
 
-		/*
-		 * Check length
-		*/
+		/* Check length */
 		if (*pLen < (Limit - LogPortIndex) * 6) {
 
 			*pLen = (Limit - LogPortIndex) * 6;
@@ -3571,9 +2992,7 @@
 			return (SK_PNMI_ERR_GENERAL);
 		}
 
-		/*
-		 * Check length
-		*/
+		/* Check length */
 		if (*pLen < (Limit - LogPortIndex) * 6) {
 
 			*pLen = (Limit - LogPortIndex) * 6;
@@ -3647,8 +3066,7 @@
  *                               exist (e.g. port instance 3 on a two port
  *	                         adapter.
  */
-
-static int CsumStat(
+PNMI_STATIC int CsumStat(
 SK_AC *pAC,		/* Pointer to adapter context */
 SK_IOC IoC,		/* IO context handle */
 int Action,		/* Get/PreSet/Set action */
@@ -3692,9 +3110,7 @@
 		return (SK_PNMI_ERR_READ_ONLY);
 	}
 
-	/*
-	 * Check length
-	 */
+	/* Check length */
 	if (*pLen < (Limit - Index) * sizeof(SK_U64)) {
 
 		*pLen = (Limit - Index) * sizeof(SK_U64);
@@ -3766,8 +3182,7 @@
  *                               exist (e.g. port instance 3 on a two port
  *	                         adapter.
  */
-
-static int SensorStat(
+PNMI_STATIC int SensorStat(
 SK_AC *pAC,		/* Pointer to adapter context */
 SK_IOC IoC,		/* IO context handle */
 int Action,		/* Get/PreSet/Set action */
@@ -3815,9 +3230,7 @@
 		return (SK_PNMI_ERR_READ_ONLY);
 	}
 
-	/*
-	 * Check length
-	 */
+	/* Check length */
 	switch (Id) {
 
 	case OID_SKGE_SENSOR_VALUE:
@@ -3976,8 +3389,8 @@
 			break;
 
 		default:
-			SK_ERR_LOG(pAC, SK_ERRCL_SW, SK_PNMI_ERR013,
-				SK_PNMI_ERR013MSG);
+			SK_DBG_MSG(pAC, SK_DBGMOD_PNMI, SK_DBGCAT_ERR,
+				("SensorStat: Unknown OID should be handled before"));
 
 			return (SK_PNMI_ERR_GENERAL);
 		}
@@ -4014,8 +3427,7 @@
  *                               exist (e.g. port instance 3 on a two port
  *	                         adapter.
  */
-
-static int Vpd(
+PNMI_STATIC int Vpd(
 SK_AC *pAC,		/* Pointer to adapter context */
 SK_IOC IoC,		/* IO context handle */
 int Action,		/* Get/PreSet/Set action */
@@ -4043,8 +3455,7 @@
 	/*
 	 * Get array of all currently stored VPD keys
 	 */
-	Ret = GetVpdKeyArr(pAC, IoC, &KeyArr[0][0], sizeof(KeyArr),
-		&KeyNo);
+	Ret = GetVpdKeyArr(pAC, IoC, &KeyArr[0][0], sizeof(KeyArr), &KeyNo);
 	if (Ret != SK_PNMI_ERR_OK) {
 		*pLen = 0;
 		return (Ret);
@@ -4290,7 +3701,7 @@
 			*pLen = 0;
 			return (SK_PNMI_ERR_GENERAL);
 		}
-	} 
+	}
 	else {
 		/* The only OID which can be set is VPD_ACTION */
 		if (Id != OID_SKGE_VPD_ACTION) {
@@ -4490,8 +3901,7 @@
  *                               exist (e.g. port instance 3 on a two port
  *	                         adapter.
  */
-
-static int General(
+PNMI_STATIC int General(
 SK_AC *pAC,		/* Pointer to adapter context */
 SK_IOC IoC,		/* IO context handle */
 int Action,		/* Get/PreSet/Set action */
@@ -4515,7 +3925,7 @@
 	SK_U64		Val64TxHwErrs = 0;
 	SK_BOOL		Is64BitReq = SK_FALSE;
 	char		Buf[256];
-
+	int			MacType;
 
 	/*
 	 * Check instance. We only handle single instance variables
@@ -4534,7 +3944,9 @@
 		*pLen = 0;
 		return (SK_PNMI_ERR_READ_ONLY);
 	}
-
+	
+	MacType = pAC->GIni.GIMacType;
+	
 	/*
 	 * Check length for the various supported OIDs
 	 */
@@ -4662,15 +4074,14 @@
 			Val64RxHwErrs =
 				GetStatVal(pAC, IoC, 0, SK_PNMI_HRX_MISSED, NetIndex) +
 				GetStatVal(pAC, IoC, 0, SK_PNMI_HRX_FRAMING, NetIndex) +
-				GetStatVal(pAC, IoC, 0, SK_PNMI_HRX_OVERFLOW, NetIndex)+
+				GetStatVal(pAC, IoC, 0, SK_PNMI_HRX_OVERFLOW, NetIndex) +
 				GetStatVal(pAC, IoC, 0, SK_PNMI_HRX_JABBER, NetIndex) +
 				GetStatVal(pAC, IoC, 0, SK_PNMI_HRX_CARRIER, NetIndex) +
-				GetStatVal(pAC, IoC, 0, SK_PNMI_HRX_IRLENGTH, NetIndex)+
+				GetStatVal(pAC, IoC, 0, SK_PNMI_HRX_IRLENGTH, NetIndex) +
 				GetStatVal(pAC, IoC, 0, SK_PNMI_HRX_SYMBOL, NetIndex) +
 				GetStatVal(pAC, IoC, 0, SK_PNMI_HRX_SHORTS, NetIndex) +
 				GetStatVal(pAC, IoC, 0, SK_PNMI_HRX_RUNT, NetIndex) +
-				GetStatVal(pAC, IoC, 0, SK_PNMI_HRX_TOO_LONG, NetIndex)-
-				GetStatVal(pAC, IoC, 0, SK_PNMI_HRX_LONGFRAMES, NetIndex)+
+				GetStatVal(pAC, IoC, 0, SK_PNMI_HRX_TOO_LONG, NetIndex) +
 				GetStatVal(pAC, IoC, 0, SK_PNMI_HRX_FCS, NetIndex) +
 				GetStatVal(pAC, IoC, 0, SK_PNMI_HRX_CEXT, NetIndex);
 	        break;
@@ -4680,10 +4091,9 @@
 		case OID_GEN_XMIT_ERROR:
 			Val64TxHwErrs =
 				GetStatVal(pAC, IoC, 0, SK_PNMI_HTX_EXCESS_COL, NetIndex) +
-				GetStatVal(pAC, IoC, 0, SK_PNMI_HTX_LATE_COL, NetIndex)+
-				GetStatVal(pAC, IoC, 0, SK_PNMI_HTX_UNDERRUN, NetIndex)+
-				GetStatVal(pAC, IoC, 0, SK_PNMI_HTX_CARRIER, NetIndex)+
-				GetStatVal(pAC, IoC, 0, SK_PNMI_HTX_EXCESS_COL, NetIndex);
+				GetStatVal(pAC, IoC, 0, SK_PNMI_HTX_LATE_COL, NetIndex) +
+				GetStatVal(pAC, IoC, 0, SK_PNMI_HTX_UNDERRUN, NetIndex) +
+				GetStatVal(pAC, IoC, 0, SK_PNMI_HTX_CARRIER, NetIndex);
 			break;
 		}
 	}
@@ -4694,7 +4104,7 @@
 	switch (Id) {
 
 	case OID_SKGE_SUPPORTED_LIST:
-		Len = sizeof(IdTable)/sizeof(IdTable[0]) * sizeof(SK_U32);
+		Len = ID_TABLE_SIZE * sizeof(SK_U32);
 		if (*pLen < Len) {
 
 			*pLen = Len;
@@ -4833,7 +4243,7 @@
 		break;
 
 	case OID_SKGE_CHIPSET:
-		Val16 = SK_PNMI_CHIPSET;
+		Val16 = pAC->Pnmi.Chipset;
 		SK_PNMI_STORE_U16(pBuf, Val16);
 		*pLen = sizeof(SK_U16);
 		break;
@@ -4895,141 +4305,281 @@
 		break;
 
 	case OID_SKGE_TX_SW_QUEUE_LEN:
-		/* Dual net mode */
-		if(pAC->Pnmi.DualNetActiveFlag == SK_TRUE){
-			Val64 = pAC->Pnmi.Port[NetIndex].TxSwQueueLen;
+		/* 2002-09-17 pweber: For XMAC, use the frozen SW counters (BufPort) */
+		if (MacType == SK_MAC_XMAC) {
+			/* Dual net mode */
+			if (pAC->Pnmi.DualNetActiveFlag == SK_TRUE) {
+				Val64 = pAC->Pnmi.BufPort[NetIndex].TxSwQueueLen;
+			}
+			/* Single net mode */
+			else {
+				Val64 = pAC->Pnmi.BufPort[0].TxSwQueueLen +
+					pAC->Pnmi.BufPort[1].TxSwQueueLen;
+			}			
 		}
-		/* Single net mode */
 		else {
-			Val64 =  pAC->Pnmi.Port[0].TxSwQueueLen +
-				pAC->Pnmi.Port[1].TxSwQueueLen;
-		}			
+			/* Dual net mode */
+			if (pAC->Pnmi.DualNetActiveFlag == SK_TRUE) {
+				Val64 = pAC->Pnmi.Port[NetIndex].TxSwQueueLen;
+			}
+			/* Single net mode */
+			else {
+				Val64 = pAC->Pnmi.Port[0].TxSwQueueLen +
+					pAC->Pnmi.Port[1].TxSwQueueLen;
+			}			
+		}
 		SK_PNMI_STORE_U64(pBuf, Val64);
 		*pLen = sizeof(SK_U64);
 		break;
 
 
 	case OID_SKGE_TX_SW_QUEUE_MAX:
-		/* Dual net mode */
-		if(pAC->Pnmi.DualNetActiveFlag == SK_TRUE){
-			Val64 = pAC->Pnmi.Port[NetIndex].TxSwQueueMax;
+		/* 2002-09-17 pweber: For XMAC, use the frozen SW counters (BufPort) */
+		if (MacType == SK_MAC_XMAC) {
+			/* Dual net mode */
+			if (pAC->Pnmi.DualNetActiveFlag == SK_TRUE) {
+				Val64 = pAC->Pnmi.BufPort[NetIndex].TxSwQueueMax;
+			}
+			/* Single net mode */
+			else {
+				Val64 = pAC->Pnmi.BufPort[0].TxSwQueueMax +
+					pAC->Pnmi.BufPort[1].TxSwQueueMax;
+			}
 		}
-		/* Single net mode */
 		else {
-			Val64 = pAC->Pnmi.Port[0].TxSwQueueMax +
-				pAC->Pnmi.Port[1].TxSwQueueMax;
+			/* Dual net mode */
+			if (pAC->Pnmi.DualNetActiveFlag == SK_TRUE) {
+				Val64 = pAC->Pnmi.Port[NetIndex].TxSwQueueMax;
+			}
+			/* Single net mode */
+			else {
+				Val64 = pAC->Pnmi.Port[0].TxSwQueueMax +
+					pAC->Pnmi.Port[1].TxSwQueueMax;
+			}
 		}
 		SK_PNMI_STORE_U64(pBuf, Val64);
 		*pLen = sizeof(SK_U64);
 		break;
 
 	case OID_SKGE_TX_RETRY:
-		/* Dual net mode */
-		if(pAC->Pnmi.DualNetActiveFlag == SK_TRUE){
-			Val64 = pAC->Pnmi.Port[NetIndex].TxRetryCts;
+		/* 2002-09-17 pweber: For XMAC, use the frozen SW counters (BufPort) */
+		if (MacType == SK_MAC_XMAC) {
+			/* Dual net mode */
+			if (pAC->Pnmi.DualNetActiveFlag == SK_TRUE) {
+				Val64 = pAC->Pnmi.BufPort[NetIndex].TxRetryCts;
+			}
+			/* Single net mode */
+			else {
+				Val64 = pAC->Pnmi.BufPort[0].TxRetryCts +
+					pAC->Pnmi.BufPort[1].TxRetryCts;
+			}
 		}
-		/* Single net mode */
 		else {
-			Val64 = pAC->Pnmi.Port[0].TxRetryCts +
-				pAC->Pnmi.Port[1].TxRetryCts;
+			/* Dual net mode */
+			if (pAC->Pnmi.DualNetActiveFlag == SK_TRUE) {
+				Val64 = pAC->Pnmi.Port[NetIndex].TxRetryCts;
+			}
+			/* Single net mode */
+			else {
+				Val64 = pAC->Pnmi.Port[0].TxRetryCts +
+					pAC->Pnmi.Port[1].TxRetryCts;
+			}
 		}
 		SK_PNMI_STORE_U64(pBuf, Val64);
 		*pLen = sizeof(SK_U64);
 		break;
 
 	case OID_SKGE_RX_INTR_CTS:
-		/* Dual net mode */
-		if(pAC->Pnmi.DualNetActiveFlag == SK_TRUE){
-			Val64 = pAC->Pnmi.Port[NetIndex].RxIntrCts;
+		/* 2002-09-17 pweber: For XMAC, use the frozen SW counters (BufPort) */
+		if (MacType == SK_MAC_XMAC) {
+			/* Dual net mode */
+			if (pAC->Pnmi.DualNetActiveFlag == SK_TRUE) {
+				Val64 = pAC->Pnmi.BufPort[NetIndex].RxIntrCts;
+			}
+			/* Single net mode */
+			else {
+				Val64 = pAC->Pnmi.BufPort[0].RxIntrCts +
+					pAC->Pnmi.BufPort[1].RxIntrCts;
+			}
 		}
-		/* Single net mode */
 		else {
-			Val64 = pAC->Pnmi.Port[0].RxIntrCts +
-				pAC->Pnmi.Port[1].RxIntrCts;
+			/* Dual net mode */
+			if (pAC->Pnmi.DualNetActiveFlag == SK_TRUE) {
+				Val64 = pAC->Pnmi.Port[NetIndex].RxIntrCts;
+			}
+			/* Single net mode */
+			else {
+				Val64 = pAC->Pnmi.Port[0].RxIntrCts +
+					pAC->Pnmi.Port[1].RxIntrCts;
+			}
 		}
 		SK_PNMI_STORE_U64(pBuf, Val64);
 		*pLen = sizeof(SK_U64);
 		break;
 
 	case OID_SKGE_TX_INTR_CTS:
-		/* Dual net mode */
-		if(pAC->Pnmi.DualNetActiveFlag == SK_TRUE){
-			Val64 = pAC->Pnmi.Port[NetIndex].TxIntrCts;
+		/* 2002-09-17 pweber: For XMAC, use the frozen SW counters (BufPort) */
+		if (MacType == SK_MAC_XMAC) {
+			/* Dual net mode */
+			if (pAC->Pnmi.DualNetActiveFlag == SK_TRUE) {
+				Val64 = pAC->Pnmi.BufPort[NetIndex].TxIntrCts;
+			}
+			/* Single net mode */
+			else {
+				Val64 = pAC->Pnmi.BufPort[0].TxIntrCts +
+					pAC->Pnmi.BufPort[1].TxIntrCts;
+			}
 		}
-		/* Single net mode */
 		else {
-			Val64 = pAC->Pnmi.Port[0].TxIntrCts +
-				pAC->Pnmi.Port[1].TxIntrCts;
+			/* Dual net mode */
+			if (pAC->Pnmi.DualNetActiveFlag == SK_TRUE) {
+				Val64 = pAC->Pnmi.Port[NetIndex].TxIntrCts;
+			}
+			/* Single net mode */
+			else {
+				Val64 = pAC->Pnmi.Port[0].TxIntrCts +
+					pAC->Pnmi.Port[1].TxIntrCts;
+			}
 		}
 		SK_PNMI_STORE_U64(pBuf, Val64);
 		*pLen = sizeof(SK_U64);
 		break;
 
 	case OID_SKGE_RX_NO_BUF_CTS:
-		/* Dual net mode */
-		if(pAC->Pnmi.DualNetActiveFlag == SK_TRUE){
-			Val64 = pAC->Pnmi.Port[NetIndex].RxNoBufCts;
+		/* 2002-09-17 pweber: For XMAC, use the frozen SW counters (BufPort) */
+		if (MacType == SK_MAC_XMAC) {
+			/* Dual net mode */
+			if (pAC->Pnmi.DualNetActiveFlag == SK_TRUE) {
+				Val64 = pAC->Pnmi.BufPort[NetIndex].RxNoBufCts;
+			}
+			/* Single net mode */
+			else {
+				Val64 = pAC->Pnmi.BufPort[0].RxNoBufCts +
+					pAC->Pnmi.BufPort[1].RxNoBufCts;
+			}
 		}
-		/* Single net mode */
 		else {
-			Val64 = pAC->Pnmi.Port[0].RxNoBufCts +
-				pAC->Pnmi.Port[1].RxNoBufCts;
+			/* Dual net mode */
+			if (pAC->Pnmi.DualNetActiveFlag == SK_TRUE) {
+				Val64 = pAC->Pnmi.Port[NetIndex].RxNoBufCts;
+			}
+			/* Single net mode */
+			else {
+				Val64 = pAC->Pnmi.Port[0].RxNoBufCts +
+					pAC->Pnmi.Port[1].RxNoBufCts;
+			}
 		}
 		SK_PNMI_STORE_U64(pBuf, Val64);
 		*pLen = sizeof(SK_U64);
 		break;
 
 	case OID_SKGE_TX_NO_BUF_CTS:
-		/* Dual net mode */
-		if(pAC->Pnmi.DualNetActiveFlag == SK_TRUE){
-			Val64 = pAC->Pnmi.Port[NetIndex].TxNoBufCts;
+		/* 2002-09-17 pweber: For XMAC, use the frozen SW counters (BufPort) */
+		if (MacType == SK_MAC_XMAC) {
+			/* Dual net mode */
+			if (pAC->Pnmi.DualNetActiveFlag == SK_TRUE) {
+				Val64 = pAC->Pnmi.BufPort[NetIndex].TxNoBufCts;
+			}
+			/* Single net mode */
+			else {
+				Val64 = pAC->Pnmi.BufPort[0].TxNoBufCts +
+					pAC->Pnmi.BufPort[1].TxNoBufCts;
+			}
 		}
-		/* Single net mode */
 		else {
-			Val64 = pAC->Pnmi.Port[0].TxNoBufCts +
-				pAC->Pnmi.Port[1].TxNoBufCts;
+			/* Dual net mode */
+			if (pAC->Pnmi.DualNetActiveFlag == SK_TRUE) {
+				Val64 = pAC->Pnmi.Port[NetIndex].TxNoBufCts;
+			}
+			/* Single net mode */
+			else {
+				Val64 = pAC->Pnmi.Port[0].TxNoBufCts +
+					pAC->Pnmi.Port[1].TxNoBufCts;
+			}
 		}
 		SK_PNMI_STORE_U64(pBuf, Val64);
 		*pLen = sizeof(SK_U64);
 		break;
 
 	case OID_SKGE_TX_USED_DESCR_NO:
-		/* Dual net mode */
-		if(pAC->Pnmi.DualNetActiveFlag == SK_TRUE){
-			Val64 = pAC->Pnmi.Port[NetIndex].TxUsedDescrNo;
+		/* 2002-09-17 pweber: For XMAC, use the frozen SW counters (BufPort) */
+		if (MacType == SK_MAC_XMAC) {
+			/* Dual net mode */
+			if (pAC->Pnmi.DualNetActiveFlag == SK_TRUE) {
+				Val64 = pAC->Pnmi.BufPort[NetIndex].TxUsedDescrNo;
+			}
+			/* Single net mode */
+			else {
+				Val64 = pAC->Pnmi.BufPort[0].TxUsedDescrNo +
+					pAC->Pnmi.BufPort[1].TxUsedDescrNo;
+			}
 		}
-		/* Single net mode */
 		else {
-			Val64 = pAC->Pnmi.Port[0].TxUsedDescrNo +
-				pAC->Pnmi.Port[1].TxUsedDescrNo;
+			/* Dual net mode */
+			if (pAC->Pnmi.DualNetActiveFlag == SK_TRUE) {
+				Val64 = pAC->Pnmi.Port[NetIndex].TxUsedDescrNo;
+			}
+			/* Single net mode */
+			else {
+				Val64 = pAC->Pnmi.Port[0].TxUsedDescrNo +
+					pAC->Pnmi.Port[1].TxUsedDescrNo;
+			}
 		}
 		SK_PNMI_STORE_U64(pBuf, Val64);
 		*pLen = sizeof(SK_U64);
 		break;
 
 	case OID_SKGE_RX_DELIVERED_CTS:
-		/* Dual net mode */
-		if(pAC->Pnmi.DualNetActiveFlag == SK_TRUE){
-			Val64 = pAC->Pnmi.Port[NetIndex].RxDeliveredCts;
+		/* 2002-09-17 pweber: For XMAC, use the frozen SW counters (BufPort) */
+		if (MacType == SK_MAC_XMAC) {
+			/* Dual net mode */
+			if (pAC->Pnmi.DualNetActiveFlag == SK_TRUE) {
+				Val64 = pAC->Pnmi.BufPort[NetIndex].RxDeliveredCts;
+			}
+			/* Single net mode */
+			else {
+				Val64 = pAC->Pnmi.BufPort[0].RxDeliveredCts +
+					pAC->Pnmi.BufPort[1].RxDeliveredCts;
+			}
 		}
-		/* Single net mode */
 		else {
-			Val64 = pAC->Pnmi.Port[0].RxDeliveredCts +
-				pAC->Pnmi.Port[1].RxDeliveredCts;
+			/* Dual net mode */
+			if (pAC->Pnmi.DualNetActiveFlag == SK_TRUE) {
+				Val64 = pAC->Pnmi.Port[NetIndex].RxDeliveredCts;
+			}
+			/* Single net mode */
+			else {
+				Val64 = pAC->Pnmi.Port[0].RxDeliveredCts +
+					pAC->Pnmi.Port[1].RxDeliveredCts;
+			}
 		}
 		SK_PNMI_STORE_U64(pBuf, Val64);
 		*pLen = sizeof(SK_U64);
 		break;
 
 	case OID_SKGE_RX_OCTETS_DELIV_CTS:
-		/* Dual net mode */
-		if(pAC->Pnmi.DualNetActiveFlag == SK_TRUE){
-			Val64 = pAC->Pnmi.Port[NetIndex].RxOctetsDeliveredCts;
+		/* 2002-09-17 pweber: For XMAC, use the frozen SW counters (BufPort) */
+		if (MacType == SK_MAC_XMAC) {
+			/* Dual net mode */
+			if (pAC->Pnmi.DualNetActiveFlag == SK_TRUE) {
+				Val64 = pAC->Pnmi.BufPort[NetIndex].RxOctetsDeliveredCts;
+			}
+			/* Single net mode */
+			else {
+				Val64 = pAC->Pnmi.BufPort[0].RxOctetsDeliveredCts +
+					pAC->Pnmi.BufPort[1].RxOctetsDeliveredCts;
+			}
 		}
-		/* Single net mode */
 		else {
-			Val64 = pAC->Pnmi.Port[0].RxOctetsDeliveredCts +
-				pAC->Pnmi.Port[1].RxOctetsDeliveredCts;
+			/* Dual net mode */
+			if (pAC->Pnmi.DualNetActiveFlag == SK_TRUE) {
+				Val64 = pAC->Pnmi.Port[NetIndex].RxOctetsDeliveredCts;
+			}
+			/* Single net mode */
+			else {
+				Val64 = pAC->Pnmi.Port[0].RxOctetsDeliveredCts +
+					pAC->Pnmi.Port[1].RxOctetsDeliveredCts;
+			}
 		}
 		SK_PNMI_STORE_U64(pBuf, Val64);
 		*pLen = sizeof(SK_U64);
@@ -5046,44 +4596,88 @@
 		break;
 
 	case OID_SKGE_IN_ERRORS_CTS:
-		/* Dual net mode */
-		if(pAC->Pnmi.DualNetActiveFlag == SK_TRUE){
-			Val64 = Val64RxHwErrs + pAC->Pnmi.Port[NetIndex].RxNoBufCts;
+		/* 2002-09-17 pweber: For XMAC, use the frozen SW counters (BufPort) */
+		if (MacType == SK_MAC_XMAC) {
+			/* Dual net mode */
+			if (pAC->Pnmi.DualNetActiveFlag == SK_TRUE) {
+				Val64 = Val64RxHwErrs + pAC->Pnmi.BufPort[NetIndex].RxNoBufCts;
+			}
+			/* Single net mode */
+			else {
+				Val64 = Val64RxHwErrs +
+					pAC->Pnmi.BufPort[0].RxNoBufCts +
+					pAC->Pnmi.BufPort[1].RxNoBufCts;
+			}
 		}
-		/* Single net mode */
 		else {
-			Val64 = Val64RxHwErrs + 
-				pAC->Pnmi.Port[0].RxNoBufCts +
-				pAC->Pnmi.Port[1].RxNoBufCts;
+			/* Dual net mode */
+			if (pAC->Pnmi.DualNetActiveFlag == SK_TRUE) {
+				Val64 = Val64RxHwErrs + pAC->Pnmi.Port[NetIndex].RxNoBufCts;
+			}
+			/* Single net mode */
+			else {
+				Val64 = Val64RxHwErrs +
+					pAC->Pnmi.Port[0].RxNoBufCts +
+					pAC->Pnmi.Port[1].RxNoBufCts;
+			}
 		}
 		SK_PNMI_STORE_U64(pBuf, Val64);
 		*pLen = sizeof(SK_U64);
 		break;
 
 	case OID_SKGE_OUT_ERROR_CTS:
-		/* Dual net mode */
-		if(pAC->Pnmi.DualNetActiveFlag == SK_TRUE){
-			Val64 = Val64TxHwErrs + pAC->Pnmi.Port[NetIndex].TxNoBufCts;
+		/* 2002-09-17 pweber: For XMAC, use the frozen SW counters (BufPort) */
+		if (MacType == SK_MAC_XMAC) {
+			/* Dual net mode */
+			if (pAC->Pnmi.DualNetActiveFlag == SK_TRUE) {
+				Val64 = Val64TxHwErrs + pAC->Pnmi.BufPort[NetIndex].TxNoBufCts;
+			}
+			/* Single net mode */
+			else {
+				Val64 = Val64TxHwErrs +
+					pAC->Pnmi.BufPort[0].TxNoBufCts +
+					pAC->Pnmi.BufPort[1].TxNoBufCts;
+			}
 		}
-		/* Single net mode */
 		else {
-			Val64 = Val64TxHwErrs + 
-				pAC->Pnmi.Port[0].TxNoBufCts +
-				pAC->Pnmi.Port[1].TxNoBufCts;
+			/* Dual net mode */
+			if (pAC->Pnmi.DualNetActiveFlag == SK_TRUE) {
+				Val64 = Val64TxHwErrs + pAC->Pnmi.Port[NetIndex].TxNoBufCts;
+			}
+			/* Single net mode */
+			else {
+				Val64 = Val64TxHwErrs +
+					pAC->Pnmi.Port[0].TxNoBufCts +
+					pAC->Pnmi.Port[1].TxNoBufCts;
+			}
 		}
 		SK_PNMI_STORE_U64(pBuf, Val64);
 		*pLen = sizeof(SK_U64);
 		break;
 
 	case OID_SKGE_ERR_RECOVERY_CTS:
-		/* Dual net mode */
-		if(pAC->Pnmi.DualNetActiveFlag == SK_TRUE){
-			Val64 = pAC->Pnmi.Port[NetIndex].ErrRecoveryCts;
-		}
-		/* Single net mode */
+		/* 2002-09-17 pweber: For XMAC, use the frozen SW counters (BufPort) */
+		if (MacType == SK_MAC_XMAC) {
+			/* Dual net mode */
+			if (pAC->Pnmi.DualNetActiveFlag == SK_TRUE) {
+				Val64 = pAC->Pnmi.BufPort[NetIndex].ErrRecoveryCts;
+			}
+			/* Single net mode */
+			else {
+				Val64 = pAC->Pnmi.BufPort[0].ErrRecoveryCts +
+					pAC->Pnmi.BufPort[1].ErrRecoveryCts;
+			}
+		}
 		else {
-			Val64 = pAC->Pnmi.Port[0].ErrRecoveryCts +
-				pAC->Pnmi.Port[1].ErrRecoveryCts;
+			/* Dual net mode */
+			if (pAC->Pnmi.DualNetActiveFlag == SK_TRUE) {
+				Val64 = pAC->Pnmi.Port[NetIndex].ErrRecoveryCts;
+			}
+			/* Single net mode */
+			else {
+				Val64 = pAC->Pnmi.Port[0].ErrRecoveryCts +
+					pAC->Pnmi.Port[1].ErrRecoveryCts;
+			}
 		}
 		SK_PNMI_STORE_U64(pBuf, Val64);
 		*pLen = sizeof(SK_U64);
@@ -5103,7 +4697,13 @@
 		break;
 
 	case OID_GEN_RCV_ERROR:
-		Val64 = Val64RxHwErrs + pAC->Pnmi.Port[NetIndex].RxNoBufCts;
+		/* 2002-09-17 pweber: For XMAC, use the frozen SW counters (BufPort) */
+		if (MacType == SK_MAC_XMAC) {
+			Val64 = Val64RxHwErrs + pAC->Pnmi.BufPort[NetIndex].RxNoBufCts;
+		}
+		else {
+			Val64 = Val64RxHwErrs + pAC->Pnmi.Port[NetIndex].RxNoBufCts;
+		}
 
 		/*
 		 * by default 32bit values are evaluated
@@ -5120,7 +4720,13 @@
 		break;
 
 	case OID_GEN_XMIT_ERROR:
-		Val64 = Val64TxHwErrs + pAC->Pnmi.Port[NetIndex].TxNoBufCts;
+		/* 2002-09-17 pweber: For XMAC, use the frozen SW counters (BufPort) */
+		if (MacType == SK_MAC_XMAC) {
+			Val64 = Val64TxHwErrs + pAC->Pnmi.BufPort[NetIndex].TxNoBufCts;
+		}
+		else {
+			Val64 = Val64TxHwErrs + pAC->Pnmi.Port[NetIndex].TxNoBufCts;
+		}
 
 		/*
 		 * by default 32bit values are evaluated
@@ -5137,7 +4743,13 @@
 		break;
 
 	case OID_GEN_RCV_NO_BUFFER:
-		Val64 = pAC->Pnmi.Port[NetIndex].RxNoBufCts;
+		/* 2002-09-17 pweber: For XMAC, use the frozen SW counters (BufPort) */
+		if (MacType == SK_MAC_XMAC) {
+			Val64 = pAC->Pnmi.BufPort[NetIndex].RxNoBufCts;
+		}
+		else {
+			Val64 = pAC->Pnmi.Port[NetIndex].RxNoBufCts;
+		}
 
 		/*
 		 * by default 32bit values are evaluated
@@ -5200,8 +4812,7 @@
  *                               exist (e.g. port instance 3 on a two port
  *	                         adapter.
  */
-
-static int Rlmt(
+PNMI_STATIC int Rlmt(
 SK_AC *pAC,		/* Pointer to adapter context */
 SK_IOC IoC,		/* IO context handle */
 int Action,		/* Get/PreSet/Set action */
@@ -5359,8 +4970,8 @@
 			break;
 
 		default:
-			SK_ERR_LOG(pAC, SK_ERRCL_SW, SK_PNMI_ERR036,
-				SK_PNMI_ERR036MSG);
+			SK_DBG_MSG(pAC, SK_DBGMOD_PNMI, SK_DBGCAT_ERR,
+				("Rlmt: Unknown OID should be handled before"));
 
 			pAC->Pnmi.RlmtUpdatedFlag --;
 			*pLen = 0;
@@ -5506,8 +5117,7 @@
  *                               exist (e.g. port instance 3 on a two port
  *	                         adapter.
  */
-
-static int RlmtStat(
+PNMI_STATIC int RlmtStat(
 SK_AC *pAC,		/* Pointer to adapter context */
 SK_IOC IoC,		/* IO context handle */
 int Action,		/* Get/PreSet/Set action */
@@ -5543,7 +5153,7 @@
 		PhysPortIndex = Instance - 1;
 
 		/* Dual net mode */
-		if(pAC->Pnmi.DualNetActiveFlag == SK_TRUE){
+		if (pAC->Pnmi.DualNetActiveFlag == SK_TRUE) {
 			PhysPortIndex = NetIndex;
 		}
 
@@ -5556,7 +5166,7 @@
 		Limit = PhysPortMax;
 
 		/* Dual net mode */
-		if(pAC->Pnmi.DualNetActiveFlag == SK_TRUE){
+		if (pAC->Pnmi.DualNetActiveFlag == SK_TRUE) {
 			PhysPortIndex = NetIndex;
 			Limit = PhysPortIndex + 1;
 		}
@@ -5674,8 +5284,8 @@
 			break;
 
 		default:
-			SK_ERR_LOG(pAC, SK_ERRCL_SW, SK_PNMI_ERR040,
-				SK_PNMI_ERR040MSG);
+			SK_DBG_MSG(pAC, SK_DBGMOD_PNMI, SK_DBGCAT_ERR,
+				("RlmtStat: Unknown OID should be errored before"));
 
 			pAC->Pnmi.RlmtUpdatedFlag --;
 			*pLen = 0;
@@ -5709,8 +5319,7 @@
  *                               exist (e.g. port instance 3 on a two port
  *	                         adapter.
  */
-
-static int MacPrivateConf(
+PNMI_STATIC int MacPrivateConf(
 SK_AC *pAC,		/* Pointer to adapter context */
 SK_IOC IoC,		/* IO context handle */
 int Action,		/* Get/PreSet/Set action */
@@ -5728,19 +5337,18 @@
 	unsigned int	Limit;
 	unsigned int	Offset;
 	char		Val8;
-	int		Ret;
+	char 		*pBufPtr;
+	int			Ret;
 	SK_EVPARA	EventParam;
 	SK_U32		Val32;
 
-
 	/*
-	 * Calculate instance if wished. MAC index 0 is the virtual
-	 * MAC.
+	 * Calculate instance if wished. MAC index 0 is the virtual MAC.
 	 */
 	PhysPortMax = pAC->GIni.GIMacsFound;
 	LogPortMax = SK_PNMI_PORT_PHYS2LOG(PhysPortMax);
 
-	if(pAC->Pnmi.DualNetActiveFlag == SK_TRUE){ /* Dual net mode */
+	if (pAC->Pnmi.DualNetActiveFlag == SK_TRUE) { /* Dual net mode */
 		LogPortMax--;
 	}
 
@@ -5766,9 +5374,7 @@
 	 */
 	if (Action == SK_PNMI_GET) {
 
-		/*
-		 * Check length
-		 */
+		/* Check length */
 		switch (Id) {
 
 		case OID_SKGE_PMD:
@@ -5783,6 +5389,9 @@
 		case OID_SKGE_PHY_OPERATION_CAP:
 		case OID_SKGE_PHY_OPERATION_MODE:
 		case OID_SKGE_PHY_OPERATION_STATUS:
+		case OID_SKGE_SPEED_CAP:
+		case OID_SKGE_SPEED_MODE:
+		case OID_SKGE_SPEED_STATUS:
 			if (*pLen < (Limit - LogPortIndex) * sizeof(SK_U8)) {
 
 				*pLen = (Limit - LogPortIndex) *
@@ -5823,210 +5432,303 @@
 		Offset = 0;
 		for (; LogPortIndex < Limit; LogPortIndex ++) {
 
+			pBufPtr = pBuf + Offset;
+			
 			switch (Id) {
 
 			case OID_SKGE_PMD:
-				*(pBuf + Offset) = pAC->Pnmi.PMD;
+				*pBufPtr = pAC->Pnmi.PMD;
 				Offset += sizeof(char);
 				break;
 
 			case OID_SKGE_CONNECTOR:
-				*(pBuf + Offset) = pAC->Pnmi.Connector;
+				*pBufPtr = pAC->Pnmi.Connector;
 				Offset += sizeof(char);
 				break;
 
 			case OID_SKGE_LINK_CAP:
-				if (LogPortIndex == 0) {
+				if (!pAC->Pnmi.DualNetActiveFlag) { /* SingleNetMode */
+					if (LogPortIndex == 0) {
+						/* Get value for virtual port */
+						VirtualConf(pAC, IoC, Id, pBufPtr);
+					}
+					else {
+						/* Get value for physical ports */
+						PhysPortIndex = SK_PNMI_PORT_LOG2PHYS(
+							pAC, LogPortIndex);
 
-					/* Get value for virtual port */
-					VirtualConf(pAC, IoC, Id, pBuf +
-						Offset);
+						*pBufPtr = pAC->GIni.GP[PhysPortIndex].PLinkCap;
+					}
 				}
-				else {
-					/* Get value for physical ports */
-					PhysPortIndex = SK_PNMI_PORT_LOG2PHYS(
-						pAC, LogPortIndex);
-
-					*(pBuf + Offset) = pAC->GIni.GP[
-						PhysPortIndex].PLinkCap;
+				else { /* DualNetMode */
+					
+					*pBufPtr = pAC->GIni.GP[NetIndex].PLinkCap;
 				}
 				Offset += sizeof(char);
 				break;
 
 			case OID_SKGE_LINK_MODE:
-				if (LogPortIndex == 0) {
+				if (!pAC->Pnmi.DualNetActiveFlag) { /* SingleNetMode */
+					if (LogPortIndex == 0) {
+						/* Get value for virtual port */
+						VirtualConf(pAC, IoC, Id, pBufPtr);
+					}
+					else {
+						/* Get value for physical ports */
+						PhysPortIndex = SK_PNMI_PORT_LOG2PHYS(
+							pAC, LogPortIndex);
 
-					/* Get value for virtual port */
-					VirtualConf(pAC, IoC, Id, pBuf +
-						Offset);
+						*pBufPtr = pAC->GIni.GP[PhysPortIndex].PLinkModeConf;
+					}
 				}
-				else {
-					/* Get value for physical ports */
-					PhysPortIndex = SK_PNMI_PORT_LOG2PHYS(
-						pAC, LogPortIndex);
-
-					*(pBuf + Offset) = pAC->GIni.GP[
-						PhysPortIndex].PLinkModeConf;
+				else { /* DualNetMode */
+				
+					*pBufPtr = pAC->GIni.GP[NetIndex].PLinkModeConf;
 				}
-
 				Offset += sizeof(char);
 				break;
 
 			case OID_SKGE_LINK_MODE_STATUS:
-				if (LogPortIndex == 0) {
+				if (!pAC->Pnmi.DualNetActiveFlag) { /* SingleNetMode */
+					if (LogPortIndex == 0) {
+						/* Get value for virtual port */
+						VirtualConf(pAC, IoC, Id, pBufPtr);
+					}
+					else {
+						/* Get value for physical port */
+						PhysPortIndex = SK_PNMI_PORT_LOG2PHYS(
+							pAC, LogPortIndex);
 
-					/* Get value for virtual port */
-					VirtualConf(pAC, IoC, Id, pBuf +
-						Offset);
+						*pBufPtr =
+							CalculateLinkModeStatus(pAC, IoC, PhysPortIndex);
+					}
 				}
-				else {
-					/* Get value for physical port */
-					PhysPortIndex = SK_PNMI_PORT_LOG2PHYS(
-						pAC, LogPortIndex);
-
-					*(pBuf + Offset) =
-						CalculateLinkModeStatus(pAC,
-							IoC, PhysPortIndex);
+				else { /* DualNetMode */
+					
+					*pBufPtr = CalculateLinkModeStatus(pAC, IoC, NetIndex);
 				}
 				Offset += sizeof(char);
 				break;
 
 			case OID_SKGE_LINK_STATUS:
-				if (LogPortIndex == 0) {
-
-					/* Get value for virtual port */
-					VirtualConf(pAC, IoC, Id, pBuf +
-						Offset);
+				if (!pAC->Pnmi.DualNetActiveFlag) { /* SingleNetMode */
+					if (LogPortIndex == 0) {
+						/* Get value for virtual port */
+						VirtualConf(pAC, IoC, Id, pBufPtr);
+					}
+					else {
+						/* Get value for physical ports */
+						PhysPortIndex = SK_PNMI_PORT_LOG2PHYS(
+							pAC, LogPortIndex);
+	
+						*pBufPtr = CalculateLinkStatus(pAC, IoC, PhysPortIndex);
+					}
 				}
-				else {
-					/* Get value for physical ports */
-					PhysPortIndex = SK_PNMI_PORT_LOG2PHYS(
-						pAC, LogPortIndex);
+				else { /* DualNetMode */
 
-					*(pBuf + Offset) =
-						CalculateLinkStatus(pAC,
-							IoC, PhysPortIndex);
+					*pBufPtr = CalculateLinkStatus(pAC, IoC, NetIndex);
 				}
 				Offset += sizeof(char);
 				break;
 
 			case OID_SKGE_FLOWCTRL_CAP:
-				if (LogPortIndex == 0) {
-
-					/* Get value for virtual port */
-					VirtualConf(pAC, IoC, Id, pBuf +
-						Offset);
+				if (!pAC->Pnmi.DualNetActiveFlag) { /* SingleNetMode */
+					if (LogPortIndex == 0) {
+						/* Get value for virtual port */
+						VirtualConf(pAC, IoC, Id, pBufPtr);
+					}
+					else {
+						/* Get value for physical ports */
+						PhysPortIndex = SK_PNMI_PORT_LOG2PHYS(
+							pAC, LogPortIndex);
+	
+						*pBufPtr = pAC->GIni.GP[PhysPortIndex].PFlowCtrlCap;
+					}
 				}
-				else {
-					/* Get value for physical ports */
-					PhysPortIndex = SK_PNMI_PORT_LOG2PHYS(
-						pAC, LogPortIndex);
-
-					*(pBuf + Offset) = pAC->GIni.GP[
-						PhysPortIndex].PFlowCtrlCap;
+				else { /* DualNetMode */
+				
+					*pBufPtr = pAC->GIni.GP[NetIndex].PFlowCtrlCap;
 				}
 				Offset += sizeof(char);
 				break;
 
 			case OID_SKGE_FLOWCTRL_MODE:
-				if (LogPortIndex == 0) {
-
-					/* Get value for virtual port */
-					VirtualConf(pAC, IoC, Id, pBuf +
-						Offset);
+				if (!pAC->Pnmi.DualNetActiveFlag) { /* SingleNetMode */
+					if (LogPortIndex == 0) {
+						/* Get value for virtual port */
+						VirtualConf(pAC, IoC, Id, pBufPtr);
+					}
+					else {
+						/* Get value for physical port */
+						PhysPortIndex = SK_PNMI_PORT_LOG2PHYS(
+							pAC, LogPortIndex);
+	
+						*pBufPtr = pAC->GIni.GP[PhysPortIndex].PFlowCtrlMode;
+					}
 				}
-				else {
-					/* Get value for physical port */
-					PhysPortIndex = SK_PNMI_PORT_LOG2PHYS(
-						pAC, LogPortIndex);
+				else { /* DualNetMode */
 
-					*(pBuf + Offset) = pAC->GIni.GP[
-						PhysPortIndex].PFlowCtrlMode;
+					*pBufPtr = pAC->GIni.GP[NetIndex].PFlowCtrlMode;
 				}
 				Offset += sizeof(char);
 				break;
 
 			case OID_SKGE_FLOWCTRL_STATUS:
-				if (LogPortIndex == 0) {
-
-					/* Get value for virtual port */
-					VirtualConf(pAC, IoC, Id, pBuf +
-						Offset);
+				if (!pAC->Pnmi.DualNetActiveFlag) { /* SingleNetMode */
+					if (LogPortIndex == 0) {
+						/* Get value for virtual port */
+						VirtualConf(pAC, IoC, Id, pBufPtr);
+					}
+					else {
+						/* Get value for physical port */
+						PhysPortIndex = SK_PNMI_PORT_LOG2PHYS(
+							pAC, LogPortIndex);
+	
+						*pBufPtr = pAC->GIni.GP[PhysPortIndex].PFlowCtrlStatus;
+					}
 				}
-				else {
-					/* Get value for physical port */
-					PhysPortIndex = SK_PNMI_PORT_LOG2PHYS(
-						pAC, LogPortIndex);
+				else { /* DualNetMode */
 
-					*(pBuf + Offset) = pAC->GIni.GP[
-						PhysPortIndex].PFlowCtrlStatus;
+					*pBufPtr = pAC->GIni.GP[NetIndex].PFlowCtrlStatus;
 				}
 				Offset += sizeof(char);
 				break;
 
 			case OID_SKGE_PHY_OPERATION_CAP:
-				if (LogPortIndex == 0) {
-
-					/* Get value for virtual port */
-					VirtualConf(pAC, IoC, Id, pBuf +
-						Offset);
+				if (!pAC->Pnmi.DualNetActiveFlag) { /* SingleNetMode */
+					if (LogPortIndex == 0) {
+						/* Get value for virtual port */
+						VirtualConf(pAC, IoC, Id, pBufPtr);
+					}
+					else {
+						/* Get value for physical ports */
+						PhysPortIndex = SK_PNMI_PORT_LOG2PHYS(
+							pAC, LogPortIndex);
+	
+						*pBufPtr = pAC->GIni.GP[PhysPortIndex].PMSCap;
+					}
 				}
-				else {
-					/* Get value for physical ports */
-					PhysPortIndex = SK_PNMI_PORT_LOG2PHYS(
-						pAC, LogPortIndex);
-
-					*(pBuf + Offset) = pAC->GIni.GP[
-						PhysPortIndex].PMSCap;
+				else { /* DualNetMode */
+				
+					*pBufPtr = pAC->GIni.GP[NetIndex].PMSCap;
 				}
 				Offset += sizeof(char);
 				break;
 
 			case OID_SKGE_PHY_OPERATION_MODE:
-				if (LogPortIndex == 0) {
+				if (!pAC->Pnmi.DualNetActiveFlag) { /* SingleNetMode */
+					if (LogPortIndex == 0) {
+						/* Get value for virtual port */
+						VirtualConf(pAC, IoC, Id, pBufPtr);
+					}
+					else {
+						/* Get value for physical port */
+						PhysPortIndex = SK_PNMI_PORT_LOG2PHYS(
+							pAC, LogPortIndex);
 
-					/* Get value for virtual port */
-					VirtualConf(pAC, IoC, Id, pBuf +
-						Offset);
+						*pBufPtr = pAC->GIni.GP[PhysPortIndex].PMSMode;
+					}
 				}
-				else {
-					/* Get value for physical port */
-					PhysPortIndex = SK_PNMI_PORT_LOG2PHYS(
-						pAC, LogPortIndex);
-
-					*(pBuf + Offset) = pAC->GIni.GP[
-						PhysPortIndex].PMSMode;
+				else { /* DualNetMode */
+				
+					*pBufPtr = pAC->GIni.GP[NetIndex].PMSMode;
 				}
 				Offset += sizeof(char);
 				break;
 
 			case OID_SKGE_PHY_OPERATION_STATUS:
-				if (LogPortIndex == 0) {
-
-					/* Get value for virtual port */
-					VirtualConf(pAC, IoC, Id, pBuf +
-						Offset);
+				if (!pAC->Pnmi.DualNetActiveFlag) { /* SingleNetMode */
+					if (LogPortIndex == 0) {
+						/* Get value for virtual port */
+						VirtualConf(pAC, IoC, Id, pBufPtr);
+					}
+					else {
+						/* Get value for physical port */
+						PhysPortIndex = SK_PNMI_PORT_LOG2PHYS(
+							pAC, LogPortIndex);
+	
+						*pBufPtr = pAC->GIni.GP[PhysPortIndex].PMSStatus;
+					}
 				}
 				else {
-					/* Get value for physical port */
-					PhysPortIndex = SK_PNMI_PORT_LOG2PHYS(
-						pAC, LogPortIndex);
+				
+					*pBufPtr = pAC->GIni.GP[NetIndex].PMSStatus;
+				}
+				Offset += sizeof(char);
+				break;
+
+			case OID_SKGE_SPEED_CAP:
+				if (!pAC->Pnmi.DualNetActiveFlag) { /* SingleNetMode */
+					if (LogPortIndex == 0) {
+						/* Get value for virtual port */
+						VirtualConf(pAC, IoC, Id, pBufPtr);
+					}
+					else {
+						/* Get value for physical ports */
+						PhysPortIndex = SK_PNMI_PORT_LOG2PHYS(
+							pAC, LogPortIndex);
+	
+						*pBufPtr = pAC->GIni.GP[PhysPortIndex].PLinkSpeedCap;
+					}
+				}
+				else { /* DualNetMode */
+				
+					*pBufPtr = pAC->GIni.GP[NetIndex].PLinkSpeedCap;
+				}
+				Offset += sizeof(char);
+				break;
+
+			case OID_SKGE_SPEED_MODE:
+				if (!pAC->Pnmi.DualNetActiveFlag) { /* SingleNetMode */
+					if (LogPortIndex == 0) {
+						/* Get value for virtual port */
+						VirtualConf(pAC, IoC, Id, pBufPtr);
+					}
+					else {
+						/* Get value for physical port */
+						PhysPortIndex = SK_PNMI_PORT_LOG2PHYS(
+							pAC, LogPortIndex);
+	
+						*pBufPtr = pAC->GIni.GP[PhysPortIndex].PLinkSpeed;
+					}
+				}
+				else { /* DualNetMode */
 
-					*(pBuf + Offset) = pAC->GIni.GP[
-						PhysPortIndex].PMSStatus;
+					*pBufPtr = pAC->GIni.GP[NetIndex].PLinkSpeed;
 				}
 				Offset += sizeof(char);
 				break;
 
+			case OID_SKGE_SPEED_STATUS:
+				if (!pAC->Pnmi.DualNetActiveFlag) { /* SingleNetMode */
+					if (LogPortIndex == 0) {
+						/* Get value for virtual port */
+						VirtualConf(pAC, IoC, Id, pBufPtr);
+					}
+					else {
+						/* Get value for physical port */
+						PhysPortIndex = SK_PNMI_PORT_LOG2PHYS(
+							pAC, LogPortIndex);
+	
+						*pBufPtr = pAC->GIni.GP[PhysPortIndex].PLinkSpeedUsed;
+					}
+				}
+				else { /* DualNetMode */
+
+					*pBufPtr = pAC->GIni.GP[NetIndex].PLinkSpeedUsed;
+				}
+				Offset += sizeof(char);
+				break;
+			
 			case OID_SKGE_MTU:
 				Val32 = SK_DRIVER_GET_MTU(pAC, IoC, NetIndex);
-				SK_PNMI_STORE_U32(pBuf + Offset, Val32);
+				SK_PNMI_STORE_U32(pBufPtr, Val32);
 				Offset += sizeof(SK_U32);
 				break;
 
 			default:
-				SK_ERR_LOG(pAC, SK_ERRCL_SW, SK_PNMI_ERR042,
-					SK_PNMI_ERR042MSG);
+				SK_DBG_MSG(pAC, SK_DBGMOD_PNMI, SK_DBGCAT_ERR,
+					("MacPrivateConf: Unknown OID should be handled before"));
 
 				pAC->Pnmi.SirqUpdatedFlag --;
 				return (SK_PNMI_ERR_GENERAL);
@@ -6047,6 +5749,7 @@
 	case OID_SKGE_LINK_MODE:
 	case OID_SKGE_FLOWCTRL_MODE:
 	case OID_SKGE_PHY_OPERATION_MODE:
+	case OID_SKGE_SPEED_MODE:
 		if (*pLen < Limit - LogPortIndex) {
 
 			*pLen = Limit - LogPortIndex;
@@ -6284,8 +5987,8 @@
 						EventParam) > 0) {
 
 						SK_ERR_LOG(pAC, SK_ERRCL_SW,
-							SK_PNMI_ERR052,
-							SK_PNMI_ERR052MSG);
+							SK_PNMI_ERR042,
+							SK_PNMI_ERR042MSG);
 
 						*pLen = 0;
 						return (SK_PNMI_ERR_GENERAL);
@@ -6304,8 +6007,8 @@
 					SK_HWEV_SET_ROLE, EventParam) > 0) {
 
 					SK_ERR_LOG(pAC, SK_ERRCL_SW,
-						SK_PNMI_ERR052,
-						SK_PNMI_ERR052MSG);
+						SK_PNMI_ERR042,
+						SK_PNMI_ERR042MSG);
 
 					*pLen = 0;
 					return (SK_PNMI_ERR_GENERAL);
@@ -6315,6 +6018,82 @@
 			Offset += sizeof(char);
 			break;
 
+		case OID_SKGE_SPEED_MODE:
+			/* Check the value range */
+			Val8 = *(pBuf + Offset);
+			if (Val8 == 0) {
+
+				Offset += sizeof(char);
+				break;
+			}
+			if (Val8 < (SK_LSPEED_AUTO) ||
+				(LogPortIndex != 0 && Val8 > (SK_LSPEED_1000MBPS)) ||
+				(LogPortIndex == 0 && Val8 > (SK_LSPEED_INDETERMINATED))) {
+
+				*pLen = 0;
+				return (SK_PNMI_ERR_BAD_VALUE);
+			}
+
+			/* The preset ends here */
+			if (Action == SK_PNMI_PRESET) {
+
+				return (SK_PNMI_ERR_OK);
+			}
+
+			if (LogPortIndex == 0) {
+
+				/*
+				 * The virtual port consists of all currently
+				 * active ports. Find them and send an event
+				 * with the new flow control mode to SIRQ.
+				 */
+				for (PhysPortIndex = 0;
+					PhysPortIndex < PhysPortMax;
+					PhysPortIndex ++) {
+
+					if (!pAC->Pnmi.Port[PhysPortIndex].ActiveFlag) {
+
+						continue;
+					}
+
+					EventParam.Para32[0] = PhysPortIndex;
+					EventParam.Para32[1] = (SK_U32)Val8;
+					if (SkGeSirqEvent(pAC, IoC,
+						SK_HWEV_SET_SPEED,
+						EventParam) > 0) {
+
+						SK_ERR_LOG(pAC, SK_ERRCL_SW,
+							SK_PNMI_ERR045,
+							SK_PNMI_ERR045MSG);
+
+						*pLen = 0;
+						return (SK_PNMI_ERR_GENERAL);
+					}
+				}
+			}
+			else {
+				/*
+				 * Send an event with the new flow control
+				 * mode to the SIRQ module.
+				 */
+				EventParam.Para32[0] = SK_PNMI_PORT_LOG2PHYS(
+					pAC, LogPortIndex);
+				EventParam.Para32[1] = (SK_U32)Val8;
+				if (SkGeSirqEvent(pAC, IoC,
+					SK_HWEV_SET_SPEED,
+					EventParam) > 0) {
+
+					SK_ERR_LOG(pAC, SK_ERRCL_SW,
+						SK_PNMI_ERR045,
+						SK_PNMI_ERR045MSG);
+
+					*pLen = 0;
+					return (SK_PNMI_ERR_GENERAL);
+				}
+			}
+			Offset += sizeof(char);
+			break;
+
 		case OID_SKGE_MTU :
 			/* Check the value range */
 			Val32 = *(SK_U32*)(pBuf + Offset);
@@ -6341,8 +6120,8 @@
 			break;
 
 		default:
-			SK_ERR_LOG(pAC, SK_ERRCL_SW, SK_PNMI_ERR045,
-				SK_PNMI_ERR045MSG);
+            SK_DBG_MSG(pAC, SK_DBGMOD_PNMI, SK_DBGCAT_ERR,
+                ("MacPrivateConf: Unknown OID should be handled before set"));
 
 			*pLen = 0;
 			return (SK_PNMI_ERR_GENERAL);
@@ -6373,8 +6152,7 @@
  *                               exist (e.g. port instance 3 on a two port
  *	                         adapter.
  */
-
-static int Monitor(
+PNMI_STATIC int Monitor(
 SK_AC *pAC,		/* Pointer to adapter context */
 SK_IOC IoC,		/* IO context handle */
 int Action,		/* Get/PreSet/Set action */
@@ -6489,8 +6267,7 @@
  * Returns:
  *	Nothing
  */
-
-static void VirtualConf(
+PNMI_STATIC void VirtualConf(
 SK_AC *pAC,		/* Pointer to adapter context */
 SK_IOC IoC,		/* IO context handle */
 SK_U32 Id,		/* Object ID that is to be processed */
@@ -6500,15 +6277,17 @@
 	unsigned int	PhysPortIndex;
 	SK_U8		Val8;
 	SK_BOOL		PortActiveFlag;
-
+	SK_GEPORT	*pPrt;
 
 	*pBuf = 0;
 	PortActiveFlag = SK_FALSE;
 	PhysPortMax = pAC->GIni.GIMacsFound;
-
+	
 	for (PhysPortIndex = 0; PhysPortIndex < PhysPortMax;
 		PhysPortIndex ++) {
 
+		pPrt = &pAC->GIni.GP[PhysPortIndex];
+
 		/* Check if the physical port is active */
 		if (!pAC->Pnmi.Port[PhysPortIndex].ActiveFlag) {
 
@@ -6527,15 +6306,14 @@
 			 * From a curious point of view the virtual port
 			 * is capable of all found capabilities.
 			 */
-			*pBuf |= pAC->GIni.GP[PhysPortIndex].PLinkCap;
+			*pBuf |= pPrt->PLinkCap;
 			break;
 
 		case OID_SKGE_LINK_MODE:
 			/* Check if it is the first active port */
 			if (*pBuf == 0) {
 
-				*pBuf = pAC->GIni.GP[PhysPortIndex].
-					PLinkModeConf;
+				*pBuf = pPrt->PLinkModeConf;
 				continue;
 			}
 
@@ -6544,8 +6322,7 @@
 			 * mode than the first one we return a value that
 			 * indicates that the link mode is indeterminated.
 			 */
-			if (*pBuf != pAC->GIni.GP[PhysPortIndex].PLinkModeConf
-				) {
+			if (*pBuf != pPrt->PLinkModeConf) {
 
 				*pBuf = SK_LMODE_INDETERMINATED;
 			}
@@ -6553,8 +6330,7 @@
 
 		case OID_SKGE_LINK_MODE_STATUS:
 			/* Get the link mode of the physical port */
-			Val8 = CalculateLinkModeStatus(pAC, IoC,
-				PhysPortIndex);
+			Val8 = CalculateLinkModeStatus(pAC, IoC, PhysPortIndex);
 
 			/* Check if it is the first active port */
 			if (*pBuf == 0) {
@@ -6602,8 +6378,7 @@
 			/* Check if it is the first active port */
 			if (*pBuf == 0) {
 
-				*pBuf = pAC->GIni.GP[PhysPortIndex].
-					PFlowCtrlCap;
+				*pBuf = pPrt->PFlowCtrlCap;
 				continue;
 			}
 
@@ -6611,15 +6386,14 @@
 			 * From a curious point of view the virtual port
 			 * is capable of all found capabilities.
 			 */
-			*pBuf |= pAC->GIni.GP[PhysPortIndex].PFlowCtrlCap;
+			*pBuf |= pPrt->PFlowCtrlCap;
 			break;
 
 		case OID_SKGE_FLOWCTRL_MODE:
 			/* Check if it is the first active port */
 			if (*pBuf == 0) {
 
-				*pBuf = pAC->GIni.GP[PhysPortIndex].
-					PFlowCtrlMode;
+				*pBuf = pPrt->PFlowCtrlMode;
 				continue;
 			}
 
@@ -6628,8 +6402,7 @@
 			 * control mode than the first one, we return a value
 			 * that indicates that the mode is indeterminated.
 			 */
-			if (*pBuf != pAC->GIni.GP[PhysPortIndex].
-				PFlowCtrlMode) {
+			if (*pBuf != pPrt->PFlowCtrlMode) {
 
 				*pBuf = SK_FLOW_MODE_INDETERMINATED;
 			}
@@ -6639,8 +6412,7 @@
 			/* Check if it is the first active port */
 			if (*pBuf == 0) {
 
-				*pBuf = pAC->GIni.GP[PhysPortIndex].
-					PFlowCtrlStatus;
+				*pBuf = pPrt->PFlowCtrlStatus;
 				continue;
 			}
 
@@ -6650,18 +6422,17 @@
 			 * value that indicates that the status is
 			 * indeterminated.
 			 */
-			if (*pBuf != pAC->GIni.GP[PhysPortIndex].
-				PFlowCtrlStatus) {
+			if (*pBuf != pPrt->PFlowCtrlStatus) {
 
 				*pBuf = SK_FLOW_STAT_INDETERMINATED;
 			}
 			break;
+		
 		case OID_SKGE_PHY_OPERATION_CAP:
 			/* Check if it is the first active port */
 			if (*pBuf == 0) {
 
-				*pBuf = pAC->GIni.GP[PhysPortIndex].
-					PMSCap;
+				*pBuf = pPrt->PMSCap;
 				continue;
 			}
 
@@ -6669,15 +6440,14 @@
 			 * From a curious point of view the virtual port
 			 * is capable of all found capabilities.
 			 */
-			*pBuf |= pAC->GIni.GP[PhysPortIndex].PMSCap;
+			*pBuf |= pPrt->PMSCap;
 			break;
 
 		case OID_SKGE_PHY_OPERATION_MODE:
 			/* Check if it is the first active port */
 			if (*pBuf == 0) {
 
-				*pBuf = pAC->GIni.GP[PhysPortIndex].
-					PMSMode;
+				*pBuf = pPrt->PMSMode;
 				continue;
 			}
 
@@ -6686,8 +6456,7 @@
 			 * slave mode than the first one, we return a value
 			 * that indicates that the mode is indeterminated.
 			 */
-			if (*pBuf != pAC->GIni.GP[PhysPortIndex].
-				PMSMode) {
+			if (*pBuf != pPrt->PMSMode) {
 
 				*pBuf = SK_MS_MODE_INDETERMINATED;
 			}
@@ -6697,8 +6466,7 @@
 			/* Check if it is the first active port */
 			if (*pBuf == 0) {
 
-				*pBuf = pAC->GIni.GP[PhysPortIndex].
-					PMSStatus;
+				*pBuf = pPrt->PMSStatus;
 				continue;
 			}
 
@@ -6708,12 +6476,50 @@
 			 * value that indicates that the status is
 			 * indeterminated.
 			 */
-			if (*pBuf != pAC->GIni.GP[PhysPortIndex].
-				PMSStatus) {
+			if (*pBuf != pPrt->PMSStatus) {
 
 				*pBuf = SK_MS_STAT_INDETERMINATED;
 			}
 			break;
+		
+		case OID_SKGE_SPEED_MODE:
+			/* Check if it is the first active port */
+			if (*pBuf == 0) {
+
+				*pBuf = pPrt->PLinkSpeed;
+				continue;
+			}
+
+			/*
+			 * If we find an active port with a different flow
+			 * control mode than the first one, we return a value
+			 * that indicates that the mode is indeterminated.
+			 */
+			if (*pBuf != pPrt->PLinkSpeed) {
+
+				*pBuf = SK_LSPEED_INDETERMINATED;
+			}
+			break;
+		
+		case OID_SKGE_SPEED_STATUS:
+			/* Check if it is the first active port */
+			if (*pBuf == 0) {
+
+				*pBuf = pPrt->PLinkSpeedUsed;
+				continue;
+			}
+
+			/*
+			 * If we find an active port with a different flow
+			 * control status than the first one, we return a
+			 * value that indicates that the status is
+			 * indeterminated.
+			 */
+			if (*pBuf != pPrt->PLinkSpeedUsed) {
+
+				*pBuf = SK_LSPEED_STAT_INDETERMINATED;
+			}
+			break;
 		}
 	}
 
@@ -6760,6 +6566,17 @@
 		case OID_SKGE_PHY_OPERATION_STATUS:
 			*pBuf = SK_MS_STAT_INDETERMINATED;
 			break;
+		case OID_SKGE_SPEED_CAP:
+			*pBuf = SK_LSPEED_CAP_INDETERMINATED;
+			break;
+
+		case OID_SKGE_SPEED_MODE:
+			*pBuf = SK_LSPEED_INDETERMINATED;
+			break;
+
+		case OID_SKGE_SPEED_STATUS:
+			*pBuf = SK_LSPEED_STAT_INDETERMINATED;
+			break;
 		}
 	}
 }
@@ -6779,15 +6596,13 @@
  * Returns:
  *	Link status of physical port
  */
-
-static SK_U8 CalculateLinkStatus(
+PNMI_STATIC SK_U8 CalculateLinkStatus(
 SK_AC *pAC,			/* Pointer to adapter context */
 SK_IOC IoC,			/* IO context handle */
 unsigned int PhysPortIndex)	/* Physical port index */
 {
 	SK_U8	Result;
 
-
 	if (!pAC->GIni.GP[PhysPortIndex].PHWLinkUp) {
 
 		Result = SK_PNMI_RLMT_LSTAT_PHY_DOWN;
@@ -6820,15 +6635,13 @@
  * Returns:
  *	The link mode status
  */
-
-static SK_U8 CalculateLinkModeStatus(
+PNMI_STATIC SK_U8 CalculateLinkModeStatus(
 SK_AC *pAC,			/* Pointer to adapter context */
 SK_IOC IoC,			/* IO context handle */
 unsigned int PhysPortIndex)	/* Physical port index */
 {
 	SK_U8	Result;
 
-
 	/* Get the current mode, which can be full or half duplex */
 	Result = pAC->GIni.GP[PhysPortIndex].PLinkModeStatus;
 
@@ -6836,7 +6649,7 @@
 	if (Result < SK_LMODE_STAT_HALF) {
 
 		Result = SK_LMODE_STAT_UNKNOWN;
-	} 
+	}
 	else if (pAC->GIni.GP[PhysPortIndex].PLinkMode >= SK_LMODE_AUTOHALF) {
 
 		/*
@@ -6869,8 +6682,7 @@
  *	SK_PNMI_ERR_OK	     Task successfully performed.
  *	SK_PNMI_ERR_GENERAL  Something went wrong.
  */
-
-static int GetVpdKeyArr(
+PNMI_STATIC int GetVpdKeyArr(
 SK_AC *pAC,		/* Pointer to adapter context */
 SK_IOC IoC,		/* IO context handle */
 char *pKeyArr,		/* Ptr KeyArray */
@@ -6966,8 +6778,7 @@
  *	SK_PNMI_ERR_OK	     Task successfully performed.
  *	SK_PNMI_ERR_GENERAL  Something went wrong.
  */
-
-static int SirqUpdate(
+PNMI_STATIC int SirqUpdate(
 SK_AC *pAC,	/* Pointer to adapter context */
 SK_IOC IoC)	/* IO context handle */
 {
@@ -7006,8 +6817,7 @@
  *	SK_PNMI_ERR_OK	     Task successfully performed.
  *	SK_PNMI_ERR_GENERAL  Something went wrong.
  */
-
-static int RlmtUpdate(
+PNMI_STATIC int RlmtUpdate(
 SK_AC *pAC,	/* Pointer to adapter context */
 SK_IOC IoC,	/* IO context handle */
 SK_U32 NetIndex)	/* NetIndex (0..n), in single net mode allways zero */
@@ -7043,23 +6853,19 @@
  * Description:
  *	The XMAC holds its statistic internally. To obtain the current
  *	values we must send a command so that the statistic data will
- *	be written to a predefined memory area on the adapter. 
+ *	be written to a predefined memory area on the adapter.
  *
  * Returns:
  *	SK_PNMI_ERR_OK	     Task successfully performed.
  *	SK_PNMI_ERR_GENERAL  Something went wrong.
  */
-
-static int MacUpdate(
+PNMI_STATIC int MacUpdate(
 SK_AC *pAC,		/* Pointer to adapter context */
 SK_IOC IoC,		/* IO context handle */
 unsigned int FirstMac,	/* Index of the first Mac to be updated */
 unsigned int LastMac)	/* Index of the last Mac to be updated */
 {
 	unsigned int	MacIndex;
-	SK_U16		StatReg;
-	unsigned int	WaitIndex;
-
 
 	/*
 	 * Were the statistics already updated during the
@@ -7070,31 +6876,21 @@
 		return (SK_PNMI_ERR_OK);
 	}
 
-	/* Send an update command to all XMACs specified */
+	/* Send an update command to all MACs specified */
 	for (MacIndex = FirstMac; MacIndex <= LastMac; MacIndex ++) {
 
-		StatReg = XM_SC_SNP_TXC | XM_SC_SNP_RXC;
-		XM_OUT16(IoC, MacIndex, XM_STAT_CMD, StatReg);
-
 		/*
-		 * It is an auto-clearing register. If the command bits
-		 * went to zero again, the statistics are transfered.
-		 * Normally the command should be executed immediately.
-		 * But just to be sure we execute a loop.
+		 * 2002-09-13 pweber:	Freeze the current SW counters.
+		 *                      (That should be done as close as
+		 *                      possible to the update of the
+		 *                      HW counters)
 		 */
-		for (WaitIndex = 0; WaitIndex < 10; WaitIndex ++) {
-
-			XM_IN16(IoC, MacIndex, XM_STAT_CMD, &StatReg);
-			if ((StatReg & (XM_SC_SNP_TXC | XM_SC_SNP_RXC)) ==
-				0) {
-
-				break;
-			}
+		if (pAC->GIni.GIMacType == SK_MAC_XMAC) {
+			pAC->Pnmi.BufPort[MacIndex] = pAC->Pnmi.Port[MacIndex];
 		}
-		if (WaitIndex == 10 ) {
-
-			SK_ERR_LOG(pAC, SK_ERRCL_HW, SK_PNMI_ERR050,
-				SK_PNMI_ERR050MSG);
+			
+		/* 2002-09-13 pweber:  Update the HW counter  */
+		if (pAC->GIni.GIFunc.pFnMacUpdateStats(pAC, IoC, MacIndex) != 0) {
 
 			return (SK_PNMI_ERR_GENERAL);
 		}
@@ -7119,8 +6915,7 @@
  * Returns:
  *	Requested statistic value
  */
-
-static SK_U64 GetStatVal(
+PNMI_STATIC SK_U64 GetStatVal(
 SK_AC *pAC,					/* Pointer to adapter context */
 SK_IOC IoC,					/* IO context handle */
 unsigned int LogPortIndex,	/* Index of the logical Port to be processed */
@@ -7129,16 +6924,16 @@
 {
 	unsigned int	PhysPortIndex;
 	unsigned int	PhysPortMax;
-	SK_U64		Val = 0;
+	SK_U64			Val = 0;
 
 
-	if(pAC->Pnmi.DualNetActiveFlag == SK_TRUE){	/* Dual net mode */
+	if (pAC->Pnmi.DualNetActiveFlag == SK_TRUE) {	/* Dual net mode */
 
 		PhysPortIndex = NetIndex;
+		
 		Val = GetPhysStatVal(pAC, IoC, PhysPortIndex, StatIndex);
-    }	/* end of dual net mode */
-
-	else { /* single net mode */
+	}
+	else {	/* Single Net mode */
 
 		if (LogPortIndex == 0) {
 
@@ -7150,8 +6945,7 @@
 
 				if (pAC->Pnmi.Port[PhysPortIndex].ActiveFlag) {
 
-					Val += GetPhysStatVal(pAC, IoC, PhysPortIndex,
-						StatIndex);
+					Val += GetPhysStatVal(pAC, IoC, PhysPortIndex, StatIndex);
 				}
 			}
 
@@ -7161,9 +6955,10 @@
 		else {
 			/* Get counter value of physical port */
 			PhysPortIndex = SK_PNMI_PORT_LOG2PHYS(pAC, LogPortIndex);
+			
 			Val = GetPhysStatVal(pAC, IoC, PhysPortIndex, StatIndex);
 		}
-	} /* end of single net mode */
+	}
 	return (Val);
 }
 
@@ -7183,87 +6978,325 @@
  * Returns:
  *	Counter value
  */
-
-static SK_U64 GetPhysStatVal(
+PNMI_STATIC SK_U64 GetPhysStatVal(
 SK_AC *pAC,					/* Pointer to adapter context */
 SK_IOC IoC,					/* IO context handle */
 unsigned int PhysPortIndex,	/* Index of the logical Port to be processed */
 unsigned int StatIndex)		/* Index to statistic value */
 {
-	SK_U64		Val = 0;
-	SK_U32		LowVal;
-	SK_U32		HighVal;
-
+	SK_U64	Val = 0;
+	SK_U32	LowVal = 0;
+	SK_U32	HighVal = 0;
+	SK_U16	Word;
+	int		MacType;
+	unsigned int HelpIndex;
+	SK_GEPORT	*pPrt;
+	
+	SK_PNMI_PORT	*pPnmiPrt;
+	SK_GEMACFUNC	*pFnMac;
+	
+	pPrt = &pAC->GIni.GP[PhysPortIndex];
+	
+	MacType = pAC->GIni.GIMacType;
+	
+	/* 2002-09-17 pweber: For XMAC, use the frozen SW counters (BufPort) */
+	if (MacType == SK_MAC_XMAC) {
+		pPnmiPrt = &pAC->Pnmi.BufPort[PhysPortIndex];
+	}
+	else {
+		pPnmiPrt = &pAC->Pnmi.Port[PhysPortIndex];
+	}
+	
+	pFnMac   = &pAC->GIni.GIFunc;
 
 	switch (StatIndex) {
+	case SK_PNMI_HTX:
+		if (MacType == SK_MAC_GMAC) {
+			(void)pFnMac->pFnMacStatistic(pAC, IoC, PhysPortIndex,
+							StatAddr[SK_PNMI_HTX_BROADCAST][MacType].Reg,
+							&LowVal);
+			(void)pFnMac->pFnMacStatistic(pAC, IoC, PhysPortIndex,
+							StatAddr[SK_PNMI_HTX_MULTICAST][MacType].Reg,
+							&HighVal);
+			LowVal += HighVal;
+			(void)pFnMac->pFnMacStatistic(pAC, IoC, PhysPortIndex,
+							StatAddr[SK_PNMI_HTX_UNICAST][MacType].Reg,
+							&HighVal);
+			LowVal += HighVal;
+		}
+		else {
+			(void)pFnMac->pFnMacStatistic(pAC, IoC, PhysPortIndex,
+										  StatAddr[StatIndex][MacType].Reg,
+										  &LowVal);
+		}
+		HighVal = pPnmiPrt->CounterHigh[StatIndex];
+		break;
+	
+	case SK_PNMI_HRX:
+		if (MacType == SK_MAC_GMAC) {
+			(void)pFnMac->pFnMacStatistic(pAC, IoC, PhysPortIndex,
+							StatAddr[SK_PNMI_HRX_BROADCAST][MacType].Reg,
+							&LowVal);
+			(void)pFnMac->pFnMacStatistic(pAC, IoC, PhysPortIndex,
+							StatAddr[SK_PNMI_HRX_MULTICAST][MacType].Reg,
+							&HighVal);
+			LowVal += HighVal;
+			(void)pFnMac->pFnMacStatistic(pAC, IoC, PhysPortIndex,
+							StatAddr[SK_PNMI_HRX_UNICAST][MacType].Reg,
+							&HighVal);
+			LowVal += HighVal;
+		}
+		else {
+			(void)pFnMac->pFnMacStatistic(pAC, IoC, PhysPortIndex,
+										  StatAddr[StatIndex][MacType].Reg,
+										  &LowVal);
+		}
+		HighVal = pPnmiPrt->CounterHigh[StatIndex];
+		break;
 
 	case SK_PNMI_HTX_OCTET:
-		XM_IN32(IoC, PhysPortIndex, XM_TXO_OK_LO, &LowVal);
-		XM_IN32(IoC, PhysPortIndex, XM_TXO_OK_HI, &HighVal);
+	case SK_PNMI_HRX_OCTET:
+		(void)pFnMac->pFnMacStatistic(pAC, IoC, PhysPortIndex,
+									  StatAddr[StatIndex][MacType].Reg,
+									  &HighVal);
+		(void)pFnMac->pFnMacStatistic(pAC, IoC, PhysPortIndex,
+									  StatAddr[StatIndex + 1][MacType].Reg,
+									  &LowVal);
+		break;
+
+	case SK_PNMI_HTX_BURST:
+	case SK_PNMI_HTX_EXCESS_DEF:
+	case SK_PNMI_HTX_CARRIER:
+		/* Not supported by GMAC */
+		if (MacType == SK_MAC_GMAC) {
+			return (Val);
+		}
+
+		(void)pFnMac->pFnMacStatistic(pAC, IoC, PhysPortIndex,
+									  StatAddr[StatIndex][MacType].Reg,
+									  &LowVal);
+		HighVal = pPnmiPrt->CounterHigh[StatIndex];
+		break;
+
+	case SK_PNMI_HTX_MACC:
+		/* GMAC only supports PAUSE MAC control frames */
+		if (MacType == SK_MAC_GMAC) {
+			HelpIndex = SK_PNMI_HTX_PMACC;
+		}
+		else {
+			HelpIndex = StatIndex;
+		}
+		
+		(void)pFnMac->pFnMacStatistic(pAC, IoC, PhysPortIndex,
+								StatAddr[HelpIndex][MacType].Reg,
+								&LowVal);
+
+		HighVal = pPnmiPrt->CounterHigh[StatIndex];
 		break;
 
-	case SK_PNMI_HRX_OCTET:
-		XM_IN32(IoC, PhysPortIndex, XM_RXO_OK_LO, &LowVal);
-		XM_IN32(IoC, PhysPortIndex, XM_RXO_OK_HI, &HighVal);
+	case SK_PNMI_HTX_COL:
+	case SK_PNMI_HRX_UNDERSIZE:
+		/* Not supported by XMAC */
+		if (MacType == SK_MAC_XMAC) {
+			return (Val);
+		}
+
+		(void)pFnMac->pFnMacStatistic(pAC, IoC, PhysPortIndex,
+									  StatAddr[StatIndex][MacType].Reg,
+									  &LowVal);
+		HighVal = pPnmiPrt->CounterHigh[StatIndex];
+		break;
+
+	case SK_PNMI_HTX_DEFFERAL:
+		/* Not supported by GMAC */
+		if (MacType == SK_MAC_GMAC) {
+			return (Val);
+		}
+		
+		/*
+		 * XMAC counts frames with deferred transmission
+		 * even in full-duplex mode.
+		 *
+		 * In full-duplex mode the counter remains constant!
+		 */
+		if ((pPrt->PLinkModeStatus == SK_LMODE_STAT_AUTOFULL) ||
+			(pPrt->PLinkModeStatus == SK_LMODE_STAT_FULL)) {
+
+			LowVal = 0;
+			HighVal = 0;
+		}
+		else {
+			/* Otherwise get contents of hardware register */
+			(void)pFnMac->pFnMacStatistic(pAC, IoC, PhysPortIndex,
+										  StatAddr[StatIndex][MacType].Reg,
+										  &LowVal);
+			HighVal = pPnmiPrt->CounterHigh[StatIndex];
+		}
+		break;
+
+	case SK_PNMI_HRX_BADOCTET:
+		/* Not supported by XMAC */
+		if (MacType == SK_MAC_XMAC) {
+			return (Val);
+		}
+
+		(void)pFnMac->pFnMacStatistic(pAC, IoC, PhysPortIndex,
+									  StatAddr[StatIndex][MacType].Reg,
+									  &HighVal);
+		(void)pFnMac->pFnMacStatistic(pAC, IoC, PhysPortIndex,
+									  StatAddr[StatIndex + 1][MacType].Reg,
+                                      &LowVal);
 		break;
 
 	case SK_PNMI_HTX_OCTETLOW:
 	case SK_PNMI_HRX_OCTETLOW:
+	case SK_PNMI_HRX_BADOCTETLOW:
 		return (Val);
 
-	case SK_PNMI_HTX_SYNC:
-		LowVal = (SK_U32)pAC->Pnmi.Port[PhysPortIndex].StatSyncCts;
-		HighVal = (SK_U32)
-			(pAC->Pnmi.Port[PhysPortIndex].StatSyncCts >> 32);
+	case SK_PNMI_HRX_LONGFRAMES:
+		/* For XMAC the SW counter is managed by PNMI */
+		if (MacType == SK_MAC_XMAC) {
+			return (pPnmiPrt->StatRxLongFrameCts);
+		}
+		
+		(void)pFnMac->pFnMacStatistic(pAC, IoC, PhysPortIndex,
+									  StatAddr[StatIndex][MacType].Reg,
+									  &LowVal);
+		HighVal = pPnmiPrt->CounterHigh[StatIndex];
+		break;
+		
+	case SK_PNMI_HRX_TOO_LONG:
+		(void)pFnMac->pFnMacStatistic(pAC, IoC, PhysPortIndex,
+								StatAddr[StatIndex][MacType].Reg,
+								&LowVal);
+		HighVal = pPnmiPrt->CounterHigh[StatIndex];
+		
+		Val = (((SK_U64)HighVal << 32) | (SK_U64)LowVal);
+
+		if (MacType == SK_MAC_GMAC) {
+			/* For GMAC the SW counter is additionally managed by PNMI */
+			Val += pPnmiPrt->StatRxFrameTooLongCts;
+		}
+		else {
+			/*
+			 * Frames longer than IEEE 802.3 frame max size are counted
+			 * by XMAC in frame_too_long counter even reception of long
+			 * frames was enabled and the frame was correct.
+			 * So correct the value by subtracting RxLongFrame counter.
+			 */
+			Val -= pPnmiPrt->StatRxLongFrameCts;
+		}
+
+		LowVal = (SK_U32)Val;
+		HighVal = (SK_U32)(Val >> 32);
 		break;
+		
+	case SK_PNMI_HRX_SHORTS:
+		/* Not supported by GMAC */
+		if (MacType == SK_MAC_GMAC) {
+			/* GM_RXE_FRAG?? */
+			return (Val);
+		}
+		
+		/*
+		 * XMAC counts short frame errors even if link down (#10620)
+		 *
+		 * If link-down the counter remains constant
+		 */
+		if (pPrt->PLinkModeStatus != SK_LMODE_STAT_UNKNOWN) {
 
-	case SK_PNMI_HTX_SYNC_OCTET:
-		LowVal = (SK_U32)pAC->Pnmi.Port[PhysPortIndex].
-			StatSyncOctetsCts;
-		HighVal = (SK_U32)
-			(pAC->Pnmi.Port[PhysPortIndex].StatSyncOctetsCts >>
-			32);
+			/* Otherwise get incremental difference */
+			(void)pFnMac->pFnMacStatistic(pAC, IoC, PhysPortIndex,
+										  StatAddr[StatIndex][MacType].Reg,
+										  &LowVal);
+			HighVal = pPnmiPrt->CounterHigh[StatIndex];
+
+			Val = (((SK_U64)HighVal << 32) | (SK_U64)LowVal);
+			Val -= pPnmiPrt->RxShortZeroMark;
+
+			LowVal = (SK_U32)Val;
+			HighVal = (SK_U32)(Val >> 32);
+		}
 		break;
 
-	case SK_PNMI_HRX_LONGFRAMES:
-		LowVal = (SK_U32)pAC->Pnmi.Port[PhysPortIndex].StatRxLongFrameCts;
-		HighVal = (SK_U32)
-			(pAC->Pnmi.Port[PhysPortIndex].StatRxLongFrameCts >> 32);
+	case SK_PNMI_HRX_MACC:
+	case SK_PNMI_HRX_MACC_UNKWN:
+	case SK_PNMI_HRX_BURST:
+	case SK_PNMI_HRX_MISSED:
+	case SK_PNMI_HRX_FRAMING:
+	case SK_PNMI_HRX_CARRIER:
+	case SK_PNMI_HRX_IRLENGTH:
+	case SK_PNMI_HRX_SYMBOL:
+	case SK_PNMI_HRX_CEXT:
+		/* Not supported by GMAC */
+		if (MacType == SK_MAC_GMAC) {
+			return (Val);
+		}
+
+		(void)pFnMac->pFnMacStatistic(pAC, IoC, PhysPortIndex,
+									  StatAddr[StatIndex][MacType].Reg,
+									  &LowVal);
+		HighVal = pPnmiPrt->CounterHigh[StatIndex];
+		break;
+
+	case SK_PNMI_HRX_PMACC_ERR:
+		/* For GMAC the SW counter is managed by PNMI */
+		if (MacType == SK_MAC_GMAC) {
+			return (pPnmiPrt->StatRxPMaccErr);
+		}
+		
+		(void)pFnMac->pFnMacStatistic(pAC, IoC, PhysPortIndex,
+									  StatAddr[StatIndex][MacType].Reg,
+									  &LowVal);
+		HighVal = pPnmiPrt->CounterHigh[StatIndex];
+		break;
+
+	/* SW counter managed by PNMI */
+	case SK_PNMI_HTX_SYNC:
+		LowVal = (SK_U32)pPnmiPrt->StatSyncCts;
+		HighVal = (SK_U32)(pPnmiPrt->StatSyncCts >> 32);
+		break;
+
+	/* SW counter managed by PNMI */
+	case SK_PNMI_HTX_SYNC_OCTET:
+		LowVal = (SK_U32)pPnmiPrt->StatSyncOctetsCts;
+		HighVal = (SK_U32)(pPnmiPrt->StatSyncOctetsCts >> 32);
 		break;
 
 	case SK_PNMI_HRX_FCS:
-		/* 
-		 * Broadcom filters fcs errors and counts it in 
+		/*
+		 * Broadcom filters FCS errors and counts it in
 		 * Receive Error Counter register
 		 */
-		if (pAC->GIni.GP[PhysPortIndex].PhyType == SK_PHY_BCOM) {
+		if (pPrt->PhyType == SK_PHY_BCOM) {
 			/* do not read while not initialized (PHY_READ hangs!)*/
-			if (pAC->GIni.GP[PhysPortIndex].PState) {
-				PHY_READ(IoC, &pAC->GIni.GP[PhysPortIndex],
-					 PhysPortIndex, PHY_BCOM_RE_CTR,
-					&LowVal);
+			if (pPrt->PState != SK_PRT_RESET) {
+				SkXmPhyRead(pAC, IoC, PhysPortIndex, PHY_BCOM_RE_CTR, &Word);
+				
+				LowVal = Word;
 			}
-			else {
-				LowVal = 0;
-			}
-			HighVal = pAC->Pnmi.Port[PhysPortIndex].CounterHigh[StatIndex];
+			HighVal = pPnmiPrt->CounterHigh[StatIndex];
 		}
 		else {
-			XM_IN32(IoC, PhysPortIndex,
-				StatAddress[StatIndex].Param, &LowVal);
-			HighVal = pAC->Pnmi.Port[PhysPortIndex].CounterHigh[StatIndex];
+			(void)pFnMac->pFnMacStatistic(pAC, IoC, PhysPortIndex,
+										  StatAddr[StatIndex][MacType].Reg,
+										  &LowVal);
+			HighVal = pPnmiPrt->CounterHigh[StatIndex];
 		}
+		break;
+
 	default:
-		XM_IN32(IoC, PhysPortIndex, StatAddress[StatIndex].Param,
-			&LowVal);
-		HighVal = pAC->Pnmi.Port[PhysPortIndex].CounterHigh[StatIndex];
+		(void)pFnMac->pFnMacStatistic(pAC, IoC, PhysPortIndex,
+									  StatAddr[StatIndex][MacType].Reg,
+									  &LowVal);
+		HighVal = pPnmiPrt->CounterHigh[StatIndex];
 		break;
 	}
 
 	Val = (((SK_U64)HighVal << 32) | (SK_U64)LowVal);
 
 	/* Correct value because of possible XMAC reset. XMAC Errata #2 */
-	Val += pAC->Pnmi.Port[PhysPortIndex].CounterOffset[StatIndex];
+	Val += pPnmiPrt->CounterOffset[StatIndex];
 
 	return (Val);
 }
@@ -7279,8 +7312,7 @@
  * Returns:
  *	Nothing
  */
-
-static void ResetCounter(
+PNMI_STATIC void ResetCounter(
 SK_AC *pAC,		/* Pointer to adapter context */
 SK_IOC IoC,		/* IO context handle */
 SK_U32 NetIndex)
@@ -7305,7 +7337,8 @@
 
 	/* Notify CSUM module */
 #ifdef SK_USE_CSUM
-	EventParam.Para64 = (SK_U64)(-1);
+	EventParam.Para32[0] = NetIndex;
+	EventParam.Para32[1] = (SK_U32)-1;
 	SkEventQueue(pAC, SKGE_CSUM, SK_CSUM_EVENT_CLEAR_PROTO_STATS,
 		EventParam);
 #endif
@@ -7314,11 +7347,7 @@
 	for (PhysPortIndex = 0; PhysPortIndex <
 		(unsigned int)pAC->GIni.GIMacsFound; PhysPortIndex ++) {
 
-		XM_OUT16(IoC, PhysPortIndex, XM_STAT_CMD,
-			XM_SC_CLR_RXC | XM_SC_CLR_TXC);
-		/* Clear two times according to Errata #3 */
-		XM_OUT16(IoC, PhysPortIndex, XM_STAT_CMD,
-			XM_SC_CLR_RXC | XM_SC_CLR_TXC);
+		(void)pAC->GIni.GIFunc.pFnMacResetCounter(pAC, IoC, PhysPortIndex);
 
 		SK_MEMSET((char *)&pAC->Pnmi.Port[PhysPortIndex].CounterHigh,
 			0, sizeof(pAC->Pnmi.Port[PhysPortIndex].CounterHigh));
@@ -7333,6 +7362,12 @@
 		SK_MEMSET((char *)&pAC->Pnmi.Port[PhysPortIndex].
 			StatRxLongFrameCts, 0, sizeof(pAC->Pnmi.Port[
 			PhysPortIndex].StatRxLongFrameCts));
+		SK_MEMSET((char *)&pAC->Pnmi.Port[PhysPortIndex].
+				  StatRxFrameTooLongCts, 0, sizeof(pAC->Pnmi.Port[
+			PhysPortIndex].StatRxFrameTooLongCts));
+		SK_MEMSET((char *)&pAC->Pnmi.Port[PhysPortIndex].
+				  StatRxPMaccErr, 0, sizeof(pAC->Pnmi.Port[
+			PhysPortIndex].StatRxPMaccErr));
 	}
 
 	/*
@@ -7373,8 +7408,7 @@
  * Returns:
  *	A pointer to the trap entry
  */
-
-static char* GetTrapEntry(
+PNMI_STATIC char* GetTrapEntry(
 SK_AC *pAC,		/* Pointer to adapter context */
 SK_U32 TrapId,		/* SNMP ID of the trap */
 unsigned int Size)	/* Space needed for trap entry */
@@ -7399,11 +7433,11 @@
 	if (Beg >= Size) {
 
 		NeededSpace = Size;
-		Wrap = FALSE;
+		Wrap = SK_FALSE;
 	}
 	else {
 		NeededSpace = Beg + Size;
-		Wrap = TRUE;
+		Wrap = SK_TRUE;
 	}
 
 	/*
@@ -7435,7 +7469,7 @@
 		}
 	}
 
-	/* 
+	/*
 	 * Insert new entry as first entry. Newest entries are
 	 * stored at the beginning of the queue.
 	 */
@@ -7479,8 +7513,7 @@
  * Returns:
  *	Nothing
  */
-
-static void CopyTrapQueue(
+PNMI_STATIC void CopyTrapQueue(
 SK_AC *pAC,		/* Pointer to adapter context */
 char *pDstBuf)		/* Buffer to which the queued traps will be copied */
 {
@@ -7523,8 +7556,7 @@
  * Returns:
  *	Nothing
  */
-
-static void GetTrapQueueLen(
+PNMI_STATIC void GetTrapQueueLen(
 SK_AC *pAC,		/* Pointer to adapter context */
 unsigned int *pLen,	/* Length in Bytes of all queued traps */
 unsigned int *pEntries)	/* Returns number of trapes stored in queue */
@@ -7566,8 +7598,7 @@
  * Returns:
  *	Nothing
  */
-
-static void QueueSimpleTrap(
+PNMI_STATIC void QueueSimpleTrap(
 SK_AC *pAC,		/* Pointer to adapter context */
 SK_U32 TrapId)		/* Type of sensor trap */
 {
@@ -7585,8 +7616,7 @@
  * Returns:
  *	Nothing
  */
-
-static void QueueSensorTrap(
+PNMI_STATIC void QueueSensorTrap(
 SK_AC *pAC,			/* Pointer to adapter context */
 SK_U32 TrapId,			/* Type of sensor trap */
 unsigned int SensorIndex)	/* Index of sensor which caused the trap */
@@ -7641,8 +7671,7 @@
  * Returns:
  *	Nothing
  */
-
-static void QueueRlmtNewMacTrap(
+PNMI_STATIC void QueueRlmtNewMacTrap(
 SK_AC *pAC,		/* Pointer to adapter context */
 unsigned int ActiveMac)	/* Index (0..n) of the currently active port */
 {
@@ -7669,8 +7698,7 @@
  * Returns:
  *	Nothing
  */
-
-static void QueueRlmtPortTrap(
+PNMI_STATIC void QueueRlmtPortTrap(
 SK_AC *pAC,		/* Pointer to adapter context */
 SK_U32 TrapId,		/* Type of RLMT port trap */
 unsigned int PortIndex)	/* Index of the port, which changed its state */
@@ -7697,8 +7725,7 @@
  * Returns:
  *	Nothing
  */
-
-static void CopyMac(
+PNMI_STATIC void CopyMac(
 char *pDst,		/* Pointer to destination buffer */
 SK_MAC_ADDR *pMac)	/* Pointer of Source */
 {
@@ -7710,3 +7737,521 @@
 		*(pDst + i) = pMac->a[i];
 	}
 }
+
+
+#ifdef SK_POWER_MGMT
+/*****************************************************************************
+ *
+ * PowerManagement - OID handler function of PowerManagement OIDs
+ *
+ * Description:
+ *	The code is simple. No description necessary.
+ *
+ * Returns:
+ *	SK_PNMI_ERR_OK           The request was successfully performed.
+ *	SK_PNMI_ERR_GENERAL      A general severe internal error occured.
+ *	SK_PNMI_ERR_TOO_SHORT    The passed buffer is too short to contain
+ *	                         the correct data (e.g. a 32bit value is
+ *	                         needed, but a 16 bit value was passed).
+ *	SK_PNMI_ERR_UNKNOWN_INST The requested instance of the OID doesn't
+ *                               exist (e.g. port instance 3 on a two port
+ *	                         adapter.
+ */
+
+PNMI_STATIC int PowerManagement(
+SK_AC *pAC,		/* Pointer to adapter context */
+SK_IOC IoC,		/* IO context handle */
+int Action,		/* Get/PreSet/Set action */
+SK_U32 Id,		/* Object ID that is to be processed */
+char *pBuf,		/* Buffer to which to mgmt data will be retrieved */
+unsigned int *pLen,	/* On call: buffer length. On return: used buffer */
+SK_U32 Instance,	/* Instance (1..n) that is to be queried or -1 */
+unsigned int TableIndex, /* Index to the Id table */
+SK_U32 NetIndex)	/* NetIndex (0..n), in single net mode allways zero */
+{
+	
+	SK_U32	RetCode = SK_PNMI_ERR_GENERAL;
+
+	/*
+	 * Check instance. We only handle single instance variables
+	 */
+	if (Instance != (SK_U32)(-1) && Instance != 1) {
+
+		*pLen = 0;
+		return (SK_PNMI_ERR_UNKNOWN_INST);
+	}
+
+	/*
+	 * Perform action
+	 */
+	if (Action == SK_PNMI_GET) {
+
+		/* Check length */
+		switch (Id) {
+
+		case OID_PNP_CAPABILITIES:
+			if (*pLen < sizeof(SK_PNP_CAPABILITIES)) {
+
+				*pLen = sizeof(SK_PNP_CAPABILITIES);
+				return (SK_PNMI_ERR_TOO_SHORT);
+			}
+			break;
+
+		case OID_PNP_QUERY_POWER:
+		case OID_PNP_ENABLE_WAKE_UP:
+			if (*pLen < sizeof(SK_U32)) {
+
+				*pLen = sizeof(SK_U32);
+				return (SK_PNMI_ERR_TOO_SHORT);
+			}
+			break;
+
+		case OID_PNP_SET_POWER:
+		case OID_PNP_ADD_WAKE_UP_PATTERN:
+		case OID_PNP_REMOVE_WAKE_UP_PATTERN:
+			break;
+		
+		default:
+			SK_ERR_LOG(pAC, SK_ERRCL_SW, SK_PNMI_ERR040,
+				SK_PNMI_ERR040MSG);
+			*pLen = 0;
+			return (SK_PNMI_ERR_GENERAL);
+		}
+
+		/*
+		 * Get value
+		 */
+		switch (Id) {
+
+		case OID_PNP_CAPABILITIES:
+			RetCode = SkPowerQueryPnPCapabilities(pAC, IoC, pBuf, pLen);
+			break;
+
+		case OID_PNP_QUERY_POWER:
+			/* The Windows DDK describes: An OID_PNP_QUERY_POWER requests
+			 the miniport to indicate whether it can transition its NIC
+			 to the low-power state.
+			 A miniport driver must always return NDIS_STATUS_SUCCESS
+			 to a query of OID_PNP_QUERY_POWER. */
+			RetCode = SK_PNMI_ERR_OK;
+			break;
+
+			/* NDIS handles these OIDs as write-only.
+			 * So in case of get action the buffer with written length = 0
+			 * is returned
+			 */
+		case OID_PNP_SET_POWER:
+		case OID_PNP_ADD_WAKE_UP_PATTERN:
+		case OID_PNP_REMOVE_WAKE_UP_PATTERN:
+			*pLen = 0;	
+			RetCode = SK_PNMI_ERR_OK;
+			break;
+
+		case OID_PNP_ENABLE_WAKE_UP:
+			RetCode = SkPowerGetEnableWakeUp(pAC, IoC, pBuf, pLen);
+			break;
+
+		default:
+			RetCode = SK_PNMI_ERR_GENERAL;
+			break;
+		}
+
+		return (RetCode);
+	}
+	
+	/*
+	 * From here SET or PRESET action. Check if the passed
+	 * buffer length is plausible.
+	 */
+	switch (Id) {
+	case OID_PNP_SET_POWER:
+	case OID_PNP_ENABLE_WAKE_UP:
+		if (*pLen < sizeof(SK_U32)) {
+
+			*pLen = sizeof(SK_U32);
+			return (SK_PNMI_ERR_TOO_SHORT);
+		}
+		if (*pLen != sizeof(SK_U32)) {
+
+			*pLen = 0;
+			return (SK_PNMI_ERR_BAD_VALUE);
+		}
+		break;
+
+	case OID_PNP_ADD_WAKE_UP_PATTERN:
+	case OID_PNP_REMOVE_WAKE_UP_PATTERN:
+		if (*pLen < sizeof(SK_PM_PACKET_PATTERN)) {
+
+			*pLen = 0;
+			return (SK_PNMI_ERR_BAD_VALUE);
+		}
+		break;
+
+    default:
+		*pLen = 0;
+		return (SK_PNMI_ERR_READ_ONLY);
+	}
+
+	/*
+	 * Perform preset or set
+	 */
+	
+	/* POWER module does not support PRESET action */
+	if (Action == SK_PNMI_PRESET) {
+		return (SK_PNMI_ERR_OK);
+	}
+
+	switch (Id) {
+	case OID_PNP_SET_POWER:
+		RetCode = SkPowerSetPower(pAC, IoC, pBuf, pLen);	
+		break;
+
+	case OID_PNP_ADD_WAKE_UP_PATTERN:
+		RetCode = SkPowerAddWakeUpPattern(pAC, IoC, pBuf, pLen);	
+		break;
+		
+	case OID_PNP_REMOVE_WAKE_UP_PATTERN:
+		RetCode = SkPowerRemoveWakeUpPattern(pAC, IoC, pBuf, pLen);	
+		break;
+		
+	case OID_PNP_ENABLE_WAKE_UP:
+		RetCode = SkPowerSetEnableWakeUp(pAC, IoC, pBuf, pLen);
+		break;
+		
+	default:
+		RetCode = SK_PNMI_ERR_GENERAL;
+	}
+	
+	return (RetCode);
+}
+#endif /* SK_POWER_MGMT */
+
+
+/*****************************************************************************
+ *
+ * Vct - OID handler function of  OIDs
+ *
+ * Description:
+ *	The code is simple. No description necessary.
+ *
+ * Returns:
+ *	SK_PNMI_ERR_OK           The request was performed successfully.
+ *	SK_PNMI_ERR_GENERAL      A general severe internal error occured.
+ *	SK_PNMI_ERR_TOO_SHORT    The passed buffer is too short to contain
+ *	                         the correct data (e.g. a 32bit value is
+ *	                         needed, but a 16 bit value was passed).
+ *	SK_PNMI_ERR_UNKNOWN_INST The requested instance of the OID doesn't
+ *                               exist (e.g. port instance 3 on a two port
+ *	                         adapter).
+ *	SK_PNMI_ERR_READ_ONLY	 Only the Get action is allowed.
+ *
+ */
+
+PNMI_STATIC int Vct(
+SK_AC *pAC,		/* Pointer to adapter context */
+SK_IOC IoC,		/* IO context handle */
+int Action,		/* Get/PreSet/Set action */
+SK_U32 Id,		/* Object ID that is to be processed */
+char *pBuf,		/* Buffer to which the mgmt data will be copied */
+unsigned int *pLen,	/* On call: buffer length. On return: used buffer */
+SK_U32 Instance,	/* Instance (-1,2..n) that is to be queried */
+unsigned int TableIndex, /* Index to the Id table */
+SK_U32 NetIndex)	/* NetIndex (0..n), in single net mode always zero */
+{
+	SK_GEPORT	*pPrt;
+	SK_PNMI_VCT	*pVctBackupData;
+	SK_U32		LogPortMax;
+	SK_U32		PhysPortMax;
+	SK_U32		PhysPortIndex;
+	SK_U32		Limit;
+	SK_U32		Offset;
+	SK_BOOL		Link;
+	SK_U32		RetCode = SK_PNMI_ERR_GENERAL;
+	int		i;
+	SK_EVPARA	Para;
+	SK_U32		CableLength;
+	
+	/*
+	 * Calculate the port indexes from the instance.
+	 */
+	PhysPortMax = pAC->GIni.GIMacsFound;
+	LogPortMax = SK_PNMI_PORT_PHYS2LOG(PhysPortMax);
+	
+	/* Dual net mode? */
+	if (pAC->Pnmi.DualNetActiveFlag == SK_TRUE) {
+		LogPortMax--;
+	}
+	
+	if ((Instance != (SK_U32) (-1))) {
+		/* Check instance range. */
+		if ((Instance < 2) || (Instance > LogPortMax)) {
+			*pLen = 0;
+			return (SK_PNMI_ERR_UNKNOWN_INST);
+		}
+		
+		if (pAC->Pnmi.DualNetActiveFlag == SK_TRUE) {
+			PhysPortIndex = NetIndex;
+		}
+		else {
+			PhysPortIndex = Instance - 2;
+		}
+		Limit = PhysPortIndex + 1;
+	}
+	else {	/*
+		 * Instance == (SK_U32) (-1), get all Instances of that OID.
+		 *
+		 * Not implemented yet. May be used in future releases.
+		 */
+		PhysPortIndex = 0;
+		Limit = PhysPortMax;
+	}
+	
+	pPrt = &pAC->GIni.GP[PhysPortIndex];
+	if (pPrt->PHWLinkUp) {
+		Link = SK_TRUE;
+	}
+	else {
+		Link = SK_FALSE;
+	}
+	
+	/* Check MAC type */
+	if (pPrt->PhyType != SK_PHY_MARV_COPPER) {
+		*pLen = 0;
+		return (SK_PNMI_ERR_GENERAL);
+	}
+	
+	/* Initialize backup data pointer. */
+	pVctBackupData = &pAC->Pnmi.VctBackup[PhysPortIndex];
+	
+	/* Check action type */
+	if (Action == SK_PNMI_GET) {
+		/* Check length */
+		switch (Id) {
+		
+		case OID_SKGE_VCT_GET:
+			if (*pLen < (Limit - PhysPortIndex) * sizeof(SK_PNMI_VCT)) {
+				*pLen = (Limit - PhysPortIndex) * sizeof(SK_PNMI_VCT);
+				return (SK_PNMI_ERR_TOO_SHORT);
+			}
+			break;
+		
+		case OID_SKGE_VCT_STATUS:
+			if (*pLen < (Limit - PhysPortIndex) * sizeof(SK_U8)) {
+				*pLen = (Limit - PhysPortIndex) * sizeof(SK_U8);
+				return (SK_PNMI_ERR_TOO_SHORT);
+			}
+			break;
+		
+		default:
+			*pLen = 0;
+			return (SK_PNMI_ERR_GENERAL);
+		}	
+		
+		/* Get value */
+		Offset = 0;
+		for (; PhysPortIndex < Limit; PhysPortIndex++) {
+			switch (Id) {
+			
+			case OID_SKGE_VCT_GET:
+				if ((Link == SK_FALSE) &&
+					(pAC->Pnmi.VctStatus[PhysPortIndex] & SK_PNMI_VCT_PENDING)) {
+					RetCode = SkGmCableDiagStatus(pAC, IoC, PhysPortIndex, SK_FALSE);
+					if (RetCode == 0) {
+						pAC->Pnmi.VctStatus[PhysPortIndex] &= ~SK_PNMI_VCT_PENDING;
+						pAC->Pnmi.VctStatus[PhysPortIndex] |=
+							(SK_PNMI_VCT_NEW_VCT_DATA | SK_PNMI_VCT_TEST_DONE);
+						
+						/* Copy results for later use to PNMI struct. */
+						for (i = 0; i < 4; i++)  {
+							if (pPrt->PMdiPairSts[i] == SK_PNMI_VCT_NORMAL_CABLE) {
+								if ((pPrt->PMdiPairLen[i] > 35) && (pPrt->PMdiPairLen[i] < 0xff)) {
+									pPrt->PMdiPairSts[i] = SK_PNMI_VCT_IMPEDANCE_MISMATCH;
+								}
+							}
+							if ((pPrt->PMdiPairLen[i] > 35) && (pPrt->PMdiPairLen[i] != 0xff)) {
+								CableLength = 1000 * (((175 * pPrt->PMdiPairLen[i]) / 210) - 28);
+							}
+							else {
+								CableLength = 0;
+							}
+							pVctBackupData->PMdiPairLen[i] = CableLength;
+							pVctBackupData->PMdiPairSts[i] = pPrt->PMdiPairSts[i];
+						}
+
+						Para.Para32[0] = PhysPortIndex;
+						Para.Para32[1] = -1;
+						SkEventQueue(pAC, SKGE_DRV, SK_DRV_PORT_RESET, Para);
+						SkEventDispatcher(pAC, IoC);
+					}
+					else {
+						; /* VCT test is running. */
+					}
+				}
+				
+				/* Get all results. */
+				CheckVctStatus(pAC, IoC, pBuf, Offset, PhysPortIndex);
+				Offset += sizeof(SK_U8);
+				*(pBuf + Offset) = pPrt->PCableLen;
+				Offset += sizeof(SK_U8);
+				for (i = 0; i < 4; i++)  {
+					SK_PNMI_STORE_U32((pBuf + Offset), pVctBackupData->PMdiPairLen[i]);
+					Offset += sizeof(SK_U32);
+				}
+				for (i = 0; i < 4; i++)  {
+					*(pBuf + Offset) = pVctBackupData->PMdiPairSts[i];
+					Offset += sizeof(SK_U8);
+				}
+				
+				RetCode = SK_PNMI_ERR_OK;
+				break;
+		
+			case OID_SKGE_VCT_STATUS:
+				CheckVctStatus(pAC, IoC, pBuf, Offset, PhysPortIndex);
+				Offset += sizeof(SK_U8);
+				RetCode = SK_PNMI_ERR_OK;
+				break;
+			
+			default:
+				*pLen = 0;
+				return (SK_PNMI_ERR_GENERAL);
+			}
+		} /* for */
+		*pLen = Offset;
+		return (RetCode);
+	
+	} /* if SK_PNMI_GET */
+	
+	/*
+	 * From here SET or PRESET action. Check if the passed
+	 * buffer length is plausible.
+	 */
+	
+	/* Check length */
+	switch (Id) {
+	case OID_SKGE_VCT_SET:
+		if (*pLen < (Limit - PhysPortIndex) * sizeof(SK_U32)) {
+			*pLen = (Limit - PhysPortIndex) * sizeof(SK_U32);
+			return (SK_PNMI_ERR_TOO_SHORT);
+		}
+		break;
+	
+	default:
+		*pLen = 0;
+		return (SK_PNMI_ERR_GENERAL);
+	}
+	
+	/*
+	 * Perform preset or set.
+	 */
+	
+	/* VCT does not support PRESET action. */
+	if (Action == SK_PNMI_PRESET) {
+		return (SK_PNMI_ERR_OK);
+	}
+	
+	Offset = 0;
+	for (; PhysPortIndex < Limit; PhysPortIndex++) {
+		switch (Id) {
+		case OID_SKGE_VCT_SET: /* Start VCT test. */
+			if (Link == SK_FALSE) {
+				SkGeStopPort(pAC, IoC, PhysPortIndex, SK_STOP_ALL, SK_SOFT_RST);
+				
+				RetCode = SkGmCableDiagStatus(pAC, IoC, PhysPortIndex, SK_TRUE);
+				if (RetCode == 0) { /* RetCode: 0 => Start! */
+					pAC->Pnmi.VctStatus[PhysPortIndex] |= SK_PNMI_VCT_PENDING;
+					pAC->Pnmi.VctStatus[PhysPortIndex] &= ~SK_PNMI_VCT_NEW_VCT_DATA;
+					pAC->Pnmi.VctStatus[PhysPortIndex] &= ~SK_PNMI_VCT_LINK;
+					
+					/*
+					 * Start VCT timer counter.
+					 */
+					SK_MEMSET((char *) &Para, 0, sizeof(Para));
+					Para.Para32[0] = PhysPortIndex;
+					Para.Para32[1] = -1;
+					SkTimerStart(pAC, IoC, &pAC->Pnmi.VctTimeout[PhysPortIndex].VctTimer,
+						4000000, SKGE_PNMI, SK_PNMI_EVT_VCT_RESET, Para);
+					SK_PNMI_STORE_U32((pBuf + Offset), RetCode);
+					RetCode = SK_PNMI_ERR_OK;
+				}
+				else { /* RetCode: 2 => Running! */
+					SK_PNMI_STORE_U32((pBuf + Offset), RetCode);
+					RetCode = SK_PNMI_ERR_OK;
+				}
+			}
+			else { /* RetCode: 4 => Link! */
+				RetCode = 4;
+				SK_PNMI_STORE_U32((pBuf + Offset), RetCode);
+				RetCode = SK_PNMI_ERR_OK;
+			}
+			Offset += sizeof(SK_U32);
+			break;
+	
+		default:
+			*pLen = 0;
+			return (SK_PNMI_ERR_GENERAL);
+		}
+	} /* for */
+	*pLen = Offset;
+	return (RetCode);
+
+} /* Vct */
+
+
+PNMI_STATIC void CheckVctStatus(
+SK_AC		*pAC,
+SK_IOC		IoC,
+char		*pBuf,
+SK_U32		Offset,
+SK_U32		PhysPortIndex)
+{
+	SK_GEPORT 	*pPrt;
+	SK_PNMI_VCT	*pVctData;
+	SK_U32		RetCode;
+	
+	pPrt = &pAC->GIni.GP[PhysPortIndex];
+	
+	pVctData = (SK_PNMI_VCT *) (pBuf + Offset);
+	pVctData->VctStatus = SK_PNMI_VCT_NONE;
+	
+	if (!pPrt->PHWLinkUp) {
+		
+		/* Was a VCT test ever made before? */
+		if (pAC->Pnmi.VctStatus[PhysPortIndex] & SK_PNMI_VCT_TEST_DONE) {
+			if ((pAC->Pnmi.VctStatus[PhysPortIndex] & SK_PNMI_VCT_LINK)) {
+				pVctData->VctStatus |= SK_PNMI_VCT_OLD_VCT_DATA;
+			}
+			else {
+				pVctData->VctStatus |= SK_PNMI_VCT_NEW_VCT_DATA;
+			}
+		}
+		
+		/* Check VCT test status. */
+		RetCode = SkGmCableDiagStatus(pAC,IoC, PhysPortIndex, SK_FALSE);
+		if (RetCode == 2) { /* VCT test is running. */
+			pVctData->VctStatus |= SK_PNMI_VCT_RUNNING;
+		}
+		else { /* VCT data was copied to pAC here. Check PENDING state. */
+			if (pAC->Pnmi.VctStatus[PhysPortIndex] & SK_PNMI_VCT_PENDING) {
+				pVctData->VctStatus |= SK_PNMI_VCT_NEW_VCT_DATA;
+			}
+		}
+		
+		if (pPrt->PCableLen != 0xff) { /* Old DSP value. */
+			pVctData->VctStatus |= SK_PNMI_VCT_OLD_DSP_DATA;
+		}
+	}
+	else {
+		
+		/* Was a VCT test ever made before? */
+		if (pAC->Pnmi.VctStatus[PhysPortIndex] & SK_PNMI_VCT_TEST_DONE) {
+			pVctData->VctStatus &= ~SK_PNMI_VCT_NEW_VCT_DATA;
+			pVctData->VctStatus |= SK_PNMI_VCT_OLD_VCT_DATA;
+		}
+		
+		/* DSP only valid in 100/1000 modes. */
+		if (pAC->GIni.GP[PhysPortIndex].PLinkSpeedUsed !=
+			SK_LSPEED_STAT_10MBPS) {	
+			pVctData->VctStatus |= SK_PNMI_VCT_NEW_DSP_DATA;
+		}
+	}
+} /* CheckVctStatus */
diff -ruN linux/drivers/net/sk98lin/skgesirq.c linuxn/drivers/net/sk98lin/skgesirq.c
--- linux/drivers/net/sk98lin/skgesirq.c	Wed Jul  4 20:50:39 2001
+++ linuxn/drivers/net/sk98lin/skgesirq.c	Tue May 20 12:17:40 2003
@@ -2,15 +2,16 @@
  *
  * Name:	skgesirq.c
  * Project:	GEnesis, PCI Gigabit Ethernet Adapter
- * Version:	$Revision: 1.65 $
- * Date:	$Date: 2001/02/23 13:41:51 $
+ * Version:	$Revision: 1.87 $
+ * Date:	$Date: 2003/04/28 09:18:31 $
  * Purpose:	Special IRQ module
  *
  ******************************************************************************/
 
 /******************************************************************************
  *
- *	(C)Copyright 1998-2000 SysKonnect GmbH.
+ *	(C)Copyright 1998-2002 SysKonnect.
+ *	(C)Copyright 2002-2003 Marvell.
  *
  *	This program is free software; you can redistribute it and/or modify
  *	it under the terms of the GNU General Public License as published by
@@ -26,6 +27,119 @@
  * History:
  *
  *	$Log: skgesirq.c,v $
+ *	Revision 1.87  2003/04/28 09:18:31  rschmidt
+ *	Added increment for GITimeStampCnt (high dword for
+ *	Time Stamp Timer counter), when overflow IRQ occurs.
+ *	Disabled HW Error IRQ on 32-bit Yukon if sensor IRQ occurs
+ *	by changing the common mask stored in GIValIrqMask.
+ *	Changed handling for HW Error IRQ in SkGeSirqIsr().
+ *	Added clearing of the software forced IRQ in SkGeSirqIsr().
+ *	Editorial changes.
+ *	
+ *	Revision 1.86  2003/04/09 13:03:24  rschmidt
+ *	Added workaround for configuration of GPHY's Auto-negotiation
+ *	advertisement register after link down event in SkPhyIsrGmac().
+ *	
+ *	Revision 1.85  2003/04/08 16:39:02  rschmidt
+ *	Changed handling for different PhyTypes for source code
+ *	portability to PXE, UNDI.
+ *	Editorial changes.
+ *	
+ *	Revision 1.84  2003/03/31 07:01:43  mkarl
+ *	Corrected Copyright.
+ *	Editorial changes.
+ *	
+ *	Revision 1.83  2003/02/05 15:10:59  rschmidt
+ *	Fixed setting of PLinkSpeedUsed in SkHWLinkUp() when
+ *	auto-negotiation is disabled.
+ *	Editorial changes.
+ *	
+ *	Revision 1.82  2003/01/29 13:34:33  rschmidt
+ *	Added some typecasts to avoid compiler warnings.
+ *	
+ *	Revision 1.81  2002/12/05 10:49:51  rschmidt
+ *	Fixed missing Link Down Event for fiber (Bug Id #10768)
+ *	Added reading of cable length when link is up
+ *	Removed testing of unused error bits in PHY ISR
+ *	Editorial changes.
+ *	
+ *	Revision 1.80  2002/11/12 17:15:21  rschmidt
+ *	Replaced SkPnmiGetVar() by ...MacStatistic() in SkMacParity().
+ *	Editorial changes.
+ *	
+ *	Revision 1.79  2002/10/14 15:14:51  rschmidt
+ *	Changed clearing of IS_M1_PAR_ERR (MAC 1 Parity Error) in
+ *	SkMacParity() depending on GIChipRev (HW-Bug #8).
+ *	Added error messages for GPHY Auto-Negotiation Error and
+ *	FIFO Overflow/Underrun in SkPhyIsrGmac().
+ *	Editorial changes.
+ *	
+ *	Revision 1.78  2002/10/10 15:54:29  mkarl
+ *	changes for PLinkSpeedUsed
+ *	
+ *	Revision 1.77  2002/09/12 08:58:51  rwahl
+ *	Retrieve counters needed for XMAC errata workarounds directly because
+ *	PNMI returns corrected counter values (e.g. #10620).
+ *	
+ *	Revision 1.76  2002/08/16 15:21:54  rschmidt
+ *	Replaced all if(GIChipId == CHIP_ID_GENESIS) with new entry GIGenesis.
+ *	Replaced wrong 1st para pAC with IoC in SK_IN/OUT macros.
+ *	Editorial changes.
+ *	
+ *	Revision 1.75  2002/08/12 13:50:47  rschmidt
+ *	Changed clearing of IS_M1_PAR_ERR (MAC 1 Parity Error) in
+ *	SkMacParity() by GMF_CLI_TX_FC instead of GMF_CLI_TX_PE (HW-Bug #8).
+ *	Added clearing of IS_IRQ_TIST_OV and IS_IRQ_SENSOR in SkGeHwErr().
+ *	Corrected handling of Link Up and Auto-Negotiation Over for GPHY.
+ *	in SkGePortCheckUpGmac().
+ *	Editorial changes.
+ *	
+ *	Revision 1.74  2002/08/08 16:17:04  rschmidt
+ *	Added PhyType check for SK_HWEV_SET_ROLE event (copper only)
+ *	Changed Link Up check reading PHY Specific Status (YUKON)
+ *	Editorial changes
+ *	
+ *	Revision 1.73  2002/07/15 18:36:53  rwahl
+ *	Editorial changes.
+ *	
+ *	Revision 1.72  2002/07/15 15:46:26  rschmidt
+ *	Added new event: SK_HWEV_SET_SPEED
+ *	Editorial changes
+ *	
+ *	Revision 1.71  2002/06/10 09:34:19  rschmidt
+ *	Editorial changes
+ *	
+ *	Revision 1.70  2002/06/05 08:29:18  rschmidt
+ *	SkXmRxTxEnable() replaced by SkMacRxTxEnable().
+ *	Editorial changes.
+ *	
+ *	Revision 1.69  2002/04/25 13:03:49  rschmidt
+ *	Changes for handling YUKON.
+ *	Use of #ifdef OTHER_PHY to eliminate code for unused Phy types.
+ *	Replaced all XMAC-access macros by functions: SkMacRxTxDisable(),
+ *	SkMacIrqDisable().
+ *	Added handling for GMAC FIFO in SkMacParity().
+ *	Replaced all SkXm...() functions with SkMac...() to handle also
+ *	YUKON's GMAC.
+ *	Macros for XMAC PHY access PHY_READ(), PHY_WRITE() replaced
+ *	by functions SkXmPhyRead(), SkXmPhyWrite().
+ *	Disabling all PHY interrupts moved to SkMacIrqDisable().
+ *	Added handling for GPHY IRQ in SkGeSirqIsr().
+ *	Removed status parameter from MAC IRQ handler SkMacIrq().
+ *	Added SkGePortCheckUpGmac(), SkPhyIsrGmac() for GMAC.
+ *	Editorial changes
+ *	
+ *	Revision 1.68  2002/02/26 15:24:53  rwahl
+ *	Fix: no link with manual configuration (#10673). The previous fix for
+ *	#10639 was removed. So for RLMT mode = CLS the RLMT may switch to
+ *	misconfigured port. It should not occur for the other RLMT modes.
+ *	
+ *	Revision 1.67  2001/11/20 09:19:58  rwahl
+ *	Reworked bugfix #10639 (no dependency to RLMT mode).
+ *	
+ *	Revision 1.66  2001/10/26 07:52:53  afischer
+ *	Port switching bug in `check local link` mode
+ *	
  *	Revision 1.65  2001/02/23 13:41:51  gklug
  *	fix: PHYS2INST should be used correctly for Dual Net operation
  *	chg: do no longer work with older PNMI
@@ -49,7 +163,7 @@
  *	Added workaround for half duplex hangup.
  *	
  *	Revision 1.58  2000/09/28 13:06:04  gklug
- *	fix: BCOM may NOT be touched if XMAC is in RESET state
+ *	fix: BCom may NOT be touched if XMAC is in RESET state
  *	
  *	Revision 1.57  2000/09/08 12:38:39  cgoos
  *	Added forgotten variable declaration.
@@ -254,49 +368,55 @@
  *
  *	In the ISR of the driver the bits for frame transmission complete and
  *	for receive complete are checked and handled by the driver itself.
- *	The bits of the slow path mask are checked after this and then the
- *	entry into the so-called "slow path" is prepared. It is an implemetors
+ *	The bits of the slow path mask are checked after that and then the
+ *	entry into the so-called "slow path" is prepared. It is an implementors
  *	decision whether this is executed directly or just scheduled by
- *	disabling the mask. In the interrupt service routine events may be
+ *	disabling the mask. In the interrupt service routine some events may be
  *	generated, so it would be a good idea to call the EventDispatcher
  *	right after this ISR.
  *
- *	The Interrupt service register of the adapter is NOT read by this
- *	module. SO if the drivers implemetor needs a while loop around the
- *	slow data paths Interrupt bits, he needs to call the SkGeIsr() for
+ *	The Interrupt source register of the adapter is NOT read by this module.
+ *  SO if the drivers implementor needs a while loop around the
+ *	slow data paths interrupt bits, he needs to call the SkGeSirqIsr() for
  *	each loop entered.
  *
- *	However, the XMAC Interrupt status registers are read in a while loop.
+ *	However, the MAC Interrupt status registers are read in a while loop.
  *
  */
- 
+
+#ifndef _lint
 static const char SysKonnectFileId[] =
-	"$Id: skgesirq.c,v 1.65 2001/02/23 13:41:51 gklug Exp $" ;
+	"@(#) $Id: skgesirq.c,v 1.87 2003/04/28 09:18:31 rschmidt Exp $ (C) Marvell.";
+#endif /* !_lint */
 
 #include "h/skdrv1st.h"		/* Driver Specific Definitions */
 #include "h/skgepnmi.h"		/* PNMI Definitions */
 #include "h/skrlmt.h"		/* RLMT Definitions */
-#include "h/skdrv2nd.h"		/* Adapter Control- and Driver specific Def. */
+#include "h/skdrv2nd.h"		/* Adapter Control and Driver specific Def. */
 
 /* local function prototypes */
 static int	SkGePortCheckUpXmac(SK_AC*, SK_IOC, int);
 static int	SkGePortCheckUpBcom(SK_AC*, SK_IOC, int);
+static int	SkGePortCheckUpGmac(SK_AC*, SK_IOC, int);
+static void	SkPhyIsrBcom(SK_AC*, SK_IOC, int, SK_U16);
+static void	SkPhyIsrGmac(SK_AC*, SK_IOC, int, SK_U16);
+#ifdef OTHER_PHY
 static int	SkGePortCheckUpLone(SK_AC*, SK_IOC, int);
 static int	SkGePortCheckUpNat(SK_AC*, SK_IOC, int);
-static void	SkPhyIsrBcom(SK_AC*, SK_IOC, int, SK_U16);
 static void	SkPhyIsrLone(SK_AC*, SK_IOC, int, SK_U16);
+#endif /* OTHER_PHY */
 
 /*
- * Define an array of RX counter which are checked
- * in AutoSense mode to check whether a link is not able to autonegotiate.
+ * array of Rx counter from XMAC which are checked
+ * in AutoSense mode to check whether a link is not able to auto-negotiate.
  */
-static const SK_U32 SkGeRxOids[]= {
-	OID_SKGE_STAT_RX_64,
-	OID_SKGE_STAT_RX_127,
-	OID_SKGE_STAT_RX_255,
-	OID_SKGE_STAT_RX_511,
-	OID_SKGE_STAT_RX_1023,
-	OID_SKGE_STAT_RX_MAX,
+static const SK_U16 SkGeRxRegs[]= {
+	XM_RXF_64B,
+	XM_RXF_127B,
+	XM_RXF_255B,
+	XM_RXF_511B,
+	XM_RXF_1023B,
+	XM_RXF_MAX_SZ
 } ;
 
 #ifdef __C2MAN__
@@ -310,7 +430,7 @@
 {}
 #endif
 
-/* Define return codes of SkGePortCheckUp and CheckShort. */
+/* Define return codes of SkGePortCheckUp and CheckShort */
 #define	SK_HW_PS_NONE		0	/* No action needed */
 #define	SK_HW_PS_RESTART	1	/* Restart needed */
 #define	SK_HW_PS_LINK		2	/* Link Up actions needed */
@@ -319,18 +439,16 @@
  *
  *	SkHWInitDefSense() - Default Autosensing mode initialization
  *
- * Description:
- *	This function handles the Hardware link down signal
- *
- * Note:
+ * Description: sets the PLinkMode for HWInit
  *
+ * Returns: N/A
  */
-void	SkHWInitDefSense(
+static void SkHWInitDefSense(
 SK_AC	*pAC,	/* adapter context */
 SK_IOC	IoC,	/* IO context */
-int	Port)		/* Port Index (MAC_1 + n) */
+int		Port)	/* Port Index (MAC_1 + n) */
 {
-	SK_GEPORT	*pPrt;
+	SK_GEPORT	*pPrt;		/* GIni Port struct pointer */
 
 	pPrt = &pAC->GIni.GP[Port];
 
@@ -343,8 +461,7 @@
 
 	SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_IRQ,
 		("AutoSensing: First mode %d on Port %d\n",
-		(int)SK_LMODE_AUTOFULL,
-		 Port));
+		(int)SK_LMODE_AUTOFULL, Port));
 
 	pPrt->PLinkMode = SK_LMODE_AUTOFULL;
 
@@ -354,20 +471,19 @@
 
 /******************************************************************************
  *
- *	SkHWSenseGetNext() - GetNextAutosensing Mode
+ *	SkHWSenseGetNext() - Get Next Autosensing Mode
  *
- * Description:
- *	This function handles the AutoSensing
+ * Description: gets the appropriate next mode
  *
  * Note:
  *
  */
-SK_U8	SkHWSenseGetNext(
+static SK_U8 SkHWSenseGetNext(
 SK_AC	*pAC,	/* adapter context */
 SK_IOC	IoC,	/* IO context */
-int	Port)		/* Port Index (MAC_1 + n) */
+int		Port)	/* Port Index (MAC_1 + n) */
 {
-	SK_GEPORT	*pPrt;
+	SK_GEPORT	*pPrt;		/* GIni Port struct pointer */
 
 	pPrt = &pAC->GIni.GP[Port];
 
@@ -375,16 +491,16 @@
 
 	if (pPrt->PLinkModeConf != SK_LMODE_AUTOSENSE) {
 		/* Leave all as configured */
-		return (pPrt->PLinkModeConf);
+		return(pPrt->PLinkModeConf);
 	}
 
 	if (pPrt->PLinkMode == SK_LMODE_AUTOFULL) {
 		/* Return next mode AUTOBOTH */
-		return (SK_LMODE_AUTOBOTH);
+		return(SK_LMODE_AUTOBOTH);
 	}
 
 	/* Return default autofull */
-	return (SK_LMODE_AUTOFULL);
+	return(SK_LMODE_AUTOFULL);
 }	/* SkHWSenseGetNext */
 
 
@@ -392,19 +508,17 @@
  *
  *	SkHWSenseSetNext() - Autosensing Set next mode
  *
- * Description:
- *	This function sets the appropriate next mode.
- *
- * Note:
+ * Description:	sets the appropriate next mode
  *
+ * Returns: N/A
  */
-void	SkHWSenseSetNext(
+static void SkHWSenseSetNext(
 SK_AC	*pAC,		/* adapter context */
 SK_IOC	IoC,		/* IO context */
-int	Port,			/* Port Index (MAC_1 + n) */
+int		Port,		/* Port Index (MAC_1 + n) */
 SK_U8	NewMode)	/* New Mode to be written in sense mode */
 {
-	SK_GEPORT	*pPrt;
+	SK_GEPORT	*pPrt;		/* GIni Port struct pointer */
 
 	pPrt = &pAC->GIni.GP[Port];
 
@@ -415,7 +529,9 @@
 	}
 
 	SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_IRQ,
-		("AutoSensing: next mode %d on Port %d\n", (int)NewMode, Port));
+		("AutoSensing: next mode %d on Port %d\n",
+		(int)NewMode, Port));
+
 	pPrt->PLinkMode = NewMode;
 
 	return;
@@ -426,79 +542,51 @@
  *
  *	SkHWLinkDown() - Link Down handling
  *
- * Description:
- *	This function handles the Hardware link down signal
- *
- * Note:
+ * Description: handles the hardware link down signal
  *
+ * Returns: N/A
  */
-void	SkHWLinkDown(
+void SkHWLinkDown(
 SK_AC	*pAC,		/* adapter context */
 SK_IOC	IoC,		/* IO context */
 int		Port)		/* Port Index (MAC_1 + n) */
 {
-	SK_GEPORT	*pPrt;
-	SK_U16		Word;
+	SK_GEPORT	*pPrt;		/* GIni Port struct pointer */
 
 	pPrt = &pAC->GIni.GP[Port];
 
-	/* Disable all XMAC interrupts. */
-	XM_OUT16(IoC, Port, XM_IMSK, 0xffff);
+	/* Disable all MAC interrupts */
+	SkMacIrqDisable(pAC, IoC, Port);
 
-	/* Disable Receiver and Transmitter. */
-	XM_IN16(IoC, Port, XM_MMU_CMD, &Word);
-	XM_OUT16(IoC, Port, XM_MMU_CMD, Word & ~(XM_MMU_ENA_RX | XM_MMU_ENA_TX));
+	/* Disable Receiver and Transmitter */
+	SkMacRxTxDisable(pAC, IoC, Port);
 	
-	/* Disable all PHY interrupts. */
-	switch (pPrt->PhyType) {
-		case SK_PHY_BCOM:
-			/* Make sure that PHY is initialized. */
-			if (pAC->GIni.GP[Port].PState) {
-				/* NOT allowed if BCOM is in RESET state */
-				/* Workaround BCOM Errata (#10523) all BCom. */
-				/* Disable Power Management if link is down. */
-				PHY_READ(IoC, pPrt, Port, PHY_BCOM_AUX_CTRL, &Word);
-				PHY_WRITE(IoC, pPrt, Port, PHY_BCOM_AUX_CTRL,
-					Word | PHY_B_AC_DIS_PM);
-				PHY_WRITE(IoC, pPrt, Port, PHY_BCOM_INT_MASK, 0xffff);
-			}
-			break;
-		case SK_PHY_LONE:
-			PHY_WRITE(IoC, pPrt, Port, PHY_LONE_INT_ENAB, 0x0);
-			break;
-		case SK_PHY_NAT:
-			/* todo: National
-			PHY_WRITE(IoC, pPrt, Port, PHY_NAT_INT_MASK, 0xffff); */
-			break;
-	}
-
-	/* Init default sense mode. */
+	/* Init default sense mode */
 	SkHWInitDefSense(pAC, IoC, Port);
 
-	if (!pPrt->PHWLinkUp) {
+	if (pPrt->PHWLinkUp == SK_FALSE) {
 		return;
-	} 
+	}
 
-	SK_DBG_MSG(pAC,SK_DBGMOD_HWM,SK_DBGCAT_IRQ,
+	SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_IRQ,
 		("Link down Port %d\n", Port));
 
-	/* Set Link to DOWN. */
+	/* Set Link to DOWN */
 	pPrt->PHWLinkUp = SK_FALSE;
 
 	/* Reset Port stati */
 	pPrt->PLinkModeStatus = SK_LMODE_STAT_UNKNOWN;
 	pPrt->PFlowCtrlStatus = SK_FLOW_STAT_NONE;
+	pPrt->PLinkSpeedUsed = SK_LSPEED_STAT_INDETERMINATED;
 
-	/*
-	 * Reinit Phy especially when the AutoSense default is set now.
-	 */
-	SkXmInitPhy(pAC, IoC, Port, SK_FALSE);
+	/* Re-init Phy especially when the AutoSense default is set now */
+	SkMacInitPhy(pAC, IoC, Port, SK_FALSE);
 
-	/* GP0: used for workaround of Rev. C Errata 2. */
+	/* GP0: used for workaround of Rev. C Errata 2 */
 
-	/* Do NOT signal to RLMT. */
+	/* Do NOT signal to RLMT */
 
-	/* Do NOT start the timer here. */
+	/* Do NOT start the timer here */
 }	/* SkHWLinkDown */
 
 
@@ -506,25 +594,23 @@
  *
  *	SkHWLinkUp() - Link Up handling
  *
- * Description:
- *	This function handles the Hardware link up signal
- *
- * Note:
+ * Description: handles the hardware link up signal
  *
+ * Returns: N/A
  */
-void	SkHWLinkUp(
+void SkHWLinkUp(
 SK_AC	*pAC,	/* adapter context */
 SK_IOC	IoC,	/* IO context */
-int	Port)		/* Port Index (MAC_1 + n) */
+int		Port)	/* Port Index (MAC_1 + n) */
 {
-	SK_GEPORT	*pPrt;
+	SK_GEPORT	*pPrt;		/* GIni Port struct pointer */
 
 	pPrt = &pAC->GIni.GP[Port];
 
 	if (pPrt->PHWLinkUp) {
 		/* We do NOT need to proceed on active link */
 		return;
-	} 
+	}
 
 	pPrt->PHWLinkUp = SK_TRUE;
 	pPrt->PAutoNegFail = SK_FALSE;
@@ -533,11 +619,24 @@
 	if (pPrt->PLinkMode != SK_LMODE_AUTOHALF &&
 	    pPrt->PLinkMode != SK_LMODE_AUTOFULL &&
 	    pPrt->PLinkMode != SK_LMODE_AUTOBOTH) {
-		/* Link is up and no Autonegotiation should be done */
+		/* Link is up and no Auto-negotiation should be done */
 
-		/* Configure Port */
+		/* Link speed should be the configured one */
+		switch (pPrt->PLinkSpeed) {
+		case SK_LSPEED_AUTO:
+			/* default is 1000 Mbps */
+		case SK_LSPEED_1000MBPS:
+			pPrt->PLinkSpeedUsed = SK_LSPEED_STAT_1000MBPS;
+			break;
+		case SK_LSPEED_100MBPS:
+			pPrt->PLinkSpeedUsed = SK_LSPEED_STAT_100MBPS;
+			break;
+		case SK_LSPEED_10MBPS:
+			pPrt->PLinkSpeedUsed = SK_LSPEED_STAT_10MBPS;
+			break;
+		}
 
-		/* Set Link Mode */
+		/* Set Link Mode Status */
 		if (pPrt->PLinkMode == SK_LMODE_FULL) {
 			pPrt->PLinkModeStatus = SK_LMODE_STAT_FULL;
 		}
@@ -545,46 +644,54 @@
 			pPrt->PLinkModeStatus = SK_LMODE_STAT_HALF;
 		}
 
-		/* No flow control without autonegotiation */
+		/* No flow control without auto-negotiation */
 		pPrt->PFlowCtrlStatus = SK_FLOW_STAT_NONE;
 
-		/* RX/TX enable */
-		SkXmRxTxEnable(pAC, IoC, Port);
+		/* enable Rx/Tx */
+		SkMacRxTxEnable(pAC, IoC, Port);
 	}
 }	/* SkHWLinkUp */
 
 
 /******************************************************************************
  *
- * SkMacParity	- does everything to handle MAC parity errors correctly
+ *	SkMacParity() - MAC parity workaround
+ *
+ * Description: handles MAC parity errors correctly
  *
+ * Returns: N/A
  */
-static	void	SkMacParity(
+static void SkMacParity(
 SK_AC	*pAC,	/* adapter context */
 SK_IOC	IoC,	/* IO context */
-int	Port)		/* Port Index of the port failed */
+int		Port)	/* Port Index of the port failed */
 {
 	SK_EVPARA	Para;
 	SK_GEPORT	*pPrt;		/* GIni Port struct pointer */
-	SK_U64		TxMax;		/* TxMax Counter */
-	unsigned	Len;
+	SK_U32		TxMax;		/* TxMax Counter */
 
 	pPrt = &pAC->GIni.GP[Port];
 
-	/* Clear IRQ */
-	SK_OUT16(IoC, MR_ADDR(Port,TX_MFF_CTRL1), MFF_CLR_PERR);
+	/* Clear IRQ Tx Parity Error */
+	if (pAC->GIni.GIGenesis) {
+		SK_OUT16(IoC, MR_ADDR(Port, TX_MFF_CTRL1), MFF_CLR_PERR);
+	}
+	else {
+		/* HW-Bug #8: cleared by GMF_CLI_TX_FC instead of GMF_CLI_TX_PE */
+		SK_OUT8(IoC, MR_ADDR(Port, TX_GMF_CTRL_T),
+			(SK_U8)((pAC->GIni.GIChipRev == 0) ? GMF_CLI_TX_FC : GMF_CLI_TX_PE));
+	}
 
 	if (pPrt->PCheckPar) {
 		if (Port == MAC_1) {
-			SK_ERR_LOG(pAC, SK_ERRCL_HW , SKERR_SIRQ_E016,
-				SKERR_SIRQ_E016MSG);
+			SK_ERR_LOG(pAC, SK_ERRCL_HW, SKERR_SIRQ_E016, SKERR_SIRQ_E016MSG);
 		}
 		else {
-			SK_ERR_LOG(pAC, SK_ERRCL_HW , SKERR_SIRQ_E017,
-				SKERR_SIRQ_E017MSG);
+			SK_ERR_LOG(pAC, SK_ERRCL_HW, SKERR_SIRQ_E017, SKERR_SIRQ_E017MSG);
 		}
 		Para.Para64 = Port;
 		SkEventQueue(pAC, SKGE_DRV, SK_DRV_PORT_FAIL, Para);
+		
 		Para.Para32[0] = Port;
 		SkEventQueue(pAC, SKGE_RLMT, SK_RLMT_LINK_DOWN, Para);
 
@@ -592,11 +699,16 @@
 	}
 
 	/* Check whether frames with a size of 1k were sent */
-	Len = sizeof(SK_U64);
-	SkPnmiGetVar(pAC, IoC, OID_SKGE_STAT_TX_MAX, (char *)&TxMax,
-		&Len, (SK_U32)SK_PNMI_PORT_PHYS2INST(pAC, Port),
-		pAC->Rlmt.Port[Port].Net->NetNumber);
-
+	if (pAC->GIni.GIGenesis) {
+		/* Snap statistic counters */
+		(void)SkXmUpdateStats(pAC, IoC, Port);
+		
+		(void)SkXmMacStatistic(pAC, IoC, Port, XM_TXF_MAX_SZ, &TxMax);
+	}
+	else {
+		(void)SkGmMacStatistic(pAC, IoC, Port, GM_TXF_1518B, &TxMax);
+	}
+	
 	if (TxMax > 0) {
 		/* From now on check the parity */
 		pPrt->PCheckPar = SK_TRUE;
@@ -606,13 +718,13 @@
 
 /******************************************************************************
  *
- *	Hardware Error service routine
+ *	SkGeHwErr() - Hardware Error service routine
  *
- * Description:
+ * Description: handles all HW Error interrupts
  *
- * Notes:
+ * Returns: N/A
  */
-static	void	SkGeHwErr(
+static void SkGeHwErr(
 SK_AC	*pAC,		/* adapter context */
 SK_IOC	IoC,		/* IO context */
 SK_U32	HwStatus)	/* Interrupt status word */
@@ -620,17 +732,19 @@
 	SK_EVPARA	Para;
 	SK_U16		Word;
 
-	if ((HwStatus & IS_IRQ_MST_ERR) || (HwStatus & IS_IRQ_STAT)) {
-		if (HwStatus & IS_IRQ_STAT) {
-			SK_ERR_LOG(pAC, SK_ERRCL_HW , SKERR_SIRQ_E013, SKERR_SIRQ_E013MSG);
+	if ((HwStatus & (IS_IRQ_MST_ERR | IS_IRQ_STAT)) != 0) {
+		/* PCI Errors occured */
+		if ((HwStatus & IS_IRQ_STAT) != 0) {
+			SK_ERR_LOG(pAC, SK_ERRCL_HW, SKERR_SIRQ_E013, SKERR_SIRQ_E013MSG);
 		}
 		else {
-			SK_ERR_LOG(pAC, SK_ERRCL_HW , SKERR_SIRQ_E012, SKERR_SIRQ_E012MSG);
+			SK_ERR_LOG(pAC, SK_ERRCL_HW, SKERR_SIRQ_E012, SKERR_SIRQ_E012MSG);
 		}
 
 		/* Reset all bits in the PCI STATUS register */
-		SK_OUT8(IoC, B2_TST_CTRL1, TST_CFG_WRITE_ON);
 		SK_IN16(IoC, PCI_C(PCI_STATUS), &Word);
+		
+		SK_OUT8(IoC, B2_TST_CTRL1, TST_CFG_WRITE_ON);
 		SK_OUT16(IoC, PCI_C(PCI_STATUS), Word | PCI_ERRBITS);
 		SK_OUT8(IoC, B2_TST_CTRL1, TST_CFG_WRITE_OFF);
 
@@ -638,70 +752,93 @@
 		SkEventQueue(pAC, SKGE_DRV, SK_DRV_ADAP_FAIL, Para);
 	}
 
-	if (HwStatus & IS_NO_STAT_M1) {
-		/* Ignore it */
-		/* This situation is also indicated in the descriptor */
-		SK_OUT16(IoC, MR_ADDR(MAC_1,RX_MFF_CTRL1), MFF_CLR_INSTAT);
-	}
-
-	if (HwStatus & IS_NO_STAT_M2) {
-		/* Ignore it */
-		/* This situation is also indicated in the descriptor */
-		SK_OUT16(IoC, MR_ADDR(MAC_2,RX_MFF_CTRL1), MFF_CLR_INSTAT);
-	}
-
-	if (HwStatus & IS_NO_TIST_M1) {
-		/* Ignore it */
-		/* This situation is also indicated in the descriptor */
-		SK_OUT16(IoC, MR_ADDR(MAC_1,RX_MFF_CTRL1), MFF_CLR_INTIST);
-	}
+	if (pAC->GIni.GIGenesis) {
 
-	if (HwStatus & IS_NO_TIST_M2) {
-		/* Ignore it */
-		/* This situation is also indicated in the descriptor */
-		SK_OUT16(IoC, MR_ADDR(MAC_2,RX_MFF_CTRL1), MFF_CLR_INTIST);
+		if ((HwStatus & IS_NO_STAT_M1) != 0) {
+			/* Ignore it */
+			/* This situation is also indicated in the descriptor */
+			SK_OUT16(IoC, MR_ADDR(MAC_1, RX_MFF_CTRL1), MFF_CLR_INSTAT);
+		}
+	
+		if ((HwStatus & IS_NO_STAT_M2) != 0) {
+			/* Ignore it */
+			/* This situation is also indicated in the descriptor */
+			SK_OUT16(IoC, MR_ADDR(MAC_2, RX_MFF_CTRL1), MFF_CLR_INSTAT);
+		}
+	
+		if ((HwStatus & IS_NO_TIST_M1) != 0) {
+			/* Ignore it */
+			/* This situation is also indicated in the descriptor */
+			SK_OUT16(IoC, MR_ADDR(MAC_1, RX_MFF_CTRL1), MFF_CLR_INTIST);
+		}
+	
+		if ((HwStatus & IS_NO_TIST_M2) != 0) {
+			/* Ignore it */
+			/* This situation is also indicated in the descriptor */
+			SK_OUT16(IoC, MR_ADDR(MAC_2, RX_MFF_CTRL1), MFF_CLR_INTIST);
+		}
+	}
+	else {	/* YUKON */
+		/* This is necessary only for Rx timing measurements */
+		if ((HwStatus & IS_IRQ_TIST_OV) != 0) {
+			/* increment Time Stamp Timer counter (high) */
+			pAC->GIni.GITimeStampCnt++;
+
+			/* Clear Time Stamp Timer IRQ */
+			SK_OUT8(IoC, GMAC_TI_ST_CTRL, (SK_U8)GMT_ST_CLR_IRQ);
+		}
+
+		if ((HwStatus & IS_IRQ_SENSOR) != 0) {
+			/* no sensors on 32-bit Yukon */
+			if (pAC->GIni.GIYukon32Bit) {
+				/* disable HW Error IRQ */
+				pAC->GIni.GIValIrqMask &= ~IS_HW_ERR;
+			}
+		}
 	}
 
-	if (HwStatus & IS_RAM_RD_PAR) {
+	if ((HwStatus & IS_RAM_RD_PAR) != 0) {
 		SK_OUT16(IoC, B3_RI_CTRL, RI_CLR_RD_PERR);
-		SK_ERR_LOG(pAC, SK_ERRCL_HW , SKERR_SIRQ_E014, SKERR_SIRQ_E014MSG);
+		SK_ERR_LOG(pAC, SK_ERRCL_HW, SKERR_SIRQ_E014, SKERR_SIRQ_E014MSG);
 		Para.Para64 = 0;
 		SkEventQueue(pAC, SKGE_DRV, SK_DRV_ADAP_FAIL, Para);
 	}
 
-	if (HwStatus & IS_RAM_WR_PAR) {
+	if ((HwStatus & IS_RAM_WR_PAR) != 0) {
 		SK_OUT16(IoC, B3_RI_CTRL, RI_CLR_WR_PERR);
-		SK_ERR_LOG(pAC, SK_ERRCL_HW , SKERR_SIRQ_E015, SKERR_SIRQ_E015MSG);
+		SK_ERR_LOG(pAC, SK_ERRCL_HW, SKERR_SIRQ_E015, SKERR_SIRQ_E015MSG);
 		Para.Para64 = 0;
 		SkEventQueue(pAC, SKGE_DRV, SK_DRV_ADAP_FAIL, Para);
 	}
 
-	if (HwStatus & IS_M1_PAR_ERR) {
+	if ((HwStatus & IS_M1_PAR_ERR) != 0) {
 		SkMacParity(pAC, IoC, MAC_1);
 	}
 
-	if (HwStatus & IS_M2_PAR_ERR) {
+	if ((HwStatus & IS_M2_PAR_ERR) != 0) {
 		SkMacParity(pAC, IoC, MAC_2);
 	}
 
-	if (HwStatus & IS_R1_PAR_ERR) {
+	if ((HwStatus & IS_R1_PAR_ERR) != 0) {
 		/* Clear IRQ */
 		SK_OUT32(IoC, B0_R1_CSR, CSR_IRQ_CL_P);
 
-		SK_ERR_LOG(pAC, SK_ERRCL_HW , SKERR_SIRQ_E018, SKERR_SIRQ_E018MSG);
+		SK_ERR_LOG(pAC, SK_ERRCL_HW, SKERR_SIRQ_E018, SKERR_SIRQ_E018MSG);
 		Para.Para64 = MAC_1;
 		SkEventQueue(pAC, SKGE_DRV, SK_DRV_PORT_FAIL, Para);
+		
 		Para.Para32[0] = MAC_1;
 		SkEventQueue(pAC, SKGE_RLMT, SK_RLMT_LINK_DOWN, Para);
 	}
 
-	if (HwStatus & IS_R2_PAR_ERR) {
+	if ((HwStatus & IS_R2_PAR_ERR) != 0) {
 		/* Clear IRQ */
 		SK_OUT32(IoC, B0_R2_CSR, CSR_IRQ_CL_P);
 
-		SK_ERR_LOG(pAC, SK_ERRCL_HW , SKERR_SIRQ_E019, SKERR_SIRQ_E019MSG);
+		SK_ERR_LOG(pAC, SK_ERRCL_HW, SKERR_SIRQ_E019, SKERR_SIRQ_E019MSG);
 		Para.Para64 = MAC_2;
 		SkEventQueue(pAC, SKGE_DRV, SK_DRV_PORT_FAIL, Para);
+		
 		Para.Para32[0] = MAC_2;
 		SkEventQueue(pAC, SKGE_RLMT, SK_RLMT_LINK_DOWN, Para);
 	}
@@ -710,132 +847,127 @@
 
 /******************************************************************************
  *
- *	Interrupt service routine
+ *	SkGeSirqIsr() - Special Interrupt Service Routine
  *
- * Description:
+ * Description: handles all non data transfer specific interrupts (slow path)
  *
- * Notes:
+ * Returns: N/A
  */
-void	SkGeSirqIsr(
+void SkGeSirqIsr(
 SK_AC	*pAC,		/* adapter context */
 SK_IOC	IoC,		/* IO context */
 SK_U32	Istatus)	/* Interrupt status word */
 {
 	SK_EVPARA	Para;
-	SK_U32		RegVal32;	/* Read register Value */
-	SK_U16		XmIsr;
+	SK_U32		RegVal32;	/* Read register value */
+	SK_GEPORT	*pPrt;		/* GIni Port struct pointer */
+	unsigned 	Len;
+	SK_U64		Octets;
+	SK_U16 		PhyInt;
+	int			i;
 
-	if (Istatus & IS_HW_ERR) {
+	if (((Istatus & IS_HW_ERR) & pAC->GIni.GIValIrqMask) != 0) {
+		/* read the HW Error Interrupt source */
 		SK_IN32(IoC, B0_HWE_ISRC, &RegVal32);
+		
 		SkGeHwErr(pAC, IoC, RegVal32);
 	}
 
 	/*
 	 * Packet Timeout interrupts
 	 */
-	/* Check whether XMACs are correctly initialized */
-	if ((Istatus & (IS_PA_TO_RX1 | IS_PA_TO_TX1)) &&
-		!pAC->GIni.GP[MAC_1].PState) {
-		/* XMAC was not initialized but Packet timeout occured */
+	/* Check whether MACs are correctly initialized */
+	if (((Istatus & (IS_PA_TO_RX1 | IS_PA_TO_TX1)) != 0) &&
+		pAC->GIni.GP[MAC_1].PState == SK_PRT_RESET) {
+		/* MAC 1 was not initialized but Packet timeout occured */
 		SK_ERR_LOG(pAC, SK_ERRCL_SW | SK_ERRCL_INIT, SKERR_SIRQ_E004,
 			SKERR_SIRQ_E004MSG);
 	}
 
-	if ((Istatus & (IS_PA_TO_RX2 | IS_PA_TO_TX2)) &&
-	    !pAC->GIni.GP[MAC_2].PState) {
-		/* XMAC was not initialized but Packet timeout occured */
+	if (((Istatus & (IS_PA_TO_RX2 | IS_PA_TO_TX2)) != 0) &&
+	    pAC->GIni.GP[MAC_2].PState == SK_PRT_RESET) {
+		/* MAC 2 was not initialized but Packet timeout occured */
 		SK_ERR_LOG(pAC, SK_ERRCL_SW | SK_ERRCL_INIT, SKERR_SIRQ_E005,
 			SKERR_SIRQ_E005MSG);
 	}
 
-	if (Istatus & IS_PA_TO_RX1) {
+	if ((Istatus & IS_PA_TO_RX1) != 0) {
 		/* Means network is filling us up */
 		SK_ERR_LOG(pAC, SK_ERRCL_HW | SK_ERRCL_INIT, SKERR_SIRQ_E002,
 			SKERR_SIRQ_E002MSG);
 		SK_OUT16(IoC, B3_PA_CTRL, PA_CLR_TO_RX1);
 	}
 
-	if (Istatus & IS_PA_TO_RX2) {
+	if ((Istatus & IS_PA_TO_RX2) != 0) {
 		/* Means network is filling us up */
 		SK_ERR_LOG(pAC, SK_ERRCL_HW | SK_ERRCL_INIT, SKERR_SIRQ_E003,
 			SKERR_SIRQ_E003MSG);
 		SK_OUT16(IoC, B3_PA_CTRL, PA_CLR_TO_RX2);
 	}
 
-	if (Istatus & IS_PA_TO_TX1) {
-		unsigned int	Len;
-		SK_U64		Octets;
-		SK_GEPORT	*pPrt = &pAC->GIni.GP[0];
+	if ((Istatus & IS_PA_TO_TX1) != 0) {
+		
+		pPrt = &pAC->GIni.GP[0];
 
 		/* May be a normal situation in a server with a slow network */
 		SK_OUT16(IoC, B3_PA_CTRL, PA_CLR_TO_TX1);
 
 		/*
-		 * workaround: if in half duplex mode, check for tx hangup.
+		 * workaround: if in half duplex mode, check for Tx hangup.
 		 * Read number of TX'ed bytes, wait for 10 ms, then compare
-		 * the number with current value. If nothing changed, we
-		 * assume that tx is hanging and do a FIFO flush (see event
-		 * routine).
+		 * the number with current value. If nothing changed, we assume
+		 * that Tx is hanging and do a FIFO flush (see event routine).
 		 */
-		if ((pPrt->PLinkModeStatus == SK_LMODE_STAT_HALF || 
+		if ((pPrt->PLinkModeStatus == SK_LMODE_STAT_HALF ||
 		    pPrt->PLinkModeStatus == SK_LMODE_STAT_AUTOHALF) &&
 		    !pPrt->HalfDupTimerActive) {
-			/* 
+			/*
 			 * many more pack. arb. timeouts may come in between,
 			 * we ignore those
 			 */
 			pPrt->HalfDupTimerActive = SK_TRUE;
 
 			Len = sizeof(SK_U64);
-			SkPnmiGetVar(pAC, IoC, OID_SKGE_STAT_TX_OCTETS, (char *) &Octets,
+			SkPnmiGetVar(pAC, IoC, OID_SKGE_STAT_TX_OCTETS, (char *)&Octets,
 				&Len, (SK_U32) SK_PNMI_PORT_PHYS2INST(pAC, 0),
 				pAC->Rlmt.Port[0].Net->NetNumber);
+			
 			pPrt->LastOctets = Octets;
+			
 			Para.Para32[0] = 0;
-			SkTimerStart(pAC, IoC,
-				&pPrt->HalfDupChkTimer,
-				SK_HALFDUP_CHK_TIME,
-				SKGE_HWAC,
-				SK_HWEV_HALFDUP_CHK,
-				Para);
+			SkTimerStart(pAC, IoC, &pPrt->HalfDupChkTimer, SK_HALFDUP_CHK_TIME,
+				SKGE_HWAC, SK_HWEV_HALFDUP_CHK, Para);
 		}
 	}
 
-	if (Istatus & IS_PA_TO_TX2) {
-		unsigned int	Len;
-		SK_U64		Octets;
-		SK_GEPORT	*pPrt = &pAC->GIni.GP[1];
+	if ((Istatus & IS_PA_TO_TX2) != 0) {
+		
+		pPrt = &pAC->GIni.GP[1];
 
 		/* May be a normal situation in a server with a slow network */
 		SK_OUT16(IoC, B3_PA_CTRL, PA_CLR_TO_TX2);
 
-		/*
-		 * workaround: see above
-		 */
-		if ((pPrt->PLinkModeStatus == SK_LMODE_STAT_HALF || 
-		    pPrt->PLinkModeStatus == SK_LMODE_STAT_AUTOHALF) &&
+		/* workaround: see above */
+		if ((pPrt->PLinkModeStatus == SK_LMODE_STAT_HALF ||
+		     pPrt->PLinkModeStatus == SK_LMODE_STAT_AUTOHALF) &&
 		    !pPrt->HalfDupTimerActive) {
 			pPrt->HalfDupTimerActive = SK_TRUE;
 
 			Len = sizeof(SK_U64);
-			SkPnmiGetVar(pAC, IoC, OID_SKGE_STAT_TX_OCTETS, (char *) &Octets,
+			SkPnmiGetVar(pAC, IoC, OID_SKGE_STAT_TX_OCTETS, (char *)&Octets,
 				&Len, (SK_U32) SK_PNMI_PORT_PHYS2INST(pAC, 1),
 				pAC->Rlmt.Port[1].Net->NetNumber);
+			
 			pPrt->LastOctets = Octets;
+			
 			Para.Para32[0] = 1;
-			SkTimerStart(pAC, IoC,
-				&pPrt->HalfDupChkTimer,
-				SK_HALFDUP_CHK_TIME,
-				SKGE_HWAC,
-				SK_HWEV_HALFDUP_CHK,
-				Para);
+			SkTimerStart(pAC, IoC, &pPrt->HalfDupChkTimer, SK_HALFDUP_CHK_TIME,
+				SKGE_HWAC, SK_HWEV_HALFDUP_CHK, Para);
 		}
 	}
 
-	/*
-	 * Check interrupts of the particular queues.
-	 */
-	if (Istatus & IS_R1_C) {
+	/* Check interrupts of the particular queues */
+	if ((Istatus & IS_R1_C) != 0) {
 		/* Clear IRQ */
 		SK_OUT32(IoC, B0_R1_CSR, CSR_IRQ_CL_C);
 		SK_ERR_LOG(pAC, SK_ERRCL_SW | SK_ERRCL_INIT, SKERR_SIRQ_E006,
@@ -846,7 +978,7 @@
 		SkEventQueue(pAC, SKGE_RLMT, SK_RLMT_LINK_DOWN, Para);
 	}
 
-	if (Istatus & IS_R2_C) {
+	if ((Istatus & IS_R2_C) != 0) {
 		/* Clear IRQ */
 		SK_OUT32(IoC, B0_R2_CSR, CSR_IRQ_CL_C);
 		SK_ERR_LOG(pAC, SK_ERRCL_SW | SK_ERRCL_INIT, SKERR_SIRQ_E007,
@@ -857,7 +989,7 @@
 		SkEventQueue(pAC, SKGE_RLMT, SK_RLMT_LINK_DOWN, Para);
 	}
 
-	if (Istatus & IS_XS1_C) {
+	if ((Istatus & IS_XS1_C) != 0) {
 		/* Clear IRQ */
 		SK_OUT32(IoC, B0_XS1_CSR, CSR_IRQ_CL_C);
 		SK_ERR_LOG(pAC, SK_ERRCL_SW | SK_ERRCL_INIT, SKERR_SIRQ_E008,
@@ -868,7 +1000,7 @@
 		SkEventQueue(pAC, SKGE_RLMT, SK_RLMT_LINK_DOWN, Para);
 	}
 
-	if (Istatus & IS_XA1_C) {
+	if ((Istatus & IS_XA1_C) != 0) {
 		/* Clear IRQ */
 		SK_OUT32(IoC, B0_XA1_CSR, CSR_IRQ_CL_C);
 		SK_ERR_LOG(pAC, SK_ERRCL_SW | SK_ERRCL_INIT, SKERR_SIRQ_E009,
@@ -879,7 +1011,7 @@
 		SkEventQueue(pAC, SKGE_RLMT, SK_RLMT_LINK_DOWN, Para);
 	}
 
-	if (Istatus & IS_XS2_C) {
+	if ((Istatus & IS_XS2_C) != 0) {
 		/* Clear IRQ */
 		SK_OUT32(IoC, B0_XS2_CSR, CSR_IRQ_CL_C);
 		SK_ERR_LOG(pAC, SK_ERRCL_SW | SK_ERRCL_INIT, SKERR_SIRQ_E010,
@@ -890,7 +1022,7 @@
 		SkEventQueue(pAC, SKGE_RLMT, SK_RLMT_LINK_DOWN, Para);
 	}
 
-	if (Istatus & IS_XA2_C) {
+	if ((Istatus & IS_XA2_C) != 0) {
 		/* Clear IRQ */
 		SK_OUT32(IoC, B0_XA2_CSR, CSR_IRQ_CL_C);
 		SK_ERR_LOG(pAC, SK_ERRCL_SW | SK_ERRCL_INIT, SKERR_SIRQ_E011,
@@ -901,77 +1033,73 @@
 		SkEventQueue(pAC, SKGE_RLMT, SK_RLMT_LINK_DOWN, Para);
 	}
 
-	/*
-	 * External reg interrupt.
-	 */
-	if (Istatus & IS_EXT_REG) {
-		SK_U16 	PhyInt;
-		SK_U16 	PhyIMsk;
-		int		i;
-		SK_GEPORT	*pPrt;		/* GIni Port struct pointer */
-
-		/* Test IRQs from PHY. */
+	/* External reg interrupt */
+	if ((Istatus & IS_EXT_REG) != 0) {
+		/* Test IRQs from PHY */
 		for (i = 0; i < pAC->GIni.GIMacsFound; i++) {
+			
 			pPrt = &pAC->GIni.GP[i];
-			switch (pPrt->PhyType) {
-			case SK_PHY_XMAC:
-				break;
-			case SK_PHY_BCOM:
-				if (pPrt->PState) {
-					PHY_READ(IoC, pPrt, i, PHY_BCOM_INT_STAT, &PhyInt);
-					PHY_READ(IoC, pPrt, i, PHY_BCOM_INT_MASK, &PhyIMsk);
-
-#ifdef xDEBUG
-					if (PhyInt & PhyIMsk) {
-						CMSMPrintString(
-							pAC->pConfigTable,
-							MSG_TYPE_RUNTIME_INFO,
-							"SirqIsr - Stat: %x",
-							(void *)PhyInt,
-							(void *)NULL);
+			
+			if (pPrt->PState == SK_PRT_RESET) {
+				continue;
+			}
+			
+			if (pAC->GIni.GIGenesis) {
+				
+				switch (pPrt->PhyType) {
+				
+				case SK_PHY_XMAC:
+					break;
+				
+				case SK_PHY_BCOM:
+					SkXmPhyRead(pAC, IoC, i, PHY_BCOM_INT_STAT, &PhyInt);
+	
+					if ((PhyInt & ~PHY_B_DEF_MSK) != 0) {
+						SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_IRQ,
+							("Port %d Bcom Int: 0x%04X\n",
+							i, PhyInt));
+						SkPhyIsrBcom(pAC, IoC, i, PhyInt);
 					}
-#endif	/* DEBUG */
+					break;
+#ifdef OTHER_PHY
+				case SK_PHY_LONE:
+					SkXmPhyRead(pAC, IoC, i, PHY_LONE_INT_STAT, &PhyInt);
 					
-					if (PhyInt & ~PhyIMsk) {
-						SK_DBG_MSG(
-							pAC,
-							SK_DBGMOD_HWM,
-							SK_DBGCAT_IRQ,
-							("Port %d Bcom Int: %x Mask: %x\n",
-								i, PhyInt, PhyIMsk));
-						SkPhyIsrBcom(pAC, IoC, i, PhyInt);
+					if ((PhyInt & PHY_L_DEF_MSK) != 0) {
+						SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_IRQ,
+							("Port %d Lone Int: %x\n",
+							i, PhyInt));
+						SkPhyIsrLone(pAC, IoC, i, PhyInt);
 					}
+					break;
+#endif /* OTHER_PHY */
 				}
-				break;
-			case SK_PHY_LONE:
-				PHY_READ(IoC, pPrt, i, PHY_LONE_INT_STAT, &PhyInt);
-				PHY_READ(IoC, pPrt, i, PHY_LONE_INT_ENAB, &PhyIMsk);
-				
-				if (PhyInt & PhyIMsk) {
-					SK_DBG_MSG(
-						pAC,
-						SK_DBGMOD_HWM,
-						SK_DBGCAT_IRQ,
-						("Port %d  Lone Int: %x Mask: %x\n",
-						i, PhyInt, PhyIMsk));
-					SkPhyIsrLone(pAC, IoC, i, PhyInt);
+			}
+			else {
+				SkGmPhyRead(pAC, IoC, i, PHY_MARV_INT_STAT, &PhyInt);
+
+				if ((PhyInt & PHY_M_DEF_MSK) != 0) {
+					SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_IRQ,
+						("Port %d Marv Int: 0x%04X\n",
+						i, PhyInt));
+					SkPhyIsrGmac(pAC, IoC, i, PhyInt);
 				}
-				break;
-			case SK_PHY_NAT:
-				/* todo: National */
-				break;
 			}
 		}
 	}
 
-	/*
-	 * I2C Ready interrupt
-	 */
-	if (Istatus & IS_I2C_READY) {
+	/* I2C Ready interrupt */
+	if ((Istatus & IS_I2C_READY) != 0) {
 		SkI2cIsr(pAC, IoC);
 	}
 
-	if (Istatus & IS_LNK_SYNC_M1) {
+	/* SW forced interrupt */
+	if ((Istatus & IS_IRQ_SW) != 0) {
+		/* clear the software IRQ */
+		SK_OUT8(IoC, B0_CTST, CS_CL_SW_IRQ);
+	}
+
+	if ((Istatus & IS_LNK_SYNC_M1) != 0) {
 		/*
 		 * We do NOT need the Link Sync interrupt, because it shows
 		 * us only a link going down.
@@ -981,56 +1109,61 @@
 	}
 
 	/* Check MAC after link sync counter */
-	if (Istatus & IS_MAC1) {
-		XM_IN16(IoC, MAC_1, XM_ISRC, &XmIsr);
-		SkXmIrq(pAC, IoC, MAC_1, XmIsr);
+	if ((Istatus & IS_MAC1) != 0) {
+		/* IRQ from MAC 1 */
+		SkMacIrq(pAC, IoC, MAC_1);
 	}
 
-	if (Istatus & IS_LNK_SYNC_M2) {
+	if ((Istatus & IS_LNK_SYNC_M2) != 0) {
 		/*
 		 * We do NOT need the Link Sync interrupt, because it shows
 		 * us only a link going down.
 		 */
 		/* clear interrupt */
-		SK_OUT8(IoC, MR_ADDR(MAC_2,LNK_SYNC_CTRL), LED_CLR_IRQ);
+		SK_OUT8(IoC, MR_ADDR(MAC_2, LNK_SYNC_CTRL), LED_CLR_IRQ);
 	}
 
 	/* Check MAC after link sync counter */
-	if (Istatus & IS_MAC2) {
-		XM_IN16(IoC, MAC_2, XM_ISRC, &XmIsr);
-		SkXmIrq(pAC, IoC, MAC_2, XmIsr);
+	if ((Istatus & IS_MAC2) != 0) {
+		/* IRQ from MAC 2 */
+		SkMacIrq(pAC, IoC, MAC_2);
 	}
 
-	/*
-	 * Timer interrupt
-	 *  To be served last
-	 */
-	if (Istatus & IS_TIMINT) {
+	/* Timer interrupt (served last) */
+	if ((Istatus & IS_TIMINT) != 0) {
+		/* check for HW Errors */
+		if (((Istatus & IS_HW_ERR) & ~pAC->GIni.GIValIrqMask) != 0) {
+			/* read the HW Error Interrupt source */
+			SK_IN32(IoC, B0_HWE_ISRC, &RegVal32);
+
+			SkGeHwErr(pAC, IoC, RegVal32);
+		}
+
 		SkHwtIsr(pAC, IoC);
 	}
+
 }	/* SkGeSirqIsr */
 
 
 /******************************************************************************
  *
- * SkGePortCheckShorts - Implementing of the Workaround Errata # 2
+ * SkGePortCheckShorts() - Implementing XMAC Workaround Errata # 2
  *
  * return:
  *	0	o.k. nothing needed
  *	1	Restart needed on this port
  */
-int	SkGePortCheckShorts(
+static int SkGePortCheckShorts(
 SK_AC	*pAC,		/* Adapter Context */
 SK_IOC	IoC,		/* IO Context */
 int		Port)		/* Which port should be checked */
 {
-	SK_U64		Shorts;			/* Short Event Counter */
-	SK_U64		CheckShorts;	/* Check value for Short Event Counter */
-	SK_U64		RxCts;			/* RX Counter (packets on network) */
-	SK_U64		RxTmp;			/* RX temp. Counter */
-	SK_U64		FcsErrCts;		/* FCS Error Counter */
+	SK_U32		Shorts;			/* Short Event Counter */
+	SK_U32		CheckShorts;	/* Check value for Short Event Counter */
+	SK_U64		RxCts;			/* Rx Counter (packets on network) */
+	SK_U32		RxTmp;			/* Rx temp. Counter */
+	SK_U32		FcsErrCts;		/* FCS Error Counter */
 	SK_GEPORT	*pPrt;			/* GIni Port struct pointer */
-	unsigned 	Len;
 	int			Rtv;			/* Return value */
 	int			i;
 
@@ -1039,48 +1172,35 @@
 	/* Default: no action */
 	Rtv = SK_HW_PS_NONE;
 
-	/*
-	 * Extra precaution: check for short Event counter
-	 */
-	Len = sizeof(SK_U64);
-	SkPnmiGetVar(pAC, IoC, OID_SKGE_STAT_RX_SHORTS, (char *)&Shorts,
-		&Len, (SK_U32)SK_PNMI_PORT_PHYS2INST(pAC, Port),
-		pAC->Rlmt.Port[Port].Net->NetNumber);
+	(void)SkXmUpdateStats(pAC, IoC, Port);
+
+	/* Extra precaution: check for short Event counter */
+	(void)SkXmMacStatistic(pAC, IoC, Port, XM_RXE_SHT_ERR, &Shorts);
 
 	/*
-	 * Read RX counter (packets seen on the network and not neccesarily
+	 * Read Rx counter (packets seen on the network and not necessarily
 	 * really received.
 	 */
-	Len = sizeof(SK_U64);
 	RxCts = 0;
 
-	for (i = 0; i < sizeof(SkGeRxOids)/sizeof(SK_U32); i++) {
-		SkPnmiGetVar(pAC, IoC, SkGeRxOids[i], (char *)&RxTmp,
-			&Len, (SK_U32)SK_PNMI_PORT_PHYS2INST(pAC, Port),
-			pAC->Rlmt.Port[Port].Net->NetNumber);
-		RxCts += RxTmp;
+	for (i = 0; i < sizeof(SkGeRxRegs)/sizeof(SkGeRxRegs[0]); i++) {
+		(void)SkXmMacStatistic(pAC, IoC, Port, SkGeRxRegs[i], &RxTmp);
+		RxCts += (SK_U64)RxTmp;
 	}
 
 	/* On default: check shorts against zero */
 	CheckShorts = 0;
 
-	/*
-	 * Extra extra precaution on active links:
-	 */
+	/* Extra precaution on active links */
 	if (pPrt->PHWLinkUp) {
-		/*
-		 * Reset Link Restart counter
-		 */
+		/* Reset Link Restart counter */
 		pPrt->PLinkResCt = 0;
 		pPrt->PAutoNegTOCt = 0;
 
 		/* If link is up check for 2 */
 		CheckShorts = 2;
 
-		Len = sizeof(SK_U64);
-		SkPnmiGetVar(pAC, IoC, OID_SKGE_STAT_RX_FCS,
-			(char *)&FcsErrCts, &Len, (SK_U32)SK_PNMI_PORT_PHYS2INST(pAC, Port),
-			pAC->Rlmt.Port[Port].Net->NetNumber);
+		(void)SkXmMacStatistic(pAC, IoC, Port, XM_RXF_FCS_ERR, &FcsErrCts);
 		
 		if (pPrt->PLinkModeConf == SK_LMODE_AUTOSENSE &&
 		    pPrt->PLipaAutoNeg == SK_LIPA_UNKNOWN &&
@@ -1091,13 +1211,11 @@
 			 * manual full/half duplex mode.
 			 */
 			if (RxCts == pPrt->PPrevRx) {
-				/*
-				 * Nothing received
-				 * restart link
-				 */
+				/* Nothing received, restart link */
 				pPrt->PPrevFcs = FcsErrCts;
 				pPrt->PPrevShorts = Shorts;
-				return (SK_HW_PS_RESTART);
+				
+				return(SK_HW_PS_RESTART);
 			}
 			else {
 				pPrt->PLipaAutoNeg = SK_LIPA_MANUAL;
@@ -1118,7 +1236,7 @@
 			pPrt->PPrevFcs = FcsErrCts;
 			pPrt->PPrevShorts = Shorts;
 
-			return (SK_HW_PS_NONE);
+			return(SK_HW_PS_NONE);
 		}
 
 		pPrt->PPrevFcs = FcsErrCts;
@@ -1134,55 +1252,62 @@
 	pPrt->PPrevShorts = Shorts;
 	pPrt->PPrevRx = RxCts;
 
-	return (Rtv);
-}	/* SkGePortCheckShorts*/
+	return(Rtv);
+}	/* SkGePortCheckShorts */
 
 
 /******************************************************************************
  *
- * SkGePortCheckUp - Implementation of the Workaround for Errata #2
+ * SkGePortCheckUp() - Check if the link is up
  *
  * return:
  *	0	o.k. nothing needed
  *	1	Restart needed on this port
  *	2	Link came up
  */
-int	SkGePortCheckUp(
+static int SkGePortCheckUp(
 SK_AC	*pAC,		/* Adapter Context */
 SK_IOC	IoC,		/* IO Context */
 int		Port)		/* Which port should be checked */
 {
-	switch (pAC->GIni.GP[Port].PhyType) {
-	case SK_PHY_XMAC:
-		return (SkGePortCheckUpXmac(pAC, IoC, Port));
-	case SK_PHY_BCOM:
-		return (SkGePortCheckUpBcom(pAC, IoC, Port));
-	case SK_PHY_LONE:
-		return (SkGePortCheckUpLone(pAC, IoC, Port));
-	case SK_PHY_NAT:
-		return (SkGePortCheckUpNat(pAC, IoC, Port));
+	if (pAC->GIni.GIGenesis) {
+		switch (pAC->GIni.GP[Port].PhyType) {
+		case SK_PHY_XMAC:
+			return(SkGePortCheckUpXmac(pAC, IoC, Port));
+		case SK_PHY_BCOM:
+			return(SkGePortCheckUpBcom(pAC, IoC, Port));
+#ifdef OTHER_PHY
+		case SK_PHY_LONE:
+			return(SkGePortCheckUpLone(pAC, IoC, Port));
+		case SK_PHY_NAT:
+			return(SkGePortCheckUpNat(pAC, IoC, Port));
+#endif /* OTHER_PHY */
+		default:
+			return(SK_HW_PS_NONE);
+		}
+	}
+	else {
+		return(SkGePortCheckUpGmac(pAC, IoC, Port));
 	}
-	return (SK_HW_PS_NONE);
 }	/* SkGePortCheckUp */
 
 
 /******************************************************************************
  *
- * SkGePortCheckUpXmac - Implementing of the Workaround Errata # 2
+ * SkGePortCheckUpXmac() - Implementing of the Workaround Errata # 2
  *
  * return:
  *	0	o.k. nothing needed
  *	1	Restart needed on this port
  *	2	Link came up
  */
-static int	SkGePortCheckUpXmac(
+static int SkGePortCheckUpXmac(
 SK_AC	*pAC,		/* Adapter Context */
 SK_IOC	IoC,		/* IO Context */
 int		Port)		/* Which port should be checked */
 {
-	SK_U64		Shorts;		/* Short Event Counter */
+	SK_U32		Shorts;		/* Short Event Counter */
 	SK_GEPORT	*pPrt;		/* GIni Port struct pointer */
-	unsigned	Len;
 	int			Done;
 	SK_U32		GpReg;		/* General Purpose register value */
 	SK_U16		Isrc;		/* Interrupt source register */
@@ -1190,26 +1315,25 @@
 	SK_U16		LpAb;		/* Link Partner Ability */
 	SK_U16		ResAb;		/* Resolved Ability */
 	SK_U16		ExtStat;	/* Extended Status Register */
-	SK_BOOL		AutoNeg;	/* Is Autonegotiation used ? */
+	SK_BOOL		AutoNeg;	/* Is Auto-negotiation used ? */
 	SK_U8		NextMode;	/* Next AutoSensing Mode */
 
 	pPrt = &pAC->GIni.GP[Port];
 
 	if (pPrt->PHWLinkUp) {
 		if (pPrt->PhyType != SK_PHY_XMAC) {
-			return (SK_HW_PS_NONE);
+			return(SK_HW_PS_NONE);
 		}
 		else {
-			return (SkGePortCheckShorts(pAC, IoC, Port));
+			return(SkGePortCheckShorts(pAC, IoC, Port));
 		}
 	}
 
 	IsrcSum = pPrt->PIsave;
 	pPrt->PIsave = 0;
 
-	/* Now wait for each port's link. */
-	if (pPrt->PLinkMode == SK_LMODE_HALF ||
-	    pPrt->PLinkMode == SK_LMODE_FULL) {
+	/* Now wait for each port's link */
+	if (pPrt->PLinkMode == SK_LMODE_HALF || pPrt->PLinkMode == SK_LMODE_FULL) {
 		AutoNeg = SK_FALSE;
 	}
 	else {
@@ -1218,27 +1342,27 @@
 
 	if (pPrt->PLinkBroken) {
 		/* Link was broken */
-		XM_IN32(IoC,Port,XM_GP_PORT, &GpReg);
+		XM_IN32(IoC, Port, XM_GP_PORT, &GpReg);
 
 		if ((GpReg & XM_GP_INP_ASS) == 0) {
 			/* The Link is in sync */
-			XM_IN16(IoC,Port,XM_ISRC, &Isrc);
+			XM_IN16(IoC, Port, XM_ISRC, &Isrc);
 			IsrcSum |= Isrc;
 			SkXmAutoNegLipaXmac(pAC, IoC, Port, IsrcSum);
+			
 			if ((Isrc & XM_IS_INP_ASS) == 0) {
-				/* It has been in sync since last Time */
+				/* It has been in sync since last time */
 				/* Restart the PORT */
 				SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_IRQ,
 					("Link in sync Restart Port %d\n", Port));
 
-				/* We now need to reinitialize the PrevShorts counter. */
-				Len = sizeof(SK_U64);
-				SkPnmiGetVar(pAC, IoC, OID_SKGE_STAT_RX_SHORTS, (char *)&Shorts,
-					&Len, (SK_U32)SK_PNMI_PORT_PHYS2INST(pAC, Port),
-					pAC->Rlmt.Port[Port].Net->NetNumber);
+				(void)SkXmUpdateStats(pAC, IoC, Port);
+
+				/* We now need to reinitialize the PrevShorts counter */
+				(void)SkXmMacStatistic(pAC, IoC, Port, XM_RXE_SHT_ERR, &Shorts);
 				pPrt->PPrevShorts = Shorts;
 
-				pAC->GIni.GP[Port].PLinkBroken = SK_FALSE;
+				pPrt->PLinkBroken = SK_FALSE;
 
 				/*
 				 * Link Restart Workaround:
@@ -1248,31 +1372,34 @@
 				 *  happening we check for a maximum number
 				 *  of consecutive restart. If those happens,
 				 *  we do NOT restart the active link and
-				 *  check whether the lionk is now o.k.
+				 *  check whether the link is now o.k.
 				 */
-				pAC->GIni.GP[Port].PLinkResCt ++;
+				pPrt->PLinkResCt++;
+				
 				pPrt->PAutoNegTimeOut = 0;
 
-				if (pAC->GIni.GP[Port].PLinkResCt < SK_MAX_LRESTART) {
-					return (SK_HW_PS_RESTART);
+				if (pPrt->PLinkResCt < SK_MAX_LRESTART) {
+					return(SK_HW_PS_RESTART);
 				}
 
-				SK_DBG_MSG(pAC,SK_DBGMOD_HWM,SK_DBGCAT_CTRL,
+				pPrt->PLinkResCt = 0;
+				
+				SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_CTRL,
 					("Do NOT restart on Port %d %x %x\n", Port, Isrc, IsrcSum));
-				pAC->GIni.GP[Port].PLinkResCt = 0;
 			}
 			else {
-				pPrt->PIsave = (SK_U16)(IsrcSum & (XM_IS_AND));
-				SK_DBG_MSG(pAC,SK_DBGMOD_HWM,SK_DBGCAT_CTRL,
+				pPrt->PIsave = (SK_U16)(IsrcSum & XM_IS_AND);
+				
+				SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_CTRL,
 					("Save Sync/nosync Port %d %x %x\n", Port, Isrc, IsrcSum));
 
 				/* Do nothing more if link is broken */
-				return (SK_HW_PS_NONE);
+				return(SK_HW_PS_NONE);
 			}
 		}
 		else {
 			/* Do nothing more if link is broken */
-			return (SK_HW_PS_NONE);
+			return(SK_HW_PS_NONE);
 		}
 
 	}
@@ -1280,69 +1407,67 @@
 		/* Link was not broken, check if it is */
 		XM_IN16(IoC, Port, XM_ISRC, &Isrc);
 		IsrcSum |= Isrc;
-		if ((Isrc & XM_IS_INP_ASS) == XM_IS_INP_ASS) {
+		if ((Isrc & XM_IS_INP_ASS) != 0) {
 			XM_IN16(IoC, Port, XM_ISRC, &Isrc);
 			IsrcSum |= Isrc;
-			if ((Isrc & XM_IS_INP_ASS) == XM_IS_INP_ASS) {
+			if ((Isrc & XM_IS_INP_ASS) != 0) {
 				XM_IN16(IoC, Port, XM_ISRC, &Isrc);
 				IsrcSum |= Isrc;
-				if ((Isrc & XM_IS_INP_ASS) == XM_IS_INP_ASS) {
+				if ((Isrc & XM_IS_INP_ASS) != 0) {
 					pPrt->PLinkBroken = SK_TRUE;
-					/*
-					 * Re-Init Link partner Autoneg flag
-					 */
+					/* Re-Init Link partner Autoneg flag */
 					pPrt->PLipaAutoNeg = SK_LIPA_UNKNOWN;
-					SK_DBG_MSG(pAC,SK_DBGMOD_HWM, SK_DBGCAT_IRQ,
+					SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_IRQ,
 						("Link broken Port %d\n", Port));
 
-					/* Cable removed-> reinit sense mode. */
-					/* Init default sense mode. */
+					/* Cable removed-> reinit sense mode */
 					SkHWInitDefSense(pAC, IoC, Port);
 
-					return (SK_HW_PS_RESTART);
+					return(SK_HW_PS_RESTART);
 				}
 			}
 		}
 		else {
 			SkXmAutoNegLipaXmac(pAC, IoC, Port, Isrc);
 			if (SkGePortCheckShorts(pAC, IoC, Port) == SK_HW_PS_RESTART) {
-				return (SK_HW_PS_RESTART);
+				return(SK_HW_PS_RESTART);
 			}
 		}
 	}
 
 	/*
 	 * here we usually can check whether the link is in sync and
-	 * autonegotiation is done.
+	 * auto-negotiation is done.
 	 */
 	XM_IN32(IoC, Port, XM_GP_PORT, &GpReg);
 	XM_IN16(IoC, Port, XM_ISRC, &Isrc);
 	IsrcSum |= Isrc;
 
 	SkXmAutoNegLipaXmac(pAC, IoC, Port, IsrcSum);
+	
 	if ((GpReg & XM_GP_INP_ASS) != 0 || (IsrcSum & XM_IS_INP_ASS) != 0) {
 		if ((GpReg & XM_GP_INP_ASS) == 0) {
-			/* Save Autonegotiation Done interrupt only if link is in sync. */
-			pPrt->PIsave = (SK_U16)(IsrcSum & (XM_IS_AND));
+			/* Save Auto-negotiation Done interrupt only if link is in sync */
+			pPrt->PIsave = (SK_U16)(IsrcSum & XM_IS_AND);
 		}
-#ifdef	DEBUG
-		if (pPrt->PIsave & (XM_IS_AND)) {
-			SK_DBG_MSG(pAC,SK_DBGMOD_HWM,SK_DBGCAT_CTRL,
+#ifdef DEBUG
+		if ((pPrt->PIsave & XM_IS_AND) != 0) {
+			SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_CTRL,
 				("AutoNeg done rescheduled Port %d\n", Port));
 		}
-#endif
-		return (SK_HW_PS_NONE);
+#endif /* DEBUG */
+		return(SK_HW_PS_NONE);
 	}
 
 	if (AutoNeg) {
-		if (IsrcSum & XM_IS_AND) {
+		if ((IsrcSum & XM_IS_AND) != 0) {
 			SkHWLinkUp(pAC, IoC, Port);
-			Done = SkXmAutoNegDone(pAC,IoC,Port);
+			Done = SkMacAutoNegDone(pAC, IoC, Port);
 			if (Done != SK_AND_OK) {
-				/* Get PHY parameters, for debuging only */
-				PHY_READ(IoC, pPrt, Port, PHY_XMAC_AUNE_LP, &LpAb);
-				PHY_READ(IoC, pPrt, Port, PHY_XMAC_RES_ABI, &ResAb);
-				SK_DBG_MSG(pAC,SK_DBGMOD_HWM,SK_DBGCAT_CTRL,
+				/* Get PHY parameters, for debugging only */
+				SkXmPhyRead(pAC, IoC, Port, PHY_XMAC_AUNE_LP, &LpAb);
+				SkXmPhyRead(pAC, IoC, Port, PHY_XMAC_RES_ABI, &ResAb);
+				SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_CTRL,
 					("AutoNeg FAIL Port %d (LpAb %x, ResAb %x)\n",
 					 Port, LpAb, ResAb));
 					
@@ -1354,44 +1479,30 @@
 					SkHWSenseSetNext(pAC, IoC, Port, NextMode);
 				}
 
-				return (SK_HW_PS_RESTART);
+				return(SK_HW_PS_RESTART);
 			}
-			else {
-				/*
-				 * Dummy Read extended status to prevent extra link down/ups
-				 * (clear Page Received bit if set)
-				 */
-				PHY_READ(IoC, pPrt, Port, PHY_XMAC_AUNE_EXP, &ExtStat);
-				SK_DBG_MSG(pAC,SK_DBGMOD_HWM,SK_DBGCAT_CTRL,
-					("AutoNeg done Port %d\n", Port));
-				return (SK_HW_PS_LINK);
-			}
-		} 
-		
-		/*
-		 * AutoNeg not done, but HW link is up. Check for timeouts
-		 */
-		pPrt->PAutoNegTimeOut ++;
-		if (pPrt->PAutoNegTimeOut >= SK_AND_MAX_TO) {
 			/*
-			 * Increase the Timeout counter.
+			 * Dummy Read extended status to prevent extra link down/ups
+			 * (clear Page Received bit if set)
 			 */
-			pPrt->PAutoNegTOCt ++;
+			SkXmPhyRead(pAC, IoC, Port, PHY_XMAC_AUNE_EXP, &ExtStat);
+			SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_CTRL,
+				("AutoNeg done Port %d\n", Port));
+			return(SK_HW_PS_LINK);
+		}
+		
+		/* AutoNeg not done, but HW link is up. Check for timeouts */
+		pPrt->PAutoNegTimeOut++;
+		if (pPrt->PAutoNegTimeOut >= SK_AND_MAX_TO) {
+			/* Increase the Timeout counter */
+			pPrt->PAutoNegTOCt++;
 
-			/*
-			 * Timeout occured.
-			 * What do we need now?
-			 */
-			SK_DBG_MSG(pAC,SK_DBGMOD_HWM,
-				SK_DBGCAT_IRQ,
-				("AutoNeg timeout Port %d\n",
-				 Port));
+			/* Timeout occured */
+			SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_IRQ,
+				("AutoNeg timeout Port %d\n", Port));
 			if (pPrt->PLinkModeConf == SK_LMODE_AUTOSENSE &&
 				pPrt->PLipaAutoNeg != SK_LIPA_AUTO) {
-				/*
-				 * Timeout occured
-				 * Set Link manually up.
-				 */
+				/* Set Link manually up */
 				SkHWSenseSetNext(pAC, IoC, Port, SK_LMODE_FULL);
 				SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_IRQ,
 					("Set manual full duplex Port %d\n", Port));
@@ -1403,10 +1514,10 @@
 				/*
 				 * This is rather complicated.
 				 * we need to check here whether the LIPA_AUTO
-				 * we saw before is false alert. We saw at one 
+				 * we saw before is false alert. We saw at one
 				 * switch ( SR8800) that on boot time it sends
-				 * just one autoneg packet and does no further
-				 * autonegotiation.
+				 * just one auto-neg packet and does no further
+				 * auto-negotiation.
 				 * Solution: we restart the autosensing after
 				 * a few timeouts.
 				 */
@@ -1415,43 +1526,44 @@
 				SkHWInitDefSense(pAC, IoC, Port);
 			}
 
-			/*
-			 * Do the restart
-			 */
-			return (SK_HW_PS_RESTART);
+			/* Do the restart */
+			return(SK_HW_PS_RESTART);
 		}
 	}
 	else {
-		/*
-		 * Link is up and we don't need more.
-		 */
-#ifdef	DEBUG
+		/* Link is up and we don't need more */
+#ifdef DEBUG
 		if (pPrt->PLipaAutoNeg == SK_LIPA_AUTO) {
 			SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_CTRL,
 				("ERROR: Lipa auto detected on port %d\n", Port));
 		}
-#endif
-
-		SK_DBG_MSG(pAC,SK_DBGMOD_HWM,SK_DBGCAT_IRQ,
+#endif /* DEBUG */
+		SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_IRQ,
 			("Link sync(GP), Port %d\n", Port));
 		SkHWLinkUp(pAC, IoC, Port);
-		return (SK_HW_PS_LINK);
+		
+		/*
+		 * Link sync (GP) and so assume a good connection. But if not received
+		 * a bunch of frames received in a time slot (maybe broken tx cable)
+		 * the port is restart.
+		 */
+		return(SK_HW_PS_LINK);
 	}
 
-	return (SK_HW_PS_NONE);
+	return(SK_HW_PS_NONE);
 }	/* SkGePortCheckUpXmac */
 
 
 /******************************************************************************
  *
- * SkGePortCheckUpBcom - Check, if the link is up
+ * SkGePortCheckUpBcom() - Check if the link is up on Bcom PHY
  *
  * return:
  *	0	o.k. nothing needed
  *	1	Restart needed on this port
  *	2	Link came up
  */
-static int	SkGePortCheckUpBcom(
+static int SkGePortCheckUpBcom(
 SK_AC	*pAC,	/* Adapter Context */
 SK_IOC	IoC,	/* IO Context */
 int		Port)	/* Which port should be checked */
@@ -1465,20 +1577,22 @@
 #ifdef DEBUG
 	SK_U16		LpAb;
 	SK_U16		ExtStat;
-#endif	/* DEBUG */
-	SK_BOOL		AutoNeg;	/* Is Autonegotiation used ? */
+#endif /* DEBUG */
+	SK_BOOL		AutoNeg;	/* Is Auto-negotiation used ? */
 
 	pPrt = &pAC->GIni.GP[Port];
 
 	/* Check for No HCD Link events (#10523) */
-	PHY_READ(IoC, pPrt, Port, PHY_BCOM_INT_STAT, &Isrc);
+	SkXmPhyRead(pAC, IoC, Port, PHY_BCOM_INT_STAT, &Isrc);
 
 #ifdef xDEBUG
-	if ((Isrc & ~0x1800) == 0x70) {
+	if ((Isrc & ~(PHY_B_IS_HCT | PHY_B_IS_LCT) ==
+		(PHY_B_IS_SCR_S_ER | PHY_B_IS_RRS_CHANGE | PHY_B_IS_LRS_CHANGE)) {
+
 		SK_U32	Stat1, Stat2, Stat3;
 
 		Stat1 = 0;
-		PHY_READ(pAC, pPrt, Port, PHY_BCOM_INT_MASK, &Stat1);
+		SkXmPhyRead(pAC, IoC, Port, PHY_BCOM_INT_MASK, &Stat1);
 		CMSMPrintString(
 			pAC->pConfigTable,
 			MSG_TYPE_RUNTIME_INFO,
@@ -1487,14 +1601,14 @@
 			(void *)Stat1);
 
 		Stat1 = 0;
-		PHY_READ(pAC, pPrt, Port, PHY_BCOM_CTRL, &Stat1);
+		SkXmPhyRead(pAC, IoC, Port, PHY_BCOM_CTRL, &Stat1);
 		Stat2 = 0;
-		PHY_READ(pAC, pPrt, Port, PHY_BCOM_STAT, &Stat2);
+		SkXmPhyRead(pAC, IoC, Port, PHY_BCOM_STAT, &Stat2);
 		Stat1 = Stat1 << 16 | Stat2;
 		Stat2 = 0;
-		PHY_READ(pAC, pPrt, Port, PHY_BCOM_AUNE_ADV, &Stat2);
+		SkXmPhyRead(pAC, IoC, Port, PHY_BCOM_AUNE_ADV, &Stat2);
 		Stat3 = 0;
-		PHY_READ(pAC, pPrt, Port, PHY_BCOM_AUNE_LP, &Stat3);
+		SkXmPhyRead(pAC, IoC, Port, PHY_BCOM_AUNE_LP, &Stat3);
 		Stat2 = Stat2 << 16 | Stat3;
 		CMSMPrintString(
 			pAC->pConfigTable,
@@ -1504,14 +1618,14 @@
 			(void *)Stat2);
 
 		Stat1 = 0;
-		PHY_READ(pAC, pPrt, Port, PHY_BCOM_AUNE_EXP, &Stat1);
+		SkXmPhyRead(pAC, IoC, Port, PHY_BCOM_AUNE_EXP, &Stat1);
 		Stat2 = 0;
-		PHY_READ(pAC, pPrt, Port, PHY_BCOM_EXT_STAT, &Stat2);
+		SkXmPhyRead(pAC, IoC, Port, PHY_BCOM_EXT_STAT, &Stat2);
 		Stat1 = Stat1 << 16 | Stat2;
 		Stat2 = 0;
-		PHY_READ(pAC, pPrt, Port, PHY_BCOM_1000T_CTRL, &Stat2);
+		SkXmPhyRead(pAC, IoC, Port, PHY_BCOM_1000T_CTRL, &Stat2);
 		Stat3 = 0;
-		PHY_READ(pAC, pPrt, Port, PHY_BCOM_1000T_STAT, &Stat3);
+		SkXmPhyRead(pAC, IoC, Port, PHY_BCOM_1000T_STAT, &Stat3);
 		Stat2 = Stat2 << 16 | Stat3;
 		CMSMPrintString(
 			pAC->pConfigTable,
@@ -1521,14 +1635,14 @@
 			(void *)Stat2);
 
 		Stat1 = 0;
-		PHY_READ(pAC, pPrt, Port, PHY_BCOM_P_EXT_CTRL, &Stat1);
+		SkXmPhyRead(pAC, IoC, Port, PHY_BCOM_P_EXT_CTRL, &Stat1);
 		Stat2 = 0;
-		PHY_READ(pAC, pPrt, Port, PHY_BCOM_P_EXT_STAT, &Stat2);
+		SkXmPhyRead(pAC, IoC, Port, PHY_BCOM_P_EXT_STAT, &Stat2);
 		Stat1 = Stat1 << 16 | Stat2;
 		Stat2 = 0;
-		PHY_READ(pAC, pPrt, Port, PHY_BCOM_AUX_CTRL, &Stat2);
+		SkXmPhyRead(pAC, IoC, Port, PHY_BCOM_AUX_CTRL, &Stat2);
 		Stat3 = 0;
-		PHY_READ(pAC, pPrt, Port, PHY_BCOM_AUX_STAT, &Stat3);
+		SkXmPhyRead(pAC, IoC, Port, PHY_BCOM_AUX_STAT, &Stat3);
 		Stat2 = Stat2 << 16 | Stat3;
 		CMSMPrintString(
 			pAC->pConfigTable,
@@ -1537,16 +1651,18 @@
 			(void *)Stat1,
 			(void *)Stat2);
 	}
-#endif	/* DEBUG */
+#endif /* DEBUG */
 
 	if ((Isrc & (PHY_B_IS_NO_HDCL /* | PHY_B_IS_NO_HDC */)) != 0) {
 		/*
-		 * Workaround BCOM Errata:
+		 * Workaround BCom Errata:
 		 *	enable and disable loopback mode if "NO HCD" occurs.
 		 */
-		PHY_READ(IoC, pPrt, Port, PHY_BCOM_CTRL, &Ctrl);
-		PHY_WRITE(IoC, pPrt, Port, PHY_BCOM_CTRL, Ctrl | PHY_CT_LOOP);
-		PHY_WRITE(IoC, pPrt, Port, PHY_BCOM_CTRL, Ctrl & ~PHY_CT_LOOP);
+		SkXmPhyRead(pAC, IoC, Port, PHY_BCOM_CTRL, &Ctrl);
+		SkXmPhyWrite(pAC, IoC, Port, PHY_BCOM_CTRL,
+			(SK_U16)(Ctrl | PHY_CT_LOOP));
+		SkXmPhyWrite(pAC, IoC, Port, PHY_BCOM_CTRL,
+			(SK_U16)(Ctrl & ~PHY_CT_LOOP));
 		SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_CTRL,
 			("No HCD Link event, Port %d\n", Port));
 #ifdef xDEBUG
@@ -1556,14 +1672,14 @@
 			"No HCD link event, port %d.",
 			(void *)Port,
 			(void *)NULL);
-#endif	/* DEBUG */
+#endif /* DEBUG */
 	}
 
 	/* Not obsolete: link status bit is latched to 0 and autoclearing! */
-	PHY_READ(IoC, pPrt, Port, PHY_BCOM_STAT, &PhyStat);
+	SkXmPhyRead(pAC, IoC, Port, PHY_BCOM_STAT, &PhyStat);
 
 	if (pPrt->PHWLinkUp) {
-		return (SK_HW_PS_NONE);
+		return(SK_HW_PS_NONE);
 	}
 
 #ifdef xDEBUG
@@ -1571,7 +1687,7 @@
 		SK_U32	Stat1, Stat2, Stat3;
 
 		Stat1 = 0;
-		PHY_READ(pAC, pPrt, Port, PHY_BCOM_INT_MASK, &Stat1);
+		SkXmPhyRead(pAC, IoC, Port, PHY_BCOM_INT_MASK, &Stat1);
 		CMSMPrintString(
 			pAC->pConfigTable,
 			MSG_TYPE_RUNTIME_INFO,
@@ -1580,14 +1696,14 @@
 			(void *)Stat1);
 
 		Stat1 = 0;
-		PHY_READ(pAC, pPrt, Port, PHY_BCOM_CTRL, &Stat1);
+		SkXmPhyRead(pAC, IoC, Port, PHY_BCOM_CTRL, &Stat1);
 		Stat2 = 0;
-		PHY_READ(pAC, pPrt, Port, PHY_BCOM_STAT, &PhyStat);
+		SkXmPhyRead(pAC, IoC, Port, PHY_BCOM_STAT, &PhyStat);
 		Stat1 = Stat1 << 16 | PhyStat;
 		Stat2 = 0;
-		PHY_READ(pAC, pPrt, Port, PHY_BCOM_AUNE_ADV, &Stat2);
+		SkXmPhyRead(pAC, IoC, Port, PHY_BCOM_AUNE_ADV, &Stat2);
 		Stat3 = 0;
-		PHY_READ(pAC, pPrt, Port, PHY_BCOM_AUNE_LP, &Stat3);
+		SkXmPhyRead(pAC, IoC, Port, PHY_BCOM_AUNE_LP, &Stat3);
 		Stat2 = Stat2 << 16 | Stat3;
 		CMSMPrintString(
 			pAC->pConfigTable,
@@ -1597,14 +1713,14 @@
 			(void *)Stat2);
 
 		Stat1 = 0;
-		PHY_READ(pAC, pPrt, Port, PHY_BCOM_AUNE_EXP, &Stat1);
+		SkXmPhyRead(pAC, IoC, Port, PHY_BCOM_AUNE_EXP, &Stat1);
 		Stat2 = 0;
-		PHY_READ(pAC, pPrt, Port, PHY_BCOM_EXT_STAT, &Stat2);
+		SkXmPhyRead(pAC, IoC, Port, PHY_BCOM_EXT_STAT, &Stat2);
 		Stat1 = Stat1 << 16 | Stat2;
 		Stat2 = 0;
-		PHY_READ(pAC, pPrt, Port, PHY_BCOM_1000T_CTRL, &Stat2);
+		SkXmPhyRead(pAC, IoC, Port, PHY_BCOM_1000T_CTRL, &Stat2);
 		Stat3 = 0;
-		PHY_READ(pAC, pPrt, Port, PHY_BCOM_1000T_STAT, &ResAb);
+		SkXmPhyRead(pAC, IoC, Port, PHY_BCOM_1000T_STAT, &ResAb);
 		Stat2 = Stat2 << 16 | ResAb;
 		CMSMPrintString(
 			pAC->pConfigTable,
@@ -1614,14 +1730,14 @@
 			(void *)Stat2);
 
 		Stat1 = 0;
-		PHY_READ(pAC, pPrt, Port, PHY_BCOM_P_EXT_CTRL, &Stat1);
+		SkXmPhyRead(pAC, IoC, Port, PHY_BCOM_P_EXT_CTRL, &Stat1);
 		Stat2 = 0;
-		PHY_READ(pAC, pPrt, Port, PHY_BCOM_P_EXT_STAT, &Stat2);
+		SkXmPhyRead(pAC, IoC, Port, PHY_BCOM_P_EXT_STAT, &Stat2);
 		Stat1 = Stat1 << 16 | Stat2;
 		Stat2 = 0;
-		PHY_READ(pAC, pPrt, Port, PHY_BCOM_AUX_CTRL, &Stat2);
+		SkXmPhyRead(pAC, IoC, Port, PHY_BCOM_AUX_CTRL, &Stat2);
 		Stat3 = 0;
-		PHY_READ(pAC, pPrt, Port, PHY_BCOM_AUX_STAT, &Stat3);
+		SkXmPhyRead(pAC, IoC, Port, PHY_BCOM_AUX_STAT, &Stat3);
 		Stat2 = Stat2 << 16 | Stat3;
 		CMSMPrintString(
 			pAC->pConfigTable,
@@ -1630,9 +1746,9 @@
 			(void *)Stat1,
 			(void *)Stat2);
 	}
-#endif	/* DEBUG */
+#endif /* DEBUG */
 
-	/* Now wait for each port's link. */
+	/* Now wait for each port's link */
 	if (pPrt->PLinkMode == SK_LMODE_HALF || pPrt->PLinkMode == SK_LMODE_FULL) {
 		AutoNeg = SK_FALSE;
 	}
@@ -1642,76 +1758,59 @@
 
 	/*
 	 * Here we usually can check whether the link is in sync and
-	 * autonegotiation is done.
+	 * auto-negotiation is done.
 	 */
-#if 0
-/* RA;:;: obsolete */
-	XM_IN16(IoC, Port, XM_ISRC, &Isrc);
-#endif	/* 0 */
-
-	PHY_READ(IoC, pPrt, Port, PHY_BCOM_STAT, &PhyStat);
 
-#ifdef xDEBUG
-	if ((PhyStat & PHY_ST_LSYNC) >> 2 != (ExtStat & PHY_B_PES_LS) >> 8) {
-		CMSMPrintString(
-			pAC->pConfigTable,
-			MSG_TYPE_RUNTIME_INFO,
-			"PhyStat != ExtStat: %x %x",
-			(void *)PhyStat,
-			(void *)ExtStat);
-	}
-#endif	/* DEBUG */
+	SkXmPhyRead(pAC, IoC, Port, PHY_BCOM_STAT, &PhyStat);
 
-	SkXmAutoNegLipaBcom(pAC, IoC, Port, PhyStat);
+	SkMacAutoNegLipaPhy(pAC, IoC, Port, PhyStat);
 	
 	SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_CTRL,
-		("AutoNeg:%d, PhyStat: %Xh.\n", AutoNeg, PhyStat));
+		("AutoNeg: %d, PhyStat: 0x%04X\n", AutoNeg, PhyStat));
 
-	PHY_READ(IoC, pPrt, Port, PHY_BCOM_1000T_STAT, &ResAb);
+	SkXmPhyRead(pAC, IoC, Port, PHY_BCOM_1000T_STAT, &ResAb);
 
-	if (ResAb & PHY_B_1000S_MSF) {
+	if ((ResAb & PHY_B_1000S_MSF) != 0) {
 		/* Error */
 		SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_CTRL,
 			("Master/Slave Fault port %d\n", Port));
 		pPrt->PAutoNegFail = SK_TRUE;
 		pPrt->PMSStatus = SK_MS_STAT_FAULT;
-		return (SK_HW_PS_RESTART);
+		
+		return(SK_HW_PS_RESTART);
 	}
 
 	if ((PhyStat & PHY_ST_LSYNC) == 0) {
-		return (SK_HW_PS_NONE);
-	}
-	else if (ResAb & PHY_B_1000S_MSR) {
-		pPrt->PMSStatus = SK_MS_STAT_MASTER;
-	}
-	else {
-		pPrt->PMSStatus = SK_MS_STAT_SLAVE;
+		return(SK_HW_PS_NONE);
 	}
 	
+	pPrt->PMSStatus = ((ResAb & PHY_B_1000S_MSR) != 0) ?
+		SK_MS_STAT_MASTER : SK_MS_STAT_SLAVE;
+	
 	SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_CTRL,
-		("AutoNeg:%d, PhyStat: %Xh.\n", AutoNeg, PhyStat));
+		("AutoNeg: %d, PhyStat: 0x%04X\n", AutoNeg, PhyStat));
 
 	if (AutoNeg) {
-		if (PhyStat & PHY_ST_AN_OVER) {
+		if ((PhyStat & PHY_ST_AN_OVER) != 0) {
 			SkHWLinkUp(pAC, IoC, Port);
-			Done = SkXmAutoNegDone(pAC, IoC, Port);
+			Done = SkMacAutoNegDone(pAC, IoC, Port);
 			if (Done != SK_AND_OK) {
 #ifdef DEBUG
-				/* Get PHY parameters, for debugging only. */
-				PHY_READ(IoC, pPrt, Port, PHY_BCOM_AUNE_LP, &LpAb);
-				PHY_READ(IoC, pPrt, Port, PHY_BCOM_1000T_STAT, &ExtStat);
+				/* Get PHY parameters, for debugging only */
+				SkXmPhyRead(pAC, IoC, Port, PHY_BCOM_AUNE_LP, &LpAb);
+				SkXmPhyRead(pAC, IoC, Port, PHY_BCOM_1000T_STAT, &ExtStat);
 				SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_CTRL,
 					("AutoNeg FAIL Port %d (LpAb %x, 1000TStat %x)\n",
 					Port, LpAb, ExtStat));
-#endif	/* DEBUG */
-				return (SK_HW_PS_RESTART);
+#endif /* DEBUG */
+				return(SK_HW_PS_RESTART);
 			}
 			else {
 #ifdef xDEBUG
-				/* Dummy read ISR to prevent extra link downs/ups. */
-				PHY_READ(IoC, pPrt, Port, PHY_BCOM_INT_STAT, &ExtStat);
+				/* Dummy read ISR to prevent extra link downs/ups */
+				SkXmPhyRead(pAC, IoC, Port, PHY_BCOM_INT_STAT, &ExtStat);
 
-				if ((ExtStat & ~0x1800) != 0) {
+				if ((ExtStat & ~(PHY_B_IS_HCT | PHY_B_IS_LCT)) != 0) {
 					CMSMPrintString(
 						pAC->pConfigTable,
 						MSG_TYPE_RUNTIME_INFO,
@@ -1719,30 +1818,28 @@
 						(void *)ExtStat,
 						(void *)NULL);
 				}
-#endif	/* DEBUG */
+#endif /* DEBUG */
 				
 				SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_CTRL,
 					("AutoNeg done Port %d\n", Port));
-				return (SK_HW_PS_LINK);
+				return(SK_HW_PS_LINK);
 			}
-		} 
+		}
 	}
 	else {	/* !AutoNeg */
-		/*
-		 * Link is up and we don't need more.
-		 */
-#ifdef	DEBUG
+		/* Link is up and we don't need more. */
+#ifdef DEBUG
 		if (pPrt->PLipaAutoNeg == SK_LIPA_AUTO) {
 			SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_CTRL,
 				("ERROR: Lipa auto detected on port %d\n", Port));
 		}
-#endif
+#endif /* DEBUG */
 
 #ifdef xDEBUG
-		/* Dummy read ISR to prevent extra link downs/ups. */
-		PHY_READ(IoC, pPrt, Port, PHY_BCOM_INT_STAT, &ExtStat);
+		/* Dummy read ISR to prevent extra link downs/ups */
+		SkXmPhyRead(pAC, IoC, Port, PHY_BCOM_INT_STAT, &ExtStat);
 
-		if ((ExtStat & ~0x1800) != 0) {
+		if ((ExtStat & ~(PHY_B_IS_HCT | PHY_B_IS_LCT)) != 0) {
 			CMSMPrintString(
 				pAC->pConfigTable,
 				MSG_TYPE_RUNTIME_INFO,
@@ -1750,54 +1847,175 @@
 				(void *)ExtStat,
 				(void *)NULL);
 		}
-#endif	/* DEBUG */
+#endif /* DEBUG */
 		
 		SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_IRQ,
 			("Link sync(GP), Port %d\n", Port));
 		SkHWLinkUp(pAC, IoC, Port);
-		return (SK_HW_PS_LINK);
+		
+		return(SK_HW_PS_LINK);
 	}
 
-	return (SK_HW_PS_NONE);
+	return(SK_HW_PS_NONE);
 }	/* SkGePortCheckUpBcom */
 
 
 /******************************************************************************
  *
- * SkGePortCheckUpLone - Check if the link is up
+ * SkGePortCheckUpGmac() - Check if the link is up on Marvell PHY
  *
  * return:
  *	0	o.k. nothing needed
  *	1	Restart needed on this port
  *	2	Link came up
  */
-static int	SkGePortCheckUpLone(
+static int SkGePortCheckUpGmac(
+SK_AC	*pAC,	/* Adapter Context */
+SK_IOC	IoC,	/* IO Context */
+int		Port)	/* Which port should be checked */
+{
+	SK_GEPORT	*pPrt;		/* GIni Port struct pointer */
+	int			Done;
+	SK_U16		Isrc;		/* Interrupt source */
+	SK_U16		PhyStat;	/* Phy Status */
+	SK_U16		PhySpecStat;/* Phy Specific Status */
+	SK_U16		ResAb;		/* Master/Slave resolution */
+	SK_BOOL		AutoNeg;	/* Is Auto-negotiation used ? */
+
+	pPrt = &pAC->GIni.GP[Port];
+
+	/* Read PHY Interrupt Status */
+	SkGmPhyRead(pAC, IoC, Port, PHY_MARV_INT_STAT, &Isrc);
+
+	if ((Isrc & PHY_M_IS_AN_COMPL) != 0) {
+		/* TBD */
+	}
+
+	if ((Isrc & PHY_M_IS_DOWNSH_DET) != 0) {
+		SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_CTRL,
+			("Downshift detected port %d\n", Port));
+	}
+
+	if (pPrt->PHWLinkUp) {
+		return(SK_HW_PS_NONE);
+	}
+
+	/* Now wait for each port's link */
+	if (pPrt->PLinkMode == SK_LMODE_HALF || pPrt->PLinkMode == SK_LMODE_FULL) {
+		AutoNeg = SK_FALSE;
+	}
+	else {
+		AutoNeg = SK_TRUE;
+	}
+
+	/* Read PHY Status */
+	SkGmPhyRead(pAC, IoC, Port, PHY_MARV_STAT, &PhyStat);
+
+	SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_CTRL,
+		("AutoNeg: %d, PhyStat: 0x%04X\n", AutoNeg, PhyStat));
+
+	SkMacAutoNegLipaPhy(pAC, IoC, Port, PhyStat);
+	
+	SkGmPhyRead(pAC, IoC, Port, PHY_MARV_1000T_STAT, &ResAb);
+
+	if ((ResAb & PHY_B_1000S_MSF) != 0) {
+		/* Error */
+		SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_CTRL,
+			("Master/Slave Fault port %d\n", Port));
+		pPrt->PAutoNegFail = SK_TRUE;
+		pPrt->PMSStatus = SK_MS_STAT_FAULT;
+		
+		return(SK_HW_PS_RESTART);
+	}
+
+	/* Read PHY Specific Status */
+	SkGmPhyRead(pAC, IoC, Port, PHY_MARV_PHY_STAT, &PhySpecStat);
+	
+	SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_CTRL,
+		("AutoNeg: %d, PhySpecStat: 0x%04X\n", AutoNeg, PhySpecStat));
+
+	if ((PhySpecStat & PHY_M_PS_LINK_UP) == 0) {
+		return(SK_HW_PS_NONE);
+	}
+	
+	pPrt->PMSStatus = ((ResAb & PHY_B_1000S_MSR) != 0) ?
+		SK_MS_STAT_MASTER : SK_MS_STAT_SLAVE;
+	
+	pPrt->PCableLen = (SK_U8)((PhySpecStat & PHY_M_PS_CABLE_MSK) >> 7);
+	
+	if (AutoNeg) {
+		/* Auto-Negotiation Over ? */
+		if ((PhyStat & PHY_ST_AN_OVER) != 0) {
+			
+			SkHWLinkUp(pAC, IoC, Port);
+			
+			Done = SkMacAutoNegDone(pAC, IoC, Port);
+			
+			if (Done != SK_AND_OK) {
+				return(SK_HW_PS_RESTART);
+			}
+			
+			SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_CTRL,
+				("AutoNeg done Port %d\n", Port));
+			return(SK_HW_PS_LINK);
+		}
+	}
+	else {	/* !AutoNeg */
+		/* Link is up and we don't need more */
+#ifdef DEBUG
+		if (pPrt->PLipaAutoNeg == SK_LIPA_AUTO) {
+			SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_CTRL,
+				("ERROR: Lipa auto detected on port %d\n", Port));
+		}
+#endif /* DEBUG */
+
+		SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_IRQ,
+			("Link sync, Port %d\n", Port));
+		SkHWLinkUp(pAC, IoC, Port);
+		
+		return(SK_HW_PS_LINK);
+	}
+
+	return(SK_HW_PS_NONE);
+}	/* SkGePortCheckUpGmac */
+
+
+#ifdef OTHER_PHY
+/******************************************************************************
+ *
+ * SkGePortCheckUpLone() - Check if the link is up on Level One PHY
+ *
+ * return:
+ *	0	o.k. nothing needed
+ *	1	Restart needed on this port
+ *	2	Link came up
+ */
+static int SkGePortCheckUpLone(
 SK_AC	*pAC,		/* Adapter Context */
 SK_IOC	IoC,		/* IO Context */
 int		Port)		/* Which port should be checked */
 {
 	SK_GEPORT	*pPrt;		/* GIni Port struct pointer */
-	int		Done;
+	int			Done;
 	SK_U16		Isrc;		/* Interrupt source register */
 	SK_U16		LpAb;		/* Link Partner Ability */
 	SK_U16		ExtStat;	/* Extended Status Register */
 	SK_U16		PhyStat;	/* Phy Status Register */
 	SK_U16		StatSum;
-	SK_BOOL		AutoNeg;	/* Is Autonegotiation used ? */
+	SK_BOOL		AutoNeg;	/* Is Auto-negotiation used ? */
 	SK_U8		NextMode;	/* Next AutoSensing Mode */
 
 	pPrt = &pAC->GIni.GP[Port];
 
 	if (pPrt->PHWLinkUp) {
-		return (SK_HW_PS_NONE);
+		return(SK_HW_PS_NONE);
 	}
 
 	StatSum = pPrt->PIsave;
 	pPrt->PIsave = 0;
 
 	/* Now wait for each ports link */
-	if (pPrt->PLinkMode == SK_LMODE_HALF ||
-	    pPrt->PLinkMode == SK_LMODE_FULL) {
+	if (pPrt->PLinkMode == SK_LMODE_HALF || pPrt->PLinkMode == SK_LMODE_FULL) {
 		AutoNeg = SK_FALSE;
 	}
 	else {
@@ -1806,39 +2024,33 @@
 
 	/*
 	 * here we usually can check whether the link is in sync and
-	 * autonegotiation is done.
+	 * auto-negotiation is done.
 	 */
-	XM_IN16(IoC, Port, XM_ISRC, &Isrc);
-	PHY_READ(IoC, pPrt, Port, PHY_LONE_STAT, &PhyStat);
+	SkXmPhyRead(pAC, IoC, Port, PHY_LONE_STAT, &PhyStat);
 	StatSum |= PhyStat;
 
-	SkXmAutoNegLipaLone(pAC, IoC, Port, PhyStat);
-	if ((PhyStat & PHY_ST_LSYNC) == 0){
-		/*
-		 * Save Autonegotiation Done bit
-		 */
+	SkMacAutoNegLipaPhy(pAC, IoC, Port, PhyStat);
+	
+	if ((PhyStat & PHY_ST_LSYNC) == 0) {
+		/* Save Auto-negotiation Done bit */
 		pPrt->PIsave = (SK_U16)(StatSum & PHY_ST_AN_OVER);
 #ifdef DEBUG
-		if (pPrt->PIsave & PHY_ST_AN_OVER) {
-			SK_DBG_MSG(pAC,SK_DBGMOD_HWM,SK_DBGCAT_CTRL,
+		if ((pPrt->PIsave & PHY_ST_AN_OVER) != 0) {
+			SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_CTRL,
 				("AutoNeg done rescheduled Port %d\n", Port));
 		}
-#endif
-		return (SK_HW_PS_NONE);
+#endif /* DEBUG */
+		return(SK_HW_PS_NONE);
 	}
 
 	if (AutoNeg) {
-		if (StatSum & PHY_ST_AN_OVER) {
+		if ((StatSum & PHY_ST_AN_OVER) != 0) {
 			SkHWLinkUp(pAC, IoC, Port);
-			Done = SkXmAutoNegDone(pAC,IoC,Port);
+			Done = SkMacAutoNegDone(pAC, IoC, Port);
 			if (Done != SK_AND_OK) {
-				/* Get PHY parameters, for debuging only */
-				PHY_READ(IoC, pPrt, Port,
-					PHY_LONE_AUNE_LP,
-					&LpAb);
-				PHY_READ(IoC, pPrt, Port,
-					PHY_LONE_1000T_STAT,
-					&ExtStat);
+				/* Get PHY parameters, for debugging only */
+				SkXmPhyRead(pAC, IoC, Port, PHY_LONE_AUNE_LP, &LpAb);
+				SkXmPhyRead(pAC, IoC, Port, PHY_LONE_1000T_STAT, &ExtStat);
 				SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_CTRL,
 					("AutoNeg FAIL Port %d (LpAb %x, 1000TStat %x)\n",
 					 Port, LpAb, ExtStat));
@@ -1851,7 +2063,7 @@
 					SkHWSenseSetNext(pAC, IoC, Port, NextMode);
 				}
 
-				return (SK_HW_PS_RESTART);
+				return(SK_HW_PS_RESTART);
 
 			}
 			else {
@@ -1859,95 +2071,80 @@
 				 * Dummy Read interrupt status to prevent
 				 * extra link down/ups
 				 */
-				PHY_READ(IoC, pPrt, Port, PHY_LONE_INT_STAT, &ExtStat);
+				SkXmPhyRead(pAC, IoC, Port, PHY_LONE_INT_STAT, &ExtStat);
 				SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_CTRL,
 					("AutoNeg done Port %d\n", Port));
-				return (SK_HW_PS_LINK);
+				return(SK_HW_PS_LINK);
 			}
-		} 
+		}
 		
-		/*
-		 * AutoNeg not done, but HW link is up. Check for timeouts
-		 */
-		pPrt->PAutoNegTimeOut ++;
+		/* AutoNeg not done, but HW link is up. Check for timeouts */
+		pPrt->PAutoNegTimeOut++;
 		if (pPrt->PAutoNegTimeOut >= SK_AND_MAX_TO) {
-			/*
-			 * Timeout occured.
-			 * What do we need now?
-			 */
-			SK_DBG_MSG(pAC,SK_DBGMOD_HWM,
-				SK_DBGCAT_IRQ,
-				("AutoNeg timeout Port %d\n",
-				 Port));
+			/* Timeout occured */
+			SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_IRQ,
+				("AutoNeg timeout Port %d\n", Port));
 			if (pPrt->PLinkModeConf == SK_LMODE_AUTOSENSE &&
 				pPrt->PLipaAutoNeg != SK_LIPA_AUTO) {
-				/*
-				 * Timeout occured
-				 * Set Link manually up.
-				 */
-				SkHWSenseSetNext(pAC, IoC, Port,
-					SK_LMODE_FULL);
-				SK_DBG_MSG(pAC,SK_DBGMOD_HWM,
-					SK_DBGCAT_IRQ,
-					("Set manual full duplex Port %d\n",
-					 Port));
+				/* Set Link manually up */
+				SkHWSenseSetNext(pAC, IoC, Port, SK_LMODE_FULL);
+				SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_IRQ,
+					("Set manual full duplex Port %d\n", Port));
 			}
 
-			/*
-			 * Do the restart
-			 */
-			return (SK_HW_PS_RESTART);
+			/* Do the restart */
+			return(SK_HW_PS_RESTART);
 		}
 	}
 	else {
-		/*
-		 * Link is up and we don't need more.
-		 */
-#ifdef	DEBUG
+		/* Link is up and we don't need more */
+#ifdef DEBUG
 		if (pPrt->PLipaAutoNeg == SK_LIPA_AUTO) {
 			SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_CTRL,
 				("ERROR: Lipa auto detected on port %d\n", Port));
 		}
-#endif
+#endif /* DEBUG */
 
 		/*
 		 * Dummy Read interrupt status to prevent
 		 * extra link down/ups
 		 */
-		PHY_READ(IoC, pPrt, Port, PHY_LONE_INT_STAT, &ExtStat);
+		SkXmPhyRead(pAC, IoC, Port, PHY_LONE_INT_STAT, &ExtStat);
 		
 		SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_IRQ,
 			("Link sync(GP), Port %d\n", Port));
 		SkHWLinkUp(pAC, IoC, Port);
-		return (SK_HW_PS_LINK);
+		
+		return(SK_HW_PS_LINK);
 	}
 
-	return (SK_HW_PS_NONE);
-}	/* SkGePortCheckUpLone*/
+	return(SK_HW_PS_NONE);
+}	/* SkGePortCheckUpLone */
 
 
 /******************************************************************************
  *
- * SkGePortCheckUpNat - Check if the link is up
+ * SkGePortCheckUpNat() - Check if the link is up on National PHY
  *
  * return:
  *	0	o.k. nothing needed
  *	1	Restart needed on this port
  *	2	Link came up
  */
-static int	SkGePortCheckUpNat(
+static int SkGePortCheckUpNat(
 SK_AC	*pAC,		/* Adapter Context */
 SK_IOC	IoC,		/* IO Context */
 int		Port)		/* Which port should be checked */
 {
 	/* todo: National */
-	return (SK_HW_PS_NONE);
+	return(SK_HW_PS_NONE);
 }	/* SkGePortCheckUpNat */
+#endif /* OTHER_PHY */
 
 
 /******************************************************************************
  *
- *	Event service routine
+ *	SkGeSirqEvent() - Event Service Routine
  *
  * Description:
  *
@@ -1968,7 +2165,7 @@
 	SK_U8		Val8;
 
 	Port = Para.Para32[0];
-	pPrt = & pAC->GIni.GP[Port];
+	pPrt = &pAC->GIni.GP[Port];
 
 	switch (Event) {
 	case SK_HWEV_WATIM:
@@ -1978,9 +2175,7 @@
 		switch (PortStat) {
 		case SK_HW_PS_RESTART:
 			if (pPrt->PHWLinkUp) {
-				/*
-				 * Set Link to down.
-				 */
+				/* Set Link to down */
 				SkHWLinkDown(pAC, IoC, Port);
 
 				/*
@@ -2010,9 +2205,9 @@
 		}
 
 		/* Todo: still needed for non-XMAC PHYs??? */
-		/* Start workaround Errata #2 timer. */
-		SkTimerStart(pAC, IoC, &pAC->GIni.GP[Port].PWaTimer,
-			Time, SKGE_HWAC, SK_HWEV_WATIM, Para);
+		/* Start workaround Errata #2 timer */
+		SkTimerStart(pAC, IoC, &pPrt->PWaTimer, Time,
+			SKGE_HWAC, SK_HWEV_WATIM, Para);
 		break;
 
 	case SK_HWEV_PORT_START:
@@ -2035,7 +2230,7 @@
 		break;
 
 	case SK_HWEV_PORT_STOP:
-		if (pAC->GIni.GP[Port].PHWLinkUp) {
+		if (pPrt->PHWLinkUp) {
 			/*
 			 * Signal directly to RLMT to ensure correct
 			 * sequence of SWITCH and RESET event.
@@ -2087,6 +2282,10 @@
 		break;
 
 	case SK_HWEV_SET_ROLE:
+		/* not possible for fiber */
+		if (!pAC->GIni.GICopperType) {
+			break;
+		}
 		Val8 = (SK_U8)Para.Para32[1];
 		if (pPrt->PMSMode != Val8) {
 			/* Set New link mode */
@@ -2098,38 +2297,56 @@
 		}
 		break;
 
+	case SK_HWEV_SET_SPEED:
+		if (pPrt->PhyType != SK_PHY_MARV_COPPER) {
+			break;
+		}
+		Val8 = (SK_U8)Para.Para32[1];
+		if (pPrt->PLinkSpeed != Val8) {
+			/* Set New Speed parameter */
+			pPrt->PLinkSpeed = Val8;
+
+			/* Restart Port */
+			SkEventQueue(pAC, SKGE_HWAC, SK_HWEV_PORT_STOP, Para);
+			SkEventQueue(pAC, SKGE_HWAC, SK_HWEV_PORT_START, Para);
+		}
+		break;
+
 	case SK_HWEV_HALFDUP_CHK:
 		/*
-		 * half duplex hangup workaround. See packet arbiter timeout
-		 * interrupt for description
+		 * half duplex hangup workaround.
+		 * See packet arbiter timeout interrupt for description
 		 */
 		pPrt->HalfDupTimerActive = SK_FALSE;
-		if (pPrt->PLinkModeStatus == SK_LMODE_STAT_HALF || 
+		if (pPrt->PLinkModeStatus == SK_LMODE_STAT_HALF ||
 		    pPrt->PLinkModeStatus == SK_LMODE_STAT_AUTOHALF) {
+			
 			Len = sizeof(SK_U64);
 			SkPnmiGetVar(pAC, IoC, OID_SKGE_STAT_TX_OCTETS, (char *)&Octets,
 				&Len, (SK_U32)SK_PNMI_PORT_PHYS2INST(pAC, Port),
 				pAC->Rlmt.Port[Port].Net->NetNumber);
+			
 			if (pPrt->LastOctets == Octets) {
-				/* TX hanging, do a FIFO flush restarts it. */
-				SkXmFlushTxFifo(pAC, IoC, Port);
+				/* Tx hanging, a FIFO flush restarts it */
+				SkMacFlushTxFifo(pAC, IoC, Port);
 			}
 		}
 		break;
+	
 	default:
 		SK_ERR_LOG(pAC, SK_ERRCL_SW, SKERR_SIRQ_E001, SKERR_SIRQ_E001MSG);
 		break;
 	}
 
-	return (0);
+	return(0);
 }	/* SkGeSirqEvent */
 
 
 /******************************************************************************
  *
- *	SkPhyIsrBcom - PHY interrupt service routine
+ *	SkPhyIsrBcom() - PHY interrupt service routine
  *
- * Description: handle all interrupts from BCOM PHY
+ * Description: handles all interrupts from BCom PHY
  *
  * Returns: N/A
  */
@@ -2144,79 +2361,91 @@
 
 	pPrt = &pAC->GIni.GP[Port];
 
-	if (IStatus & PHY_B_IS_PSE) {
-		/* Incorrectable pair swap error. */
+	if ((IStatus & PHY_B_IS_PSE) != 0) {
+		/* Incorrectable pair swap error */
 		SK_ERR_LOG(pAC, SK_ERRCL_SW | SK_ERRCL_INIT, SKERR_SIRQ_E022,
 			SKERR_SIRQ_E022MSG);
 	}
 	
-	if (IStatus & PHY_B_IS_MDXI_SC) {
-		/* not used */
-	}
-	
-	if (IStatus & PHY_B_IS_HCT) {
-		/* not used */
-	}
-	
-	if (IStatus & PHY_B_IS_LCT) {
-		/* not used */
-	}
-	
-	if (IStatus & (PHY_B_IS_AN_PR | PHY_B_IS_LST_CHANGE)) {
-		Para.Para32[0] = (SK_U32)Port;
+	if ((IStatus & (PHY_B_IS_AN_PR | PHY_B_IS_LST_CHANGE)) != 0) {
 
 		SkHWLinkDown(pAC, IoC, Port);
 
+		Para.Para32[0] = (SK_U32)Port;
 		/* Signal to RLMT */
 		SkEventQueue(pAC, SKGE_RLMT, SK_RLMT_LINK_DOWN, Para);
 
 		/* Start workaround Errata #2 timer */
-		SkTimerStart(pAC, IoC, &pPrt->PWaTimer,
-			SK_WA_INA_TIME, SKGE_HWAC, SK_HWEV_WATIM, Para);
+		SkTimerStart(pAC, IoC, &pPrt->PWaTimer, SK_WA_INA_TIME,
+			SKGE_HWAC, SK_HWEV_WATIM, Para);
 	}
 
-	if (IStatus & PHY_B_IS_NO_HDCL) {
-	}
+}	/* SkPhyIsrBcom */
 
-	if (IStatus & PHY_B_IS_NO_HDC) {
-		/* not used */
-	}
 
-	if (IStatus & PHY_B_IS_NEG_USHDC) {
-		/* not used */
-	}
+/******************************************************************************
+ *
+ *	SkPhyIsrGmac() - PHY interrupt service routine
+ *
+ * Description: handles all interrupts from Marvell PHY
+ *
+ * Returns: N/A
+ */
+static void SkPhyIsrGmac(
+SK_AC		*pAC,		/* Adapter Context */
+SK_IOC		IoC,		/* Io Context */
+int			Port,		/* Port Num = PHY Num */
+SK_U16		IStatus)	/* Interrupt Status */
+{
+	SK_GEPORT	*pPrt;		/* GIni Port struct pointer */
+	SK_EVPARA	Para;
+	SK_U16		Word;
 
-	if (IStatus & PHY_B_IS_SCR_S_ER) {
-		/* not used */
-	}
+	pPrt = &pAC->GIni.GP[Port];
 
-	if (IStatus & PHY_B_IS_RRS_CHANGE) {
-		/* not used */
-	}
+	if ((IStatus & (PHY_M_IS_AN_PR | PHY_M_IS_LST_CHANGE)) != 0) {
 
-	if (IStatus & PHY_B_IS_LRS_CHANGE) {
-		/* not used */
-	}
+		SkHWLinkDown(pAC, IoC, Port);
 
-	if (IStatus & PHY_B_IS_DUP_CHANGE) {
-		/* not used */
-	}
+		SkGmPhyRead(pAC, IoC, Port, PHY_MARV_AUNE_ADV, &Word);
 
-	if (IStatus & PHY_B_IS_LSP_CHANGE) {
-		/* not used */
+		SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_CTRL,
+			("AutoNeg.Adv: 0x%04X\n", Word));
+		
+		/* Set Auto-negotiation advertisement */
+		if (pPrt->PFlowCtrlMode == SK_FLOW_MODE_SYM_OR_REM) {
+			/* restore Asymmetric Pause bit */
+			SkGmPhyWrite(pAC, IoC, Port, PHY_MARV_AUNE_ADV,
+				(SK_U16)(Word | PHY_M_AN_ASP));
+		}
+		
+		Para.Para32[0] = (SK_U32)Port;
+		/* Signal to RLMT */
+		SkEventQueue(pAC, SKGE_RLMT, SK_RLMT_LINK_DOWN, Para);
 	}
-
-	if (IStatus & PHY_B_IS_CRC_ER) {
-		/* not used */
+	
+	if ((IStatus & PHY_M_IS_AN_ERROR) != 0) {
+		/* Auto-Negotiation Error */
+		SK_ERR_LOG(pAC, SK_ERRCL_HW, SKERR_SIRQ_E023, SKERR_SIRQ_E023MSG);
 	}
-}	/* SkPhyIsrBcom */
+	
+	if ((IStatus & PHY_M_IS_LSP_CHANGE) != 0) {
+		/* TBD */
+	}
+	
+	if ((IStatus & PHY_M_IS_FIFO_ERROR) != 0) {
+		/* FIFO Overflow/Underrun Error */
+		SK_ERR_LOG(pAC, SK_ERRCL_HW, SKERR_SIRQ_E024, SKERR_SIRQ_E024MSG);
+	}
+}	/* SkPhyIsrGmac */
 
 
+#ifdef OTHER_PHY
 /******************************************************************************
  *
- *	SkPhyIsrLone - PHY interrupt service routine
+ *	SkPhyIsrLone() - PHY interrupt service routine
  *
- * Description: handle all interrupts from LONE PHY
+ * Description: handles all interrupts from LONE PHY
  *
  * Returns: N/A
  */
@@ -2228,49 +2457,16 @@
 {
 	SK_EVPARA	Para;
 
-	if (IStatus & PHY_L_IS_CROSS) {
-		/* not used */
-	}
-	
-	if (IStatus & PHY_L_IS_POL) {
-		/* not used */
-	}
-	
-	if (IStatus & PHY_L_IS_SS) {
-		/* not used */
-	}
-	
-	if (IStatus & PHY_L_IS_CFULL) {
-		/* not used */
-	}
-	
-	if (IStatus & PHY_L_IS_AN_C) {
-		/* not used */
-	}
-	
-	if (IStatus & PHY_L_IS_SPEED) {
-		/* not used */
-	}
-	
-	if (IStatus & PHY_L_IS_CFULL) {
-		/* not used */
-	}
-	
 	if (IStatus & (PHY_L_IS_DUP | PHY_L_IS_ISOL)) {
+		
 		SkHWLinkDown(pAC, IoC, Port);
 
-		/* Signal to RLMT */
 		Para.Para32[0] = (SK_U32)Port;
+		/* Signal to RLMT */
 		SkEventQueue(pAC, SKGE_RLMT, SK_RLMT_LINK_DOWN, Para);
-
-		/* Start workaround Errata #2 timer */
-		SkTimerStart(pAC, IoC, &pAC->GIni.GP[Port].PWaTimer,
-			SK_WA_INA_TIME, SKGE_HWAC, SK_HWEV_WATIM, Para);
 	}
 
-	if (IStatus & PHY_L_IS_MDINT) {
-		/* not used */
-	}
 }	/* SkPhyIsrLone */
+#endif /* OTHER_PHY */
 
 /* End of File */
diff -ruN linux/drivers/net/sk98lin/ski2c.c linuxn/drivers/net/sk98lin/ski2c.c
--- linux/drivers/net/sk98lin/ski2c.c	Wed Jul  4 20:50:39 2001
+++ linuxn/drivers/net/sk98lin/ski2c.c	Tue May 20 12:17:40 2003
@@ -2,16 +2,15 @@
  *
  * Name:	ski2c.c
  * Project:	GEnesis, PCI Gigabit Ethernet Adapter
- * Version:	$Revision: 1.47 $
- * Date:	$Date: 2001/04/05 11:38:09 $
+ * Version:	$Revision: 1.57 $
+ * Date:	$Date: 2003/01/28 09:17:38 $
  * Purpose:	Functions to access Voltage and Temperature Sensor
- *			(taken from Monalisa (taken from Concentrator))
  *
  ******************************************************************************/
 
 /******************************************************************************
  *
- *	(C)Copyright 1998-2001 SysKonnect GmbH.
+ *	(C)Copyright 1998-2003 SysKonnect GmbH.
  *
  *	This program is free software; you can redistribute it and/or modify
  *	it under the terms of the GNU General Public License as published by
@@ -27,6 +26,47 @@
  * History:
  *
  *	$Log: ski2c.c,v $
+ *	Revision 1.57  2003/01/28 09:17:38  rschmidt
+ *	Fixed handling for sensors on YUKON Fiber.
+ *	Editorial changes.
+ *	
+ *	Revision 1.56  2002/12/19 14:20:41  rschmidt
+ *	Added debugging code in SkI2cWait().
+ *	Replaced all I2C-write operations with function SkI2cWrite().
+ *	Fixed compiler warning because of uninitialized 'Time' in SkI2cEvent().
+ *	Editorial changes.
+ *	
+ *	Revision 1.55  2002/10/15 07:23:55  rschmidt
+ *	Added setting of the GIYukon32Bit bool variable to distinguish
+ *	32-bit adapters.
+ *	Editorial changes (TWSI).
+ *	
+ *	Revision 1.54  2002/08/13 09:05:06  rschmidt
+ *	Added new thresholds if VAUX is not available (GIVauxAvail).
+ *	Merged defines for PHY PLL 3V3 voltage (A and B).
+ *	Editorial changes.
+ *	
+ *	Revision 1.53  2002/08/08 11:04:53  rwahl
+ *	Added missing comment for revision 1.51
+ *	
+ *	Revision 1.52  2002/08/08 10:09:02  jschmalz
+ *	Sensor init state caused wrong error log entry
+ *	
+ *	Revision 1.51  2002/08/06 09:43:03  jschmalz
+ *	Extensions and changes for Yukon
+ *	
+ *	Revision 1.50  2002/08/02 12:09:22  rschmidt
+ *	Added support for YUKON sensors.
+ *	Editorial changes.
+ *	
+ *	Revision 1.49  2002/07/30 11:07:52  rschmidt
+ *	Replaced MaxSens init by update for Copper in SkI2cInit1(),
+ *	because it was already initialized in SkI2cInit0().
+ *	Editorial changes.
+ *	
+ *	Revision 1.48  2001/08/16 12:44:33  afischer
+ *	LM80 sensor init values corrected
+ *	
  *	Revision 1.47  2001/04/05 11:38:09  rassmann
  *	Set SenState to idle in SkI2cWaitIrq().
  *	Changed error message in SkI2cWaitIrq().
@@ -178,7 +218,7 @@
  *	Revision 1.2  1998/08/11 07:27:15  gklug
  *	add: functions of the interface
  *	adapt rest of source to C coding Conventions
- *	rmv: unneccessary code taken from Mona Lisa
+ *	rmv: unnecessary code taken from Mona Lisa
  *
  *	Revision 1.1  1998/06/19 14:28:43  malthoff
  *	Created. Sources taken from ML Projekt.
@@ -192,7 +232,7 @@
  *	I2C Protocol
  */
 static const char SysKonnectFileId[] =
-	"$Id: ski2c.c,v 1.47 2001/04/05 11:38:09 rassmann Exp $";
+	"$Id: ski2c.c,v 1.57 2003/01/28 09:17:38 rschmidt Exp $";
 
 #include "h/skdrv1st.h"		/* Driver Specific Definitions */
 #include "h/lm80.h"
@@ -213,7 +253,7 @@
 	The Genesis has 2 I2C buses. One for the EEPROM which holds
 	the VPD Data and one for temperature and voltage sensor.
 	The following picture shows the I2C buses, I2C devices and
-	there control registers.
+	their control registers.
 
 	Note: The VPD functions are in skvpd.c
 .
@@ -278,23 +318,23 @@
  * If new devices are added to the I2C bus the timing values have to be checked.
  */
 #ifndef I2C_SLOW_TIMING
-#define	T_CLK_LOW		1300L	/* clock low time in ns */
-#define	T_CLK_HIGH		 600L	/* clock high time in ns */
-#define T_DATA_IN_SETUP		 100L	/* data in Set-UP Time */
+#define	T_CLK_LOW			1300L	/* clock low time in ns */
+#define	T_CLK_HIGH		 	 600L	/* clock high time in ns */
+#define T_DATA_IN_SETUP		 100L	/* data in Set-up Time */
 #define T_START_HOLD		 600L	/* start condition hold time */
 #define T_START_SETUP		 600L	/* start condition Set-up time */
 #define	T_STOP_SETUP		 600L	/* stop condition Set-up time */
-#define T_BUS_IDLE		1300L	/* time the bus must free after tx */
+#define T_BUS_IDLE			1300L	/* time the bus must free after Tx */
 #define	T_CLK_2_DATA_OUT	 900L	/* max. clock low to data output valid */
 #else	/* I2C_SLOW_TIMING */
 /* I2C Standard Mode Timing */
-#define	T_CLK_LOW		4700L	/* clock low time in ns */
-#define	T_CLK_HIGH		4000L	/* clock high time in ns */
-#define T_DATA_IN_SETUP		 250L	/* data in Set-UP Time */
+#define	T_CLK_LOW			4700L	/* clock low time in ns */
+#define	T_CLK_HIGH			4000L	/* clock high time in ns */
+#define T_DATA_IN_SETUP		 250L	/* data in Set-up Time */
 #define T_START_HOLD		4000L	/* start condition hold time */
-#define T_START_SETUP		4700L	/* start condition Set_up time */
+#define T_START_SETUP		4700L	/* start condition Set-up time */
 #define	T_STOP_SETUP		4000L	/* stop condition Set-up time */
-#define T_BUS_IDLE		4700L	/* time the bus must free after tx */
+#define T_BUS_IDLE			4700L	/* time the bus must free after Tx */
 #endif	/* !I2C_SLOW_TIMING */
 
 #define NS2BCLK(x)	(((x)*125)/10000)
@@ -312,9 +352,9 @@
 #define I2C_DATA_HIGH(IoC)	SK_I2C_SET_BIT(IoC, I2C_DATA)
 #define	I2C_DATA_LOW(IoC)	SK_I2C_CLR_BIT(IoC, I2C_DATA)
 #define	I2C_DATA_OUT(IoC)	SK_I2C_SET_BIT(IoC, I2C_DATA_DIR)
-#define	I2C_DATA_IN(IoC)	SK_I2C_CLR_BIT(IoC, I2C_DATA_DIR|I2C_DATA)
+#define	I2C_DATA_IN(IoC)	SK_I2C_CLR_BIT(IoC, I2C_DATA_DIR | I2C_DATA)
 #define	I2C_CLK_HIGH(IoC)	SK_I2C_SET_BIT(IoC, I2C_CLK)
-#define	I2C_CLK_LOW(IoC)	SK_I2C_CLR_BIT(IoC, I2C_CLK|I2C_DATA_DIR)
+#define	I2C_CLK_LOW(IoC)	SK_I2C_CLR_BIT(IoC, I2C_CLK | I2C_DATA_DIR)
 #define	I2C_START_COND(IoC)	SK_I2C_CLR_BIT(IoC, I2C_CLK)
 
 #define NS2CLKT(x)	((x*125L)/10000)
@@ -331,7 +371,8 @@
 	I2C_DATA_OUT(IoC);
 	if (Bit) {
 		I2C_DATA_HIGH(IoC);
-	} else {
+	}
+	else {
 		I2C_DATA_LOW(IoC);
 	}
 	SkDgWaitTime(IoC, NS2BCLK(T_DATA_IN_SETUP));
@@ -428,11 +469,8 @@
 	SkDgWaitTime(IoC, NS2BCLK(T_CLK_HIGH));
 
 	SK_I2C_GET_SW(IoC, &I2cSwCtrl);
-	if (I2cSwCtrl & I2C_DATA) {
-		Bit = 1;
-	} else {
-		Bit = 0;
-	}
+	
+	Bit = (I2cSwCtrl & I2C_DATA) ? 1 : 0;
 
 	I2C_CLK_LOW(IoC);
 	SkDgWaitTime(IoC, NS2BCLK(T_CLK_LOW-T_CLK_2_DATA_OUT));
@@ -444,16 +482,16 @@
 /*
  * Receive an ACK.
  *
- * returns	0 If acknoledged
+ * returns	0 If acknowledged
  *		1 in case of an error
  */
 int SkI2cRcvAck(
-SK_IOC IoC)	/* I/O Context */
+SK_IOC	IoC)	/* I/O Context */
 {
 	/*
 	 * Received bit must be zero.
 	 */
-	return (SkI2cRcvBit(IoC) != 0);
+	return(SkI2cRcvBit(IoC) != 0);
 }	/* SkI2cRcvAck */
 
 
@@ -461,7 +499,7 @@
  * Send an NACK.
  */
 void SkI2cSndNAck(
-SK_IOC IoC)	/* I/O Context */
+SK_IOC	IoC)	/* I/O Context */
 {
 	/*
 	 * Received bit must be zero.
@@ -487,18 +525,19 @@
 /*
  * Send one byte to the I2C device and wait for ACK.
  *
- * Return acknoleged status.
+ * Return acknowleged status.
  */
 int SkI2cSndByte(
 SK_IOC	IoC,	/* I/O Context */
-int	Byte)		/* byte to send */
+int		Byte)	/* byte to send */
 {
 	int	i;
 
 	for (i = 0; i < 8; i++) {
 		if (Byte & (1<<(7-i))) {
 			SkI2cSndBit(IoC, 1);
-		} else {
+		}
+		else {
 			SkI2cSndBit(IoC, 0);
 		}
 	}
@@ -514,7 +553,7 @@
  */
 int SkI2cRcvByte(
 SK_IOC	IoC,	/* I/O Context */
-int	Last)		/* Last Byte Flag */
+int		Last)	/* Last Byte Flag */
 {
 	int	i;
 	int	Byte = 0;
@@ -526,7 +565,8 @@
 
 	if (Last) {
 		SkI2cSndNAck(IoC);
-	} else {
+	}
+	else {
 		SkI2cSndAck(IoC);
 	}
 
@@ -537,7 +577,7 @@
 /*
  * Start dialog and send device address
  *
- * Return 0 if acknoleged, 1 in case of an error
+ * Return 0 if acknowleged, 1 in case of an error
  */
 int	SkI2cSndDev(
 SK_IOC	IoC,	/* I/O Context */
@@ -545,7 +585,7 @@
 int		Rw)		/* Read / Write Flag */
 {
 	SkI2cStart(IoC);
-	Rw = ~Rw; 
+	Rw = ~Rw;
 	Rw &= I2C_WRITE;
 	return(SkI2cSndByte(IoC, (Addr<<1) | Rw));
 }	/* SkI2cSndDev */
@@ -567,18 +607,33 @@
 int		Event)	/* complete event to wait for (I2C_READ or I2C_WRITE) */
 {
 	SK_U64	StartTime;
+	SK_U64	CurrentTime;
 	SK_U32	I2cCtrl;
 
 	StartTime = SkOsGetTime(pAC);
+	
 	do {
-		if (SkOsGetTime(pAC) - StartTime > SK_TICKS_PER_SEC / 8) {
+		CurrentTime = SkOsGetTime(pAC);
+
+		if (CurrentTime - StartTime > SK_TICKS_PER_SEC / 8) {
+			
 			SK_I2C_STOP(IoC);
 #ifndef SK_DIAG
 			SK_ERR_LOG(pAC, SK_ERRCL_SW, SKERR_I2C_E002, SKERR_I2C_E002MSG);
 #endif	/* !SK_DIAG */
 			return(1);
 		}
+		
 		SK_I2C_GET_CTL(IoC, &I2cCtrl);
+
+#ifdef xYUKON_DBG
+		printf("StartTime=%lu, CurrentTime=%lu\n",
+			StartTime, CurrentTime);
+		if (kbhit()) {
+			return(1);
+		}
+#endif /* YUKON_DBG */
+	
 	} while ((I2cCtrl & I2C_FLAG) == (SK_U32)Event << 31);
 
 	return(0);
@@ -591,7 +646,7 @@
  * Returns
  *	Nothing
  */
-void	SkI2cWaitIrq(
+void SkI2cWaitIrq(
 SK_AC	*pAC,	/* Adapter Context */
 SK_IOC	IoC)	/* I/O Context */
 {
@@ -621,8 +676,6 @@
 	return;
 }	/* SkI2cWaitIrq */
 
-#ifdef	SK_DIAG
-
 /*
  * writes a single byte or 4 bytes into the I2C device
  *
@@ -635,14 +688,17 @@
 SK_U32	I2cData,	/* I2C Data to write */
 int		I2cDev,		/* I2C Device Address */
 int		I2cReg,		/* I2C Device Register Address */
-int		I2cBurst)	/* I2C Burst Flag ( 0 || I2C_BURST ) */
+int		I2cBurst)	/* I2C Burst Flag */
 {
 	SK_OUT32(IoC, B2_I2C_DATA, I2cData);
 	SK_I2C_CTL(IoC, I2C_WRITE, I2cDev, I2cReg, I2cBurst);
+	
 	return(SkI2cWait(pAC, IoC, I2C_WRITE));
 }	/* SkI2cWrite*/
 
 
+#ifdef	SK_DIAG
+
 /*
  * reads a single byte or 4 bytes from the I2C device
  *
@@ -653,15 +709,17 @@
 SK_IOC	IoC,		/* I/O Context */
 int		I2cDev,		/* I2C Device Address */
 int		I2cReg,		/* I2C Device Register Address */
-int		I2cBurst)	/* I2C Burst Flag ( 0 || I2C_BURST ) */
+int		I2cBurst)	/* I2C Burst Flag */
 {
 	SK_U32	Data;
 
 	SK_OUT32(IoC, B2_I2C_DATA, 0);
 	SK_I2C_CTL(IoC, I2C_READ, I2cDev, I2cReg, I2cBurst);
-	if (SkI2cWait(pAC, IoC, I2C_READ)) {
-		w_print("I2C Transfer Timeout!\n"); 
+	
+	if (SkI2cWait(pAC, IoC, I2C_READ) != 0) {
+		w_print("%s\n", SKERR_I2C_E002MSG);
 	}
+	
 	SK_IN32(IoC, B2_I2C_DATA, &Data);
 	return(Data);
 }	/* SkI2cRead */
@@ -684,13 +742,17 @@
 SK_IOC		IoC,	/* I/O Context */
 SK_SENSOR	*pSen)	/* Sensor to be read */
 {
-	return((*pSen->SenRead)(pAC, IoC, pSen));
+    if (pSen->SenRead != NULL) {
+        return((*pSen->SenRead)(pAC, IoC, pSen));
+    }
+    else
+        return(0); /* no success */
 }	/* SkI2cReadSensor*/
 
 /*
  * Do the Init state 0 initialization
  */
-static	int	SkI2cInit0(
+static int SkI2cInit0(
 SK_AC	*pAC)	/* Adapter Context */
 {
 	int	i;
@@ -698,95 +760,245 @@
 	/* Begin with first sensor */
 	pAC->I2c.CurrSens = 0;
 	
-	/* Set to mimimum sensor number */
-	pAC->I2c.MaxSens = SK_MIN_SENSORS;
+	/* Begin with timeout control for state machine */
+	pAC->I2c.TimerMode = SK_TIMER_WATCH_STATEMACHINE;
+	
+	/* Set sensor number to zero */
+	pAC->I2c.MaxSens = 0;
 
 #ifndef	SK_DIAG
 	/* Initialize Number of Dummy Reads */
 	pAC->I2c.DummyReads = SK_MAX_SENSORS;
 #endif
 
-	for (i = 0; i < SK_MAX_SENSORS; i ++) {
+	for (i = 0; i < SK_MAX_SENSORS; i++) {
+		pAC->I2c.SenTable[i].SenDesc = "unknown";
+		pAC->I2c.SenTable[i].SenType = SK_SEN_UNKNOWN;
+		pAC->I2c.SenTable[i].SenThreErrHigh = 0;
+		pAC->I2c.SenTable[i].SenThreErrLow = 0;
+		pAC->I2c.SenTable[i].SenThreWarnHigh = 0;
+		pAC->I2c.SenTable[i].SenThreWarnLow = 0;
+		pAC->I2c.SenTable[i].SenReg = LM80_FAN2_IN;
+		pAC->I2c.SenTable[i].SenInit = SK_SEN_DYN_INIT_NONE;
+		pAC->I2c.SenTable[i].SenValue = 0;
+		pAC->I2c.SenTable[i].SenErrFlag = SK_SEN_ERR_NOT_PRESENT;
+		pAC->I2c.SenTable[i].SenErrCts = 0;
+		pAC->I2c.SenTable[i].SenBegErrTS = 0;
+		pAC->I2c.SenTable[i].SenState = SK_SEN_IDLE;
+		pAC->I2c.SenTable[i].SenRead = NULL;
+		pAC->I2c.SenTable[i].SenDev = 0;
+	}
+
+	/* Now we are "INIT data"ed */
+	pAC->I2c.InitLevel = SK_INIT_DATA;
+	return(0);
+}	/* SkI2cInit0*/
+
+
+/*
+ * Do the init state 1 initialization
+ *
+ * initialize the following register of the LM80:
+ * Configuration register:
+ * - START, noINT, activeLOW, noINT#Clear, noRESET, noCI, noGPO#, noINIT
+ *
+ * Interrupt Mask Register 1:
+ * - all interrupts are Disabled (0xff)
+ *
+ * Interrupt Mask Register 2:
+ * - all interrupts are Disabled (0xff) Interrupt modi doesn't matter.
+ *
+ * Fan Divisor/RST_OUT register:
+ * - Divisors set to 1 (bits 00), all others 0s.
+ *
+ * OS# Configuration/Temperature resolution Register:
+ * - all 0s
+ *
+ */
+static int SkI2cInit1(
+SK_AC	*pAC,	/* Adapter Context */
+SK_IOC	IoC)	/* I/O Context */
+{
+    int i;
+    SK_U8 I2cSwCtrl;
+	SK_GEPORT *pPrt;	/* GIni Port struct pointer */
+
+	if (pAC->I2c.InitLevel != SK_INIT_DATA) {
+		/* ReInit not needed in I2C module */
+		return(0);
+	}
+
+    /* Set the Direction of I2C-Data Pin to IN */
+    SK_I2C_CLR_BIT(IoC, I2C_DATA_DIR | I2C_DATA);
+    /* Check for 32-Bit Yukon with Low at I2C-Data Pin */
+	SK_I2C_GET_SW(IoC, &I2cSwCtrl);
+
+	if ((I2cSwCtrl & I2C_DATA) == 0) {
+		/* this is a 32-Bit board */
+		pAC->GIni.GIYukon32Bit = SK_TRUE;
+        return(0);
+    }
+
+	/* Check for 64 Bit Yukon without sensors */
+	if (SkI2cWrite(pAC, IoC, 0, LM80_ADDR, LM80_CFG, 0) != 0) {
+        return(0);
+    }
+
+	(void)SkI2cWrite(pAC, IoC, 0xff, LM80_ADDR, LM80_IMSK_1, 0);
+	
+	(void)SkI2cWrite(pAC, IoC, 0xff, LM80_ADDR, LM80_IMSK_2, 0);
+	
+	(void)SkI2cWrite(pAC, IoC, 0, LM80_ADDR, LM80_FAN_CTRL, 0);
+	
+	(void)SkI2cWrite(pAC, IoC, 0, LM80_ADDR, LM80_TEMP_CTRL, 0);
+	
+	(void)SkI2cWrite(pAC, IoC, LM80_CFG_START, LM80_ADDR, LM80_CFG, 0);
+	
+	/*
+	 * MaxSens has to be updated here, because PhyType is not
+	 * set when performing Init Level 0
+	 */
+    pAC->I2c.MaxSens = 5;
+	
+	pPrt = &pAC->GIni.GP[0];
+	
+	if (pAC->GIni.GIGenesis) {
+		if (pPrt->PhyType == SK_PHY_BCOM) {
+			if (pAC->GIni.GIMacsFound == 1) {
+				pAC->I2c.MaxSens += 1;
+			}
+			else {
+				pAC->I2c.MaxSens += 3;
+			}
+		}
+	}
+	else {
+		pAC->I2c.MaxSens += 3;
+	}
+	
+	for (i = 0; i < pAC->I2c.MaxSens; i++) {
 		switch (i) {
 		case 0:
 			pAC->I2c.SenTable[i].SenDesc = "Temperature";
 			pAC->I2c.SenTable[i].SenType = SK_SEN_TEMP;
-			pAC->I2c.SenTable[i].SenThreErrHigh = SK_SEN_ERRHIGH0;
-			pAC->I2c.SenTable[i].SenThreErrLow = SK_SEN_ERRLOW0;
-			pAC->I2c.SenTable[i].SenThreWarnHigh = SK_SEN_WARNHIGH0;
-			pAC->I2c.SenTable[i].SenThreWarnLow = SK_SEN_WARNLOW0;
+			pAC->I2c.SenTable[i].SenThreErrHigh = SK_SEN_TEMP_HIGH_ERR;
+			pAC->I2c.SenTable[i].SenThreWarnHigh = SK_SEN_TEMP_HIGH_WARN;
+			pAC->I2c.SenTable[i].SenThreWarnLow = SK_SEN_TEMP_LOW_WARN;
+			pAC->I2c.SenTable[i].SenThreErrLow = SK_SEN_TEMP_LOW_ERR;
 			pAC->I2c.SenTable[i].SenReg = LM80_TEMP_IN;
-			pAC->I2c.SenTable[i].SenInit = SK_TRUE;
 			break;
 		case 1:
 			pAC->I2c.SenTable[i].SenDesc = "Voltage PCI";
 			pAC->I2c.SenTable[i].SenType = SK_SEN_VOLT;
-			pAC->I2c.SenTable[i].SenThreErrHigh = SK_SEN_ERRHIGH1;
-			pAC->I2c.SenTable[i].SenThreErrLow = SK_SEN_ERRLOW1;
-			pAC->I2c.SenTable[i].SenThreWarnHigh = SK_SEN_WARNHIGH1;
-			pAC->I2c.SenTable[i].SenThreWarnLow = SK_SEN_WARNLOW1;
+			pAC->I2c.SenTable[i].SenThreErrHigh = SK_SEN_PCI_5V_HIGH_ERR;
+			pAC->I2c.SenTable[i].SenThreWarnHigh = SK_SEN_PCI_5V_HIGH_WARN;
+			pAC->I2c.SenTable[i].SenThreWarnLow = SK_SEN_PCI_5V_LOW_WARN;
+			pAC->I2c.SenTable[i].SenThreErrLow = SK_SEN_PCI_5V_LOW_ERR;
 			pAC->I2c.SenTable[i].SenReg = LM80_VT0_IN;
-			pAC->I2c.SenTable[i].SenInit = SK_TRUE;
 			break;
 		case 2:
 			pAC->I2c.SenTable[i].SenDesc = "Voltage PCI-IO";
 			pAC->I2c.SenTable[i].SenType = SK_SEN_VOLT;
-			pAC->I2c.SenTable[i].SenThreErrHigh = SK_SEN_ERRHIGH2;
-			pAC->I2c.SenTable[i].SenThreErrLow = SK_SEN_ERRLOW2;
-			pAC->I2c.SenTable[i].SenThreWarnHigh = SK_SEN_WARNHIGH2;
-			pAC->I2c.SenTable[i].SenThreWarnLow = SK_SEN_WARNLOW2;
+			pAC->I2c.SenTable[i].SenThreErrHigh = SK_SEN_PCI_IO_5V_HIGH_ERR;
+			pAC->I2c.SenTable[i].SenThreWarnHigh = SK_SEN_PCI_IO_5V_HIGH_WARN;
+			pAC->I2c.SenTable[i].SenThreWarnLow = SK_SEN_PCI_IO_3V3_LOW_WARN;
+			pAC->I2c.SenTable[i].SenThreErrLow = SK_SEN_PCI_IO_3V3_LOW_ERR;
 			pAC->I2c.SenTable[i].SenReg = LM80_VT1_IN;
-			pAC->I2c.SenTable[i].SenInit = SK_FALSE;
+			pAC->I2c.SenTable[i].SenInit = SK_SEN_DYN_INIT_PCI_IO;
 			break;
 		case 3:
 			pAC->I2c.SenTable[i].SenDesc = "Voltage ASIC";
 			pAC->I2c.SenTable[i].SenType = SK_SEN_VOLT;
-			pAC->I2c.SenTable[i].SenThreErrHigh = SK_SEN_ERRHIGH3;
-			pAC->I2c.SenTable[i].SenThreErrLow = SK_SEN_ERRLOW3;
-			pAC->I2c.SenTable[i].SenThreWarnHigh = SK_SEN_WARNHIGH3;
-			pAC->I2c.SenTable[i].SenThreWarnLow = SK_SEN_WARNLOW3;
+			pAC->I2c.SenTable[i].SenThreErrHigh = SK_SEN_VDD_HIGH_ERR;
+			pAC->I2c.SenTable[i].SenThreWarnHigh = SK_SEN_VDD_HIGH_WARN;
+			pAC->I2c.SenTable[i].SenThreWarnLow = SK_SEN_VDD_LOW_WARN;
+			pAC->I2c.SenTable[i].SenThreErrLow = SK_SEN_VDD_LOW_ERR;
 			pAC->I2c.SenTable[i].SenReg = LM80_VT2_IN;
-			pAC->I2c.SenTable[i].SenInit = SK_TRUE;
 			break;
 		case 4:
-			pAC->I2c.SenTable[i].SenDesc = "Voltage PMA";
+			if (pAC->GIni.GIGenesis) {
+				if (pPrt->PhyType == SK_PHY_BCOM) {
+					pAC->I2c.SenTable[i].SenDesc = "Voltage PHY A PLL";
+					pAC->I2c.SenTable[i].SenThreErrHigh = SK_SEN_PLL_3V3_HIGH_ERR;
+					pAC->I2c.SenTable[i].SenThreWarnHigh = SK_SEN_PLL_3V3_HIGH_WARN;
+					pAC->I2c.SenTable[i].SenThreWarnLow = SK_SEN_PLL_3V3_LOW_WARN;
+					pAC->I2c.SenTable[i].SenThreErrLow = SK_SEN_PLL_3V3_LOW_ERR;
+				}
+				else {
+					pAC->I2c.SenTable[i].SenDesc = "Voltage PMA";
+					pAC->I2c.SenTable[i].SenThreErrHigh = SK_SEN_PLL_3V3_HIGH_ERR;
+					pAC->I2c.SenTable[i].SenThreWarnHigh = SK_SEN_PLL_3V3_HIGH_WARN;
+					pAC->I2c.SenTable[i].SenThreWarnLow = SK_SEN_PLL_3V3_LOW_WARN;
+					pAC->I2c.SenTable[i].SenThreErrLow = SK_SEN_PLL_3V3_LOW_ERR;
+				}
+			}
+			else {
+				pAC->I2c.SenTable[i].SenDesc = "Voltage VAUX";
+				pAC->I2c.SenTable[i].SenThreErrHigh = SK_SEN_VAUX_3V3_HIGH_ERR;
+				pAC->I2c.SenTable[i].SenThreWarnHigh = SK_SEN_VAUX_3V3_HIGH_WARN;
+				if (pAC->GIni.GIVauxAvail) {
+					pAC->I2c.SenTable[i].SenThreWarnLow = SK_SEN_VAUX_3V3_LOW_WARN;
+					pAC->I2c.SenTable[i].SenThreErrLow = SK_SEN_VAUX_3V3_LOW_ERR;
+				}
+				else {
+					pAC->I2c.SenTable[i].SenThreErrLow = SK_SEN_VAUX_0V_WARN_ERR;
+					pAC->I2c.SenTable[i].SenThreWarnLow = SK_SEN_VAUX_0V_WARN_ERR;
+				}
+			}
 			pAC->I2c.SenTable[i].SenType = SK_SEN_VOLT;
-			pAC->I2c.SenTable[i].SenThreErrHigh = SK_SEN_ERRHIGH4;
-			pAC->I2c.SenTable[i].SenThreErrLow = SK_SEN_ERRLOW4;
-			pAC->I2c.SenTable[i].SenThreWarnHigh = SK_SEN_WARNHIGH4;
-			pAC->I2c.SenTable[i].SenThreWarnLow = SK_SEN_WARNLOW4;
 			pAC->I2c.SenTable[i].SenReg = LM80_VT3_IN;
-			pAC->I2c.SenTable[i].SenInit = SK_TRUE;
 			break;
 		case 5:
-			pAC->I2c.SenTable[i].SenDesc = "Voltage PHY 2V5";
+			if (pAC->GIni.GIGenesis) {
+				pAC->I2c.SenTable[i].SenDesc = "Voltage PHY 2V5";
+				pAC->I2c.SenTable[i].SenThreErrHigh = SK_SEN_PHY_2V5_HIGH_ERR;
+				pAC->I2c.SenTable[i].SenThreWarnHigh = SK_SEN_PHY_2V5_HIGH_WARN;
+				pAC->I2c.SenTable[i].SenThreWarnLow = SK_SEN_PHY_2V5_LOW_WARN;
+				pAC->I2c.SenTable[i].SenThreErrLow = SK_SEN_PHY_2V5_LOW_ERR;
+			}
+			else {
+				pAC->I2c.SenTable[i].SenDesc = "Voltage ASIC-Co 1V5";
+				pAC->I2c.SenTable[i].SenThreErrHigh = SK_SEN_CORE_1V5_HIGH_ERR;
+				pAC->I2c.SenTable[i].SenThreWarnHigh = SK_SEN_CORE_1V5_HIGH_WARN;
+				pAC->I2c.SenTable[i].SenThreWarnLow = SK_SEN_CORE_1V5_LOW_WARN;
+				pAC->I2c.SenTable[i].SenThreErrLow = SK_SEN_CORE_1V5_LOW_ERR;
+			}
 			pAC->I2c.SenTable[i].SenType = SK_SEN_VOLT;
-			pAC->I2c.SenTable[i].SenThreErrHigh = SK_SEN_ERRHIGH5;
-			pAC->I2c.SenTable[i].SenThreErrLow = SK_SEN_ERRLOW5;
-			pAC->I2c.SenTable[i].SenThreWarnHigh = SK_SEN_WARNHIGH5;
-			pAC->I2c.SenTable[i].SenThreWarnLow = SK_SEN_WARNLOW5;
 			pAC->I2c.SenTable[i].SenReg = LM80_VT4_IN;
-			pAC->I2c.SenTable[i].SenInit = SK_TRUE;
 			break;
 		case 6:
-			pAC->I2c.SenTable[i].SenDesc = "Voltage PHY B PLL";
+			if (pAC->GIni.GIGenesis) {
+				pAC->I2c.SenTable[i].SenDesc = "Voltage PHY B PLL";
+			}
+			else {
+				pAC->I2c.SenTable[i].SenDesc = "Voltage PHY 3V3";
+			}
 			pAC->I2c.SenTable[i].SenType = SK_SEN_VOLT;
-			pAC->I2c.SenTable[i].SenThreErrHigh = SK_SEN_ERRHIGH6;
-			pAC->I2c.SenTable[i].SenThreErrLow = SK_SEN_ERRLOW6;
-			pAC->I2c.SenTable[i].SenThreWarnHigh = SK_SEN_WARNHIGH6;
-			pAC->I2c.SenTable[i].SenThreWarnLow = SK_SEN_WARNLOW6;
+			pAC->I2c.SenTable[i].SenThreErrHigh = SK_SEN_PLL_3V3_HIGH_ERR;
+			pAC->I2c.SenTable[i].SenThreWarnHigh = SK_SEN_PLL_3V3_HIGH_WARN;
+			pAC->I2c.SenTable[i].SenThreWarnLow = SK_SEN_PLL_3V3_LOW_WARN;
+			pAC->I2c.SenTable[i].SenThreErrLow = SK_SEN_PLL_3V3_LOW_ERR;
 			pAC->I2c.SenTable[i].SenReg = LM80_VT5_IN;
-			pAC->I2c.SenTable[i].SenInit = SK_TRUE;
 			break;
 		case 7:
-			pAC->I2c.SenTable[i].SenDesc = "Speed Fan";
-			pAC->I2c.SenTable[i].SenType = SK_SEN_FAN;
-			pAC->I2c.SenTable[i].SenThreErrHigh = SK_SEN_ERRHIGH;
-			pAC->I2c.SenTable[i].SenThreErrLow = SK_SEN_ERRLOW;
-			pAC->I2c.SenTable[i].SenThreWarnHigh = SK_SEN_WARNHIGH;
-			pAC->I2c.SenTable[i].SenThreWarnLow = SK_SEN_WARNLOW;
-			pAC->I2c.SenTable[i].SenReg = LM80_FAN2_IN;
-			pAC->I2c.SenTable[i].SenInit = SK_TRUE;
+			if (pAC->GIni.GIGenesis) {
+				pAC->I2c.SenTable[i].SenDesc = "Speed Fan";
+				pAC->I2c.SenTable[i].SenType = SK_SEN_FAN;
+				pAC->I2c.SenTable[i].SenThreErrHigh = SK_SEN_FAN_HIGH_ERR;
+				pAC->I2c.SenTable[i].SenThreWarnHigh = SK_SEN_FAN_HIGH_WARN;
+				pAC->I2c.SenTable[i].SenThreWarnLow = SK_SEN_FAN_LOW_WARN;
+				pAC->I2c.SenTable[i].SenThreErrLow = SK_SEN_FAN_LOW_ERR;
+				pAC->I2c.SenTable[i].SenReg = LM80_FAN2_IN;
+			}
+			else {
+				pAC->I2c.SenTable[i].SenDesc = "Voltage PHY 2V5";
+				pAC->I2c.SenTable[i].SenType = SK_SEN_VOLT;
+				pAC->I2c.SenTable[i].SenThreErrHigh = SK_SEN_PHY_2V5_HIGH_ERR;
+				pAC->I2c.SenTable[i].SenThreWarnHigh = SK_SEN_PHY_2V5_HIGH_WARN;
+				pAC->I2c.SenTable[i].SenThreWarnLow = SK_SEN_PHY_2V5_LOW_WARN;
+				pAC->I2c.SenTable[i].SenThreErrLow = SK_SEN_PHY_2V5_LOW_ERR;
+				pAC->I2c.SenTable[i].SenReg = LM80_VT6_IN;
+			}
 			break;
 		default:
 			SK_ERR_LOG(pAC, SK_ERRCL_INIT | SK_ERRCL_SW,
@@ -803,94 +1015,13 @@
 		pAC->I2c.SenTable[i].SenDev = LM80_ADDR;
 	}
 
-	/* Now we are "INIT data"ed */
-	pAC->I2c.InitLevel = SK_INIT_DATA;
-	return(0);
-}	/* SkI2cInit0*/
-
-
-/*
- * Do the init state 1 initialization
- *
- * initialize the following register of the LM80:
- * Configuration register:
- * - START, noINT, activeLOW, noINT#Clear, noRESET, noCI, noGPO#, noINIT
- *
- * Interrupt Mask Register 1:
- * - all interrupts are Disabled (0xff)
- *
- * Interrupt Mask Register 2:
- * - all interrupts are Disabled (0xff) Interrupt modi doesn't matter.
- *
- * Fan Divisor/RST_OUT register:
- * - Divisors set to 1 (bits 00), all others 0s.
- *
- * OS# Configuration/Temperature resolution Register:
- * - all 0s
- *
- */
-static	int	SkI2cInit1(
-SK_AC	*pAC,	/* Adapter Context */
-SK_IOC	IoC)	/* I/O Context */
-{
-	if (pAC->I2c.InitLevel != SK_INIT_DATA) {
-		/* ReInit not needed in I2C module */
-		return(0);
-	}
-
-	SK_OUT32(IoC, B2_I2C_DATA, 0);
-	SK_I2C_CTL(IoC, I2C_WRITE, LM80_ADDR, LM80_CFG, 0);
-	(void)SkI2cWait(pAC, IoC, I2C_WRITE);
-
-	SK_OUT32(IoC, B2_I2C_DATA, 0xff);
-	SK_I2C_CTL(IoC, I2C_WRITE, LM80_ADDR, LM80_IMSK_1, 0);
-	(void)SkI2cWait(pAC, IoC, I2C_WRITE);
-
-	SK_OUT32(IoC, B2_I2C_DATA, 0xff);
-	SK_I2C_CTL(IoC, I2C_WRITE, LM80_ADDR, LM80_IMSK_2, 0);
-	(void)SkI2cWait(pAC, IoC, I2C_WRITE);
-
-	SK_OUT32(IoC, B2_I2C_DATA, 0x0);
-	SK_I2C_CTL(IoC, I2C_WRITE, LM80_ADDR, LM80_FAN_CTRL, 0);
-	(void)SkI2cWait(pAC, IoC, I2C_WRITE);
-
-	SK_OUT32(IoC, B2_I2C_DATA, 0);
-	SK_I2C_CTL(IoC, I2C_WRITE, LM80_ADDR, LM80_TEMP_CTRL, 0);
-	(void)SkI2cWait(pAC, IoC, I2C_WRITE);
-
-	SK_OUT32(IoC, B2_I2C_DATA, LM80_CFG_START);
-	SK_I2C_CTL(IoC, I2C_WRITE, LM80_ADDR, LM80_CFG, 0);
-	(void)SkI2cWait(pAC, IoC, I2C_WRITE);
-
-	/*
-	 * MaxSens has to be initialized here, because PhyType is not
-	 * set when performing Init Level 1
-	 */
-	switch (pAC->GIni.GP[0].PhyType) {
-	case SK_PHY_XMAC:
-		pAC->I2c.MaxSens = 5;
-		break;
-	case SK_PHY_BCOM:
-		pAC->I2c.SenTable[4].SenDesc = "Voltage PHY A PLL";
-		if (pAC->GIni.GIMacsFound == 1) {
-			pAC->I2c.MaxSens = 6;
-		} 
-		else {
-			pAC->I2c.MaxSens = 8;
-		}
-		break;
-	case SK_PHY_LONE:
-		pAC->I2c.MaxSens = 5;
-		break;
-	}
-	
 #ifndef	SK_DIAG
 	pAC->I2c.DummyReads = pAC->I2c.MaxSens;
-
-	/* Clear the interrupt source */
-	SK_OUT32(IoC, B2_I2C_IRQ, I2C_CLR_IRQ);
 #endif	/* !SK_DIAG */
 	
+	/* Clear I2C IRQ */
+	SK_OUT32(IoC, B2_I2C_IRQ, I2C_CLR_IRQ);
+	
 	/* Now we are I/O initialized */
 	pAC->I2c.InitLevel = SK_INIT_IO;
 	return(0);
@@ -900,7 +1031,7 @@
 /*
  * Init level 2: Start first sensor read.
  */
-static	int	SkI2cInit2(
+static int SkI2cInit2(
 SK_AC	*pAC,	/* Adapter Context */
 SK_IOC	IoC)	/* I/O Context */
 {
@@ -977,13 +1108,13 @@
  *
  * Starts the timer if necessary.
  */
-void	SkI2cIsr(
+void SkI2cIsr(
 SK_AC	*pAC,	/* Adapter Context */
 SK_IOC	IoC)	/* I/O Context */
 {
 	SK_EVPARA	Para;
 
-	/* Clear the interrupt source */
+	/* Clear I2C IRQ */
 	SK_OUT32(IoC, B2_I2C_IRQ, I2C_CLR_IRQ);
 
 	Para.Para64 = 0;
@@ -994,7 +1125,7 @@
 /*
  * Check this sensors Value against the threshold and send events.
  */
-static	void	SkI2cCheckSensor(
+static void SkI2cCheckSensor(
 SK_AC		*pAC,	/* Adapter Context */
 SK_SENSOR	*pSen)
 {
@@ -1008,7 +1139,7 @@
 
 	/* Check Dummy Reads first */
 	if (pAC->I2c.DummyReads > 0) {
-		pAC->I2c.DummyReads --;
+		pAC->I2c.DummyReads--;
 		return;
 	}
 
@@ -1016,7 +1147,7 @@
 	CurrTime = SkOsGetTime(pAC);
 
 	/* Set para to the most useful setting: The current sensor. */
-	ParaLocal.Para64 = (SK_U64) pAC->I2c.CurrSens;
+	ParaLocal.Para64 = (SK_U64)pAC->I2c.CurrSens;
 
 	/* Check the Value against the thresholds. First: Error Thresholds */
 	TooHigh = (pSen->SenValue > pSen->SenThreErrHigh);
@@ -1053,9 +1184,9 @@
 				 */
 				DoErrLog = SK_FALSE;
 			}
-		} else {
-			/* We came from a different state */
-			/* -> Set Begin Time Stamp */
+		}
+		else {
+			/* We came from a different state -> Set Begin Time Stamp */
 			pSen->SenBegErrTS = CurrTime;
 			pSen->SenErrFlag = SK_SEN_ERR_ERR;
 		}
@@ -1063,7 +1194,7 @@
 		if (DoTrapSend) {
 			/* Set current Time */
 			pSen->SenLastErrTrapTS = CurrTime;
-			pSen->SenErrCts ++;
+			pSen->SenErrCts++;
 
 			/* Queue PNMI Event */
 			SkEventQueue(pAC, SKGE_PNMI, (TooHigh ?
@@ -1095,7 +1226,6 @@
 	TooHigh = (pSen->SenValue > pSen->SenThreWarnHigh);
 	TooLow = (pSen->SenValue < pSen->SenThreWarnLow);
 		
-
 	if (!IsError && (TooHigh || TooLow)) {
 		/* Error condition is satisfied */
 		DoTrapSend = SK_TRUE;
@@ -1123,9 +1253,9 @@
 				 */
 				DoErrLog = SK_FALSE;
 			}
-		} else {
-			/* We came from a different state */
-			/* -> Set Begin Time Stamp */
+		}
+		else {
+			/* We came from a different state -> Set Begin Time Stamp */
 			pSen->SenBegWarnTS = CurrTime;
 			pSen->SenErrFlag = SK_SEN_ERR_WARN;
 		}
@@ -1133,7 +1263,7 @@
 		if (DoTrapSend) {
 			/* Set current Time */
 			pSen->SenLastWarnTrapTS = CurrTime;
-			pSen->SenWarnCts ++;
+			pSen->SenWarnCts++;
 
 			/* Queue PNMI Event */
 			SkEventQueue(pAC, SKGE_PNMI, (TooHigh ?
@@ -1168,6 +1298,43 @@
 
 	/* End of check against the thresholds */
 
+	/* Bug fix AF: 16.Aug.2001: Correct the init base
+	 * of LM80 sensor.
+	 */
+	if (pSen->SenInit == SK_SEN_DYN_INIT_PCI_IO) {
+
+        pSen->SenInit = SK_SEN_DYN_INIT_NONE;
+
+		if (pSen->SenValue > SK_SEN_PCI_IO_RANGE_LIMITER) {
+			/* 5V PCI-IO Voltage */
+			pSen->SenThreWarnLow = SK_SEN_PCI_IO_5V_LOW_WARN;
+			pSen->SenThreErrLow = SK_SEN_PCI_IO_5V_LOW_ERR;
+		}
+		else {
+			/* 3.3V PCI-IO Voltage */
+			pSen->SenThreWarnHigh = SK_SEN_PCI_IO_3V3_HIGH_WARN;
+			pSen->SenThreErrHigh = SK_SEN_PCI_IO_3V3_HIGH_ERR;
+		}
+	}
+	
+#if 0
+    /* Dynamic thresholds also for VAUX of LM80 sensor */
+	if (pSen->SenInit == SK_SEN_DYN_INIT_VAUX) {
+
+        pSen->SenInit = SK_SEN_DYN_INIT_NONE;
+
+		/* 3.3V VAUX Voltage */
+		if (pSen->SenValue > SK_SEN_VAUX_RANGE_LIMITER) {
+			pSen->SenThreWarnLow = SK_SEN_VAUX_3V3_LOW_WARN;
+			pSen->SenThreErrLow = SK_SEN_VAUX_3V3_LOW_ERR;
+		}
+		/* 0V VAUX Voltage */
+		else {
+			pSen->SenThreWarnHigh = SK_SEN_VAUX_0V_WARN_ERR;
+			pSen->SenThreErrHigh = SK_SEN_VAUX_0V_WARN_ERR;
+		}
+	}
+
 	/*
 	 * Check initialization state:
 	 * The VIO Thresholds need adaption
@@ -1175,20 +1342,21 @@
 	if (!pSen->SenInit && pSen->SenReg == LM80_VT1_IN &&
 	     pSen->SenValue > SK_SEN_WARNLOW2C &&
 	     pSen->SenValue < SK_SEN_WARNHIGH2) {
-		pSen->SenThreErrLow = SK_SEN_ERRLOW2C; 
-		pSen->SenThreWarnLow = SK_SEN_WARNLOW2C; 
+		pSen->SenThreErrLow = SK_SEN_ERRLOW2C;
+		pSen->SenThreWarnLow = SK_SEN_WARNLOW2C;
 		pSen->SenInit = SK_TRUE;
 	}
 
 	if (!pSen->SenInit && pSen->SenReg == LM80_VT1_IN &&
 	     pSen->SenValue > SK_SEN_WARNLOW2 &&
 	     pSen->SenValue < SK_SEN_WARNHIGH2C) {
-		pSen->SenThreErrHigh = SK_SEN_ERRHIGH2C; 
-		pSen->SenThreWarnHigh = SK_SEN_WARNHIGH2C; 
+		pSen->SenThreErrHigh = SK_SEN_ERRHIGH2C;
+		pSen->SenThreWarnHigh = SK_SEN_WARNHIGH2C;
 		pSen->SenInit = SK_TRUE;
 	}
+#endif
 
-	if (!pSen->SenInit) {
+	if (pSen->SenInit != SK_SEN_DYN_INIT_NONE) {
 		SK_ERR_LOG(pAC, SK_ERRCL_HW, SKERR_I2C_E013, SKERR_I2C_E013MSG);
 	}
 }	/* SkI2cCheckSensor*/
@@ -1210,9 +1378,13 @@
 	SK_EVPARA	ParaLocal;
 	int			i;
 
+	/* New case: no sensors */
+	if (pAC->I2c.MaxSens == 0) {
+		return(0);
+	}
+
 	switch (Event) {
 	case SK_I2CEV_IRQ:
-	case SK_I2CEV_TIM:
 		pSen = &pAC->I2c.SenTable[pAC->I2c.CurrSens];
 		ReadComplete = SkI2cReadSensor(pAC, IoC, pSen);
 
@@ -1220,23 +1392,92 @@
 			/* Check sensor against defined thresholds */
 			SkI2cCheckSensor (pAC, pSen);
 
-			/* Increment Current and set appropriate Timeout */
-			Time = SK_I2C_TIM_SHORT;
+			/* Increment Current sensor and set appropriate Timeout */
+			pAC->I2c.CurrSens++;
+			if (pAC->I2c.CurrSens >= pAC->I2c.MaxSens) {
+				pAC->I2c.CurrSens = 0;
+				Time = SK_I2C_TIM_LONG;
+			}
+			else {
+				Time = SK_I2C_TIM_SHORT;
+			}
+
+			/* Start Timer */
+			ParaLocal.Para64 = (SK_U64)0;
+
+			pAC->I2c.TimerMode = SK_TIMER_NEW_GAUGING;
+			
+			SkTimerStart(pAC, IoC, &pAC->I2c.SenTimer, Time,
+				SKGE_I2C, SK_I2CEV_TIM, ParaLocal);
+		}
+        else {
+			/* Start Timer */
+			ParaLocal.Para64 = (SK_U64)0;
+
+			pAC->I2c.TimerMode = SK_TIMER_WATCH_STATEMACHINE;
+
+            SkTimerStart(pAC, IoC, &pAC->I2c.SenTimer, SK_I2C_TIM_WATCH,
+				SKGE_I2C, SK_I2CEV_TIM, ParaLocal);
+		}
+		break;
+	case SK_I2CEV_TIM:
+		if (pAC->I2c.TimerMode == SK_TIMER_NEW_GAUGING) {
+
+			ParaLocal.Para64 = (SK_U64)0;
+			SkTimerStop(pAC, IoC, &pAC->I2c.SenTimer);
+
+			pSen = &pAC->I2c.SenTable[pAC->I2c.CurrSens];
+			ReadComplete = SkI2cReadSensor(pAC, IoC, pSen);
 
-			pAC->I2c.CurrSens ++;
+			if (ReadComplete) {
+				/* Check sensor against defined thresholds */
+				SkI2cCheckSensor (pAC, pSen);
+
+				/* Increment Current sensor and set appropriate Timeout */
+				pAC->I2c.CurrSens++;
+				if (pAC->I2c.CurrSens == pAC->I2c.MaxSens) {
+					pAC->I2c.CurrSens = 0;
+					Time = SK_I2C_TIM_LONG;
+				}
+				else {
+					Time = SK_I2C_TIM_SHORT;
+				}
+
+				/* Start Timer */
+				ParaLocal.Para64 = (SK_U64)0;
+
+				pAC->I2c.TimerMode = SK_TIMER_NEW_GAUGING;
+
+				SkTimerStart(pAC, IoC, &pAC->I2c.SenTimer, Time,
+					SKGE_I2C, SK_I2CEV_TIM, ParaLocal);
+			}
+		}
+		else {
+			pSen = &pAC->I2c.SenTable[pAC->I2c.CurrSens];
+			pSen->SenErrFlag = SK_SEN_ERR_FAULTY;
+			SK_I2C_STOP(IoC);
+
+			/* Increment Current sensor and set appropriate Timeout */
+			pAC->I2c.CurrSens++;
 			if (pAC->I2c.CurrSens == pAC->I2c.MaxSens) {
 				pAC->I2c.CurrSens = 0;
 				Time = SK_I2C_TIM_LONG;
 			}
+			else {
+				Time = SK_I2C_TIM_SHORT;
+			}
 
 			/* Start Timer */
-			ParaLocal.Para64 = (SK_U64) 0;
+			ParaLocal.Para64 = (SK_U64)0;
+
+			pAC->I2c.TimerMode = SK_TIMER_NEW_GAUGING;
+
 			SkTimerStart(pAC, IoC, &pAC->I2c.SenTimer, Time,
 				SKGE_I2C, SK_I2CEV_TIM, ParaLocal);
 		}
 		break;
 	case SK_I2CEV_CLEAR:
-		for (i = 0; i < SK_MAX_SENSORS; i ++) {
+		for (i = 0; i < SK_MAX_SENSORS; i++) {
 			pAC->I2c.SenTable[i].SenErrFlag = SK_SEN_ERR_OK;
 			pAC->I2c.SenTable[i].SenErrCts = 0;
 			pAC->I2c.SenTable[i].SenWarnCts = 0;
@@ -1255,4 +1496,4 @@
 	return(0);
 }	/* SkI2cEvent*/
 
-#endif	/* !SK_DIAG */ 
+#endif	/* !SK_DIAG */
diff -ruN linux/drivers/net/sk98lin/sklm80.c linuxn/drivers/net/sk98lin/sklm80.c
--- linux/drivers/net/sk98lin/sklm80.c	Fri Sep 15 23:34:19 2000
+++ linuxn/drivers/net/sk98lin/sklm80.c	Tue May 20 12:17:40 2003
@@ -2,16 +2,15 @@
  *
  * Name:	sklm80.c
  * Project:	GEnesis, PCI Gigabit Ethernet Adapter
- * Version:	$Revision: 1.17 $
- * Date:	$Date: 1999/11/22 13:35:51 $
+ * Version:	$Revision: 1.20 $
+ * Date:	$Date: 2002/08/13 09:16:27 $
  * Purpose:	Funktions to access Voltage and Temperature Sensor (LM80)
  *
  ******************************************************************************/
 
 /******************************************************************************
  *
- *	(C)Copyright 1998,1999 SysKonnect,
- *	a business unit of Schneider & Koch & Co. Datensysteme GmbH.
+ *	(C)Copyright 1998-2002 SysKonnect GmbH.
  *
  *	This program is free software; you can redistribute it and/or modify
  *	it under the terms of the GNU General Public License as published by
@@ -27,6 +26,16 @@
  * History:
  *
  *	$Log: sklm80.c,v $
+ *	Revision 1.20  2002/08/13 09:16:27  rschmidt
+ *	Changed return value for SkLm80ReadSensor() back to 'int'
+ *	Editorial changes
+ *	
+ *	Revision 1.19  2002/08/06 09:43:31  jschmalz
+ *	Extensions and changes for Yukon
+ *	
+ *	Revision 1.18  2002/08/02 12:26:57  rschmidt
+ *	Editorial changes
+ *	
  *	Revision 1.17  1999/11/22 13:35:51  cgoos
  *	Changed license header to GPL.
  *	
@@ -93,7 +102,7 @@
 	LM80 functions
 */
 static const char SysKonnectFileId[] =
-	"$Id: sklm80.c,v 1.17 1999/11/22 13:35:51 cgoos Exp $" ;
+	"$Id: sklm80.c,v 1.20 2002/08/13 09:16:27 rschmidt Exp $" ;
 
 #include "h/skdrv1st.h"		/* Driver Specific Definitions */
 #include "h/lm80.h"
@@ -107,15 +116,15 @@
 
 #ifdef	SK_DIAG
 /*
- * read the regeister 'reg' from the device 'device'
+ * read the register 'Reg' from the device 'Dev'
  *
  * return 	read error	-1
  *		success		the read value
  */
 int	SkLm80RcvReg(
 SK_IOC	IoC,		/* Adapter Context */
-int	Dev,		/* I2C device address */
-int	Reg)		/* register to read */
+int		Dev,		/* I2C device address */
+int		Reg)		/* register to read */
 {
 	int	Val = 0;
 	int	TempExt;
@@ -134,9 +143,9 @@
 		return(-1);
 	}
 
-	switch(Reg) {
+	switch (Reg) {
 	case LM80_TEMP_IN:
-		Val = (int)SkI2cRcvByte(IoC, 1) ;
+		Val = (int)SkI2cRcvByte(IoC, 1);
 
 		/* First: correct the value: it might be negative */
 		if ((Val & 0x80) != 0) {
@@ -145,7 +154,9 @@
 		}
 		Val = Val * SK_LM80_TEMP_LSB;
 		SkI2cStop(IoC);
-		TempExt = (int) SkLm80RcvReg(IoC,LM80_ADDR,LM80_TEMP_CTRL);
+		
+		TempExt = (int)SkLm80RcvReg(IoC, LM80_ADDR, LM80_TEMP_CTRL);
+		
 		if (Val > 0) {
 			Val += ((TempExt >> 7) * SK_LM80_TEMPEXT_LSB);
 		}
@@ -158,10 +169,11 @@
 	case LM80_VT1_IN:
 	case LM80_VT2_IN:
 	case LM80_VT3_IN:
-		Val = (int) SkI2cRcvByte(IoC, 1) * SK_LM80_VT_LSB;
+		Val = (int)SkI2cRcvByte(IoC, 1) * SK_LM80_VT_LSB;
 		break;
+	
 	default:
-		Val = (int) SkI2cRcvByte(IoC, 1);
+		Val = (int)SkI2cRcvByte(IoC, 1);
 		break;
 	}
 
@@ -173,30 +185,32 @@
 /*
  * read a sensors value (LM80 specific)
  *
- * This function reads a sensors value from the I2c sensor chip LM80. The
- * sensor is defined by its index into the sensors database in the struct
+ * This function reads a sensors value from the I2C sensor chip LM80.
+ * The sensor is defined by its index into the sensors database in the struct
  * pAC points to.
  *
  * Returns	1 if the read is completed
- *		0 if the read must be continued (I2c Bus still allocated)
+ *		0 if the read must be continued (I2C Bus still allocated)
  */
-int	SkLm80ReadSensor(
+int SkLm80ReadSensor(
 SK_AC		*pAC,	/* Adapter Context */
-SK_IOC		IoC,	/* IoContext needed in level 1 and 2 */
+SK_IOC		IoC,	/* I/O Context needed in level 1 and 2 */
 SK_SENSOR	*pSen)	/* Sensor to be read */
 {
 	SK_I32		Value;
 
-	switch(pSen->SenState) {
+	switch (pSen->SenState) {
 	case SK_SEN_IDLE:
 		/* Send address to ADDR register */
-		SK_I2C_CTL(IoC,I2C_READ,pSen->SenDev,pSen->SenReg,0);
+		SK_I2C_CTL(IoC, I2C_READ, pSen->SenDev, pSen->SenReg, 0);
 
 		pSen->SenState = SK_SEN_VALUE ;
-		BREAK_OR_WAIT(pAC, IoC, I2C_READ) ;
+		BREAK_OR_WAIT(pAC, IoC, I2C_READ);
+	
 	case SK_SEN_VALUE:
 		/* Read value from data register */
-		SK_IN32(IoC,B2_I2C_DATA, ((SK_U32 *)&Value));
+		SK_IN32(IoC, B2_I2C_DATA, ((SK_U32 *)&Value));
+		
 		Value &= 0xff; /* only least significant byte is valid */
 
 		/* Do NOT check the Value against the thresholds */
@@ -228,10 +242,9 @@
 			Value = Value - 256;
 		}
 
-		/* We have a temperature sensor and need to get the signed
-		 * extension. For now we get the extension from the last
-		 * reading, so in the normal case we won't see flickering
-		 * temperatures.
+		/* We have a temperature sensor and need to get the signed extension.
+		 * For now we get the extension from the last reading, so in the normal
+		 * case we won't see flickering temperatures.
 		 */
 		pSen->SenValue = (Value * SK_LM80_TEMP_LSB) +
 			(pSen->SenValue % SK_LM80_TEMP_LSB);
@@ -240,32 +253,34 @@
 		SK_I2C_CTL(IoC, I2C_READ, pSen->SenDev, LM80_TEMP_CTRL, 0);
 
 		pSen->SenState = SK_SEN_VALEXT ;
-		BREAK_OR_WAIT(pAC, IoC, I2C_READ) ;
+		BREAK_OR_WAIT(pAC, IoC, I2C_READ);
+	
 	case SK_SEN_VALEXT:
 		/* Read value from data register */
-		SK_IN32(IoC,B2_I2C_DATA,((SK_U32 *)&Value));
+		SK_IN32(IoC, B2_I2C_DATA, ((SK_U32 *)&Value));
 		Value &= LM80_TEMP_LSB_9; /* only bit 7 is valid */
 
 		/* cut the LSB bit */
 		pSen->SenValue = ((pSen->SenValue / SK_LM80_TEMP_LSB) *
-			SK_LM80_TEMP_LSB) ;
+			SK_LM80_TEMP_LSB);
 
 		if (pSen->SenValue < 0) {
 			/* Value negative: The bit value must be subtracted */
 			pSen->SenValue -= ((Value >> 7) * SK_LM80_TEMPEXT_LSB);
-		} else {
+		}
+		else {
 			/* Value positive: The bit value must be added */
 			pSen->SenValue += ((Value >> 7) * SK_LM80_TEMPEXT_LSB);
 		}
 
 		pSen->SenState = SK_SEN_IDLE ;
 		return(1);
+	
 	default:
-		SK_ERR_LOG(pAC, SK_ERRCL_SW, SKERR_I2C_E007,
-			SKERR_I2C_E007MSG) ;
+		SK_ERR_LOG(pAC, SK_ERRCL_SW, SKERR_I2C_E007, SKERR_I2C_E007MSG);
 		return(1);
 	}
 
 	/* Not completed */
-	return(0) ;
+	return(0);
 }
diff -ruN linux/drivers/net/sk98lin/skproc.c linuxn/drivers/net/sk98lin/skproc.c
--- linux/drivers/net/sk98lin/skproc.c	Mon Sep 10 18:04:53 2001
+++ linuxn/drivers/net/sk98lin/skproc.c	Tue May 20 12:17:55 2003
@@ -2,15 +2,15 @@
  *
  * Name:    skproc.c
  * Project:	GEnesis, PCI Gigabit Ethernet Adapter
- * Version:	$Revision: 1.2.2.2 $
- * Date:    $Date: 2001/03/15 12:50:13 $
+ * Version:	$Revision: 1.5 $
+ * Date:    $Date: 2003/03/19 14:40:47 $
  * Purpose:	Funktions to display statictic data
  *
  ******************************************************************************/
  
 /******************************************************************************
  *
- *	(C)Copyright 1998-2001 SysKonnect GmbH.
+ *	(C)Copyright 1998-2003 SysKonnect GmbH.
  *
  *	This program is free software; you can redistribute it and/or modify
  *	it under the terms of the GNU General Public License as published by
@@ -28,6 +28,38 @@
  * History:
  *
  *	$Log: skproc.c,v $
+ *	Revision 1.5  2003/03/19 14:40:47  mlindner
+ *	Fix: Editorial changes
+ *	----------------------------------------------------------------------
+ *	
+ *	Revision 1.4  2003/02/25 14:16:37  mlindner
+ *	Fix: Copyright statement
+ *	
+ *	Revision 1.3  2002/10/02 12:59:51  mlindner
+ *	Add: Support for Yukon
+ *	Add: Speed check and setup
+ *	Add: Merge source for kernel 2.2.x and 2.4.x
+ *	Add: Read sensor names directly from VPD
+ *	Fix: Volt values
+ *	
+ *	Revision 1.2.2.7  2002/01/14 12:45:15  mlindner
+ *	Fix: Editorial changes
+ *	
+ *	Revision 1.2.2.6  2001/12/06 15:26:07  mlindner
+ *	Fix: Return value of proc_read
+ *	
+ *	Revision 1.2.2.5  2001/12/06 09:57:39  mlindner
+ *	New ProcFs entries
+ *	
+ *	Revision 1.2.2.4  2001/09/05 12:16:02  mlindner
+ *	Add: New ProcFs entries
+ *	Fix: Counter Errors (Jumbo == to long errors)
+ *	Fix: Kernel error compilation
+ *	Fix: too short counters
+ *	
+ *	Revision 1.2.2.3  2001/06/25 07:26:26  mlindner
+ *	Add: More error messages
+ *	
  *	Revision 1.2.2.2  2001/03/15 12:50:13  mlindner
  *	fix: ProcFS owner protection
  *	
@@ -46,36 +78,24 @@
 
 #include "h/skdrv1st.h"
 #include "h/skdrv2nd.h"
-#define ZEROPAD	1		/* pad with zero */
-#define SIGN	2		/* unsigned/signed long */
-#define PLUS	4		/* show plus */
-#define SPACE	8		/* space if plus */
-#define LEFT	16		/* left justified */
-//#define SPECIAL	32		/* 0x */
-#define LARGE	64
-
-extern void proc_fill_inode(struct inode *inode, int fill);
-extern char * SkNumber(char * str, long long num, int base, int size, 
-				int precision ,int type);
-int proc_read(char *buffer,
-				char **buffer_location,
-				off_t offset,
-				int buffer_length,
-				int *eof,
-				void *data);
-
-static const char SK_Root_Dir_entry[] = "sk98lin";
-extern struct net_device *sk98lin_root_dev;
-
-
-struct proc_dir_entry pSkRootDir = { 
-	0,
-	sizeof(SK_Root_Dir_entry)-1,
-	(const char*)SK_Root_Dir_entry,
-	S_IFDIR | S_IRUGO,
-	2, 0, 0, 0, NULL,
-	NULL
-};
+#define ZEROPAD		1		/* pad with zero */
+#define SIGN		2		/* unsigned/signed long */
+#define PLUS		4		/* show plus */
+#define SPACE		8		/* space if plus */
+#define LEFT		16		/* left justified */
+#define SPECIALX	32		/* 0x */
+#define LARGE		64
+
+extern SK_AC				*pACList;
+extern struct net_device 	*SkGeRootDev;
+
+extern char * SkNumber(
+	char * str,
+	long long num,
+	int base,
+	int size,
+	int precision,
+	int type);
 
 
 /*****************************************************************************
@@ -100,13 +120,14 @@
 	int len = 0;
 	int t;
 	int i;
-	DEV_NET				*pNet;
-	SK_AC				*pAC;
-	char 				test_buf[100];
+	DEV_NET					*pNet;
+	SK_AC					*pAC;
+	char 					test_buf[100];
+	char					sens_msg[50];
 	unsigned long			Flags;		
 	unsigned int			Size;
-	struct net_device 		*next;
-	struct net_device 		*SkgeProcDev = sk98lin_root_dev;
+	struct SK_NET_DEVICE 		*next;
+	struct SK_NET_DEVICE 		*SkgeProcDev = SkGeRootDev;
 
 	SK_PNMI_STRUCT_DATA 	*pPnmiStruct;
 	SK_PNMI_STAT		*pPnmiStat;
@@ -122,7 +143,7 @@
 		for (t=pAC->GIni.GIMacsFound; t > 0; t--) {
 			if ((pAC->GIni.GIMacsFound == 2) && pAC->RlmtNets == 1)
 				t--;
-			
+
 			spin_lock_irqsave(&pAC->SlowPathLock, Flags);
 			Size = SK_PNMI_STRUCT_SIZE;
 			SkPnmiGetStruct(pAC, pAC->IoBase, 
@@ -135,151 +156,214 @@
 					"\nDetailed statistic for device %s\n",
 					pAC->dev[t-1]->name);
 				len += sprintf(buffer + len,
-					"==================================\n");
+					"=======================================\n");
 	
 				/* Board statistics */
 				len += sprintf(buffer + len, 
 					"\nBoard statistics\n\n");
 				len += sprintf(buffer + len,
-					"Active Port               %c\n",
+					"Active Port                    %c\n",
 					'A' + pAC->Rlmt.Net[t-1].Port[pAC->Rlmt.
 					Net[t-1].PrefPort]->PortNumber);
 				len += sprintf(buffer + len,
-					"Preferred Port            %c\n",
+					"Preferred Port                 %c\n",
 					'A' + pAC->Rlmt.Net[t-1].Port[pAC->Rlmt.
 					Net[t-1].PrefPort]->PortNumber);
 
 				len += sprintf(buffer + len,
-					"Bus speed (Mhz)           %d\n",
+					"Bus speed (MHz)                %d\n",
 					pPnmiStruct->BusSpeed);
 
 				len += sprintf(buffer + len,
-					"Bus width (Bit)           %d\n",
+					"Bus width (Bit)                %d\n",
 					pPnmiStruct->BusWidth);
-
-				for (i=0; i < SK_MAX_SENSORS; i ++) {
-					if (strcmp(pAC->I2c.SenTable[i].SenDesc,
-							"Temperature") == 0 ) {
+				len += sprintf(buffer + len,
+					"Hardware revision              v%d.%d\n",
+					(pAC->GIni.GIPciHwRev >> 4) & 0x0F,
+					pAC->GIni.GIPciHwRev & 0x0F);
+
+				/* Print sensor informations */
+				for (i=0; i < pAC->I2c.MaxSens; i ++) {
+					/* Check type */
+					switch (pAC->I2c.SenTable[i].SenType) {
+					case 1:
+						strcpy(sens_msg, pAC->I2c.SenTable[i].SenDesc);
+						strcat(sens_msg, " (C)");
 						len += sprintf(buffer + len,
-							"Temperature (C)           %d.%d\n",
+							"%-25s      %d.%02d\n",
+							sens_msg,
 							pAC->I2c.SenTable[i].SenValue / 10,
 							pAC->I2c.SenTable[i].SenValue % 10);
+
+						strcpy(sens_msg, pAC->I2c.SenTable[i].SenDesc);
+						strcat(sens_msg, " (F)");
 						len += sprintf(buffer + len,
-							"Temperature (F)           %d.%d\n",
+							"%-25s      %d.%02d\n",
+							sens_msg,
 							((((pAC->I2c.SenTable[i].SenValue)
 							*10)*9)/5 + 3200)/100,
 							((((pAC->I2c.SenTable[i].SenValue)
 							*10)*9)/5 + 3200) % 10);
-					} else if (strcmp(pAC->I2c.SenTable[i].SenDesc,
-							"Speed Fan") == 0 ) {
-						len += sprintf(buffer + len,
-							"Speed Fan                 %d\n",
-							pAC->I2c.SenTable[i].SenValue);
-					} else {
+						break;
+					case 2:
+						strcpy(sens_msg, pAC->I2c.SenTable[i].SenDesc);
+						strcat(sens_msg, " (V)");
 						len += sprintf(buffer + len,
-							"%-20s      %d.%d\n",
-							pAC->I2c.SenTable[i].SenDesc,
+							"%-25s      %d.%03d\n",
+							sens_msg,
 							pAC->I2c.SenTable[i].SenValue / 1000,
 							pAC->I2c.SenTable[i].SenValue % 1000);
+						break;
+					case 3:
+						strcpy(sens_msg, pAC->I2c.SenTable[i].SenDesc);
+						strcat(sens_msg, " (rpm)");
+						len += sprintf(buffer + len,
+							"%-25s      %d\n",
+							sens_msg,
+							pAC->I2c.SenTable[i].SenValue);
+						break;
+					default:
+						break;
 					}
 				}
 				
 				/*Receive statistics */
-				
 				len += sprintf(buffer + len, 
 				"\nReceive statistics\n\n");
 
 				len += sprintf(buffer + len,
-					"Received bytes            %s\n",
+					"Received bytes                 %s\n",
 					SkNumber(test_buf, pPnmiStat->StatRxOctetsOkCts,
 					10,0,-1,0));
 				len += sprintf(buffer + len,
-					"Received packets          %s\n",
+					"Received packets               %s\n",
 					SkNumber(test_buf, pPnmiStat->StatRxOkCts,
 					10,0,-1,0));
+#if 0
+				if (pAC->GIni.GP[0].PhyType == SK_PHY_XMAC && 
+					pAC->HWRevision < 12) {
+					pPnmiStruct->InErrorsCts = pPnmiStruct->InErrorsCts - 
+						pPnmiStat->StatRxShortsCts;
+					pPnmiStat->StatRxShortsCts = 0;
+				}
+#endif
+				if (pNet->Mtu > 1500) 
+					pPnmiStruct->InErrorsCts = pPnmiStruct->InErrorsCts -
+						pPnmiStat->StatRxTooLongCts;
+
 				len += sprintf(buffer + len,
-					"Received errors           %s\n",
-					SkNumber(test_buf, pPnmiStat->StatRxFcsCts,
+					"Receive errors                 %s\n",
+					SkNumber(test_buf, pPnmiStruct->InErrorsCts,
 					10,0,-1,0));
 				len += sprintf(buffer + len,
-					"Received dropped          %s\n",
+					"Receive droped                 %s\n",
 					SkNumber(test_buf, pPnmiStruct->RxNoBufCts,
 					10,0,-1,0));
 				len += sprintf(buffer + len,
-					"Received multicast        %s\n",
+					"Received multicast             %s\n",
 					SkNumber(test_buf, pPnmiStat->StatRxMulticastOkCts,
 					10,0,-1,0));
 				len += sprintf(buffer + len,
-					"Received errors types\n");
+					"Receive error types\n");
 				len += sprintf(buffer + len,
-					"   length errors          %s\n",
+					"   length                      %s\n",
 					SkNumber(test_buf, pPnmiStat->StatRxRuntCts,
 					10, 0, -1, 0));
 				len += sprintf(buffer + len,
-					"   over errors            %s\n",
+					"   buffer overflow             %s\n",
 					SkNumber(test_buf, pPnmiStat->StatRxFifoOverflowCts,
 					10, 0, -1, 0));
 				len += sprintf(buffer + len,
-					"   crc errors             %s\n",
+					"   bad crc                     %s\n",
 					SkNumber(test_buf, pPnmiStat->StatRxFcsCts,
 					10, 0, -1, 0));
 				len += sprintf(buffer + len,
-					"   frame errors           %s\n",
+					"   framing                     %s\n",
 					SkNumber(test_buf, pPnmiStat->StatRxFramingCts,
 					10, 0, -1, 0));
 				len += sprintf(buffer + len,
-					"   fifo errors            %s\n",
-					SkNumber(test_buf, pPnmiStat->StatRxFifoOverflowCts,
-					10, 0, -1, 0));
-				len += sprintf(buffer + len,
-					"   missed errors          %s\n",
+					"   missed frames               %s\n",
 					SkNumber(test_buf, pPnmiStat->StatRxMissedCts,
 					10, 0, -1, 0));
-				
+
+				if (pNet->Mtu > 1500)
+					pPnmiStat->StatRxTooLongCts = 0;
+
+				len += sprintf(buffer + len,
+					"   too long                    %s\n",
+					SkNumber(test_buf, pPnmiStat->StatRxTooLongCts,
+					10, 0, -1, 0));					
+				len += sprintf(buffer + len,
+					"   carrier extension           %s\n",
+					SkNumber(test_buf, pPnmiStat->StatRxCextCts,
+					10, 0, -1, 0));				
+				len += sprintf(buffer + len,
+					"   too short                   %s\n",
+					SkNumber(test_buf, pPnmiStat->StatRxShortsCts,
+					10, 0, -1, 0));				
+				len += sprintf(buffer + len,
+					"   symbol                      %s\n",
+					SkNumber(test_buf, pPnmiStat->StatRxSymbolCts,
+					10, 0, -1, 0));				
+				len += sprintf(buffer + len,
+					"   LLC MAC size                %s\n",
+					SkNumber(test_buf, pPnmiStat->StatRxIRLengthCts,
+					10, 0, -1, 0));				
+				len += sprintf(buffer + len,
+					"   carrier event               %s\n",
+					SkNumber(test_buf, pPnmiStat->StatRxCarrierCts,
+					10, 0, -1, 0));				
+				len += sprintf(buffer + len,
+					"   jabber                      %s\n",
+					SkNumber(test_buf, pPnmiStat->StatRxJabberCts,
+					10, 0, -1, 0));				
+
+
 				/*Transmit statistics */
 				len += sprintf(buffer + len, 
 				"\nTransmit statistics\n\n");
 				
 				len += sprintf(buffer + len,
-					"Transmit bytes            %s\n",
+					"Transmited bytes               %s\n",
 					SkNumber(test_buf, pPnmiStat->StatTxOctetsOkCts,
 					10,0,-1,0));
 				len += sprintf(buffer + len,
-					"Transmit packets          %s\n",
+					"Transmited packets             %s\n",
 					SkNumber(test_buf, pPnmiStat->StatTxOkCts,
 					10,0,-1,0));
 				len += sprintf(buffer + len,
-					"Transmit errors           %s\n",
+					"Transmit errors                %s\n",
 					SkNumber(test_buf, pPnmiStat->StatTxSingleCollisionCts,
 					10,0,-1,0));
 				len += sprintf(buffer + len,
-					"Transmit dropped          %s\n",
+					"Transmit dropped               %s\n",
 					SkNumber(test_buf, pPnmiStruct->TxNoBufCts,
 					10,0,-1,0));
 				len += sprintf(buffer + len,
-					"Transmit collisions       %s\n",
+					"Transmit collisions            %s\n",
 					SkNumber(test_buf, pPnmiStat->StatTxSingleCollisionCts,
 					10,0,-1,0));
 				len += sprintf(buffer + len,
-					"Transmited errors types\n");
+					"Transmit error types\n");
 				len += sprintf(buffer + len,
-					"   aborted errors         %ld\n",
+					"   excessive collision         %ld\n",
 					pAC->stats.tx_aborted_errors);
 				len += sprintf(buffer + len,
-					"   carrier errors         %s\n",
+					"   carrier                     %s\n",
 					SkNumber(test_buf, pPnmiStat->StatTxCarrierCts,
 					10, 0, -1, 0));
 				len += sprintf(buffer + len,
-					"   fifo errors            %s\n",
+					"   fifo underrun               %s\n",
 					SkNumber(test_buf, pPnmiStat->StatTxFifoUnderrunCts,
 					10, 0, -1, 0));
 				len += sprintf(buffer + len,
-					"   heartbeat errors       %s\n",
+					"   heartbeat                   %s\n",
 					SkNumber(test_buf, pPnmiStat->StatTxCarrierCts,
 					10, 0, -1, 0));
 				len += sprintf(buffer + len,
-					"   window errors          %ld\n",
+					"   window                      %ld\n",
 					pAC->stats.tx_window_errors);
+				
 			}
 		}
 		SkgeProcDev = next;
@@ -388,7 +472,7 @@
 			size--;
 		}
 	}
-	if (type & SPECIAL) {
+	if (type & SPECIALX) {
 		if (base == 16)
 			size -= 2;
 		else if (base == 8)
@@ -408,7 +492,7 @@
 			*str++ = ' ';
 	if (sign)
 		*str++ = sign;
-	if (type & SPECIAL) {
+	if (type & SPECIALX) {
 		if (base==8)
 			*str++ = '0';
 		else if (base==16) {
diff -ruN linux/drivers/net/sk98lin/skqueue.c linuxn/drivers/net/sk98lin/skqueue.c
--- linux/drivers/net/sk98lin/skqueue.c	Wed Jul  4 20:50:39 2001
+++ linuxn/drivers/net/sk98lin/skqueue.c	Tue May 20 12:17:40 2003
@@ -1,32 +1,23 @@
 /******************************************************************************
  *
  * Name:	skqueue.c
- * Project:	PCI Gigabit Ethernet Adapter
- * Version:	$Revision: 1.14 $
- * Date:	$Date: 1998/10/15 15:11:35 $
+ * Project:	GEnesis, PCI Gigabit Ethernet Adapter
+ * Version:	$Revision: 1.18 $
+ * Date:	$Date: 2002/05/07 14:11:11 $
  * Purpose:	Management of an event queue.
  *
  ******************************************************************************/
 
 /******************************************************************************
  *
- *	(C)Copyright 1989-1998 SysKonnect,
+ *	(C)Copyright 1998,1999 SysKonnect,
  *	a business unit of Schneider & Koch & Co. Datensysteme GmbH.
- *	All Rights Reserved
  *
- *	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF SYSKONNECT
- *	The copyright notice above does not evidence any
- *	actual or intended publication of such source code.
- *
- *	This Module contains Proprietary Information of SysKonnect
- *	and should be treated as Confidential.
- *
- *	The information in this file is provided for the exclusive use of
- *	the licensees of SysKonnect.
- *	Such users have the right to use, modify, and incorporate this code
- *	into products for purposes authorized by the license agreement
- *	provided they include this notice and the associated copyright notice
- *	with any such product.
+ *	This program is free software; you can redistribute it and/or modify
+ *	it under the terms of the GNU General Public License as published by
+ *	the Free Software Foundation; either version 2 of the License, or
+ *	(at your option) any later version.
+ *
  *	The information in this file is provided "AS IS" without warranty.
  *
  ******************************************************************************/
@@ -36,6 +27,18 @@
  * History:
  *
  *	$Log: skqueue.c,v $
+ *	Revision 1.18  2002/05/07 14:11:11  rwahl
+ *	Fixed Watcom Precompiler error.
+ *	
+ *	Revision 1.17  2002/03/25 10:06:41  mkunz
+ *	SkIgnoreEvent deleted
+ *	
+ *	Revision 1.16  2002/03/15 10:51:59  mkunz
+ *	Added event classes for link aggregation
+ *	
+ *	Revision 1.15  1999/11/22 13:36:29  cgoos
+ *	Changed license header to GPL.
+ *	
  *	Revision 1.14  1998/10/15 15:11:35  gklug
  *	fix: ID_sccs to SysKonnectFileId
  *	
@@ -88,7 +91,7 @@
 	Event queue and dispatcher
 */
 static const char SysKonnectFileId[] =
-	"$Header: /usr56/projects/ge/schedule/skqueue.c,v 1.14 1998/10/15 15:11:35 gklug Exp $" ;
+	"$Header: /usr56/projects/ge/schedule/skqueue.c,v 1.18 2002/05/07 14:11:11 rwahl Exp $" ;
 
 #include "h/skdrv1st.h"		/* Driver Specific Definitions */
 #include "h/skqueue.h"		/* Queue Definitions */
@@ -168,9 +171,7 @@
 	while (pEv != pAC->Event.EvPut) {
 		PRINTF("dispatch Class %d Event %d\n",pEv->Class,pEv->Event) ;
 		switch(Class = pEv->Class) {
-		case SKGE_DRV :		/* Driver Event */
-			Rtv = SkDrvEvent(pAC,Ioc,pEv->Event,pEv->Para);
-			break ;
+#ifndef SK_USE_LAC_EV        
 		case SKGE_RLMT :	/* RLMT Event */
 			Rtv = SkRlmtEvent(pAC,Ioc,pEv->Event,pEv->Para);
 			break ;
@@ -180,9 +181,33 @@
 		case SKGE_PNMI :
 			Rtv = SkPnmiEvent(pAC,Ioc,pEv->Event,pEv->Para);
 			break ;
+#endif /* SK_USE_LAC_EV */
+		case SKGE_DRV :		/* Driver Event */
+			Rtv = SkDrvEvent(pAC,Ioc,pEv->Event,pEv->Para);
+			break ;
+#ifndef SK_USE_SW_TIMER        
 		case SKGE_HWAC :
 			Rtv = SkGeSirqEvent(pAC,Ioc,pEv->Event,pEv->Para);
 			break ;
+#else /* !SK_USE_SW_TIMER */
+        case SKGE_SWT : 
+			Rtv = SkSwtEvent(pAC,Ioc,pEv->Event,pEv->Para);
+			break ;
+#endif /* !SK_USE_SW_TIMER */
+#ifdef SK_USE_LAC_EV        
+		case SKGE_LACP :
+			Rtv = SkLacpEvent(pAC,Ioc,pEv->Event,pEv->Para);
+			break ;
+		case SKGE_RSF :
+			Rtv = SkRsfEvent(pAC,Ioc,pEv->Event,pEv->Para);
+			break ;
+		case SKGE_MARKER :
+			Rtv = SkMarkerEvent(pAC,Ioc,pEv->Event,pEv->Para);
+			break ;
+		case SKGE_FD :
+			Rtv = SkFdEvent(pAC,Ioc,pEv->Event,pEv->Para);
+			break ;
+#endif /* SK_USE_LAC_EV */
 #ifdef	SK_USE_CSUM
 		case SKGE_CSUM :
 			Rtv = SkCsEvent(pAC,Ioc,pEv->Event,pEv->Para);
diff -ruN linux/drivers/net/sk98lin/skrlmt.c linuxn/drivers/net/sk98lin/skrlmt.c
--- linux/drivers/net/sk98lin/skrlmt.c	Wed Jul  4 20:50:39 2001
+++ linuxn/drivers/net/sk98lin/skrlmt.c	Tue May 20 12:17:40 2003
@@ -2,15 +2,16 @@
  *
  * Name:	skrlmt.c
  * Project:	GEnesis, PCI Gigabit Ethernet Adapter
- * Version:	$Revision: 1.61 $
- * Date:	$Date: 2001/03/14 12:52:08 $
+ * Version:	$Revision: 1.69 $
+ * Date:	$Date: 2003/04/15 09:39:22 $
  * Purpose:	Manage links on SK-NET Adapters, esp. redundant ones.
  *
  ******************************************************************************/
 
 /******************************************************************************
  *
- *	(C)Copyright 1998-2001 SysKonnect GmbH.
+ *	(C)Copyright 1998-2002 SysKonnect GmbH.
+ *	(C)Copyright 2002-2003 Marvell.
  *
  *	This program is free software; you can redistribute it and/or modify
  *	it under the terms of the GNU General Public License as published by
@@ -26,6 +27,37 @@
  * History:
  *
  *	$Log: skrlmt.c,v $
+ *	Revision 1.69  2003/04/15 09:39:22  tschilli
+ *	Copyright messages changed.
+ *	"#error C++ is not yet supported." removed.
+ *	
+ *	Revision 1.68  2003/01/31 15:26:56  rschmidt
+ *	Added init for local variables in RlmtInit().
+ *	
+ *	Revision 1.67  2003/01/31 14:12:41  mkunz
+ *	single port adapter runs now with two identical MAC addresses
+ *	
+ *	Revision 1.66  2002/09/23 15:14:19  rwahl
+ *	- Reset broadcast timestamp on link down.
+ *	- Editorial corrections.
+ *	
+ *	Revision 1.65  2002/07/22 14:29:48  rwahl
+ *	- Removed BRK statement from debug check.
+ *	
+ *	Revision 1.64  2001/11/28 19:36:14  rwahl
+ *	- RLMT Packets sent to an invalid MAC address in CLP/CLPSS mode
+ *	  (#10650).
+ *	- Reworked fix for port switching in CLS mode (#10639)
+ *	 (no dependency to RLMT module).
+ *	- Enabled dbg output for entry/exit of event functions.
+ *	- Editorial changes.
+ *	
+ *	Revision 1.63  2001/10/26 07:53:18  afischer
+ *	Port switching bug in `check local link` mode
+ *	
+ *	Revision 1.62  2001/07/03 12:16:30  mkunz
+ *	New Flag ChgBcPrio (Change priority of last broadcast received)
+ *	
  *	Revision 1.61  2001/03/14 12:52:08  rassmann
  *	Fixed reporting of active port up/down to PNMI.
  *	
@@ -255,13 +287,12 @@
 
 #ifndef	lint
 static const char SysKonnectFileId[] =
-	"@(#) $Id: skrlmt.c,v 1.61 2001/03/14 12:52:08 rassmann Exp $ (C) SysKonnect.";
+	"@(#) $Id: skrlmt.c,v 1.69 2003/04/15 09:39:22 tschilli Exp $ (C) Marvell.";
 #endif	/* !defined(lint) */
 
 #define __SKRLMT_C
 
 #ifdef __cplusplus
-#error C++ is not yet supported.
 extern "C" {
 #endif	/* cplusplus */
 
@@ -561,6 +592,10 @@
 	SK_U32		i, j;
 	SK_U64		Random;
 	SK_EVPARA	Para;
+    SK_MAC_ADDR		VirtualMacAddress;
+    SK_MAC_ADDR		PhysicalAMacAddress;
+    SK_BOOL		VirtualMacAddressSet;
+    SK_BOOL		PhysicalAMacAddressSet;
 
 	SK_DBG_MSG(pAC, SK_DBGMOD_RLMT, SK_DBGCAT_INIT,
 		("RLMT Init level %d.\n", Level))
@@ -585,8 +620,8 @@
 		for (i = 0; i < SK_MAX_NETS; i++) {
 			pAC->Rlmt.Net[i].RlmtState = SK_RLMT_RS_INIT;
 			pAC->Rlmt.Net[i].RootIdSet = SK_FALSE;
-			pAC->Rlmt.Net[i].Preference = 0xFFFFFFFF;	  /* Automatic. */
 			pAC->Rlmt.Net[i].PrefPort = SK_RLMT_DEF_PREF_PORT;
+			pAC->Rlmt.Net[i].Preference = 0xFFFFFFFF;	  /* Automatic. */
 			/* Just assuming. */
 			pAC->Rlmt.Net[i].ActivePort = pAC->Rlmt.Net[i].PrefPort;
 			pAC->Rlmt.Net[i].RlmtMode = SK_RLMT_DEF_MODE;
@@ -608,7 +643,7 @@
 		pAC->Rlmt.Net[0].NumPorts = pAC->GIni.GIMacsFound;
 
 		/* Initialize HW registers? */
-		if (pAC->GIni.GIMacsFound < 2) {
+		if (pAC->GIni.GIMacsFound == 1) {
 			Para.Para32[0] = SK_RLMT_MODE_CLS;
 			Para.Para32[1] = 0;
 			(void)SkRlmtEvent(pAC, IoC, SK_RLMT_MODE_CHANGE, Para);
@@ -644,6 +679,38 @@
 
 			(void)SkAddrMcUpdate(pAC, IoC, i);
 		}
+
+    	VirtualMacAddressSet = SK_FALSE;
+		/* Read virtual MAC address from Control Register File. */
+		for (j = 0; j < SK_MAC_ADDR_LEN; j++) {
+			
+            SK_IN8(IoC, B2_MAC_1 + j, &VirtualMacAddress.a[j]);
+            VirtualMacAddressSet |= VirtualMacAddress.a[j];
+		}
+    	
+        PhysicalAMacAddressSet = SK_FALSE;
+		/* Read physical MAC address for MAC A from Control Register File. */
+		for (j = 0; j < SK_MAC_ADDR_LEN; j++) {
+			
+            SK_IN8(IoC, B2_MAC_2 + j, &PhysicalAMacAddress.a[j]);
+            PhysicalAMacAddressSet |= PhysicalAMacAddress.a[j];
+		}
+
+        /* check if the two mac addresses contain reasonable values */
+        if (!VirtualMacAddressSet || !PhysicalAMacAddressSet) {
+
+            pAC->Rlmt.RlmtOff = SK_TRUE;
+        }
+
+        /* if the two mac addresses are equal switch off the RLMT_PRE_LOOKAHEAD
+           and the RLMT_LOOKAHEAD macros */
+        else if (SK_ADDR_EQUAL(PhysicalAMacAddress.a, VirtualMacAddress.a)) {
+
+            pAC->Rlmt.RlmtOff = SK_TRUE;
+        }
+		else {
+			pAC->Rlmt.RlmtOff = SK_FALSE;
+		}
 		break;
 
 	default:	/* error */
@@ -714,7 +781,7 @@
 				FirstMacUp = pAC->Rlmt.Net[NetIdx].Port[i];
 			}
 			else {
-				pAC->Rlmt.Net[NetIdx].Port[i]->PortCheck[
+				PrevMacUp->PortCheck[
 					pAC->Rlmt.Net[NetIdx].Port[i]->PortsChecked].CheckAddr =
 					pAC->Rlmt.Net[NetIdx].Port[i]->AddrPort->CurrentMacAddress;
 				PrevMacUp->PortCheck[
@@ -737,13 +804,13 @@
 #ifdef DEBUG
 	for (i = 0; i < pAC->Rlmt.Net[NetIdx].NumPorts; i++) {
 		SK_DBG_MSG(pAC, SK_DBGMOD_RLMT, SK_DBGCAT_CTRL,
-			("Port %d checks %d other ports: %2X.\n", NetIdx,
+			("Port %d checks %d other ports: %2X.\n", i,
 				pAC->Rlmt.Net[NetIdx].Port[i]->PortsChecked,
 				pAC->Rlmt.Net[NetIdx].Port[i]->PortCheck[0].CheckAddr.a[5]))
 	}
 #endif	/* DEBUG */
 
-	return;       
+	return;
 }	/* SkRlmtBuildCheckChain */
 
 
@@ -773,6 +840,22 @@
 	SK_MBUF		*pMb;
 	SK_RLMT_PACKET	*pPacket;
 
+#ifdef DEBUG
+	SK_U8	CheckSrc  = 0;
+	SK_U8	CheckDest = 0;
+	
+	for (i = 0; i < SK_MAC_ADDR_LEN; ++i) {
+		CheckSrc  |= SrcAddr->a[i];
+		CheckDest |= DestAddr->a[i];
+	}
+
+	if ((CheckSrc == 0) || (CheckDest == 0)) {
+		SK_DBG_MSG(pAC, SK_DBGMOD_RLMT, SK_DBGCAT_ERR,
+			("SkRlmtBuildPacket: Invalid %s%saddr.\n",
+			 (CheckSrc == 0 ? "Src" : ""), (CheckDest == 0 ? "Dest" : "")))
+	}
+#endif
+
 	if ((pMb = SkDrvAllocRlmtMbuf(pAC, IoC, SK_RLMT_MAX_PACKET_SIZE)) != NULL) {
 		pPacket = (SK_RLMT_PACKET*)pMb->pData;
 		for (i = 0; i < SK_MAC_ADDR_LEN; i++) {
@@ -814,7 +897,7 @@
 		}
 	}
 
-	return (pMb);       
+	return (pMb);
 }	/* SkRlmtBuildPacket */
 
 
@@ -896,7 +979,7 @@
 		pAC->Rlmt.Port[PortNumber].TxSpHelloReqCts++;
 	}
 
-	return (pMb);       
+	return (pMb);
 }	/* SkRlmtBuildSpanningTreePacket */
 
 
@@ -963,8 +1046,8 @@
 			SK_DBG_MSG(pAC, SK_DBGMOD_RLMT, SK_DBGCAT_TX,
 				("SkRlmtSend: BPDU Packet on Port %u.\n", PortNumber))
 		}
-	}   
-	return;   
+	}
+	return;
 }	/* SkRlmtSend */
 
 
@@ -1304,7 +1387,7 @@
 					pRPort->Root.Id[0], pRPort->Root.Id[1],
 					pRPort->Root.Id[2], pRPort->Root.Id[3],
 					pRPort->Root.Id[4], pRPort->Root.Id[5],
-					pRPort->Root.Id[6], pRPort->Root.Id[7]))      
+					pRPort->Root.Id[6], pRPort->Root.Id[7]))
 		}
 
 		SkDrvFreeRlmtMbuf(pAC, IoC, pMb);
@@ -1467,10 +1550,10 @@
 			SkRlmtCheckSwitch(pAC, IoC, pRPort->Net->NetNumber);
 		}
 
-		NewTimeout = SK_RLMT_DEF_TO_VAL;              
+		NewTimeout = SK_RLMT_DEF_TO_VAL;
 	}
 
-	return (NewTimeout);       
+	return (NewTimeout);
 }	/* SkRlmtCheckPort */
 
 
@@ -1504,13 +1587,14 @@
 	
 	/* Select port with the latest TimeStamp. */
 	for (i = 0; i < (SK_U32)pAC->GIni.GIMacsFound; i++) {
-#ifdef xDEBUG
+
 		SK_DBG_MSG(pAC, SK_DBGMOD_RLMT, SK_DBGCAT_CTRL,
-			("TimeStamp Port %d: %08x %08x.\n",
+			("TimeStamp Port %d (Down: %d, NoRx: %d): %08x %08x.\n",
 				i,
+   				pAC->Rlmt.Port[i].PortDown, pAC->Rlmt.Port[i].PortNoRx,
 				*((SK_U32*)(&pAC->Rlmt.Port[i].BcTimeStamp) + OFFS_HI32),
 				*((SK_U32*)(&pAC->Rlmt.Port[i].BcTimeStamp) + OFFS_LO32)))
-#endif	/* DEBUG */
+
 		if (!pAC->Rlmt.Port[i].PortDown && !pAC->Rlmt.Port[i].PortNoRx) {
 			if (!PortFound || pAC->Rlmt.Port[i].BcTimeStamp > BcTimeStamp) {
 				BcTimeStamp = pAC->Rlmt.Port[i].BcTimeStamp;
@@ -1521,10 +1605,8 @@
 	}
 
 	if (PortFound) {
-#if 0
 		SK_DBG_MSG(pAC, SK_DBGMOD_RLMT, SK_DBGCAT_CTRL,
 			("Port %d received the last broadcast.\n", *pSelect))
-#endif	/* 0 */
 
 		/* Look if another port's time stamp is similar. */
 		for (i = 0; i < (SK_U32)pAC->GIni.GIMacsFound; i++) {
@@ -1537,19 +1619,19 @@
 				pAC->Rlmt.Port[i].BcTimeStamp +
 				 SK_RLMT_BC_DELTA > BcTimeStamp)) {
 				PortFound = SK_FALSE;
-#ifdef xDEBUG
+				
 				SK_DBG_MSG(pAC, SK_DBGMOD_RLMT, SK_DBGCAT_CTRL,
 					("Port %d received a broadcast at a similar time.\n", i))
-#endif	/* DEBUG */
 				break;
 			}
 		}
 	}
 
-#ifdef xDEBUG
+#ifdef DEBUG
 	if (PortFound) {
 		SK_DBG_MSG(pAC, SK_DBGMOD_RLMT, SK_DBGCAT_CTRL,
-			("SK_RLMT_CHECK_SWITCH found Port %d receiving the substantially latest broadcast (%d).\n",
+			("SK_RLMT_SELECT_BCRX found Port %d receiving the substantially "
+			 "latest broadcast (%u).\n",
 				*pSelect,
 				BcTimeStamp - pAC->Rlmt.Port[1 - *pSelect].BcTimeStamp))
 	}
@@ -1599,7 +1681,7 @@
 			}
 			PortFound = SK_TRUE;
 			SK_DBG_MSG(pAC, SK_DBGMOD_RLMT, SK_DBGCAT_CTRL,
-				("SK_RLMT_CHECK_SWITCH found Port %d up and not check RX.\n",
+				("SK_RLMT_SELECT_NOTSUSPECT found Port %d up and not check RX.\n",
 					*pSelect))
 			break;
 		}
@@ -1649,7 +1731,7 @@
 			}
 			PortFound = SK_TRUE;
 			SK_DBG_MSG(pAC, SK_DBGMOD_RLMT, SK_DBGCAT_CTRL,
-				("SK_RLMT_CHECK_SWITCH found Port %d up.\n", *pSelect))
+				("SK_RLMT_SELECT_UP found Port %d up.\n", *pSelect))
 			break;
 		}
 	}
@@ -1710,7 +1792,7 @@
 	}
 
 	SK_DBG_MSG(pAC, SK_DBGMOD_RLMT, SK_DBGCAT_CTRL,
-		("SK_RLMT_CHECK_SWITCH found Port %d going up.\n", *pSelect))
+		("SK_RLMT_SELECT_GOINGUP found Port %d going up.\n", *pSelect))
 	return (SK_TRUE);
 }	/* SkRlmtSelectGoingUp */
 
@@ -1756,7 +1838,7 @@
 			}
 			PortFound = SK_TRUE;
 			SK_DBG_MSG(pAC, SK_DBGMOD_RLMT, SK_DBGCAT_CTRL,
-				("SK_RLMT_CHECK_SWITCH found Port %d down.\n", *pSelect))
+				("SK_RLMT_SELECT_DOWN found Port %d down.\n", *pSelect))
 			break;
 		}
 	}
@@ -1794,6 +1876,13 @@
 	PortFound = SK_FALSE;
 	pAC->Rlmt.CheckSwitch = SK_FALSE;
 
+#if 0	/* RW 2001/10/18 - active port becomes always prefered one */
+	if (pAC->Rlmt.Net[NetIdx].Preference == 0xFFFFFFFF) { /* Automatic */
+		/* disable auto-fail back */
+		PrefPort = Active;
+	}
+#endif
+
 	if (pAC->Rlmt.Net[NetIdx].LinksUp == 0) {
 		/* Last link went down - shut down the net. */
 		pAC->Rlmt.Net[NetIdx].RlmtState = SK_RLMT_RS_NET_DOWN;
@@ -1882,7 +1971,10 @@
 		 *		else
 		 *			SwitchSoft
 		 */
-		if (pAC->Rlmt.Net[0].RlmtMode != SK_RLMT_MODE_CLS) {
+		/* check of ChgBcPrio flag added */
+		if ((pAC->Rlmt.Net[0].RlmtMode != SK_RLMT_MODE_CLS) &&
+			(!pAC->Rlmt.Net[0].ChgBcPrio)) {
+			
 			if (!PortFound) {
 				PortFound = SkRlmtSelectBcRx(
 					pAC, IoC, Active, PrefPort, &Para.Para32[1]);
@@ -1894,6 +1986,20 @@
 			}
 		}	/* pAC->Rlmt.RlmtMode != SK_RLMT_MODE_CLS */
 
+		/* with changed priority for last broadcast received */
+		if ((pAC->Rlmt.Net[0].RlmtMode != SK_RLMT_MODE_CLS) &&
+			(pAC->Rlmt.Net[0].ChgBcPrio)) {
+			if (!PortFound) {
+				PortFound = SkRlmtSelectNotSuspect(
+					pAC, IoC, Active, PrefPort, &Para.Para32[1]);
+			}
+
+			if (!PortFound) {
+				PortFound = SkRlmtSelectBcRx(
+					pAC, IoC, Active, PrefPort, &Para.Para32[1]);
+			}
+		}	/* pAC->Rlmt.RlmtMode != SK_RLMT_MODE_CLS */
+
 		if (!PortFound) {
 			PortFound = SkRlmtSelectUp(
 				pAC, IoC, Active, PrefPort, &Para.Para32[1], AUTONEG_SUCCESS);
@@ -1927,6 +2033,7 @@
 		}	/* pAC->Rlmt.RlmtMode != SK_RLMT_MODE_CLS */
 
 		if (PortFound) {
+
 			if (Para.Para32[1] != Active) {
 				SK_DBG_MSG(pAC, SK_DBGMOD_RLMT, SK_DBGCAT_CTRL,
 					("Active: %d, Para1: %d.\n", Active, Para.Para32[1]))
@@ -2369,6 +2476,7 @@
 	pRPort->PacketsPerTimeSlot = 0;
 	/* pRPort->DataPacketsPerTimeSlot = 0; */
 	pRPort->BpduPacketsPerTimeSlot = 0;
+	pRPort->BcTimeStamp = 0;
 
 	/*
 	 * RA;:;: To be checked:
@@ -2639,7 +2747,7 @@
 	}
 
 	/* Stop RLMT timers. */
-	SkTimerStop(pAC, IoC, &pAC->Rlmt.Net[Para.Para32[0]].LocTimer); 
+	SkTimerStop(pAC, IoC, &pAC->Rlmt.Net[Para.Para32[0]].LocTimer);
 	SkTimerStop(pAC, IoC, &pAC->Rlmt.Net[Para.Para32[0]].SegTimer);
 
 	/* Stop net. */
@@ -2698,10 +2806,8 @@
 	SK_U32			PortNumber;
 	SK_U32			i;
 
-#if 0
 	SK_DBG_MSG(pAC, SK_DBGMOD_RLMT, SK_DBGCAT_CTRL,
 		("SK_RLMT_TIM Event BEGIN.\n"))
-#endif	/* 0 */
 
 	if (Para.Para32[1] != (SK_U32)-1) {
 		SK_DBG_MSG(pAC, SK_DBGMOD_RLMT, SK_DBGCAT_CTRL,
@@ -2778,10 +2884,8 @@
 			SK_RLMT_RCS_SEG | SK_RLMT_RCS_REPORT_SEG;
 	}
 
-#if 0
 	SK_DBG_MSG(pAC, SK_DBGMOD_RLMT, SK_DBGCAT_CTRL,
 			("SK_RLMT_TIM Event END.\n"))
-#endif	/* 0 */
 }	/* SkRlmtEvtTim */
 
 
@@ -2804,7 +2908,7 @@
 SK_IOC		IoC,	/* I/O Context */
 SK_EVPARA	Para)	/* SK_U32 NetNumber; SK_U32 -1 */
 {
-#ifdef XDEBUG
+#ifdef xDEBUG
 	int j;
 #endif	/* DEBUG */
 
@@ -2820,7 +2924,7 @@
 	}
 
 #ifdef xDEBUG
-	for (j = 0; i < pAC->Rlmt.Net[Para.Para32[0]].NumPorts; j++) {
+	for (j = 0; j < pAC->Rlmt.Net[Para.Para32[0]].NumPorts; j++) {
 		SK_ADDR_PORT	*pAPort;
 		SK_U32			k;
 		SK_U16			*InAddr;
@@ -2842,8 +2946,8 @@
 					pAPort->Exact[k].a[4], pAPort->Exact[k].a[5]))
 		}
 	}
-#endif	/* DEBUG */
-				   
+#endif	/* xDEBUG */
+				
 	SkRlmtCheckSeg(pAC, IoC, Para.Para32[0]);
 
 	SK_DBG_MSG(pAC, SK_DBGMOD_RLMT, SK_DBGCAT_CTRL,
@@ -2874,10 +2978,9 @@
 	SK_MBUF	*pNextMb;
 	SK_U32	NetNumber;
 
-#if 0
+	
 	SK_DBG_MSG(pAC, SK_DBGMOD_RLMT, SK_DBGCAT_CTRL,
 		("SK_RLMT_PACKET_RECEIVED Event BEGIN.\n"))
-#endif	/* 0 */
 
 	/* Should we ignore frames during port switching? */
 
@@ -2905,10 +3008,8 @@
 		}
 	}
 
-#if 0
 	SK_DBG_MSG(pAC, SK_DBGMOD_RLMT, SK_DBGCAT_CTRL,
 		("SK_RLMT_PACKET_RECEIVED Event END.\n"))
-#endif	/* 0 */
 }	/* SkRlmtEvtPacketRx */
 
 
@@ -2987,6 +3088,9 @@
 SK_IOC		IoC,	/* I/O Context */
 SK_EVPARA	Para)	/* SK_U32 NetNumber; SK_U32 -1 */
 {
+	SK_DBG_MSG(pAC, SK_DBGMOD_RLMT, SK_DBGCAT_CTRL,
+		("SK_RLMT_STATS_UPDATE Event BEGIN.\n"))
+
 	if (Para.Para32[1] != (SK_U32)-1) {
 		SK_DBG_MSG(pAC, SK_DBGMOD_RLMT, SK_DBGCAT_CTRL,
 			("Bad Parameter.\n"))
@@ -3003,15 +3107,10 @@
 		return;
 	}
 
-#if 0
-	SK_DBG_MSG(pAC, SK_DBGMOD_RLMT, SK_DBGCAT_CTRL,
-		("SK_RLMT_STATS_UPDATE Event BEGIN.\n"))
-
 	/* Update statistics - currently always up-to-date. */
 
 	SK_DBG_MSG(pAC, SK_DBGMOD_RLMT, SK_DBGCAT_CTRL,
 		("SK_RLMT_STATS_UPDATE Event END.\n"))
-#endif	/* 0 */
 }	/* SkRlmtEvtStatsUpdate */
 
 
@@ -3236,7 +3335,7 @@
 
 	Para.Para32[0] |= SK_RLMT_CHECK_LINK;
 
-	if (pAC->Rlmt.Net[Para.Para32[1]].NumPorts < 2 &&
+	if ((pAC->Rlmt.Net[Para.Para32[1]].NumPorts == 1) &&
 		Para.Para32[0] != SK_RLMT_MODE_CLS) {
 		pAC->Rlmt.Net[Para.Para32[1]].RlmtMode = SK_RLMT_MODE_CLS;
 		SK_DBG_MSG(pAC, SK_DBGMOD_RLMT, SK_DBGCAT_CTRL,
@@ -3399,7 +3498,7 @@
 		break;
 	}	/* switch() */
 
-	return (0);       
+	return (0);
 }	/* SkRlmtEvent */
 
 #ifdef __cplusplus
diff -ruN linux/drivers/net/sk98lin/sktimer.c linuxn/drivers/net/sk98lin/sktimer.c
--- linux/drivers/net/sk98lin/sktimer.c	Wed Jul  4 20:50:39 2001
+++ linuxn/drivers/net/sk98lin/sktimer.c	Tue May 20 12:17:40 2003
@@ -1,32 +1,23 @@
 /******************************************************************************
  *
  * Name:	sktimer.c
- * Project:	PCI Gigabit Ethernet Adapter
- * Version:	$Revision: 1.11 $
- * Date:	$Date: 1998/12/17 13:24:13 $
+ * Project:	GEnesis, PCI Gigabit Ethernet Adapter
+ * Version:	$Revision: 1.12 $
+ * Date:	$Date: 1999/11/22 13:38:51 $
  * Purpose:	High level timer functions.
  *
  ******************************************************************************/
 
 /******************************************************************************
  *
- *	(C)Copyright 1989-1998 SysKonnect,
+ *	(C)Copyright 1998,1999 SysKonnect,
  *	a business unit of Schneider & Koch & Co. Datensysteme GmbH.
- *	All Rights Reserved
  *
- *	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF SYSKONNECT
- *	The copyright notice above does not evidence any
- *	actual or intended publication of such source code.
- *
- *	This Module contains Proprietary Information of SysKonnect
- *	and should be treated as Confidential.
- *
- *	The information in this file is provided for the exclusive use of
- *	the licensees of SysKonnect.
- *	Such users have the right to use, modify, and incorporate this code
- *	into products for purposes authorized by the license agreement
- *	provided they include this notice and the associated copyright notice
- *	with any such product.
+ *	This program is free software; you can redistribute it and/or modify
+ *	it under the terms of the GNU General Public License as published by
+ *	the Free Software Foundation; either version 2 of the License, or
+ *	(at your option) any later version.
+ *
  *	The information in this file is provided "AS IS" without warranty.
  *
  ******************************************************************************/
@@ -36,6 +27,9 @@
  * History:
  *
  *	$Log: sktimer.c,v $
+ *	Revision 1.12  1999/11/22 13:38:51  cgoos
+ *	Changed license header to GPL.
+ *	
  *	Revision 1.11  1998/12/17 13:24:13  gklug
  *	fix: restart problem: do NOT destroy timer queue if init 1 is done
  *	
@@ -82,7 +76,7 @@
 	Event queue and dispatcher
 */
 static const char SysKonnectFileId[] =
-	"$Header: /usr56/projects/ge/schedule/sktimer.c,v 1.11 1998/12/17 13:24:13 gklug Exp $" ;
+	"$Header: /usr56/projects/ge/schedule/sktimer.c,v 1.12 1999/11/22 13:38:51 cgoos Exp $" ;
 
 #include "h/skdrv1st.h"		/* Driver Specific Definitions */
 #include "h/skdrv2nd.h"		/* Adapter Control- and Driver specific Def. */
diff -ruN linux/drivers/net/sk98lin/skvpd.c linuxn/drivers/net/sk98lin/skvpd.c
--- linux/drivers/net/sk98lin/skvpd.c	Tue Nov 13 18:19:41 2001
+++ linuxn/drivers/net/sk98lin/skvpd.c	Tue May 20 12:17:40 2003
@@ -2,16 +2,15 @@
  *
  * Name:	skvpd.c
  * Project:	GEnesis, PCI Gigabit Ethernet Adapter
- * Version:	$Revision: 1.26 $
- * Date:	$Date: 2000/06/13 08:00:01 $
+ * Version:	$Revision: 1.37 $
+ * Date:	$Date: 2003/01/13 10:42:45 $
  * Purpose:	Shared software to read and write VPD data
  *
  ******************************************************************************/
 
 /******************************************************************************
  *
- *	(C)Copyright 1998,1999 SysKonnect,
- *	a business unit of Schneider & Koch & Co. Datensysteme GmbH.
+ *	(C)Copyright 1998-2003 SysKonnect GmbH.
  *
  *	This program is free software; you can redistribute it and/or modify
  *	it under the terms of the GNU General Public License as published by
@@ -27,6 +26,47 @@
  * History:
  *
  *	$Log: skvpd.c,v $
+ *	Revision 1.37  2003/01/13 10:42:45  rschmidt
+ *	Replaced check for PCI device Id from YUKON with GENESIS
+ *	to set the VPD size in VpdInit()
+ *	Editorial changes
+ *	
+ *	Revision 1.36  2002/11/14 15:16:56  gheinig
+ *	Added const specifier to key and buf parameters for VpdPara, VpdRead
+ *	and VpdWrite for Diag 7 GUI
+ *	
+ *	Revision 1.35  2002/10/21 14:31:59  gheinig
+ *	Took out CVS web garbage at head of file
+ *	
+ *	Revision 1.34  2002/10/21 11:47:24  gheinig
+ *	Reverted to version 1.32 due to unwanted commit
+ *	
+ *	Revision 1.32  2002/10/14 16:04:29  rschmidt
+ *	Added saving of VPD ROM Size from PCI_OUR_REG_2
+ *	Avoid reading of PCI_OUR_REG_2 in VpdTransferBlock()
+ *	Editorial changes
+ *	
+ *	Revision 1.31  2002/09/10 09:21:32  mkarl
+ *	Replaced all if(GIChipId == CHIP_ID_GENESIS) with new entry GIGenesis
+ *	
+ *	Revision 1.30  2002/09/09 14:43:03  mkarl
+ *	changes for diagnostics in order to read VPD data before the adapter
+ *	has been initialized
+ *	editorial changes
+ *	
+ *	Revision 1.29  2002/07/26 13:20:43  mkarl
+ *	added Yukon support
+ *	save size of VPD in pAC->vpd.vpd_size
+ *	
+ *	Revision 1.28  2002/04/02 15:31:47  afischer
+ *	Bug fix in VpdWait()
+ *	
+ *	Revision 1.27  2000/08/10 11:29:06  rassmann
+ *	Editorial changes.
+ *	Preserving 32-bit alignment in structs for the adapter context.
+ *	Removed unused function VpdWriteDword() (#if 0).
+ *	Made VpdReadKeyword() available for SKDIAG only.
+ *	
  *	Revision 1.26  2000/06/13 08:00:01  mkarl
  *	additional cast to avoid compile problems in 64 bit environment
  *	
@@ -66,11 +106,11 @@
  *	
  *	Revision 1.14  1998/10/28 07:20:38  gklug
  *	chg: Interface functions to use IoC as parameter as well
- *	fix: VpdRead/WriteDWord now return SK_U32
+ *	fix: VpdRead/WriteDWord now returns SK_U32
  *	chg: VPD_IN/OUT names conform to SK_IN/OUT
  *	add: usage of VPD_IN/OUT8 macros
  *	add: VpdRead/Write Stream functions to r/w a stream of data
- *	fix: VpdTransferBlock swapped illeagal
+ *	fix: VpdTransferBlock swapped illegal
  *	add: VpdMayWrite
  *	
  *	Revision 1.13  1998/10/22 10:02:37  gklug
@@ -86,15 +126,15 @@
  *	Remove CvsId by SysKonnectFileId.
  *	
  *	Revision 1.9  1998/09/16 07:33:52  malthoff
- *	remove memcmp() by SK_MEMCMP and
+ *	replace memcmp() by SK_MEMCMP and
  *	memcpy() by SK_MEMCPY() to be
- *	independant from the 'C' Standard Library.
+ *	independent from the 'C' Standard Library.
  *	
  *	Revision 1.8  1998/08/19 12:52:35  malthoff
  *	compiler fix: use SK_VPD_KEY instead of S_VPD.
  *	
  *	Revision 1.7  1998/08/19 08:14:01  gklug
- *	fix: remove struct keyword as much as possible from the c-code (see CCC)
+ *	fix: remove struct keyword as much as possible from the C-code (see CCC)
  *	
  *	Revision 1.6  1998/08/18 13:03:58  gklug
  *	SkOsGetTime now returns SK_U64
@@ -124,7 +164,7 @@
 	Please refer skvpd.txt for infomation how to include this module
  */
 static const char SysKonnectFileId[] =
-	"@(#)$Id: skvpd.c,v 1.26 2000/06/13 08:00:01 mkarl Exp $ (C) SK" ;
+	"@(#)$Id: skvpd.c,v 1.37 2003/01/13 10:42:45 rschmidt Exp $ (C) SK";
 
 #include "h/skdrv1st.h"
 #include "h/sktypes.h"
@@ -137,46 +177,60 @@
 #ifndef SK_KR_PROTO
 static SK_VPD_PARA	*vpd_find_para(
 	SK_AC	*pAC,
-	char		*key,
-	SK_VPD_PARA *p) ;
+	const char	*key,
+	SK_VPD_PARA *p);
 #else	/* SK_KR_PROTO */
-static SK_VPD_PARA	*vpd_find_para() ;
+static SK_VPD_PARA	*vpd_find_para();
 #endif	/* SK_KR_PROTO */
 
 /*
- * waits for a completetion of a VPD transfer
+ * waits for a completion of a VPD transfer
  * The VPD transfer must complete within SK_TICKS_PER_SEC/16
  *
  * returns	0:	success, transfer completes
  *		error	exit(9) with a error message
  */
-static int	VpdWait(
-SK_AC		*pAC,	/* Adapters context */
-SK_IOC		IoC,	/* IO Context */
+static int VpdWait(
+SK_AC	*pAC,	/* Adapters context */
+SK_IOC	IoC,	/* IO Context */
 int		event)	/* event to wait for (VPD_READ / VPD_write) completion*/
 {
-	SK_U64	start_time ;
-	SK_U16	state ;
+	SK_U64	start_time;
+	SK_U16	state;
 
-	SK_DBG_MSG(pAC,SK_DBGMOD_VPD,SK_DBGCAT_CTRL,
-		("vpd wait for %s\n",event?"Write":"Read")) ;
-	start_time = SkOsGetTime(pAC) ;
+	SK_DBG_MSG(pAC,SK_DBGMOD_VPD, SK_DBGCAT_CTRL,
+		("VPD wait for %s\n", event?"Write":"Read"));
+	start_time = SkOsGetTime(pAC);
 	do {
-		if (SkOsGetTime(pAC) - start_time > SK_TICKS_PER_SEC/16) {
-			VPD_STOP(pAC,IoC) ;
-			SK_DBG_MSG(pAC,SK_DBGMOD_VPD,
-				SK_DBGCAT_FATAL|SK_DBGCAT_ERR,
-				("ERROR:vpd wait timeout\n")) ;
-			return(1) ;
-		}
-		VPD_IN16(pAC,IoC,PCI_VPD_ADR_REG,&state) ;
-		SK_DBG_MSG(pAC,SK_DBGMOD_VPD,SK_DBGCAT_CTRL,
-			("state = %x, event %x\n",state,event)) ;
-	} while((int)(state & PCI_VPD_FLAG) == event) ;
+		if (SkOsGetTime(pAC) - start_time > SK_TICKS_PER_SEC) {
+
+			/* Bug fix AF: Thu Mar 28 2002
+			 * Do not call: VPD_STOP(pAC, IoC);
+			 * A pending VPD read cycle can not be aborted by writing
+			 * VPD_WRITE to the PCI_VPD_ADR_REG (VPD address register).
+			 * Although the write threshold in the OUR-register protects
+			 * VPD read only space from being overwritten this does not
+			 * protect a VPD read from being `converted` into a VPD write
+			 * operation (on the fly). As a consequence the VPD_STOP would
+			 * delete VPD read only data. In case of any problems with the
+			 * I2C bus we exit the loop here. The I2C read operation can
+			 * not be aborted except by a reset (->LR).
+			 */
+			SK_DBG_MSG(pAC, SK_DBGMOD_VPD, SK_DBGCAT_FATAL | SK_DBGCAT_ERR,
+				("ERROR:VPD wait timeout\n"));
+			return(1);
+		}
+		
+		VPD_IN16(pAC, IoC, PCI_VPD_ADR_REG, &state);
+		
+		SK_DBG_MSG(pAC, SK_DBGMOD_VPD, SK_DBGCAT_CTRL,
+			("state = %x, event %x\n",state,event));
+	} while((int)(state & PCI_VPD_FLAG) == event);
 
-	return(0) ;
+	return(0);
 }
 
+#ifdef SKDIAG
 
 /*
  * Read the dword at address 'addr' from the VPD EEPROM.
@@ -188,32 +242,37 @@
  *
  * Returns the data read.
  */
-SK_U32		VpdReadDWord(
-SK_AC		*pAC,	/* Adapters context */
-SK_IOC		IoC,	/* IO Context */
+SK_U32 VpdReadDWord(
+SK_AC	*pAC,	/* Adapters context */
+SK_IOC	IoC,	/* IO Context */
 int		addr)	/* VPD address */
 {
-	SK_U32	Rtv ;
+	SK_U32	Rtv;
 
 	/* start VPD read */
-	SK_DBG_MSG(pAC,SK_DBGMOD_VPD,SK_DBGCAT_CTRL,
-		("vpd read dword at 0x%x\n",addr)) ;
-	addr &= ~VPD_WRITE ;		/* ensure the R/W bit is set to read */
+	SK_DBG_MSG(pAC, SK_DBGMOD_VPD, SK_DBGCAT_CTRL,
+		("VPD read dword at 0x%x\n",addr));
+	addr &= ~VPD_WRITE;		/* ensure the R/W bit is set to read */
 
-	VPD_OUT16(pAC,IoC,PCI_VPD_ADR_REG, (SK_U16) addr) ;
+	VPD_OUT16(pAC, IoC, PCI_VPD_ADR_REG, (SK_U16)addr);
 
 	/* ignore return code here */
-	(void)VpdWait(pAC,IoC,VPD_READ) ;
+	(void)VpdWait(pAC, IoC, VPD_READ);
 
 	/* Don't swap here, it's a data stream of bytes */
-	Rtv = 0 ;
+	Rtv = 0;
 
-	VPD_IN32(pAC,IoC,PCI_VPD_DAT_REG,&Rtv) ;
-	SK_DBG_MSG(pAC,SK_DBGMOD_VPD,SK_DBGCAT_CTRL,
-		("vpd read dword data = 0x%x\n",Rtv)) ;
-	return (Rtv) ;
+	VPD_IN32(pAC, IoC, PCI_VPD_DAT_REG, &Rtv);
+	
+	SK_DBG_MSG(pAC, SK_DBGMOD_VPD, SK_DBGCAT_CTRL,
+		("VPD read dword data = 0x%x\n",Rtv));
+	return(Rtv);
 }
 
+#endif	/* SKDIAG */
+
+#if 0
+
 /*
 	Write the dword 'data' at address 'addr' into the VPD EEPROM, and
 	verify that the data is written.
@@ -233,43 +292,43 @@
 
 
  Returns	0:	success
-		1:	error,	I2C transfer does not terminate
-		2:	error,	data verify error
+			1:	error,	I2C transfer does not terminate
+			2:	error,	data verify error
 
  */
-#if 0 /* Unused at the moment */
-static int	VpdWriteDWord(
-SK_AC		*pAC,	/* pAC pointer */
-SK_IOC		IoC,	/* IO Context */
+static int VpdWriteDWord(
+SK_AC	*pAC,	/* pAC pointer */
+SK_IOC	IoC,	/* IO Context */
 int		addr,	/* VPD address */
-SK_U32		data)	/* VPD data to write */
+SK_U32	data)	/* VPD data to write */
 {
 	/* start VPD write */
 	/* Don't swap here, it's a data stream of bytes */
-	SK_DBG_MSG(pAC,SK_DBGMOD_VPD,SK_DBGCAT_CTRL,
-		("vpd write dword at addr 0x%x, data = 0x%x\n",addr,data)) ;
-	VPD_OUT32(pAC,IoC,PCI_VPD_DAT_REG, (SK_U32)data) ;
+	SK_DBG_MSG(pAC, SK_DBGMOD_VPD, SK_DBGCAT_CTRL,
+		("VPD write dword at addr 0x%x, data = 0x%x\n",addr,data));
+	VPD_OUT32(pAC, IoC, PCI_VPD_DAT_REG, (SK_U32)data);
 	/* But do it here */
-	addr |= VPD_WRITE ;
+	addr |= VPD_WRITE;
 
-	VPD_OUT16(pAC,IoC,PCI_VPD_ADR_REG, (SK_U16)(addr | VPD_WRITE)) ;
+	VPD_OUT16(pAC, IoC, PCI_VPD_ADR_REG, (SK_U16)(addr | VPD_WRITE));
 
 	/* this may take up to 10,6 ms */
-	if (VpdWait(pAC,IoC,VPD_WRITE)) {
-		SK_DBG_MSG(pAC,SK_DBGMOD_VPD,SK_DBGCAT_ERR,
-			("Write Timed Out\n")) ;
-		return(1) ;
-	} ;
+	if (VpdWait(pAC, IoC, VPD_WRITE)) {
+		SK_DBG_MSG(pAC, SK_DBGMOD_VPD, SK_DBGCAT_ERR,
+			("Write Timed Out\n"));
+		return(1);
+	};
 
 	/* verify data */
-	if (VpdReadDWord(pAC,IoC,addr) != data) {
-		SK_DBG_MSG(pAC,SK_DBGMOD_VPD,SK_DBGCAT_ERR|SK_DBGCAT_FATAL,
-			("Data Verify Error\n")) ;
-		return(2) ;
+	if (VpdReadDWord(pAC, IoC, addr) != data) {
+		SK_DBG_MSG(pAC, SK_DBGMOD_VPD, SK_DBGCAT_ERR | SK_DBGCAT_FATAL,
+			("Data Verify Error\n"));
+		return(2);
 	}
-	return(0) ;
-}
-#endif
+	return(0);
+}	/* VpdWriteDWord */
+
+#endif	/* 0 */
 
 /*
  *	Read one Stream of 'len' bytes of VPD data, starting at 'addr' from
@@ -277,89 +336,88 @@
  *
  * Returns number of bytes read / written.
  */
-static int	VpdWriteStream(
-SK_AC		*pAC,	/* Adapters context */
-SK_IOC		IoC,	/* IO Context */
-char		*buf,	/* data buffer */
+static int VpdWriteStream(
+SK_AC	*pAC,	/* Adapters context */
+SK_IOC	IoC,	/* IO Context */
+char	*buf,	/* data buffer */
 int		Addr,	/* VPD start address */
 int		Len)	/* number of bytes to read / to write */
 {
-	int		i ;
-	int		j ;
-	SK_U16		AdrReg ;
-	int		Rtv ;
-	SK_U8		* pComp;	/* Compare pointer */
-	SK_U8		Data ;		/* Input Data for Compare */
+	int		i;
+	int		j;
+	SK_U16	AdrReg;
+	int		Rtv;
+	SK_U8	* pComp;	/* Compare pointer */
+	SK_U8	Data;		/* Input Data for Compare */
 
 	/* Init Compare Pointer */
 	pComp = (SK_U8 *) buf;
 
-	for (i=0; i < Len; i ++, buf++) {
+	for (i = 0; i < Len; i++, buf++) {
 		if ((i%sizeof(SK_U32)) == 0) {
 			/*
 			 * At the begin of each cycle read the Data Reg
 			 * So it is initialized even if only a few bytes
 			 * are written.
 			 */
-			AdrReg = (SK_U16) Addr ;
-			AdrReg &= ~VPD_WRITE ;	/* READ operation */
+			AdrReg = (SK_U16) Addr;
+			AdrReg &= ~VPD_WRITE;	/* READ operation */
 
-			VPD_OUT16(pAC,IoC,PCI_VPD_ADR_REG, AdrReg) ;
+			VPD_OUT16(pAC, IoC, PCI_VPD_ADR_REG, AdrReg);
 
-			/* ignore return code here */
-			Rtv = VpdWait(pAC,IoC,VPD_READ) ;
+			/* Wait for termination */
+			Rtv = VpdWait(pAC, IoC, VPD_READ);
 			if (Rtv != 0) {
-				return(i) ;
+				return(i);
 			}
 		}
 
 		/* Write current Byte */
-		VPD_OUT8(pAC,IoC,PCI_VPD_DAT_REG+(i%sizeof(SK_U32)),
-				*(SK_U8*)buf) ;
+		VPD_OUT8(pAC, IoC, PCI_VPD_DAT_REG + (i%sizeof(SK_U32)),
+				*(SK_U8*)buf);
 
 		if (((i%sizeof(SK_U32)) == 3) || (i == (Len - 1))) {
 			/* New Address needs to be written to VPD_ADDR reg */
-			AdrReg = (SK_U16) Addr ;
+			AdrReg = (SK_U16) Addr;
 			Addr += sizeof(SK_U32);
-			AdrReg |= VPD_WRITE ;	/* WRITE operation */
+			AdrReg |= VPD_WRITE;	/* WRITE operation */
 
-			VPD_OUT16(pAC,IoC,PCI_VPD_ADR_REG, AdrReg) ;
+			VPD_OUT16(pAC, IoC, PCI_VPD_ADR_REG, AdrReg);
 
 			/* Wait for termination */
-			Rtv = VpdWait(pAC,IoC,VPD_WRITE) ;
+			Rtv = VpdWait(pAC, IoC, VPD_WRITE);
 			if (Rtv != 0) {
-				SK_DBG_MSG(pAC,SK_DBGMOD_VPD,SK_DBGCAT_ERR,
-					("Write Timed Out\n")) ;
-				return(i - (i%sizeof(SK_U32))) ;
+				SK_DBG_MSG(pAC, SK_DBGMOD_VPD, SK_DBGCAT_ERR,
+					("Write Timed Out\n"));
+				return(i - (i%sizeof(SK_U32)));
 			}
 
 			/*
 			 * Now re-read to verify
 			 */
-			AdrReg &= ~VPD_WRITE ;	/* READ operation */
+			AdrReg &= ~VPD_WRITE;	/* READ operation */
 
-			VPD_OUT16(pAC,IoC,PCI_VPD_ADR_REG, AdrReg) ;
+			VPD_OUT16(pAC, IoC, PCI_VPD_ADR_REG, AdrReg);
 
 			/* Wait for termination */
-			Rtv = VpdWait(pAC,IoC,VPD_READ) ;
+			Rtv = VpdWait(pAC, IoC, VPD_READ);
 			if (Rtv != 0) {
-				SK_DBG_MSG(pAC,SK_DBGMOD_VPD,SK_DBGCAT_ERR,
-					("Verify Timed Out\n")) ;
-				return(i - (i%sizeof(SK_U32))) ;
+				SK_DBG_MSG(pAC, SK_DBGMOD_VPD, SK_DBGCAT_ERR,
+					("Verify Timed Out\n"));
+				return(i - (i%sizeof(SK_U32)));
 			}
 
-			for (j = 0; j <= (int) (i%sizeof(SK_U32));
-				j ++, pComp ++ ) {
-				VPD_IN8(pAC,IoC,PCI_VPD_DAT_REG+j, &Data) ;
+			for (j = 0; j <= (int)(i%sizeof(SK_U32)); j++, pComp++) {
+				
+				VPD_IN8(pAC, IoC, PCI_VPD_DAT_REG + j, &Data);
+				
 				if (Data != *pComp) {
 					/* Verify Error */
-					SK_DBG_MSG(pAC,SK_DBGMOD_VPD,
-						SK_DBGCAT_ERR,
+					SK_DBG_MSG(pAC, SK_DBGMOD_VPD, SK_DBGCAT_ERR,
 						("WriteStream Verify Error\n"));
 					return(i - (i%sizeof(SK_U32)) + j);
 				}
 			}
-
 		}
 	}
 
@@ -373,86 +431,86 @@
  *
  * Returns number of bytes read / written.
  */
-static int	VpdReadStream(
-SK_AC		*pAC,	/* Adapters context */
-SK_IOC		IoC,	/* IO Context */
-char		*buf,	/* data buffer */
+static int VpdReadStream(
+SK_AC	*pAC,	/* Adapters context */
+SK_IOC	IoC,	/* IO Context */
+char	*buf,	/* data buffer */
 int		Addr,	/* VPD start address */
 int		Len)	/* number of bytes to read / to write */
 {
-	int		i ;
-	SK_U16		AdrReg ;
-	int		Rtv ;
+	int		i;
+	SK_U16	AdrReg;
+	int		Rtv;
 
-	for (i=0; i < Len; i ++, buf++) {
+	for (i = 0; i < Len; i++, buf++) {
 		if ((i%sizeof(SK_U32)) == 0) {
 			/* New Address needs to be written to VPD_ADDR reg */
-			AdrReg = (SK_U16) Addr ;
+			AdrReg = (SK_U16) Addr;
 			Addr += sizeof(SK_U32);
-			AdrReg &= ~VPD_WRITE ;	/* READ operation */
+			AdrReg &= ~VPD_WRITE;	/* READ operation */
 
-			VPD_OUT16(pAC,IoC,PCI_VPD_ADR_REG, AdrReg) ;
+			VPD_OUT16(pAC, IoC, PCI_VPD_ADR_REG, AdrReg);
 
-			/* ignore return code here */
-			Rtv = VpdWait(pAC,IoC,VPD_READ) ;
+			/* Wait for termination */
+			Rtv = VpdWait(pAC, IoC, VPD_READ);
 			if (Rtv != 0) {
-				return(i) ;
+				return(i);
 			}
-
 		}
-		VPD_IN8(pAC,IoC,PCI_VPD_DAT_REG+(i%sizeof(SK_U32)),
-			(SK_U8 *)buf) ;
+		VPD_IN8(pAC, IoC, PCI_VPD_DAT_REG + (i%sizeof(SK_U32)),
+			(SK_U8 *)buf);
 	}
 
-	return(Len) ;
+	return(Len);
 }
 
 /*
- *	Read ore wirtes 'len' bytes of VPD data, starting at 'addr' from
+ *	Read ore writes 'len' bytes of VPD data, starting at 'addr' from
  *	or to the I2C EEPROM.
  *
  * Returns number of bytes read / written.
  */
-static int	VpdTransferBlock(
-SK_AC		*pAC,	/* Adapters context */
-SK_IOC		IoC,	/* IO Context */
-char		*buf,	/* data buffer */
+static int VpdTransferBlock(
+SK_AC	*pAC,	/* Adapters context */
+SK_IOC	IoC,	/* IO Context */
+char	*buf,	/* data buffer */
 int		addr,	/* VPD start address */
 int		len,	/* number of bytes to read / to write */
 int		dir)	/* transfer direction may be VPD_READ or VPD_WRITE */
 {
-	int		Rtv ;	/* Return value */
-	int		vpd_rom_size ;
-	SK_U32		our_reg2 ;
-
-	SK_DBG_MSG(pAC,SK_DBGMOD_VPD,SK_DBGCAT_CTRL,
-		("vpd %s block, addr = 0x%x, len = %d\n",
-		dir?"write":"read",addr,len)) ;
+	int		Rtv;	/* Return value */
+	int		vpd_rom_size;
+
+	SK_DBG_MSG(pAC, SK_DBGMOD_VPD, SK_DBGCAT_CTRL,
+		("VPD %s block, addr = 0x%x, len = %d\n",
+		dir ? "write" : "read", addr, len));
 
 	if (len == 0)
-		return (0) ;
+		return(0);
 
-	VPD_IN32(pAC,IoC,PCI_OUR_REG_2,&our_reg2) ;
-	vpd_rom_size = 256 << ((our_reg2 & PCI_VPD_ROM_SZ) >> 14);
+	vpd_rom_size = pAC->vpd.rom_size;
+	
 	if (addr > vpd_rom_size - 4) {
-		SK_DBG_MSG(pAC,SK_DBGMOD_VPD,SK_DBGCAT_ERR|SK_DBGCAT_FATAL,
+		SK_DBG_MSG(pAC, SK_DBGMOD_VPD, SK_DBGCAT_ERR | SK_DBGCAT_FATAL,
 			("Address error: 0x%x, exp. < 0x%x\n",
-			addr, vpd_rom_size - 4)) ;
-		return (0) ;
+			addr, vpd_rom_size - 4));
+		return(0);
 	}
+	
 	if (addr + len > vpd_rom_size) {
-		len = vpd_rom_size - addr ;
-		SK_DBG_MSG(pAC,SK_DBGMOD_VPD,SK_DBGCAT_ERR,
-			("Warning: len was cut to %d\n",len)) ;
+		len = vpd_rom_size - addr;
+		SK_DBG_MSG(pAC, SK_DBGMOD_VPD, SK_DBGCAT_ERR,
+			("Warning: len was cut to %d\n", len));
 	}
 
 	if (dir == VPD_READ) {
 		Rtv = VpdReadStream(pAC, IoC, buf, addr, len);
-	} else {
+	}
+	else {
 		Rtv = VpdWriteStream(pAC, IoC, buf, addr, len);
 	}
 
-	return (Rtv) ;
+	return(Rtv);
 }
 
 #ifdef SKDIAG
@@ -462,14 +520,14 @@
  *
  * Returns number of bytes read.
  */
-int		VpdReadBlock(
-SK_AC		*pAC,	/* pAC pointer */
-SK_IOC		IoC,	/* IO Context */
-char		*buf,	/* buffer were the data should be stored */
+int VpdReadBlock(
+SK_AC	*pAC,	/* pAC pointer */
+SK_IOC	IoC,	/* IO Context */
+char	*buf,	/* buffer were the data should be stored */
 int		addr,	/* start reading at the VPD address */
 int		len)	/* number of bytes to read */
 {
-	return (VpdTransferBlock(pAC, IoC, buf, addr, len, VPD_READ)) ;
+	return(VpdTransferBlock(pAC, IoC, buf, addr, len, VPD_READ));
 }
 
 /*
@@ -477,14 +535,14 @@
  *
  * Returns number of bytes writes.
  */
-int		VpdWriteBlock(
-SK_AC		*pAC,	/* pAC pointer */
-SK_IOC		IoC,	/* IO Context */
-char		*buf,	/* buffer, holds the data to write */
+int VpdWriteBlock(
+SK_AC	*pAC,	/* pAC pointer */
+SK_IOC	IoC,	/* IO Context */
+char	*buf,	/* buffer, holds the data to write */
 int		addr,	/* start writing at the VPD address */
 int		len)	/* number of bytes to write */
 {
-	return (VpdTransferBlock(pAC, IoC, buf, addr, len, VPD_WRITE)) ;
+	return(VpdTransferBlock(pAC, IoC, buf, addr, len, VPD_WRITE));
 }
 #endif	/* SKDIAG */
 
@@ -497,139 +555,180 @@
  * return	0:	success
  *		1:	fatal VPD error
  */
-static int	VpdInit(
-SK_AC		*pAC,	/* Adapters context */
-SK_IOC		IoC)	/* IO Context */
-{
-	SK_VPD_PARA *r, rp ;	/* RW or RV */
-	int		i ;
-	unsigned char	x ;
+static int VpdInit(
+SK_AC	*pAC,	/* Adapters context */
+SK_IOC	IoC)	/* IO Context */
+{
+	SK_VPD_PARA *r, rp;	/* RW or RV */
+	int		i;
+	unsigned char	x;
+	int		vpd_size;
+	SK_U16	dev_id;
+	SK_U32	our_reg2;
+
+	SK_DBG_MSG(pAC, SK_DBGMOD_VPD, SK_DBGCAT_INIT, ("VpdInit .. "));
+	
+	VPD_IN16(pAC, IoC, PCI_DEVICE_ID, &dev_id);
+	
+	VPD_IN32(pAC, IoC, PCI_OUR_REG_2, &our_reg2);
+	
+	pAC->vpd.rom_size = 256 << ((our_reg2 & PCI_VPD_ROM_SZ) >> 14);
+	
+	/*
+	 * this function might get used before the hardware is initialized
+	 * therefore we cannot always trust in GIChipId
+	 */
+	if (((pAC->vpd.v.vpd_status & VPD_VALID) == 0 &&
+		dev_id != VPD_DEV_ID_GENESIS) ||
+		((pAC->vpd.v.vpd_status & VPD_VALID) != 0 &&
+		!pAC->GIni.GIGenesis)) {
+
+		/* for Yukon the VPD size is always 256 */
+		vpd_size = VPD_SIZE_YUKON;
+	}
+	else {
+		/* Genesis uses the maximum ROM size up to 512 for VPD */
+		if (pAC->vpd.rom_size > VPD_SIZE_GENESIS) {
+			vpd_size = VPD_SIZE_GENESIS;
+		}
+		else {
+			vpd_size = pAC->vpd.rom_size;
+		}
+	}
 
-	SK_DBG_MSG(pAC,SK_DBGMOD_VPD,SK_DBGCAT_INIT,("VpdInit .. ")) ;
 	/* read the VPD data into the VPD buffer */
-	if (VpdTransferBlock(pAC,IoC,pAC->vpd.vpd_buf,0,VPD_SIZE,VPD_READ)
-		!= VPD_SIZE) {
+	if (VpdTransferBlock(pAC, IoC, pAC->vpd.vpd_buf, 0, vpd_size, VPD_READ)
+		!= vpd_size) {
 
-		SK_DBG_MSG(pAC,SK_DBGMOD_VPD,SK_DBGCAT_ERR,
-			("Block Read Error\n")) ;
-		return(1) ;
+		SK_DBG_MSG(pAC, SK_DBGMOD_VPD, SK_DBGCAT_ERR,
+			("Block Read Error\n"));
+		return(1);
 	}
+	
+	pAC->vpd.vpd_size = vpd_size;
 
 	/* find the end tag of the RO area */
-	if (!(r = vpd_find_para(pAC,VPD_RV,&rp))) {
-		SK_DBG_MSG(pAC,SK_DBGMOD_VPD,SK_DBGCAT_ERR | SK_DBGCAT_FATAL,
-			("Encoding Error: RV Tag not found\n")) ;
-		return (1) ;
+	if (!(r = vpd_find_para(pAC, VPD_RV, &rp))) {
+		SK_DBG_MSG(pAC, SK_DBGMOD_VPD, SK_DBGCAT_ERR | SK_DBGCAT_FATAL,
+			("Encoding Error: RV Tag not found\n"));
+		return(1);
 	}
-	if (r->p_val + r->p_len > pAC->vpd.vpd_buf + VPD_SIZE/2) {
+	
+	if (r->p_val + r->p_len > pAC->vpd.vpd_buf + vpd_size/2) {
 		SK_DBG_MSG(pAC,SK_DBGMOD_VPD,SK_DBGCAT_ERR | SK_DBGCAT_FATAL,
-			("Encoding Error: Invalid VPD struct size\n")) ;
-		return (1) ;
+			("Encoding Error: Invalid VPD struct size\n"));
+		return(1);
 	}
-	pAC->vpd.v.vpd_free_ro = r->p_len - 1 ;
+	pAC->vpd.v.vpd_free_ro = r->p_len - 1;
 
 	/* test the checksum */
-	for (i = 0, x = 0; (unsigned)i<=(unsigned)VPD_SIZE/2 - r->p_len; i++) {
-		x += pAC->vpd.vpd_buf[i] ;
+	for (i = 0, x = 0; (unsigned)i <= (unsigned)vpd_size/2 - r->p_len; i++) {
+		x += pAC->vpd.vpd_buf[i];
 	}
+	
 	if (x != 0) {
 		/* checksum error */
-		SK_DBG_MSG(pAC,SK_DBGMOD_VPD,SK_DBGCAT_ERR | SK_DBGCAT_FATAL,
-			("VPD Checksum Error\n")) ;
-		return (1) ;
+		SK_DBG_MSG(pAC, SK_DBGMOD_VPD, SK_DBGCAT_ERR | SK_DBGCAT_FATAL,
+			("VPD Checksum Error\n"));
+		return(1);
 	}
 
 	/* find and check the end tag of the RW area */
-	if (!(r = vpd_find_para(pAC,VPD_RW,&rp))) {
-		SK_DBG_MSG(pAC,SK_DBGMOD_VPD,SK_DBGCAT_ERR | SK_DBGCAT_FATAL,
-			("Encoding Error: RV Tag not found\n")) ;
-		return (1) ;
+	if (!(r = vpd_find_para(pAC, VPD_RW, &rp))) {
+		SK_DBG_MSG(pAC, SK_DBGMOD_VPD, SK_DBGCAT_ERR | SK_DBGCAT_FATAL,
+			("Encoding Error: RV Tag not found\n"));
+		return(1);
 	}
-	if (r->p_val < pAC->vpd.vpd_buf + VPD_SIZE/2) {
-		SK_DBG_MSG(pAC,SK_DBGMOD_VPD,SK_DBGCAT_ERR | SK_DBGCAT_FATAL,
-			("Encoding Error: Invalid VPD struct size\n")) ;
-		return (1) ;
+	
+	if (r->p_val < pAC->vpd.vpd_buf + vpd_size/2) {
+		SK_DBG_MSG(pAC, SK_DBGMOD_VPD, SK_DBGCAT_ERR | SK_DBGCAT_FATAL,
+			("Encoding Error: Invalid VPD struct size\n"));
+		return(1);
 	}
-	pAC->vpd.v.vpd_free_rw = r->p_len ;
+	pAC->vpd.v.vpd_free_rw = r->p_len;
 
 	/* everything seems to be ok */
-	pAC->vpd.v.vpd_status |= VPD_VALID ;
-	SK_DBG_MSG(pAC,SK_DBGMOD_VPD,SK_DBGCAT_INIT,
+	if (pAC->GIni.GIChipId != 0) {
+		pAC->vpd.v.vpd_status |= VPD_VALID;
+	}
+
+	SK_DBG_MSG(pAC, SK_DBGMOD_VPD, SK_DBGCAT_INIT,
 		("done. Free RO = %d, Free RW = %d\n",
-		pAC->vpd.v.vpd_free_ro, pAC->vpd.v.vpd_free_rw)) ;
+		pAC->vpd.v.vpd_free_ro, pAC->vpd.v.vpd_free_rw));
 
-	return(0) ;
+	return(0);
 }
 
 /*
  *	find the Keyword 'key' in the VPD buffer and fills the
- *	parameter sturct 'p' with it's values
+ *	parameter struct 'p' with it's values
  *
  * returns	*p	success
  *		0:	parameter was not found or VPD encoding error
  */
 static SK_VPD_PARA *vpd_find_para(
-SK_AC *pAC,	/* common data base */
-char *key,		/* keyword to find (e.g. "MN") */
-SK_VPD_PARA *p)	/* parameter description struct */
+SK_AC		*pAC,	/* common data base */
+const char	*key,	/* keyword to find (e.g. "MN") */
+SK_VPD_PARA *p)		/* parameter description struct */
 {
-	char *v	;	/* points to vpd buffer */
-	int max ;	/* Maximum Number of Iterations */
+	char *v	;	/* points to VPD buffer */
+	int max;	/* Maximum Number of Iterations */
 
-	v = pAC->vpd.vpd_buf ;
-	max = 128 ;
+	v = pAC->vpd.vpd_buf;
+	max = 128;
 
-	SK_DBG_MSG(pAC,SK_DBGMOD_VPD,SK_DBGCAT_CTRL,
-		("vpd find para %s .. ",key)) ;
+	SK_DBG_MSG(pAC, SK_DBGMOD_VPD, SK_DBGCAT_CTRL,
+		("VPD find para %s .. ",key));
 
 	/* check mandatory resource type ID string (Product Name) */
-	if (*v != (char) RES_ID) {
-		SK_DBG_MSG(pAC,SK_DBGMOD_VPD,SK_DBGCAT_ERR | SK_DBGCAT_FATAL,
-			("Error: 0x%x missing\n",RES_ID)) ;
-		return (0) ;
-	}
-
-	if (strcmp(key,VPD_NAME) == 0) {
-		p->p_len = VPD_GET_RES_LEN(v) ;
-		p->p_val = VPD_GET_VAL(v) ;
-		SK_DBG_MSG(pAC,SK_DBGMOD_VPD,SK_DBGCAT_CTRL,
-			("found, len = %d\n",p->p_len)) ;
-		return(p) ;
+	if (*v != (char)RES_ID) {
+		SK_DBG_MSG(pAC, SK_DBGMOD_VPD, SK_DBGCAT_ERR | SK_DBGCAT_FATAL,
+			("Error: 0x%x missing\n", RES_ID));
+		return(0);
+	}
+
+	if (strcmp(key, VPD_NAME) == 0) {
+		p->p_len = VPD_GET_RES_LEN(v);
+		p->p_val = VPD_GET_VAL(v);
+		SK_DBG_MSG(pAC, SK_DBGMOD_VPD, SK_DBGCAT_CTRL,
+			("found, len = %d\n", p->p_len));
+		return(p);
 	}
 
-	v += 3 + VPD_GET_RES_LEN(v) + 3 ;
-	for ( ; ; ) {
+	v += 3 + VPD_GET_RES_LEN(v) + 3;
+	for (;; ) {
 		if (SK_MEMCMP(key,v,2) == 0) {
-			p->p_len = VPD_GET_VPD_LEN(v) ;
-			p->p_val = VPD_GET_VAL(v) ;
-			SK_DBG_MSG(pAC,SK_DBGMOD_VPD,SK_DBGCAT_CTRL,
-				("found, len = %d\n",p->p_len)) ;
-			return (p) ;
+			p->p_len = VPD_GET_VPD_LEN(v);
+			p->p_val = VPD_GET_VAL(v);
+			SK_DBG_MSG(pAC, SK_DBGMOD_VPD, SK_DBGCAT_CTRL,
+				("found, len = %d\n",p->p_len));
+			return(p);
 		}
 
 		/* exit when reaching the "RW" Tag or the maximum of itera. */
-		max-- ;
+		max--;
 		if (SK_MEMCMP(VPD_RW,v,2) == 0 || max == 0) {
-			break ;
+			break;
 		}
 
 		if (SK_MEMCMP(VPD_RV,v,2) == 0) {
-			v += 3 + VPD_GET_VPD_LEN(v) + 3 ;	/* skip VPD-W */
-		} else {
-			v += 3 + VPD_GET_VPD_LEN(v) ;
+			v += 3 + VPD_GET_VPD_LEN(v) + 3;	/* skip VPD-W */
+		}
+		else {
+			v += 3 + VPD_GET_VPD_LEN(v);
 		}
-		SK_DBG_MSG(pAC,SK_DBGMOD_VPD,SK_DBGCAT_CTRL,
-			("scanning '%c%c' len = %d\n",v[0],v[1],v[2])) ;
+		SK_DBG_MSG(pAC, SK_DBGMOD_VPD, SK_DBGCAT_CTRL,
+			("scanning '%c%c' len = %d\n",v[0],v[1],v[2]));
 	}
 
 #ifdef DEBUG
-	SK_DBG_MSG(pAC,SK_DBGMOD_VPD,SK_DBGCAT_CTRL,("not found\n")) ;
+	SK_DBG_MSG(pAC, SK_DBGMOD_VPD, SK_DBGCAT_CTRL, ("not found\n"));
 	if (max == 0) {
-		SK_DBG_MSG(pAC,SK_DBGMOD_VPD,SK_DBGCAT_ERR | SK_DBGCAT_FATAL,
-			("Key/Len Encoding error\n")) ;
+		SK_DBG_MSG(pAC, SK_DBGMOD_VPD, SK_DBGCAT_ERR | SK_DBGCAT_FATAL,
+			("Key/Len Encoding error\n"));
 	}
-#endif
-	return (0) ;
+#endif /* DEBUG */
+	return(0);
 }
 
 /*
@@ -639,28 +738,29 @@
  * returns nothing
  */
 static void vpd_move_para(
-char *start,		/* start of memory block */
-char *end,		/* end of memory block to move */
-int n)			/* number of bytes the memory block has to be moved */
+char	*start,		/* start of memory block */
+char	*end,		/* end of memory block to move */
+int		n)			/* number of bytes the memory block has to be moved */
 {
-	char *p ;
-	int i ;		/* number of byte copied */
+	char *p;
+	int i;		/* number of byte copied */
 
 	if (n == 0)
-		return ;
+		return;
 
-	i = (int) (end - start + 1) ;
+	i = (int) (end - start + 1);
 	if (n < 0) {
-		p = start + n ;
+		p = start + n;
 		while (i != 0) {
-			*p++ = *start++ ;
-			i-- ;
+			*p++ = *start++;
+			i--;
 		}
-	} else {
-		p = end + n ;
+	}
+	else {
+		p = end + n;
 		while (i != 0) {
-			*p-- = *end-- ;
-			i-- ;
+			*p-- = *end--;
+			i--;
 		}
 	}
 }
@@ -671,18 +771,18 @@
  * returns nothing
  */
 static void vpd_insert_key(
-char *key,		/* keyword to insert */
-char *buf,		/* buffer with the keyword value */
-int len,		/* length of the value string */
-char *ip)		/* inseration point */
-{
-	SK_VPD_KEY *p ;
-
-	p = (SK_VPD_KEY *) ip ;
-	p->p_key[0] = key[0] ;
-	p->p_key[1] = key[1] ;
-	p->p_len = (unsigned char) len ;
-	SK_MEMCPY(&p->p_val,buf,len) ;
+const char	*key,	/* keyword to insert */
+const char	*buf,	/* buffer with the keyword value */
+int		len,		/* length of the value string */
+char	*ip)		/* inseration point */
+{
+	SK_VPD_KEY *p;
+
+	p = (SK_VPD_KEY *) ip;
+	p->p_key[0] = key[0];
+	p->p_key[1] = key[1];
+	p->p_len = (unsigned char) len;
+	SK_MEMCPY(&p->p_val,buf,len);
 }
 
 /*
@@ -693,49 +793,53 @@
  *		1:	encoding error
  */
 static int vpd_mod_endtag(
-SK_AC *pAC,	/* common data base */
-char *etp)		/* end pointer input position */
+SK_AC	*pAC,		/* common data base */
+char	*etp)		/* end pointer input position */
 {
-	SK_VPD_KEY *p ;
-	unsigned char	x ;
-	int	i ;
+	SK_VPD_KEY *p;
+	unsigned char	x;
+	int	i;
+	int	vpd_size;
 
-	SK_DBG_MSG(pAC,SK_DBGMOD_VPD,SK_DBGCAT_CTRL,
-		("vpd modify endtag at 0x%x = '%c%c'\n",etp,etp[0],etp[1])) ;
+	SK_DBG_MSG(pAC, SK_DBGMOD_VPD, SK_DBGCAT_CTRL,
+		("VPD modify endtag at 0x%x = '%c%c'\n",etp,etp[0],etp[1]));
 
-	p = (SK_VPD_KEY *) etp ;
+	vpd_size = pAC->vpd.vpd_size;
+
+	p = (SK_VPD_KEY *) etp;
 
 	if (p->p_key[0] != 'R' || (p->p_key[1] != 'V' && p->p_key[1] != 'W')) {
 		/* something wrong here, encoding error */
 		SK_DBG_MSG(pAC,SK_DBGMOD_VPD,SK_DBGCAT_ERR | SK_DBGCAT_FATAL,
-			("Encoding Error: invalid end tag\n")) ;
-		return(1) ;
+			("Encoding Error: invalid end tag\n"));
+		return(1);
 	}
-	if (etp > pAC->vpd.vpd_buf + VPD_SIZE/2) {
+	if (etp > pAC->vpd.vpd_buf + vpd_size/2) {
 		/* create "RW" tag */
-		p->p_len = (unsigned char)(pAC->vpd.vpd_buf+VPD_SIZE-etp-3-1) ;
-		pAC->vpd.v.vpd_free_rw = (int) p->p_len ;
-		i = pAC->vpd.v.vpd_free_rw ;
-		etp += 3 ;
-	} else {
+		p->p_len = (unsigned char)(pAC->vpd.vpd_buf+vpd_size-etp-3-1);
+		pAC->vpd.v.vpd_free_rw = (int) p->p_len;
+		i = pAC->vpd.v.vpd_free_rw;
+		etp += 3;
+	}
+	else {
 		/* create "RV" tag */
-		p->p_len = (unsigned char)(pAC->vpd.vpd_buf+VPD_SIZE/2-etp-3) ;
-		pAC->vpd.v.vpd_free_ro = (int) p->p_len - 1 ;
+		p->p_len = (unsigned char)(pAC->vpd.vpd_buf+vpd_size/2-etp-3);
+		pAC->vpd.v.vpd_free_ro = (int) p->p_len - 1;
 
 		/* setup checksum */
-		for (i = 0, x = 0; i < VPD_SIZE/2 - p->p_len; i++) {
-			x += pAC->vpd.vpd_buf[i] ;
+		for (i = 0, x = 0; i < vpd_size/2 - p->p_len; i++) {
+			x += pAC->vpd.vpd_buf[i];
 		}
-		p->p_val = (char) 0 - x ;
-		i = pAC->vpd.v.vpd_free_ro ;
-		etp += 4 ;
+		p->p_val = (char) 0 - x;
+		i = pAC->vpd.v.vpd_free_ro;
+		etp += 4;
 	}
 	while (i) {
-		*etp++ = 0x00 ;
-		i-- ;
+		*etp++ = 0x00;
+		i--;
 	}
 
-	return (0) ;
+	return(0);
 }
 
 /*
@@ -754,82 +858,87 @@
  */
 int	VpdSetupPara(
 SK_AC	*pAC,		/* common data base */
-char	*key,		/* keyword to insert */
-char	*buf,		/* buffer with the keyword value */
-int	len,		/* length of the keyword value */
-int	type,		/* VPD_RO_KEY or VPD_RW_KEY */
-int	op)			/* operation to do: ADD_KEY or OWR_KEY */
-{
-	SK_VPD_PARA vp ;
-	char	*etp ;		/* end tag position */
-	int	free ;		/* remaining space in selected area */
-	char	*ip ;		/* input position inside the VPD buffer */
-	int	rtv ;		/* return code */
-	int	head ;		/* additional haeder bytes to move */
-	int	found ;		/* additinoal bytes if the keyword was found */
+const char	*key,	/* keyword to insert */
+const char	*buf,	/* buffer with the keyword value */
+int		len,		/* length of the keyword value */
+int		type,		/* VPD_RO_KEY or VPD_RW_KEY */
+int		op)			/* operation to do: ADD_KEY or OWR_KEY */
+{
+	SK_VPD_PARA vp;
+	char	*etp;		/* end tag position */
+	int	free;		/* remaining space in selected area */
+	char	*ip;		/* input position inside the VPD buffer */
+	int	rtv;		/* return code */
+	int	head;		/* additional haeder bytes to move */
+	int	found;		/* additinoal bytes if the keyword was found */
+	int vpd_size;
 
-	SK_DBG_MSG(pAC,SK_DBGMOD_VPD,SK_DBGCAT_CTRL,
-		("vpd setup para key = %s, val = %s\n",key,buf)) ;
+	SK_DBG_MSG(pAC, SK_DBGMOD_VPD, SK_DBGCAT_CTRL,
+		("VPD setup para key = %s, val = %s\n",key,buf));
+	
+	vpd_size = pAC->vpd.vpd_size;
 
-	rtv = 0 ;
-	ip = 0 ;
+	rtv = 0;
+	ip = 0;
 	if (type == VPD_RW_KEY) {
 		/* end tag is "RW" */
-		free = pAC->vpd.v.vpd_free_rw ;
-		etp = pAC->vpd.vpd_buf + (VPD_SIZE - free - 1 - 3) ;
-	} else {
+		free = pAC->vpd.v.vpd_free_rw;
+		etp = pAC->vpd.vpd_buf + (vpd_size - free - 1 - 3);
+	}
+	else {
 		/* end tag is "RV" */
-		free = pAC->vpd.v.vpd_free_ro ;
-		etp = pAC->vpd.vpd_buf + (VPD_SIZE/2 - free - 4) ;
+		free = pAC->vpd.v.vpd_free_ro;
+		etp = pAC->vpd.vpd_buf + (vpd_size/2 - free - 4);
 	}
-	SK_DBG_MSG(pAC,SK_DBGMOD_VPD,SK_DBGCAT_CTRL,
+	SK_DBG_MSG(pAC, SK_DBGMOD_VPD, SK_DBGCAT_CTRL,
 		("Free RO = %d, Free RW = %d\n",
-		pAC->vpd.v.vpd_free_ro, pAC->vpd.v.vpd_free_rw)) ;
+		pAC->vpd.v.vpd_free_ro, pAC->vpd.v.vpd_free_rw));
 
-	head = 0 ;
-	found = 0 ;
+	head = 0;
+	found = 0;
 	if (op == OWR_KEY) {
-		if (vpd_find_para(pAC,key,&vp)) {
-			found = 3 ;
-			ip = vp.p_val - 3 ;
-			free += vp.p_len + 3 ;
-			SK_DBG_MSG(pAC,SK_DBGMOD_VPD,SK_DBGCAT_CTRL,
-				("Overwrite Key\n")) ;
-		} else {
-			op = ADD_KEY ;
-			SK_DBG_MSG(pAC,SK_DBGMOD_VPD,SK_DBGCAT_CTRL,
-				("Add Key\n")) ;
+		if (vpd_find_para(pAC, key, &vp)) {
+			found = 3;
+			ip = vp.p_val - 3;
+			free += vp.p_len + 3;
+			SK_DBG_MSG(pAC, SK_DBGMOD_VPD, SK_DBGCAT_CTRL,
+				("Overwrite Key\n"));
+		}
+		else {
+			op = ADD_KEY;
+			SK_DBG_MSG(pAC, SK_DBGMOD_VPD, SK_DBGCAT_CTRL,
+				("Add Key\n"));
 		}
 	}
 	if (op == ADD_KEY) {
-		ip = etp ;
-		vp.p_len = 0 ;
-		head = 3 ;
+		ip = etp;
+		vp.p_len = 0;
+		head = 3;
 	}
 
 	if (len + 3 > free) {
 		if (free < 7) {
-			SK_DBG_MSG(pAC,SK_DBGMOD_VPD,SK_DBGCAT_ERR,
+			SK_DBG_MSG(pAC, SK_DBGMOD_VPD, SK_DBGCAT_ERR,
 				("VPD Buffer Overflow, keyword not written\n"));
-			return (4) ;
+			return(4);
 		}
 		/* cut it again */
-		len = free - 3 ;
-		rtv = 2 ;
-		SK_DBG_MSG(pAC,SK_DBGMOD_VPD,SK_DBGCAT_ERR,
-			("VPD Buffer Full, Keyword was cut\n")) ;
+		len = free - 3;
+		rtv = 2;
+		SK_DBG_MSG(pAC, SK_DBGMOD_VPD, SK_DBGCAT_ERR,
+			("VPD Buffer Full, Keyword was cut\n"));
 	}
 
-	vpd_move_para(ip + vp.p_len + found, etp+2, len-vp.p_len+head) ;
-	vpd_insert_key(key, buf, len, ip) ;
+	vpd_move_para(ip + vp.p_len + found, etp+2, len-vp.p_len+head);
+	vpd_insert_key(key, buf, len, ip);
 	if (vpd_mod_endtag(pAC, etp + len - vp.p_len + head)) {
-		pAC->vpd.v.vpd_status &= ~VPD_VALID ;
-		SK_DBG_MSG(pAC,SK_DBGMOD_VPD,SK_DBGCAT_ERR,
-			("VPD Encoding Error\n")) ;
-		return(6) ;
+		pAC->vpd.v.vpd_status &= ~VPD_VALID;
+		SK_DBG_MSG(pAC, SK_DBGMOD_VPD, SK_DBGCAT_ERR,
+			("VPD Encoding Error\n"));
+		return(6);
 	}
 
-	return (rtv) ;
+	return(rtv);
 }
 
 
@@ -837,17 +946,17 @@
  *	Read the contents of the VPD EEPROM and copy it to the
  *	VPD buffer if not already done.
  *
- * return:	A pointer to the vpd_status structure. The structure contain
+ * return:	A pointer to the vpd_status structure. The structure contains
  *		this fields.
  */
-SK_VPD_STATUS	*VpdStat(
-SK_AC		*pAC,	/* Adapters context */
-SK_IOC		IoC)	/* IO Context */
+SK_VPD_STATUS *VpdStat(
+SK_AC	*pAC,	/* Adapters context */
+SK_IOC	IoC)	/* IO Context */
 {
-	if (!(pAC->vpd.v.vpd_status & VPD_VALID)) {
-		(void)VpdInit(pAC,IoC) ;
+	if ((pAC->vpd.v.vpd_status & VPD_VALID) == 0) {
+		(void)VpdInit(pAC, IoC);
 	}
-	return(&pAC->vpd.v) ;
+	return(&pAC->vpd.v);
 }
 
 
@@ -873,74 +982,76 @@
  *		*len =		30
  *		*elements =	 9
  */
-int		VpdKeys(
-SK_AC		*pAC,		/* common data base */
-SK_IOC		IoC,		/* IO Context */
-char		*buf,		/* buffer where to copy the keywords */
+int VpdKeys(
+SK_AC	*pAC,		/* common data base */
+SK_IOC	IoC,		/* IO Context */
+char	*buf,		/* buffer where to copy the keywords */
 int		*len,		/* buffer length */
 int		*elements)	/* number of keywords returned */
 {
-	char *v ;
-	int n ;
+	char *v;
+	int n;
 
-	SK_DBG_MSG(pAC,SK_DBGMOD_VPD,SK_DBGCAT_RX,("list vpd keys .. ")) ;
-	*elements = 0 ;
-	if (!(pAC->vpd.v.vpd_status & VPD_VALID)) {
-		if (VpdInit(pAC,IoC) != 0 ) {
-			*len = 0 ;
-			SK_DBG_MSG(pAC,SK_DBGMOD_VPD,SK_DBGCAT_ERR,
-				("VPD Init Error, terminated\n")) ;
-			return(6) ;
+	SK_DBG_MSG(pAC, SK_DBGMOD_VPD, SK_DBGCAT_RX, ("list VPD keys .. "));
+	*elements = 0;
+	if ((pAC->vpd.v.vpd_status & VPD_VALID) == 0) {
+		if (VpdInit(pAC, IoC) != 0) {
+			*len = 0;
+			SK_DBG_MSG(pAC, SK_DBGMOD_VPD, SK_DBGCAT_ERR,
+				("VPD Init Error, terminated\n"));
+			return(6);
 		}
 	}
 
 	if ((signed)strlen(VPD_NAME) + 1 <= *len) {
-		v = pAC->vpd.vpd_buf ;
-		strcpy(buf,VPD_NAME) ;
-		n = strlen(VPD_NAME) + 1 ;
-		buf += n ;
-		*elements = 1 ;
-		SK_DBG_MSG(pAC,SK_DBGMOD_VPD,SK_DBGCAT_RX,
-			("'%c%c' ",v[0],v[1])) ;
-	} else {
-		*len = 0 ;
+		v = pAC->vpd.vpd_buf;
+		strcpy(buf,VPD_NAME);
+		n = strlen(VPD_NAME) + 1;
+		buf += n;
+		*elements = 1;
+		SK_DBG_MSG(pAC, SK_DBGMOD_VPD, SK_DBGCAT_RX,
+			("'%c%c' ",v[0],v[1]));
+	}
+	else {
+		*len = 0;
 		SK_DBG_MSG(pAC,SK_DBGMOD_VPD,SK_DBGCAT_ERR,
-			("buffer overflow\n")) ;
-		return(2) ;
+			("buffer overflow\n"));
+		return(2);
 	}
 
-	v += 3 + VPD_GET_RES_LEN(v) + 3 ;
-	for ( ; ; ) {
+	v += 3 + VPD_GET_RES_LEN(v) + 3;
+	for (;; ) {
 		/* exit when reaching the "RW" Tag */
 		if (SK_MEMCMP(VPD_RW,v,2) == 0) {
-			break ;
+			break;
 		}
 
 		if (SK_MEMCMP(VPD_RV,v,2) == 0) {
-			v += 3 + VPD_GET_VPD_LEN(v) + 3 ;	/* skip VPD-W */
-			continue ;
+			v += 3 + VPD_GET_VPD_LEN(v) + 3;	/* skip VPD-W */
+			continue;
 		}
 
 		if (n+3 <= *len) {
-			SK_MEMCPY(buf,v,2) ;
-			buf += 2 ;
-			*buf++ = '\0' ;
-			n += 3 ;
-			v += 3 + VPD_GET_VPD_LEN(v) ;
-			*elements += 1 ;
-			SK_DBG_MSG(pAC,SK_DBGMOD_VPD,SK_DBGCAT_RX,
-				("'%c%c' ",v[0],v[1])) ;
-		} else {
-			*len = n ;
-			SK_DBG_MSG(pAC,SK_DBGMOD_VPD,SK_DBGCAT_ERR,
-				("buffer overflow\n")) ;
-			return (2) ;
+			SK_MEMCPY(buf,v,2);
+			buf += 2;
+			*buf++ = '\0';
+			n += 3;
+			v += 3 + VPD_GET_VPD_LEN(v);
+			*elements += 1;
+			SK_DBG_MSG(pAC, SK_DBGMOD_VPD, SK_DBGCAT_RX,
+				("'%c%c' ",v[0],v[1]));
+		}
+		else {
+			*len = n;
+			SK_DBG_MSG(pAC, SK_DBGMOD_VPD, SK_DBGCAT_ERR,
+				("buffer overflow\n"));
+			return(2);
 		}
 	}
 
-	SK_DBG_MSG(pAC,SK_DBGMOD_VPD,SK_DBGCAT_RX,("\n")) ;
-	*len = n ;
-	return(0) ;
+	SK_DBG_MSG(pAC, SK_DBGMOD_VPD, SK_DBGCAT_RX, ("\n"));
+	*len = n;
+	return(0);
 }
 
 
@@ -957,41 +1068,42 @@
  *		3:	VPD transfer timeout
  *		6:	fatal VPD error
  */
-int		VpdRead(
+int VpdRead(
 SK_AC		*pAC,	/* common data base */
 SK_IOC		IoC,	/* IO Context */
-char		*key,	/* keyword to read (e.g. "MN") */
+const char	*key,	/* keyword to read (e.g. "MN") */
 char		*buf,	/* buffer where to copy the keyword value */
-int		*len)	/* buffer length */
+int			*len)	/* buffer length */
 {
-	SK_VPD_PARA *p, vp ;
+	SK_VPD_PARA *p, vp;
 
-	SK_DBG_MSG(pAC,SK_DBGMOD_VPD,SK_DBGCAT_RX,("vpd read %s .. ",key)) ;
-	if (!(pAC->vpd.v.vpd_status & VPD_VALID)) {
-		if (VpdInit(pAC,IoC) != 0 ) {
-			*len = 0 ;
-			SK_DBG_MSG(pAC,SK_DBGMOD_VPD,SK_DBGCAT_ERR,
-				("vpd init error\n")) ;
-			return(6) ;
+	SK_DBG_MSG(pAC, SK_DBGMOD_VPD, SK_DBGCAT_RX, ("VPD read %s .. ", key));
+	if ((pAC->vpd.v.vpd_status & VPD_VALID) == 0) {
+		if (VpdInit(pAC, IoC) != 0) {
+			*len = 0;
+			SK_DBG_MSG(pAC, SK_DBGMOD_VPD, SK_DBGCAT_ERR,
+				("VPD init error\n"));
+			return(6);
 		}
 	}
 
-	if ((p = vpd_find_para(pAC,key,&vp))) {
+	if ((p = vpd_find_para(pAC, key, &vp)) != NULL) {
 		if (p->p_len > (*(unsigned *)len)-1) {
-			p->p_len = *len - 1 ;
+			p->p_len = *len - 1;
 		}
-		SK_MEMCPY(buf,p->p_val,p->p_len) ;
-		buf[p->p_len] = '\0' ;
-		*len = p->p_len ;
-		SK_DBG_MSG(pAC,SK_DBGMOD_VPD,SK_DBGCAT_RX,
+		SK_MEMCPY(buf, p->p_val, p->p_len);
+		buf[p->p_len] = '\0';
+		*len = p->p_len;
+		SK_DBG_MSG(pAC, SK_DBGMOD_VPD, SK_DBGCAT_RX,
 			("%c%c%c%c.., len = %d\n",
-			buf[0],buf[1],buf[2],buf[3],*len)) ;
-	} else {
-		*len = 0 ;
-		SK_DBG_MSG(pAC,SK_DBGMOD_VPD,SK_DBGCAT_ERR,("not found\n")) ;
-		return (1) ;
+			buf[0],buf[1],buf[2],buf[3],*len));
 	}
-	return (0) ;
+	else {
+		*len = 0;
+		SK_DBG_MSG(pAC, SK_DBGMOD_VPD, SK_DBGCAT_ERR, ("not found\n"));
+		return(1);
+	}
+	return(0);
 }
 
 
@@ -1002,16 +1114,16 @@
  *	SK_TRUE		Yes it may be written
  *	SK_FALSE	No it may be written
  */
-SK_BOOL		VpdMayWrite(
-char		*key)	/* keyword to write (allowed values "Yx", "Vx") */
+SK_BOOL VpdMayWrite(
+char	*key)	/* keyword to write (allowed values "Yx", "Vx") */
 {
 	if ((*key != 'Y' && *key != 'V') ||
 		key[1] < '0' || key[1] > 'Z' ||
 		(key[1] > '9' && key[1] < 'A') || strlen(key) != 2) {
 
-		return (SK_FALSE) ;
+		return(SK_FALSE);
 	}
-	return (SK_TRUE) ;
+	return(SK_TRUE);
 }
 
 /*
@@ -1027,52 +1139,52 @@
  *		5:	keyword cannot be written
  *		6:	fatal VPD error
  */
-int		VpdWrite(
+int VpdWrite(
 SK_AC		*pAC,	/* common data base */
 SK_IOC		IoC,	/* IO Context */
-char		*key,	/* keyword to write (allowed values "Yx", "Vx") */
-char		*buf)	/* buffer where the keyword value can be read from */
+const char	*key,	/* keyword to write (allowed values "Yx", "Vx") */
+const char	*buf)	/* buffer where the keyword value can be read from */
 {
-	int len ;			/* lenght of the keyword to write */
-	int rtv ;			/* return code */
-	int rtv2 ;
+	int len;		/* length of the keyword to write */
+	int rtv;		/* return code */
+	int rtv2;
 
-	SK_DBG_MSG(pAC,SK_DBGMOD_VPD,SK_DBGCAT_TX,
-		("vpd write %s = %s\n",key,buf)) ;
+	SK_DBG_MSG(pAC, SK_DBGMOD_VPD, SK_DBGCAT_TX,
+		("VPD write %s = %s\n",key,buf));
 
 	if ((*key != 'Y' && *key != 'V') ||
 		key[1] < '0' || key[1] > 'Z' ||
 		(key[1] > '9' && key[1] < 'A') || strlen(key) != 2) {
 
-		SK_DBG_MSG(pAC,SK_DBGMOD_VPD,SK_DBGCAT_ERR,
-			("illegal key tag, keyword not written\n")) ;
-		return (5) ;
+		SK_DBG_MSG(pAC, SK_DBGMOD_VPD, SK_DBGCAT_ERR,
+			("illegal key tag, keyword not written\n"));
+		return(5);
 	}
 
-	if (!(pAC->vpd.v.vpd_status & VPD_VALID)) {
-		if (VpdInit(pAC,IoC) != 0 ) {
-			SK_DBG_MSG(pAC,SK_DBGMOD_VPD,SK_DBGCAT_ERR,
-				("vpd init error\n")) ;
-			return(6) ;
+	if ((pAC->vpd.v.vpd_status & VPD_VALID) == 0) {
+		if (VpdInit(pAC, IoC) != 0) {
+			SK_DBG_MSG(pAC, SK_DBGMOD_VPD, SK_DBGCAT_ERR,
+				("VPD init error\n"));
+			return(6);
 		}
 	}
 
-	rtv = 0 ;
-	len = strlen(buf) ;
+	rtv = 0;
+	len = strlen(buf);
 	if (len > VPD_MAX_LEN) {
 		/* cut it */
-		len = VPD_MAX_LEN ;
-		rtv = 2 ;
-		SK_DBG_MSG(pAC,SK_DBGMOD_VPD,SK_DBGCAT_ERR,
-			("keyword to long, cut after %d bytes\n",VPD_MAX_LEN)) ;
-	}
-	if ((rtv2 = VpdSetupPara(pAC,key,buf,len,VPD_RW_KEY,OWR_KEY)) != 0) {
-		SK_DBG_MSG(pAC,SK_DBGMOD_VPD,SK_DBGCAT_ERR,
-			("vpd write error\n")) ;
-		return(rtv2) ;
+		len = VPD_MAX_LEN;
+		rtv = 2;
+		SK_DBG_MSG(pAC, SK_DBGMOD_VPD, SK_DBGCAT_ERR,
+			("keyword too long, cut after %d bytes\n",VPD_MAX_LEN));
+	}
+	if ((rtv2 = VpdSetupPara(pAC, key, buf, len, VPD_RW_KEY, OWR_KEY)) != 0) {
+		SK_DBG_MSG(pAC, SK_DBGMOD_VPD, SK_DBGCAT_ERR,
+			("VPD write error\n"));
+		return(rtv2);
 	}
 
-	return (rtv) ;
+	return(rtv);
 }
 
 /*
@@ -1087,48 +1199,52 @@
  *		5:	keyword cannot be deleted
  *		6:	fatal VPD error
  */
-int		VpdDelete(
-SK_AC		*pAC,	/* common data base */
-SK_IOC		IoC,	/* IO Context */
-char		*key)	/* keyword to read (e.g. "MN") */
+int VpdDelete(
+SK_AC	*pAC,	/* common data base */
+SK_IOC	IoC,	/* IO Context */
+char	*key)	/* keyword to read (e.g. "MN") */
 {
-	SK_VPD_PARA *p, vp ;
-	char *etp ;
+	SK_VPD_PARA *p, vp;
+	char *etp;
+	int	vpd_size;
 
-	SK_DBG_MSG(pAC,SK_DBGMOD_VPD,SK_DBGCAT_TX,("vpd delete key %s\n",key)) ;
-	if (!(pAC->vpd.v.vpd_status & VPD_VALID)) {
-		if (VpdInit(pAC,IoC) != 0 ) {
-			SK_DBG_MSG(pAC,SK_DBGMOD_VPD,SK_DBGCAT_ERR,
-				("vpd init error\n")) ;
-			return(6) ;
+	vpd_size = pAC->vpd.vpd_size;
+
+	SK_DBG_MSG(pAC,SK_DBGMOD_VPD,SK_DBGCAT_TX,("VPD delete key %s\n",key));
+	if ((pAC->vpd.v.vpd_status & VPD_VALID) == 0) {
+		if (VpdInit(pAC, IoC) != 0) {
+			SK_DBG_MSG(pAC, SK_DBGMOD_VPD, SK_DBGCAT_ERR,
+				("VPD init error\n"));
+			return(6);
 		}
 	}
 
-	if ((p = vpd_find_para(pAC,key,&vp))) {
-		if (p->p_val < pAC->vpd.vpd_buf + VPD_SIZE/2) {
+	if ((p = vpd_find_para(pAC, key, &vp)) != NULL) {
+		if (p->p_val < pAC->vpd.vpd_buf + vpd_size/2) {
 			/* try to delete read only keyword */
-			SK_DBG_MSG(pAC,SK_DBGMOD_VPD,SK_DBGCAT_ERR,
-				("cannot delete RO keyword\n")) ;
-			return (5) ;
+			SK_DBG_MSG(pAC, SK_DBGMOD_VPD, SK_DBGCAT_ERR,
+				("cannot delete RO keyword\n"));
+			return(5);
 		}
 
-		etp = pAC->vpd.vpd_buf + (VPD_SIZE-pAC->vpd.v.vpd_free_rw-1-3) ;
+		etp = pAC->vpd.vpd_buf + (vpd_size-pAC->vpd.v.vpd_free_rw-1-3);
 
 		vpd_move_para(vp.p_val+vp.p_len, etp+2,
-			- ((int)(vp.p_len + 3))) ;
+			- ((int)(vp.p_len + 3)));
 		if (vpd_mod_endtag(pAC, etp - vp.p_len - 3)) {
-			pAC->vpd.v.vpd_status &= ~VPD_VALID ;
-			SK_DBG_MSG(pAC,SK_DBGMOD_VPD,SK_DBGCAT_ERR,
-				("vpd encoding error\n")) ;
-			return(6) ;
+			pAC->vpd.v.vpd_status &= ~VPD_VALID;
+			SK_DBG_MSG(pAC, SK_DBGMOD_VPD, SK_DBGCAT_ERR,
+				("VPD encoding error\n"));
+			return(6);
 		}
-	} else {
-		SK_DBG_MSG(pAC,SK_DBGMOD_VPD,SK_DBGCAT_ERR,
-			("keyword not found\n")) ;
-		return (1) ;
+	}
+	else {
+		SK_DBG_MSG(pAC, SK_DBGMOD_VPD, SK_DBGCAT_ERR,
+			("keyword not found\n"));
+		return(1);
 	}
 
-	return (0) ;
+	return(0);
 }
 
 /*
@@ -1138,22 +1254,26 @@
  * returns	0:	success
  *		3:	VPD transfer timeout
  */
-int		VpdUpdate(
-SK_AC		*pAC,	/* Adapters context */
-SK_IOC		IoC)	/* IO Context */
-{
-	SK_DBG_MSG(pAC,SK_DBGMOD_VPD,SK_DBGCAT_TX,("vpd update .. ")) ;
-	if (pAC->vpd.v.vpd_status & VPD_VALID) {
-		if (VpdTransferBlock(pAC,IoC,pAC->vpd.vpd_buf + VPD_SIZE/2,
-			VPD_SIZE/2, VPD_SIZE/2, VPD_WRITE) != VPD_SIZE/2) {
-
-			SK_DBG_MSG(pAC,SK_DBGMOD_VPD,SK_DBGCAT_ERR,
-				("transfer timed out\n")) ;
-			return(3) ;
+int VpdUpdate(
+SK_AC	*pAC,	/* Adapters context */
+SK_IOC	IoC)	/* IO Context */
+{
+	int vpd_size;
+
+	vpd_size = pAC->vpd.vpd_size;
+
+	SK_DBG_MSG(pAC, SK_DBGMOD_VPD, SK_DBGCAT_TX, ("VPD update .. "));
+	if ((pAC->vpd.v.vpd_status & VPD_VALID) != 0) {
+		if (VpdTransferBlock(pAC, IoC, pAC->vpd.vpd_buf + vpd_size/2,
+			vpd_size/2, vpd_size/2, VPD_WRITE) != vpd_size/2) {
+
+			SK_DBG_MSG(pAC, SK_DBGMOD_VPD, SK_DBGCAT_ERR,
+				("transfer timed out\n"));
+			return(3);
 		}
 	}
-	SK_DBG_MSG(pAC,SK_DBGMOD_VPD,SK_DBGCAT_TX,("done\n")) ;
-	return (0) ;
+	SK_DBG_MSG(pAC, SK_DBGMOD_VPD, SK_DBGCAT_TX, ("done\n"));
+	return(0);
 }
 
 
@@ -1168,37 +1288,38 @@
  *
  * returns nothing, errors will be ignored.
  */
-void		VpdErrLog(
-SK_AC		*pAC,	/* common data base */
-SK_IOC		IoC,	/* IO Context */
-char		*msg)	/* error log message */
+void VpdErrLog(
+SK_AC	*pAC,	/* common data base */
+SK_IOC	IoC,	/* IO Context */
+char	*msg)	/* error log message */
 {
-	SK_VPD_PARA *v, vf ;	/* VF */
-	int len ;
+	SK_VPD_PARA *v, vf;	/* VF */
+	int len;
 
-	SK_DBG_MSG(pAC,SK_DBGMOD_VPD,SK_DBGCAT_TX,
-		("vpd error log msg %s\n",msg)) ;
-	if (!(pAC->vpd.v.vpd_status & VPD_VALID)) {
-		if (VpdInit(pAC,IoC) != 0 ) {
-			SK_DBG_MSG(pAC,SK_DBGMOD_VPD,SK_DBGCAT_ERR,
-				("vpd init error\n")) ;
-			return ;
+	SK_DBG_MSG(pAC, SK_DBGMOD_VPD, SK_DBGCAT_TX,
+		("VPD error log msg %s\n", msg));
+	if ((pAC->vpd.v.vpd_status & VPD_VALID) == 0) {
+		if (VpdInit(pAC, IoC) != 0) {
+			SK_DBG_MSG(pAC, SK_DBGMOD_VPD, SK_DBGCAT_ERR,
+				("VPD init error\n"));
+			return;
 		}
 	}
 
-	len = strlen(msg) ;
+	len = strlen(msg);
 	if (len > VPD_MAX_LEN) {
 		/* cut it */
-		len = VPD_MAX_LEN ;
+		len = VPD_MAX_LEN;
+	}
+	if ((v = vpd_find_para(pAC, VPD_VF, &vf)) != NULL) {
+		SK_DBG_MSG(pAC, SK_DBGMOD_VPD, SK_DBGCAT_TX, ("overwrite VL\n"));
+		(void)VpdSetupPara(pAC, VPD_VL, msg, len, VPD_RW_KEY, OWR_KEY);
 	}
-	if ((v = vpd_find_para(pAC,VPD_VF,&vf))) {
-		SK_DBG_MSG(pAC,SK_DBGMOD_VPD,SK_DBGCAT_TX,("overwrite VL\n")) ;
-		(void)VpdSetupPara(pAC,VPD_VL,msg,len,VPD_RW_KEY,OWR_KEY) ;
-	} else {
-		SK_DBG_MSG(pAC,SK_DBGMOD_VPD,SK_DBGCAT_TX,("write VF\n")) ;
-		(void)VpdSetupPara(pAC,VPD_VF,msg,len,VPD_RW_KEY,ADD_KEY) ;
+	else {
+		SK_DBG_MSG(pAC, SK_DBGMOD_VPD, SK_DBGCAT_TX, ("write VF\n"));
+		(void)VpdSetupPara(pAC, VPD_VF, msg, len, VPD_RW_KEY, ADD_KEY);
 	}
 
-	(void)VpdUpdate(pAC,IoC) ;
+	(void)VpdUpdate(pAC, IoC);
 }
 
diff -ruN linux/drivers/net/sk98lin/skxmac2.c linuxn/drivers/net/sk98lin/skxmac2.c
--- linux/drivers/net/sk98lin/skxmac2.c	Wed Jul  4 20:50:39 2001
+++ linuxn/drivers/net/sk98lin/skxmac2.c	Tue May 20 12:17:40 2003
@@ -2,15 +2,16 @@
  *
  * Name:	skxmac2.c
  * Project:	GEnesis, PCI Gigabit Ethernet Adapter
- * Version:	$Revision: 1.61 $
- * Date:	$Date: 2001/02/09 15:40:59 $
- * Purpose:	Contains functions to initialize the XMAC II
+ * Version:	$Revision: 1.94 $
+ * Date:	$Date: 2003/04/10 14:36:40 $
+ * Purpose:	Contains functions to initialize the MACs and PHYs
  *
  ******************************************************************************/
 
 /******************************************************************************
  *
- *	(C)Copyright 1998-2001 SysKonnect GmbH.
+ *	(C)Copyright 1998-2002 SysKonnect.
+ *	(C)Copyright 2002-2003 Marvell.
  *
  *	This program is free software; you can redistribute it and/or modify
  *	it under the terms of the GNU General Public License as published by
@@ -26,6 +27,191 @@
  * History:
  *
  *	$Log: skxmac2.c,v $
+ *	Revision 1.94  2003/04/10 14:36:40  rschmidt
+ *	Fixed define for debug code in SkGmInitPhyMarv().
+ *	
+ *	Revision 1.93  2003/04/08 16:58:16  rschmidt
+ *	Changed initialisation of GMAC and GPHY for disabling
+ *	Flow-Control with parameter 'none' (Bug Id #10769).
+ *	Changed init for blinking active LED and normal duplex LED
+ *	depending on value from GILedBlinkCtrl (LED Blink Control).
+ *	Added control for Link100 LED.
+ *	Changed handling for different PhyTypes for source code
+ *	portability to PXE, UNDI.
+ *	Editorial changes.
+ *	
+ *	Revision 1.92  2003/03/31 07:12:33  mkarl
+ *	Restore PHY_MARV_AUNE_ADV after writing to GM_GP_CTRL in order to make
+ *	auto-negotiation of limited flow-control possible.
+ *	Corrected Copyright.
+ *	Editorial changes.
+ *	
+ *	Revision 1.91  2003/02/05 15:09:34  rschmidt
+ *	Removed setting of 'Collision Test'-bit in SkGmInitPhyMarv().
+ *	Disabled auto-update for speed, duplex and flow-control when
+ *	auto-negotiation is not enabled (Bug Id #10766).
+ *	Editorial changes.
+ *	
+ *	Revision 1.90  2003/01/29 13:35:19  rschmidt
+ *	Increment Rx FIFO Overflow counter only in DEBUG-mode.
+ *	Corrected define for blinking active LED.
+ *	
+ *	Revision 1.89  2003/01/28 16:37:45  rschmidt
+ *	Changed init for blinking active LED
+ *	
+ *	Revision 1.88  2003/01/28 10:09:38  rschmidt
+ *	Added debug outputs in SkGmInitMac().
+ *	Added customized init of LED registers in SkGmInitPhyMarv(),
+ *	for blinking active LED (#ifdef ACT_LED_BLINK) and
+ *	for normal duplex LED (#ifdef DUP_LED_NORMAL).
+ *	Editorial changes.
+ *	
+ *	Revision 1.87  2002/12/10 14:39:05  rschmidt
+ *	Improved initialization of GPHY in SkGmInitPhyMarv().
+ *	Editorial changes.
+ *	
+ *	Revision 1.86  2002/12/09 15:01:12  rschmidt
+ *	Added setup of Ext. PHY Specific Ctrl Reg (downshift feature).
+ *	
+ *	Revision 1.85  2002/12/05 14:09:16  rschmidt
+ *	Improved avoiding endless loop in SkGmPhyWrite(), SkGmPhyWrite().
+ *	Added additional advertising for 10Base-T when 100Base-T is selected.
+ *	Added case SK_PHY_MARV_FIBER for YUKON Fiber adapter.
+ *	Editorial changes.
+ *	
+ *	Revision 1.84  2002/11/15 12:50:09  rschmidt
+ *	Changed SkGmCableDiagStatus() when getting results.
+ *	
+ *	Revision 1.83  2002/11/13 10:28:29  rschmidt
+ *	Added some typecasts to avoid compiler warnings.
+ *	
+ *	Revision 1.82  2002/11/13 09:20:46  rschmidt
+ *	Replaced for(..) with do {} while (...) in SkXmUpdateStats().
+ *	Replaced 2 macros GM_IN16() with 1 GM_IN32() in SkGmMacStatistic().
+ *	Added SkGmCableDiagStatus() for Virtual Cable Test (VCT).
+ *	Editorial changes.
+ *	
+ *	Revision 1.81  2002/10/28 14:28:08  rschmidt
+ *	Changed MAC address setup for GMAC in SkGmInitMac().
+ *	Optimized handling of counter overflow IRQ in SkGmOverflowStatus().
+ *	Editorial changes.
+ *	
+ *	Revision 1.80  2002/10/14 15:29:44  rschmidt
+ *	Corrected disabling of all PHY IRQs.
+ *	Added WA for deviation #16 (address used for pause packets).
+ *	Set Pause Mode in SkMacRxTxEnable() only for Genesis.
+ *	Added IRQ and counter for Receive FIFO Overflow in DEBUG-mode.
+ *	SkXmTimeStamp() replaced by SkMacTimeStamp().
+ *	Added clearing of GMAC Tx FIFO Underrun IRQ in SkGmIrq().
+ *	Editorial changes.
+ *	
+ *	Revision 1.79  2002/10/10 15:55:36  mkarl
+ *	changes for PLinkSpeedUsed
+ *	
+ *	Revision 1.78  2002/09/12 09:39:51  rwahl
+ *	Removed deactivate code for SIRQ overflow event separate for TX/RX.
+ *	
+ *	Revision 1.77  2002/09/09 12:26:37  mkarl
+ *	added handling for Yukon to SkXmTimeStamp
+ *	
+ *	Revision 1.76  2002/08/21 16:41:16  rschmidt
+ *	Added bit GPC_ENA_XC (Enable MDI crossover) in HWCFG_MODE.
+ *	Added forced speed settings in SkGmInitPhyMarv().
+ *	Added settings of full/half duplex capabilities for YUKON Fiber.
+ *	Editorial changes.
+ *	
+ *	Revision 1.75  2002/08/16 15:12:01  rschmidt
+ *	Replaced all if(GIChipId == CHIP_ID_GENESIS) with new entry GIGenesis.
+ *	Added function SkMacHashing() for ADDR-Module.
+ *	Removed functions SkXmClrSrcCheck(), SkXmClrHashAddr() (calls replaced
+ *	with macros).
+ *	Removed functions SkGmGetMuxConfig().
+ *	Added HWCFG_MODE init for YUKON Fiber.
+ *	Changed initialization of GPHY in SkGmInitPhyMarv().
+ *	Changed check of parameter in SkXmMacStatistic().
+ *	Editorial changes.
+ *	
+ *	Revision 1.74  2002/08/12 14:00:17  rschmidt
+ *	Replaced usage of Broadcom PHY Ids with defines.
+ *	Corrected error messages in SkGmMacStatistic().
+ *	Made SkMacPromiscMode() public for ADDR-Modul.
+ *	Editorial changes.
+ *	
+ *	Revision 1.73  2002/08/08 16:26:24  rschmidt
+ *	Improved reset sequence for YUKON in SkGmHardRst() and SkGmInitMac().
+ *	Replaced XMAC Rx High Watermark init value with SK_XM_RX_HI_WM.
+ *	Editorial changes.
+ *	
+ *	Revision 1.72  2002/07/24 15:11:19  rschmidt
+ *	Fixed wrong placement of parenthesis.
+ *	Editorial changes.
+ *	
+ *	Revision 1.71  2002/07/23 16:05:18  rschmidt
+ *	Added global functions for PHY: SkGePhyRead(), SkGePhyWrite().
+ *	Fixed Tx Counter Overflow IRQ (Bug ID #10730).
+ *	Editorial changes.
+ *	
+ *	Revision 1.70  2002/07/18 14:27:27  rwahl
+ *	Fixed syntax error.
+ *	
+ *	Revision 1.69  2002/07/17 17:08:47  rwahl
+ *	Fixed check in SkXmMacStatistic().
+ *	
+ *	Revision 1.68  2002/07/16 07:35:24  rwahl
+ *	Removed check for cleared mib counter in SkGmResetCounter().
+ *	
+ *	Revision 1.67  2002/07/15 18:35:56  rwahl
+ *	Added SkXmUpdateStats(), SkGmUpdateStats(), SkXmMacStatistic(),
+ *	  SkGmMacStatistic(), SkXmResetCounter(), SkGmResetCounter(),
+ *	  SkXmOverflowStatus(), SkGmOverflowStatus().
+ *	Changes to SkXmIrq() & SkGmIrq(): Combined SIRQ Overflow for both
+ *	  RX & TX.
+ *	Changes to SkGmInitMac(): call to SkGmResetCounter().
+ *	Editorial changes.
+ *	
+ *	Revision 1.66  2002/07/15 15:59:30  rschmidt
+ *	Added PHY Address in SkXmPhyRead(), SkXmPhyWrite().
+ *	Added MIB Clear Counter in SkGmInitMac().
+ *	Added Duplex and Flow-Control settings.
+ *	Reset all Multicast filtering Hash reg. in SkGmInitMac().
+ *	Added new function: SkGmGetMuxConfig().
+ *	Editorial changes.
+ *	
+ *	Revision 1.65  2002/06/10 09:35:39  rschmidt
+ *	Replaced C++ comments (//).
+ *	Added #define VCPU around VCPUwaitTime.
+ *	Editorial changes.
+ *	
+ *	Revision 1.64  2002/06/05 08:41:10  rschmidt
+ *	Added function for XMAC2: SkXmTimeStamp().
+ *	Added function for YUKON: SkGmSetRxCmd().
+ *	Changed SkGmInitMac() resp. SkGmHardRst().
+ *	Fixed wrong variable in SkXmAutoNegLipaXmac() (debug mode).
+ *	SkXmRxTxEnable() replaced by SkMacRxTxEnable().
+ *	Editorial changes.
+ *	
+ *	Revision 1.63  2002/04/25 13:04:44  rschmidt
+ *	Changes for handling YUKON.
+ *	Use of #ifdef OTHER_PHY to eliminate code for unused Phy types.
+ *	Macros for XMAC PHY access PHY_READ(), PHY_WRITE() replaced
+ *	by functions SkXmPhyRead(), SkXmPhyWrite();
+ *	Removed use of PRxCmd to setup XMAC.
+ *	Added define PHY_B_AS_PAUSE_MSK for BCom Pause Res.
+ *	Added setting of XM_RX_DIS_CEXT in SkXmInitMac().
+ *	Removed status parameter from MAC IRQ handler SkMacIrq(),
+ *	SkXmIrq() and SkGmIrq().
+ *	SkXmAutoNegLipa...() for ext. Phy replaced by SkMacAutoNegLipaPhy().
+ *	Added SkMac...() functions to handle both XMAC and GMAC.
+ *	Added functions for YUKON: SkGmHardRst(), SkGmSoftRst(),
+ *	SkGmSetRxTxEn(), SkGmIrq(), SkGmInitMac(), SkGmInitPhyMarv(),
+ *	SkGmAutoNegDoneMarv(), SkGmPhyRead(), SkGmPhyWrite().
+ *	Changes for V-CPU support.
+ *	Editorial changes.
+ *	
+ *	Revision 1.62  2001/08/06 09:50:14  rschmidt
+ *	Workaround BCOM Errata #1 for the C5 type.
+ *	Editorial changes.
+ *	
  *	Revision 1.61  2001/02/09 15:40:59  rassmann
  *	Editorial changes.
  *	
@@ -194,7 +380,7 @@
  *
  *	Revision 1.12  1998/10/14 14:45:04  malthoff
  *	Remove SKERR_SIRQ_E0xx and SKERR_SIRQ_E0xxMSG by
- *	SKERR_HWI_Exx and SKERR_HWI_E0xxMSG to be independant
+ *	SKERR_HWI_Exx and SKERR_HWI_E0xxMSG to be independent
  *	from the Sirq module.
  *
  *	Revision 1.11  1998/10/14 13:59:01  gklug
@@ -203,17 +389,16 @@
  *	Revision 1.10  1998/10/14 11:20:57  malthoff
  *	Make SkXmAutoNegDone() public, because it's
  *	used in diagnostics, too.
- *	The Link Up event to the RLMT is issued in
- *	SkXmIrq(). SkXmIrq() is not available in
- *	diagnostics. Use PHY_READ when reading
- *	PHY registers.
+ *	The Link Up event to the RLMT is issued in SkXmIrq().
+ *  SkXmIrq() is not available in diagnostics.
+ *  Use PHY_READ when reading PHY registers.
  *
  *	Revision 1.9  1998/10/14 05:50:10  cgoos
  *	Added definition for Para.
  *
  *	Revision 1.8  1998/10/14 05:41:28  gklug
  *	add: Xmac IRQ
- *	add: auto negotiation done function
+ *	add: auto-negotiation done function
  *
  *	Revision 1.7  1998/10/09 06:55:20  malthoff
  *	The configuration of the XMACs Tx Request Threshold
@@ -246,17 +431,9 @@
  ******************************************************************************/
 
 #include "h/skdrv1st.h"
-#include "h/xmac_ii.h"
 #include "h/skdrv2nd.h"
 
-/* defines ********************************************************************/
 /* typedefs *******************************************************************/
-/* global variables ***********************************************************/
-
-/* local variables ************************************************************/
-
-static const char SysKonnectFileId[] =
-	"@(#)$Id: skxmac2.c,v 1.61 2001/02/09 15:40:59 rassmann Exp $ (C) SK ";
 
 /* BCOM PHY magic pattern list */
 typedef struct s_PhyHack {
@@ -264,6 +441,13 @@
 	SK_U16	PhyVal;		/* Value to write */
 } BCOM_HACK;
 
+/* local variables ************************************************************/
+
+#ifndef _lint
+static const char SysKonnectFileId[] =
+	"@(#) $Id: skxmac2.c,v 1.94 2003/04/10 14:36:40 rschmidt Exp $ (C) Marvell.";
+#endif /* !_lint */
+
 BCOM_HACK BcomRegA1Hack[] = {
  { 0x18, 0x0c20 }, { 0x17, 0x0012 }, { 0x15, 0x1104 }, { 0x17, 0x0013 },
  { 0x15, 0x0404 }, { 0x17, 0x8006 }, { 0x15, 0x0132 }, { 0x17, 0x8006 },
@@ -279,308 +463,797 @@
 /* function prototypes ********************************************************/
 static void	SkXmInitPhyXmac(SK_AC*, SK_IOC, int, SK_BOOL);
 static void	SkXmInitPhyBcom(SK_AC*, SK_IOC, int, SK_BOOL);
-static void	SkXmInitPhyLone(SK_AC*, SK_IOC, int, SK_BOOL);
-static void	SkXmInitPhyNat (SK_AC*, SK_IOC, int, SK_BOOL);
+static void	SkGmInitPhyMarv(SK_AC*, SK_IOC, int, SK_BOOL);
 static int	SkXmAutoNegDoneXmac(SK_AC*, SK_IOC, int);
 static int	SkXmAutoNegDoneBcom(SK_AC*, SK_IOC, int);
+static int	SkGmAutoNegDoneMarv(SK_AC*, SK_IOC, int);
+#ifdef OTHER_PHY
+static void	SkXmInitPhyLone(SK_AC*, SK_IOC, int, SK_BOOL);
+static void	SkXmInitPhyNat (SK_AC*, SK_IOC, int, SK_BOOL);
 static int	SkXmAutoNegDoneLone(SK_AC*, SK_IOC, int);
 static int	SkXmAutoNegDoneNat (SK_AC*, SK_IOC, int);
+#endif /* OTHER_PHY */
+
+
 
 /******************************************************************************
  *
- *	SkXmSetRxCmd() - Modify the value of the XMACs Rx Command Register
+ *	SkXmPhyRead() - Read from XMAC PHY register
  *
- * Description:
- *	The features
- *	 o FCS stripping,			SK_STRIP_FCS_ON/OFF
- *	 o pad byte stripping,			SK_STRIP_PAD_ON/OFF
- *	 o don't set XMR_FS_ERR in frame	SK_LENERR_OK_ON/OFF
- *	   status for inrange length error
- *	   frames, and
- *	 o don't set XMR_FS_ERR in frame	SK_BIG_PK_OK_ON/OFF
- *	   status for frames > 1514 bytes
- *
- *	for incomming packets may be enabled/disabled by this function.
- *	Additional modes may be added later.
- *	Multiple modes can be enabled/disabled at the same time.
- *	The new configuration is stored into the HWAC port configuration
- *	and is written to the Receive Command register immediatlely.
- *	The new configuration is saved over any SkGePortStop() and
- *	SkGeInitPort() calls. The configured value will be overwritten
- *	when SkGeInit(Level 0) is executed.
+ * Description:	reads a 16-bit word from XMAC PHY or ext. PHY
  *
  * Returns:
  *	nothing
  */
-void SkXmSetRxCmd(
-SK_AC	*pAC,		/* adapter context */
-SK_IOC	IoC,		/* IO context */
-int		Port,		/* The XMAC to handle with belongs to this Port */
-int		Mode)		/* Mode is SK_STRIP_FCS_ON/OFF, SK_STRIP_PAD_ON/OFF,
-					   SK_LENERR_OK_ON/OFF, or SK_BIG_PK_OK_ON/OFF */
+void SkXmPhyRead(
+SK_AC	*pAC,		/* Adapter Context */
+SK_IOC	IoC,		/* I/O Context */
+int		Port,		/* Port Index (MAC_1 + n) */
+int		PhyReg,		/* Register Address (Offset) */
+SK_U16	*pVal)		/* Pointer to Value */
 {
+	SK_U16		Mmu;
 	SK_GEPORT	*pPrt;
-	SK_U16		OldRxMode;
 
 	pPrt = &pAC->GIni.GP[Port];
-	OldRxMode = pPrt->PRxCmd;
+	
+	/* write the PHY register's address */
+	XM_OUT16(IoC, Port, XM_PHY_ADDR, PhyReg | pPrt->PhyAddr);
+	
+	/* get the PHY register's value */
+	XM_IN16(IoC, Port, XM_PHY_DATA, pVal);
+	
+	if (pPrt->PhyType != SK_PHY_XMAC) {
+		do {
+			XM_IN16(IoC, Port, XM_MMU_CMD, &Mmu);
+			/* wait until 'Ready' is set */
+		} while ((Mmu & XM_MMU_PHY_RDY) == 0);
 
-	switch(Mode & (SK_STRIP_FCS_ON | SK_STRIP_FCS_OFF)) {
-	case SK_STRIP_FCS_ON:
-		pPrt->PRxCmd |= XM_RX_STRIP_FCS;
-		break;
-	case SK_STRIP_FCS_OFF:
-		pPrt->PRxCmd &= ~XM_RX_STRIP_FCS;
-		break;
+		/* get the PHY register's value */
+		XM_IN16(IoC, Port, XM_PHY_DATA, pVal);
 	}
+}	/* SkXmPhyRead */
 
-	switch(Mode & (SK_STRIP_PAD_ON | SK_STRIP_PAD_OFF)) {
-	case SK_STRIP_PAD_ON:
-		pPrt->PRxCmd |= XM_RX_STRIP_PAD;
-		break;
-	case SK_STRIP_PAD_OFF:
-		pPrt->PRxCmd &= ~XM_RX_STRIP_PAD;
-		break;
-	}
 
-	switch(Mode & (SK_LENERR_OK_ON | SK_LENERR_OK_OFF)) {
-	case SK_LENERR_OK_ON:
-		pPrt->PRxCmd |= XM_RX_LENERR_OK;
-		break;
-	case SK_LENERR_OK_OFF:
-		pPrt->PRxCmd &= ~XM_RX_LENERR_OK;
-		break;
-	}
+/******************************************************************************
+ *
+ *	SkXmPhyWrite() - Write to XMAC PHY register
+ *
+ * Description:	writes a 16-bit word to XMAC PHY or ext. PHY
+ *
+ * Returns:
+ *	nothing
+ */
+void SkXmPhyWrite(
+SK_AC	*pAC,		/* Adapter Context */
+SK_IOC	IoC,		/* I/O Context */
+int		Port,		/* Port Index (MAC_1 + n) */
+int		PhyReg,		/* Register Address (Offset) */
+SK_U16	Val)		/* Value */
+{
+	SK_U16		Mmu;
+	SK_GEPORT	*pPrt;
 
-	switch(Mode & (SK_BIG_PK_OK_ON | SK_BIG_PK_OK_OFF)) {
-	case SK_BIG_PK_OK_ON:
-		pPrt->PRxCmd |= XM_RX_BIG_PK_OK;
-		break;
-	case SK_BIG_PK_OK_OFF:
-		pPrt->PRxCmd &= ~XM_RX_BIG_PK_OK;
-		break;
+	pPrt = &pAC->GIni.GP[Port];
+	
+	if (pPrt->PhyType != SK_PHY_XMAC) {
+		do {
+			XM_IN16(IoC, Port, XM_MMU_CMD, &Mmu);
+			/* wait until 'Busy' is cleared */
+		} while ((Mmu & XM_MMU_PHY_BUSY) != 0);
 	}
-
-	/* Write the new mode to the receive command register if required */
-	if (OldRxMode != pPrt->PRxCmd) {
-		XM_OUT16(IoC, Port, XM_RX_CMD, pPrt->PRxCmd);
+	
+	/* write the PHY register's address */
+	XM_OUT16(IoC, Port, XM_PHY_ADDR, PhyReg | pPrt->PhyAddr);
+	
+	/* write the PHY register's value */
+	XM_OUT16(IoC, Port, XM_PHY_DATA, Val);
+	
+	if (pPrt->PhyType != SK_PHY_XMAC) {
+		do {
+			XM_IN16(IoC, Port, XM_MMU_CMD, &Mmu);
+			/* wait until 'Busy' is cleared */
+		} while ((Mmu & XM_MMU_PHY_BUSY) != 0);
 	}
-}	/* SkXmSetRxCmd*/
+}	/* SkXmPhyWrite */
 
 
 /******************************************************************************
  *
- *	SkXmClrExactAddr() - Clear Exact Match Address Registers
+ *	SkGmPhyRead() - Read from GPHY register
  *
- * Description:
- *	All Exact Match Address registers of the XMAC 'Port' will be
- *	cleared starting with 'StartNum' up to (and including) the
- *	Exact Match address number of 'StopNum'.
+ * Description:	reads a 16-bit word from GPHY through MDIO
  *
  * Returns:
  *	nothing
  */
-void SkXmClrExactAddr(
-SK_AC	*pAC,		/* adapter context */
-SK_IOC	IoC,		/* IO context */
-int		Port,		/* The XMAC to handle with belongs to this Port */
-int		StartNum,	/* Begin with this Address Register Index (0..15) */
-int		StopNum)	/* Stop after finished with this Register Idx (0..15) */
+void SkGmPhyRead(
+SK_AC	*pAC,		/* Adapter Context */
+SK_IOC	IoC,		/* I/O Context */
+int		Port,		/* Port Index (MAC_1 + n) */
+int		PhyReg,		/* Register Address (Offset) */
+SK_U16	*pVal)		/* Pointer to Value */
 {
-	int		i;
-	SK_U16	ZeroAddr[3] = {0x0000, 0x0000, 0x0000};
+	SK_U16	Ctrl;
+	SK_GEPORT	*pPrt;
+#ifdef VCPU
+	u_long SimCyle;
+	u_long SimLowTime;
+	
+	VCPUgetTime(&SimCyle, &SimLowTime);
+	VCPUprintf(0, "SkGmPhyRead(%u), SimCyle=%u, SimLowTime=%u\n",
+		PhyReg, SimCyle, SimLowTime);
+#endif /* VCPU */
+	
+	pPrt = &pAC->GIni.GP[Port];
+	
+	/* set PHY-Register offset and 'Read' OpCode (= 1) */
+	*pVal = (SK_U16)(GM_SMI_CT_PHY_AD(pPrt->PhyAddr) |
+		GM_SMI_CT_REG_AD(PhyReg) | GM_SMI_CT_OP_RD);
 
-	if ((unsigned)StartNum > 15 || (unsigned)StopNum > 15 ||
-		StartNum > StopNum) {
+	GM_OUT16(IoC, Port, GM_SMI_CTRL, *pVal);
 
-		SK_ERR_LOG(pAC, SK_ERRCL_SW, SKERR_HWI_E001, SKERR_HWI_E001MSG);
+	GM_IN16(IoC, Port, GM_SMI_CTRL, &Ctrl);
+	
+	/* additional check for MDC/MDIO activity */
+	if ((Ctrl & GM_SMI_CT_BUSY) == 0) {
+		*pVal = 0;
 		return;
 	}
 
-	for (i = StartNum; i <= StopNum; i++) {
-		XM_OUTADDR(IoC, Port, XM_EXM(i), &ZeroAddr[0]);
-	}
-}	/* SkXmClrExactAddr */
+	*pVal |= GM_SMI_CT_BUSY;
+	
+	do {
+#ifdef VCPU
+		VCPUwaitTime(1000);
+#endif /* VCPU */
+
+		GM_IN16(IoC, Port, GM_SMI_CTRL, &Ctrl);
+
+	/* wait until 'ReadValid' is set */
+	} while (Ctrl == *pVal);
+	
+	/* get the PHY register's value */
+	GM_IN16(IoC, Port, GM_SMI_DATA, pVal);
+
+#ifdef VCPU
+	VCPUgetTime(&SimCyle, &SimLowTime);
+	VCPUprintf(0, "VCPUgetTime(), SimCyle=%u, SimLowTime=%u\n",
+		SimCyle, SimLowTime);
+#endif /* VCPU */
+}	/* SkGmPhyRead */
 
 
 /******************************************************************************
  *
- *	SkXmClrSrcCheck() - Clear Source Check Address Register
+ *	SkGmPhyWrite() - Write to GPHY register
  *
- * Description:
- *	The Source Check Address Register of the XMAC 'Port' number
- *	will be cleared.
+ * Description:	writes a 16-bit word to GPHY through MDIO
  *
  * Returns:
  *	nothing
  */
-static void SkXmClrSrcCheck(
-SK_AC	*pAC,	/* adapter context */
-SK_IOC	IoC,	/* IO context */
-int		Port)	/* The XMAC to handle with belongs to this Port (MAC_1 + n) */
+void SkGmPhyWrite(
+SK_AC	*pAC,		/* Adapter Context */
+SK_IOC	IoC,		/* I/O Context */
+int		Port,		/* Port Index (MAC_1 + n) */
+int		PhyReg,		/* Register Address (Offset) */
+SK_U16	Val)		/* Value */
 {
-	SK_U16	ZeroAddr[3] = {0x0000, 0x0000, 0x0000};
+	SK_U16	Ctrl;
+	SK_GEPORT	*pPrt;
+#ifdef VCPU
+	SK_U32	DWord;
+	u_long	SimCyle;
+	u_long	SimLowTime;
+	
+	VCPUgetTime(&SimCyle, &SimLowTime);
+	VCPUprintf(0, "SkGmPhyWrite(Reg=%u, Val=0x%04x), SimCyle=%u, SimLowTime=%u\n",
+		PhyReg, Val, SimCyle, SimLowTime);
+#endif /* VCPU */
+	
+	pPrt = &pAC->GIni.GP[Port];
+	
+	/* write the PHY register's value */
+	GM_OUT16(IoC, Port, GM_SMI_DATA, Val);
+	
+	/* set PHY-Register offset and 'Write' OpCode (= 0) */
+	Val = GM_SMI_CT_PHY_AD(pPrt->PhyAddr) | GM_SMI_CT_REG_AD(PhyReg);
 
-	XM_OUTHASH(IoC, Port, XM_SRC_CHK, &ZeroAddr);
-}	/* SkXmClrSrcCheck */
+	GM_OUT16(IoC, Port, GM_SMI_CTRL, Val);
+
+	GM_IN16(IoC, Port, GM_SMI_CTRL, &Ctrl);
+	
+	/* additional check for MDC/MDIO activity */
+	if ((Ctrl & GM_SMI_CT_BUSY) == 0) {
+		return;
+	}
+	
+	Val |= GM_SMI_CT_BUSY;
+
+	do {
+#ifdef VCPU
+		/* read Timer value */
+		SK_IN32(IoC, B2_TI_VAL, &DWord);
+
+		VCPUwaitTime(1000);
+#endif /* VCPU */
+
+		GM_IN16(IoC, Port, GM_SMI_CTRL, &Ctrl);
+
+	/* wait until 'Busy' is cleared */
+	} while (Ctrl == Val);
+	
+#ifdef VCPU
+	VCPUgetTime(&SimCyle, &SimLowTime);
+	VCPUprintf(0, "VCPUgetTime(), SimCyle=%u, SimLowTime=%u\n",
+		SimCyle, SimLowTime);
+#endif /* VCPU */
+}	/* SkGmPhyWrite */
 
 
 /******************************************************************************
  *
- *	SkXmClrHashAddr() - Clear Hash Address Registers
+ *	SkGePhyRead() - Read from PHY register
  *
- * Description:
- *	The Hash Address Register of the XMAC 'Port' will be cleared.
+ * Description:	calls a read PHY routine dep. on board type
  *
  * Returns:
  *	nothing
  */
-static void SkXmClrHashAddr(
-SK_AC	*pAC,	/* adapter context */
-SK_IOC	IoC,	/* IO context */
-int		Port)	/* The XMAC to handle with belongs to this Port (MAC_1 + n) */
+void SkGePhyRead(
+SK_AC	*pAC,		/* Adapter Context */
+SK_IOC	IoC,		/* I/O Context */
+int		Port,		/* Port Index (MAC_1 + n) */
+int		PhyReg,		/* Register Address (Offset) */
+SK_U16	*pVal)		/* Pointer to Value */
 {
-	SK_U16	ZeroAddr[4] = {0x0000, 0x0000, 0x0000, 0x0000};
+	void (*r_func)(SK_AC *pAC, SK_IOC IoC, int Port, int Reg, SK_U16 *pVal);
 
-	XM_OUTHASH(IoC, Port, XM_HSM, &ZeroAddr);
-}	/* SkXmClrHashAddr*/
+	if (pAC->GIni.GIGenesis) {
+		r_func = SkXmPhyRead;
+	}
+	else {
+		r_func = SkGmPhyRead;
+	}
+	
+	r_func(pAC, IoC, Port, PhyReg, pVal);
+}	/* SkGePhyRead */
 
 
 /******************************************************************************
  *
- *	SkXmFlushTxFifo() - Flush the XMACs transmit FIFO
+ *	SkGePhyWrite() - Write to PHY register
  *
- * Description:
- *	Flush the transmit FIFO of the XMAC specified by the index 'Port'
+ * Description:	calls a write PHY routine dep. on board type
  *
  * Returns:
  *	nothing
  */
-void SkXmFlushTxFifo(
-SK_AC	*pAC,	/* adapter context */
-SK_IOC	IoC,	/* IO context */
-int		Port)	/* The XMAC to handle with belongs to this Port (MAC_1 + n) */
+void SkGePhyWrite(
+SK_AC	*pAC,		/* Adapter Context */
+SK_IOC	IoC,		/* I/O Context */
+int		Port,		/* Port Index (MAC_1 + n) */
+int		PhyReg,		/* Register Address (Offset) */
+SK_U16	Val)		/* Value */
 {
-	SK_U32	MdReg;
+	void (*w_func)(SK_AC *pAC, SK_IOC IoC, int Port, int Reg, SK_U16 Val);
 
-	XM_IN32(IoC, Port, XM_MODE, &MdReg);
-	MdReg |= XM_MD_FTF;
-	XM_OUT32(IoC, Port, XM_MODE, MdReg);
-}	/* SkXmFlushTxFifo */
+	if (pAC->GIni.GIGenesis) {
+		w_func = SkXmPhyWrite;
+	}
+	else {
+		w_func = SkGmPhyWrite;
+	}
+	
+	w_func(pAC, IoC, Port, PhyReg, Val);
+}	/* SkGePhyWrite */
 
 
 /******************************************************************************
  *
- *	SkXmFlushRxFifo() - Flush the XMACs receive FIFO
+ *	SkMacPromiscMode() - Enable / Disable Promiscuous Mode
  *
  * Description:
- *	Flush the receive FIFO of the XMAC specified by the index 'Port'
+ *   enables / disables promiscuous mode by setting Mode Register (XMAC) or
+ *   Receive Control Register (GMAC) dep. on board type   	
  *
  * Returns:
  *	nothing
  */
-void SkXmFlushRxFifo(
+void SkMacPromiscMode(
 SK_AC	*pAC,	/* adapter context */
 SK_IOC	IoC,	/* IO context */
-int		Port)	/* The XMAC to handle with belongs to this Port (MAC_1 + n) */
+int		Port,	/* Port Index (MAC_1 + n) */
+SK_BOOL	Enable)	/* Enable / Disable */
 {
+	SK_U16	RcReg;
 	SK_U32	MdReg;
 
-	XM_IN32(IoC, Port, XM_MODE, &MdReg);
-	MdReg |= XM_MD_FRF;
-	XM_OUT32(IoC, Port, XM_MODE, MdReg);
-}	/* SkXmFlushRxFifo*/
+	if (pAC->GIni.GIGenesis) {
+		
+		XM_IN32(IoC, Port, XM_MODE, &MdReg);
+		/* enable or disable promiscuous mode */
+		if (Enable) {
+			MdReg |= XM_MD_ENA_PROM;
+		}
+		else {
+			MdReg &= ~XM_MD_ENA_PROM;
+		}
+		/* setup Mode Register */
+		XM_OUT32(IoC, Port, XM_MODE, MdReg);
+	}
+	else {
+		
+		GM_IN16(IoC, Port, GM_RX_CTRL, &RcReg);
+		
+		/* enable or disable unicast and multicast filtering */
+		if (Enable) {
+			RcReg &= ~(GM_RXCR_UCF_ENA | GM_RXCR_MCF_ENA);
+		}
+		else {
+			RcReg |= (GM_RXCR_UCF_ENA | GM_RXCR_MCF_ENA);
+		}
+		/* setup Receive Control Register */
+		GM_OUT16(IoC, Port, GM_RX_CTRL, RcReg);
+	}
+}	/* SkMacPromiscMode*/
 
 
 /******************************************************************************
  *
- *	SkXmSoftRst() - Do a XMAC software reset
+ *	SkMacHashing() - Enable / Disable Hashing
  *
  * Description:
- *	The PHY registers should not be destroyed during this
- *	kind of software reset. Therefore the XMAC Software Reset
- *	(XM_GP_RES_MAC bit in XM_GP_PORT) must not be used!
- *
- *	The software reset is done by
- *		- disabling the Rx and Tx state maschine,
- *		- reseting the statistics module,
- *		- clear all other significant XMAC Mode,
- *		  Command, and Control Registers
- *		- clearing the Hash Register and the
- *		  Exact Match Address registers, and
- *		- flushing the XMAC's Rx and Tx FIFOs.
- *
- * Note:
- *	Another requirement when stopping the XMAC is to
- *	avoid sending corrupted frames on the network.
- *	Disabling the Tx state maschine will NOT interrupt
- *	the currently transmitted frame. But we must take care
- *	that the tx FIFO is cleared AFTER the current frame
- *	is complete sent to the network.
- *
- *	It takes about 12ns to send a frame with 1538 bytes.
- *	One PCI clock goes at least 15ns (66MHz). Therefore
- *	after reading XM_GP_PORT back, we are sure that the
- *	transmitter is disabled AND idle. And this means
- *	we may flush the transmit FIFO now.
+ *   enables / disables hashing by setting Mode Register (XMAC) or
+ *   Receive Control Register (GMAC) dep. on board type		
  *
  * Returns:
  *	nothing
  */
-void SkXmSoftRst(
+void SkMacHashing(
 SK_AC	*pAC,	/* adapter context */
 SK_IOC	IoC,	/* IO context */
-int		Port)	/* port to stop (MAC_1 + n) */
+int		Port,	/* Port Index (MAC_1 + n) */
+SK_BOOL	Enable)	/* Enable / Disable */
 {
-	SK_GEPORT	*pPrt;
-	SK_U16		Word;
-
-	pPrt = &pAC->GIni.GP[Port];
+	SK_U16	RcReg;
+	SK_U32	MdReg;
 
-	/* disable the receiver and transmitter */
-	XM_IN16(IoC, Port, XM_MMU_CMD, &Word);
-	XM_OUT16(IoC, Port, XM_MMU_CMD, Word & ~(XM_MMU_ENA_RX|XM_MMU_ENA_TX));
+	if (pAC->GIni.GIGenesis) {
+		
+		XM_IN32(IoC, Port, XM_MODE, &MdReg);
+		/* enable or disable hashing */
+		if (Enable) {
+			MdReg |= XM_MD_ENA_HASH;
+		}
+		else {
+			MdReg &= ~XM_MD_ENA_HASH;
+		}
+		/* setup Mode Register */
+		XM_OUT32(IoC, Port, XM_MODE, MdReg);
+	}
+	else {
+		
+		GM_IN16(IoC, Port, GM_RX_CTRL, &RcReg);
+		
+		/* enable or disable multicast filtering */
+		if (Enable) {
+			RcReg |= GM_RXCR_MCF_ENA;
+		}
+		else {
+			RcReg &= ~GM_RXCR_MCF_ENA;
+		}
+		/* setup Receive Control Register */
+		GM_OUT16(IoC, Port, GM_RX_CTRL, RcReg);
+	}
+}	/* SkMacHashing*/
 
-	/* reset the statistics module */
-	XM_OUT32(IoC, Port, XM_GP_PORT, XM_GP_RES_STAT);
 
-	/*
-	 * clear all other significant XMAC Mode,
-	 * Command, and Control Registers
-	 */
-	XM_OUT16(IoC, Port, XM_IMSK, 0xffff);		/* disable all IRQs */
-	XM_OUT32(IoC, Port, XM_MODE, 0x00000000);	/* clear Mode Reg */
-	XM_OUT16(IoC, Port, XM_TX_CMD, 0x0000);		/* reset TX CMD Reg */
-	XM_OUT16(IoC, Port, XM_RX_CMD, 0x0000);		/* reset RX CMD Reg */
-	
-	/* disable all PHY IRQs */
+#ifdef SK_DIAG
+/******************************************************************************
+ *
+ *	SkXmSetRxCmd() - Modify the value of the XMAC's Rx Command Register
+ *
+ * Description:
+ *	The features
+ *	 - FCS stripping,					SK_STRIP_FCS_ON/OFF
+ *	 - pad byte stripping,				SK_STRIP_PAD_ON/OFF
+ *	 - don't set XMR_FS_ERR in status	SK_LENERR_OK_ON/OFF
+ *	   for inrange length error frames
+ *	 - don't set XMR_FS_ERR in status	SK_BIG_PK_OK_ON/OFF
+ *	   for frames > 1514 bytes
+ *   - enable Rx of own packets         SK_SELF_RX_ON/OFF
+ *
+ *	for incoming packets may be enabled/disabled by this function.
+ *	Additional modes may be added later.
+ *	Multiple modes can be enabled/disabled at the same time.
+ *	The new configuration is written to the Rx Command register immediately.
+ *
+ * Returns:
+ *	nothing
+ */
+static void SkXmSetRxCmd(
+SK_AC	*pAC,		/* adapter context */
+SK_IOC	IoC,		/* IO context */
+int		Port,		/* Port Index (MAC_1 + n) */
+int		Mode)		/* Mode is SK_STRIP_FCS_ON/OFF, SK_STRIP_PAD_ON/OFF,
+					   SK_LENERR_OK_ON/OFF, or SK_BIG_PK_OK_ON/OFF */
+{
+	SK_U16	OldRxCmd;
+	SK_U16	RxCmd;
+
+	XM_IN16(IoC, Port, XM_RX_CMD, &OldRxCmd);
+
+	RxCmd = OldRxCmd;
+	
+	switch (Mode & (SK_STRIP_FCS_ON | SK_STRIP_FCS_OFF)) {
+	case SK_STRIP_FCS_ON:
+		RxCmd |= XM_RX_STRIP_FCS;
+		break;
+	case SK_STRIP_FCS_OFF:
+		RxCmd &= ~XM_RX_STRIP_FCS;
+		break;
+	}
+
+	switch (Mode & (SK_STRIP_PAD_ON | SK_STRIP_PAD_OFF)) {
+	case SK_STRIP_PAD_ON:
+		RxCmd |= XM_RX_STRIP_PAD;
+		break;
+	case SK_STRIP_PAD_OFF:
+		RxCmd &= ~XM_RX_STRIP_PAD;
+		break;
+	}
+
+	switch (Mode & (SK_LENERR_OK_ON | SK_LENERR_OK_OFF)) {
+	case SK_LENERR_OK_ON:
+		RxCmd |= XM_RX_LENERR_OK;
+		break;
+	case SK_LENERR_OK_OFF:
+		RxCmd &= ~XM_RX_LENERR_OK;
+		break;
+	}
+
+	switch (Mode & (SK_BIG_PK_OK_ON | SK_BIG_PK_OK_OFF)) {
+	case SK_BIG_PK_OK_ON:
+		RxCmd |= XM_RX_BIG_PK_OK;
+		break;
+	case SK_BIG_PK_OK_OFF:
+		RxCmd &= ~XM_RX_BIG_PK_OK;
+		break;
+	}
+
+	switch (Mode & (SK_SELF_RX_ON | SK_SELF_RX_OFF)) {
+	case SK_SELF_RX_ON:
+		RxCmd |= XM_RX_SELF_RX;
+		break;
+	case SK_SELF_RX_OFF:
+		RxCmd &= ~XM_RX_SELF_RX;
+		break;
+	}
+
+	/* Write the new mode to the Rx command register if required */
+	if (OldRxCmd != RxCmd) {
+		XM_OUT16(IoC, Port, XM_RX_CMD, RxCmd);
+	}
+}	/* SkXmSetRxCmd */
+
+
+/******************************************************************************
+ *
+ *	SkGmSetRxCmd() - Modify the value of the GMAC's Rx Control Register
+ *
+ * Description:
+ *	The features
+ *	 - FCS (CRC) stripping,				SK_STRIP_FCS_ON/OFF
+ *	 - don't set GMR_FS_LONG_ERR		SK_BIG_PK_OK_ON/OFF
+ *	   for frames > 1514 bytes
+ *   - enable Rx of own packets         SK_SELF_RX_ON/OFF
+ *
+ *	for incoming packets may be enabled/disabled by this function.
+ *	Additional modes may be added later.
+ *	Multiple modes can be enabled/disabled at the same time.
+ *	The new configuration is written to the Rx Command register immediately.
+ *
+ * Returns:
+ *	nothing
+ */
+static void SkGmSetRxCmd(
+SK_AC	*pAC,		/* adapter context */
+SK_IOC	IoC,		/* IO context */
+int		Port,		/* Port Index (MAC_1 + n) */
+int		Mode)		/* Mode is SK_STRIP_FCS_ON/OFF, SK_STRIP_PAD_ON/OFF,
+					   SK_LENERR_OK_ON/OFF, or SK_BIG_PK_OK_ON/OFF */
+{
+	SK_U16	OldRxCmd;
+	SK_U16	RxCmd;
+
+	if ((Mode & (SK_STRIP_FCS_ON | SK_STRIP_FCS_OFF)) != 0) {
+		
+		GM_IN16(IoC, Port, GM_RX_CTRL, &OldRxCmd);
+
+		RxCmd = OldRxCmd;
+
+		if ((Mode & SK_STRIP_FCS_ON) != 0) {
+			RxCmd |= GM_RXCR_CRC_DIS;
+		}
+		else {
+			RxCmd &= ~GM_RXCR_CRC_DIS;
+		}
+		/* Write the new mode to the Rx control register if required */
+		if (OldRxCmd != RxCmd) {
+			GM_OUT16(IoC, Port, GM_RX_CTRL, RxCmd);
+		}
+	}
+
+	if ((Mode & (SK_BIG_PK_OK_ON | SK_BIG_PK_OK_OFF)) != 0) {
+		
+		GM_IN16(IoC, Port, GM_SERIAL_MODE, &OldRxCmd);
+
+		RxCmd = OldRxCmd;
+
+		if ((Mode & SK_BIG_PK_OK_ON) != 0) {
+			RxCmd |= GM_SMOD_JUMBO_ENA;
+		}
+		else {
+			RxCmd &= ~GM_SMOD_JUMBO_ENA;
+		}
+		/* Write the new mode to the Rx control register if required */
+		if (OldRxCmd != RxCmd) {
+			GM_OUT16(IoC, Port, GM_SERIAL_MODE, RxCmd);
+		}
+	}
+}	/* SkGmSetRxCmd */
+
+
+/******************************************************************************
+ *
+ *	SkMacSetRxCmd() - Modify the value of the MAC's Rx Control Register
+ *
+ * Description:	modifies the MAC's Rx Control reg. dep. on board type
+ *
+ * Returns:
+ *	nothing
+ */
+void SkMacSetRxCmd(
+SK_AC	*pAC,		/* adapter context */
+SK_IOC	IoC,		/* IO context */
+int		Port,		/* Port Index (MAC_1 + n) */
+int		Mode)		/* Rx Mode */
+{
+	if (pAC->GIni.GIGenesis) {
+		
+		SkXmSetRxCmd(pAC, IoC, Port, Mode);
+	}
+	else {
+		
+		SkGmSetRxCmd(pAC, IoC, Port, Mode);
+	}
+}	/* SkMacSetRxCmd */
+
+
+/******************************************************************************
+ *
+ *	SkMacCrcGener() - Enable / Disable CRC Generation
+ *
+ * Description:	enables / disables CRC generation dep. on board type
+ *
+ * Returns:
+ *	nothing
+ */
+void SkMacCrcGener(
+SK_AC	*pAC,	/* adapter context */
+SK_IOC	IoC,	/* IO context */
+int		Port,	/* Port Index (MAC_1 + n) */
+SK_BOOL	Enable)	/* Enable / Disable */
+{
+	SK_U16	Word;
+
+	if (pAC->GIni.GIGenesis) {
+		
+		XM_IN16(IoC, Port, XM_TX_CMD, &Word);
+
+		if (Enable) {
+			Word &= ~XM_TX_NO_CRC;
+		}
+		else {
+			Word |= XM_TX_NO_CRC;
+		}
+		/* setup Tx Command Register */
+		XM_OUT16(IoC, Port, XM_TX_CMD, Word);
+	}
+	else {
+		
+		GM_IN16(IoC, Port, GM_TX_CTRL, &Word);
+		
+		if (Enable) {
+			Word &= ~GM_TXCR_CRC_DIS;
+		}
+		else {
+			Word |= GM_TXCR_CRC_DIS;
+		}
+		/* setup Tx Control Register */
+		GM_OUT16(IoC, Port, GM_TX_CTRL, Word);
+	}
+}	/* SkMacCrcGener*/
+
+#endif /* SK_DIAG */
+
+
+/******************************************************************************
+ *
+ *	SkXmClrExactAddr() - Clear Exact Match Address Registers
+ *
+ * Description:
+ *	All Exact Match Address registers of the XMAC 'Port' will be
+ *	cleared starting with 'StartNum' up to (and including) the
+ *	Exact Match address number of 'StopNum'.
+ *
+ * Returns:
+ *	nothing
+ */
+void SkXmClrExactAddr(
+SK_AC	*pAC,		/* adapter context */
+SK_IOC	IoC,		/* IO context */
+int		Port,		/* Port Index (MAC_1 + n) */
+int		StartNum,	/* Begin with this Address Register Index (0..15) */
+int		StopNum)	/* Stop after finished with this Register Idx (0..15) */
+{
+	int		i;
+	SK_U16	ZeroAddr[3] = {0x0000, 0x0000, 0x0000};
+
+	if ((unsigned)StartNum > 15 || (unsigned)StopNum > 15 ||
+		StartNum > StopNum) {
+
+		SK_ERR_LOG(pAC, SK_ERRCL_SW, SKERR_HWI_E001, SKERR_HWI_E001MSG);
+		return;
+	}
+
+	for (i = StartNum; i <= StopNum; i++) {
+		XM_OUTADDR(IoC, Port, XM_EXM(i), &ZeroAddr[0]);
+	}
+}	/* SkXmClrExactAddr */
+
+
+/******************************************************************************
+ *
+ *	SkMacFlushTxFifo() - Flush the MAC's transmit FIFO
+ *
+ * Description:
+ *	Flush the transmit FIFO of the MAC specified by the index 'Port'
+ *
+ * Returns:
+ *	nothing
+ */
+void SkMacFlushTxFifo(
+SK_AC	*pAC,	/* adapter context */
+SK_IOC	IoC,	/* IO context */
+int		Port)	/* Port Index (MAC_1 + n) */
+{
+	SK_U32	MdReg;
+
+	if (pAC->GIni.GIGenesis) {
+		
+		XM_IN32(IoC, Port, XM_MODE, &MdReg);
+
+		XM_OUT32(IoC, Port, XM_MODE, MdReg | XM_MD_FTF);
+	}
+	else {
+		/* no way to flush the FIFO we have to issue a reset */
+		/* TBD */
+	}
+}	/* SkMacFlushTxFifo */
+
+
+/******************************************************************************
+ *
+ *	SkMacFlushRxFifo() - Flush the MAC's receive FIFO
+ *
+ * Description:
+ *	Flush the receive FIFO of the MAC specified by the index 'Port'
+ *
+ * Returns:
+ *	nothing
+ */
+void SkMacFlushRxFifo(
+SK_AC	*pAC,	/* adapter context */
+SK_IOC	IoC,	/* IO context */
+int		Port)	/* Port Index (MAC_1 + n) */
+{
+	SK_U32	MdReg;
+
+	if (pAC->GIni.GIGenesis) {
+
+		XM_IN32(IoC, Port, XM_MODE, &MdReg);
+
+		XM_OUT32(IoC, Port, XM_MODE, MdReg | XM_MD_FRF);
+	}
+	else {
+		/* no way to flush the FIFO we have to issue a reset */
+		/* TBD */
+	}
+}	/* SkMacFlushRxFifo */
+
+
+/******************************************************************************
+ *
+ *	SkXmSoftRst() - Do a XMAC software reset
+ *
+ * Description:
+ *	The PHY registers should not be destroyed during this
+ *	kind of software reset. Therefore the XMAC Software Reset
+ *	(XM_GP_RES_MAC bit in XM_GP_PORT) must not be used!
+ *
+ *	The software reset is done by
+ *		- disabling the Rx and Tx state machine,
+ *		- resetting the statistics module,
+ *		- clear all other significant XMAC Mode,
+ *		  Command, and Control Registers
+ *		- clearing the Hash Register and the
+ *		  Exact Match Address registers, and
+ *		- flushing the XMAC's Rx and Tx FIFOs.
+ *
+ * Note:
+ *	Another requirement when stopping the XMAC is to
+ *	avoid sending corrupted frames on the network.
+ *	Disabling the Tx state machine will NOT interrupt
+ *	the currently transmitted frame. But we must take care
+ *	that the Tx FIFO is cleared AFTER the current frame
+ *	is complete sent to the network.
+ *
+ *	It takes about 12ns to send a frame with 1538 bytes.
+ *	One PCI clock goes at least 15ns (66MHz). Therefore
+ *	after reading XM_GP_PORT back, we are sure that the
+ *	transmitter is disabled AND idle. And this means
+ *	we may flush the transmit FIFO now.
+ *
+ * Returns:
+ *	nothing
+ */
+static void SkXmSoftRst(
+SK_AC	*pAC,	/* adapter context */
+SK_IOC	IoC,	/* IO context */
+int		Port)	/* Port Index (MAC_1 + n) */
+{
+	SK_U16	ZeroAddr[4] = {0x0000, 0x0000, 0x0000, 0x0000};
+	
+	/* reset the statistics module */
+	XM_OUT32(IoC, Port, XM_GP_PORT, XM_GP_RES_STAT);
+
+	/* disable all XMAC IRQs */
+	XM_OUT16(IoC, Port, XM_IMSK, 0xffff);
+	
+	XM_OUT32(IoC, Port, XM_MODE, 0);		/* clear Mode Reg */
+	
+	XM_OUT16(IoC, Port, XM_TX_CMD, 0);		/* reset TX CMD Reg */
+	XM_OUT16(IoC, Port, XM_RX_CMD, 0);		/* reset RX CMD Reg */
+	
+	/* disable all PHY IRQs */
 	switch (pAC->GIni.GP[Port].PhyType) {
 	case SK_PHY_BCOM:
-			PHY_WRITE(IoC, pPrt, Port, PHY_BCOM_INT_MASK, 0xffff);
+			SkXmPhyWrite(pAC, IoC, Port, PHY_BCOM_INT_MASK, 0xffff);
 			break;
+#ifdef OTHER_PHY
 		case SK_PHY_LONE:
-			PHY_WRITE(IoC, pPrt, Port, PHY_LONE_INT_ENAB, 0x0);
+			SkXmPhyWrite(pAC, IoC, Port, PHY_LONE_INT_ENAB, 0);
 			break;
 		case SK_PHY_NAT:
 			/* todo: National
-			 PHY_WRITE(IoC, pPrt, Port, PHY_NAT_INT_MASK, 
-				0xffff); */
+			 SkXmPhyWrite(pAC, IoC, Port, PHY_NAT_INT_MASK, 0xffff); */
 			break;
+#endif /* OTHER_PHY */
 	}
 
 	/* clear the Hash Register */
-	SkXmClrHashAddr(pAC, IoC, Port);
+	XM_OUTHASH(IoC, Port, XM_HSM, &ZeroAddr);
 
 	/* clear the Exact Match Address registers */
 	SkXmClrExactAddr(pAC, IoC, Port, 0, 15);
-	SkXmClrSrcCheck(pAC, IoC, Port);
-
-	/* flush the XMAC's Rx and Tx FIFOs */
-	SkXmFlushTxFifo(pAC, IoC, Port);
-	SkXmFlushRxFifo(pAC, IoC, Port);
+	
+	/* clear the Source Check Address registers */
+	XM_OUTHASH(IoC, Port, XM_SRC_CHK, &ZeroAddr);
 
-	pAC->GIni.GP[Port].PState = SK_PRT_STOP;
-}	/* SkXmSoftRst*/
+}	/* SkXmSoftRst */
 
 
 /******************************************************************************
@@ -589,23 +1262,21 @@
  *
  * Description:
  *	The XMAC of the specified 'Port' and all connected devices
- *	(PHY and SERDES) will receive a reset signal on its *Reset
- *	pins.
- *	External PHYs must be reset be clearing a bit in the GPIO
- *	register (Timing requirements: Broadcom: 400ns, Level One:
- *	none, National: 80ns).
+ *	(PHY and SERDES) will receive a reset signal on its *Reset pins.
+ *	External PHYs must be reset be clearing a bit in the GPIO register
+ *  (Timing requirements: Broadcom: 400ns, Level One: none, National: 80ns).
  *
  * ATTENTION:
- * 	It is absolutely neccessary to reset the SW_RST Bit first
+ * 	It is absolutely necessary to reset the SW_RST Bit first
  *	before calling this function.
  *
  * Returns:
  *	nothing
  */
-void SkXmHardRst(
+static void SkXmHardRst(
 SK_AC	*pAC,	/* adapter context */
 SK_IOC	IoC,	/* IO context */
-int		Port)	/* port to stop (MAC_1 + n) */
+int		Port)	/* Port Index (MAC_1 + n) */
 {
 	SK_U32	Reg;
 	int		i;
@@ -613,14 +1284,12 @@
 	SK_U16	Word;
 
 	for (i = 0; i < 4; i++) {
-		/* TX_MFF_CTRL1 is a 32 bit register but only the lowest 16 */
-		/* bit contains buttoms to press */
-		SK_OUT16(IoC, MR_ADDR(Port, TX_MFF_CTRL1), (SK_U16)MFF_CLR_MAC_RST);
+		/* TX_MFF_CTRL1 has 32 bits, but only the lowest 16 bits are used */
+		SK_OUT16(IoC, MR_ADDR(Port, TX_MFF_CTRL1), MFF_CLR_MAC_RST);
 
 		TOut = 0;
 		do {
-			TOut ++;
-			if (TOut > 10000) {
+			if (TOut++ > 10000) {
 				/*
 				 * Adapter seems to be in RESET state.
 				 * Registers cannot be written.
@@ -628,9 +1297,10 @@
 				return;
 			}
 
-			SK_OUT16(IoC, MR_ADDR(Port, TX_MFF_CTRL1),
-				(SK_U16) MFF_SET_MAC_RST);
-			SK_IN16(IoC,MR_ADDR(Port,TX_MFF_CTRL1), &Word);
+			SK_OUT16(IoC, MR_ADDR(Port, TX_MFF_CTRL1), MFF_SET_MAC_RST);
+			
+			SK_IN16(IoC, MR_ADDR(Port, TX_MFF_CTRL1), &Word);
+		
 		} while ((Word & MFF_SET_MAC_RST) == 0);
 	}
 
@@ -652,16 +1322,151 @@
 		SK_IN32(IoC, B2_GP_IO, &Reg);
 	}
 
-	pAC->GIni.GP[Port].PState = SK_PRT_RESET;
 }	/* SkXmHardRst */
 
 
 /******************************************************************************
  *
+ *	SkGmSoftRst() - Do a GMAC software reset
+ *
+ * Description:
+ *	The GPHY registers should not be destroyed during this
+ *	kind of software reset.
+ *
+ * Returns:
+ *	nothing
+ */
+static void SkGmSoftRst(
+SK_AC	*pAC,	/* adapter context */
+SK_IOC	IoC,	/* IO context */
+int		Port)	/* Port Index (MAC_1 + n) */
+{
+	SK_U16	EmptyHash[4] = {0x0000, 0x0000, 0x0000, 0x0000};
+	SK_U16  RxCtrl;
+
+	/* reset the statistics module */
+
+	/* disable all GMAC IRQs */
+	SK_OUT8(IoC, GMAC_IRQ_MSK, 0);
+	
+	/* disable all PHY IRQs */
+	SkGmPhyWrite(pAC, IoC, Port, PHY_MARV_INT_MASK, 0);
+	
+	/* clear the Hash Register */
+	GM_OUTHASH(IoC, Port, GM_MC_ADDR_H1, EmptyHash);
+
+	/* Enable Unicast and Multicast filtering */
+	GM_IN16(IoC, Port, GM_RX_CTRL, &RxCtrl);
+	
+	GM_OUT16(IoC, Port, GM_RX_CTRL,
+		RxCtrl | GM_RXCR_UCF_ENA | GM_RXCR_MCF_ENA);
+
+}	/* SkGmSoftRst */
+
+
+/******************************************************************************
+ *
+ *	SkGmHardRst() - Do a GMAC hardware reset
+ *
+ * Description:
+ *
+ * ATTENTION:
+ * 	It is absolutely necessary to reset the SW_RST Bit first
+ *	before calling this function.
+ *
+ * Returns:
+ *	nothing
+ */
+static void SkGmHardRst(
+SK_AC	*pAC,	/* adapter context */
+SK_IOC	IoC,	/* IO context */
+int		Port)	/* Port Index (MAC_1 + n) */
+{
+	/* set GPHY Control reset */
+	SK_OUT32(IoC, MR_ADDR(Port, GPHY_CTRL), GPC_RST_SET);
+
+	/* set GMAC Control reset */
+	SK_OUT32(IoC, MR_ADDR(Port, GMAC_CTRL), GMC_RST_SET);
+
+}	/* SkGmHardRst */
+
+
+/******************************************************************************
+ *
+ *	SkMacSoftRst() - Do a MAC software reset
+ *
+ * Description:	calls a MAC software reset routine dep. on board type
+ *
+ * Returns:
+ *	nothing
+ */
+void SkMacSoftRst(
+SK_AC	*pAC,	/* adapter context */
+SK_IOC	IoC,	/* IO context */
+int		Port)	/* Port Index (MAC_1 + n) */
+{
+	SK_GEPORT	*pPrt;
+
+	pPrt = &pAC->GIni.GP[Port];
+
+	/* disable receiver and transmitter */
+	SkMacRxTxDisable(pAC, IoC, Port);
+
+	if (pAC->GIni.GIGenesis) {
+		
+		SkXmSoftRst(pAC, IoC, Port);
+	}
+	else {
+		
+		SkGmSoftRst(pAC, IoC, Port);
+	}
+
+	/* flush the MAC's Rx and Tx FIFOs */
+	SkMacFlushTxFifo(pAC, IoC, Port);
+	
+	SkMacFlushRxFifo(pAC, IoC, Port);
+
+	pPrt->PState = SK_PRT_STOP;
+
+}	/* SkMacSoftRst */
+
+
+/******************************************************************************
+ *
+ *	SkMacHardRst() - Do a MAC hardware reset
+ *
+ * Description:	calls a MAC hardware reset routine dep. on board type
+ *
+ * Returns:
+ *	nothing
+ */
+void SkMacHardRst(
+SK_AC	*pAC,	/* adapter context */
+SK_IOC	IoC,	/* IO context */
+int		Port)	/* Port Index (MAC_1 + n) */
+{
+	
+	if (pAC->GIni.GIGenesis) {
+		
+		SkXmHardRst(pAC, IoC, Port);
+	}
+	else {
+		
+		SkGmHardRst(pAC, IoC, Port);
+	}
+
+	pAC->GIni.GP[Port].PState = SK_PRT_RESET;
+
+}	/* SkMacHardRst */
+
+
+
+/******************************************************************************
+ *
  *	SkXmInitMac() - Initialize the XMAC II
  *
  * Description:
- *	Initialize all the XMAC of the specified port.
+ *	Initialize the XMAC of the specified port.
  *	The XMAC must be reset or stopped before calling this function.
  *
  * Note:
@@ -679,7 +1484,6 @@
 	SK_U32		Reg;
 	int			i;
 	SK_U16		SWord;
-	SK_U16		PhyId;
 
 	pPrt = &pAC->GIni.GP[Port];
 
@@ -687,10 +1491,11 @@
 		/* Port State: SK_PRT_STOP */
 		/* Verify that the reset bit is cleared */
 		SK_IN16(IoC, MR_ADDR(Port, TX_MFF_CTRL1), &SWord);
-		if (SWord & (SK_U16)MFF_SET_MAC_RST) {
+
+		if ((SWord & MFF_SET_MAC_RST) != 0) {
 			/* PState does not match HW state */
 			SK_ERR_LOG(pAC, SK_ERRCL_SW, SKERR_HWI_E006, SKERR_HWI_E006MSG);
-			/* Correct it. */
+			/* Correct it */
 			pPrt->PState = SK_PRT_RESET;
 		}
 	}
@@ -701,220 +1506,415 @@
 		 * Note: The SW reset is self clearing, therefore there is
 		 *	 nothing to do here.
 		 */
-		SK_OUT16(IoC, MR_ADDR(Port, TX_MFF_CTRL1), (SK_U16)MFF_CLR_MAC_RST);
+		SK_OUT16(IoC, MR_ADDR(Port, TX_MFF_CTRL1), MFF_CLR_MAC_RST);
 
-		/* Ensure that XMAC reset release is done (errata from LReinbold?). */
+		/* Ensure that XMAC reset release is done (errata from LReinbold?) */
 		SK_IN16(IoC, MR_ADDR(Port, TX_MFF_CTRL1), &SWord);
 
-		/* Clear PHY reset. */
-		if (pAC->GIni.GP[Port].PhyType != SK_PHY_XMAC) {
+		/* Clear PHY reset */
+		if (pPrt->PhyType != SK_PHY_XMAC) {
+
 			SK_IN32(IoC, B2_GP_IO, &Reg);
+			
 			if (Port == 0) {
-				Reg |= GP_DIR_0; /* Set to output. */
-				Reg |= GP_IO_0;
+				Reg |= (GP_DIR_0 | GP_IO_0); /* set to output */
 			}
 			else {
-				Reg |= GP_DIR_2; /* Set to output. */
-				Reg |= GP_IO_2;
+				Reg |= (GP_DIR_2 | GP_IO_2); /* set to output */
 			}
 			SK_OUT32(IoC, B2_GP_IO, Reg);
 
-			/* Enable GMII interface. */
+			/* Enable GMII interface */
 			XM_OUT16(IoC, Port, XM_HW_CFG, XM_HW_GMII_MD);
 
-			PHY_READ(IoC, pPrt, Port, PHY_XMAC_ID1, &PhyId);
-#ifdef xDEBUG
-			if (SWord == 0xFFFF) {
-				i = 1;
-				do {
-					PHY_READ(IoC, pPrt, Port, PHY_XMAC_ID1, &SWord);
-					i++;
-					/* Limit retries; else machine may hang. */
-				} while (SWord == 0xFFFF && i < 500000);
-
-				CMSMPrintString(
-					pAC->pConfigTable,
-					MSG_TYPE_RUNTIME_INFO,
-					"ID1 is %x after %d reads.",
-					(void *)SWord,
-					(void *)i);
-
-				/* Trigger PCI analyzer */
-				/* SK_IN32(IoC, 0x012c, &Reg); */
-			}
-#endif	/* DEBUG */
+			/* read Id from external PHY (all have the same address) */
+			SkXmPhyRead(pAC, IoC, Port, PHY_XMAC_ID1, &pPrt->PhyId1);
 
 			/*
 			 * Optimize MDIO transfer by suppressing preamble.
 			 * Must be done AFTER first access to BCOM chip.
 			 */
 			XM_IN16(IoC, Port, XM_MMU_CMD, &SWord);
+			
 			XM_OUT16(IoC, Port, XM_MMU_CMD, SWord | XM_MMU_NO_PRE);
 
-			if (PhyId == 0x6044) {
-				/* Workaround BCOM Errata for the C0 type. */
-				/* Write magic patterns to reserved registers. */
+			if (pPrt->PhyId1 == PHY_BCOM_ID1_C0) {
+				/*
+				 * Workaround BCOM Errata for the C0 type.
+				 * Write magic patterns to reserved registers.
+				 */
 				i = 0;
 				while (BcomRegC0Hack[i].PhyReg != 0) {
-					PHY_WRITE(IoC, pPrt, Port, BcomRegC0Hack[i].PhyReg,
+					SkXmPhyWrite(pAC, IoC, Port, BcomRegC0Hack[i].PhyReg,
 						BcomRegC0Hack[i].PhyVal);
 					i++;
 				}
 			}
-			else if (PhyId == 0x6041) {
-				/* Workaround BCOM Errata for the A1 type. */
-				/* Write magic patterns to reserved registers. */
+			else if (pPrt->PhyId1 == PHY_BCOM_ID1_A1) {
+				/*
+				 * Workaround BCOM Errata for the A1 type.
+				 * Write magic patterns to reserved registers.
+				 */
 				i = 0;
 				while (BcomRegA1Hack[i].PhyReg != 0) {
-					PHY_WRITE(IoC, pPrt, Port, BcomRegA1Hack[i].PhyReg,
+					SkXmPhyWrite(pAC, IoC, Port, BcomRegA1Hack[i].PhyReg,
 						BcomRegA1Hack[i].PhyVal);
 					i++;
 				}
 			}
 
-			/* Workaround BCOM Errata (#10523) for all BCom PHYs. */
-			/* Disable Power Management after reset. */
-			PHY_READ(IoC, pPrt, Port, PHY_BCOM_AUX_CTRL, &SWord);
-#ifdef xDEBUG
-			if (SWord == 0xFFFF) {
-				i = 1;
-				do {
-					PHY_READ(IoC, pPrt, Port, PHY_BCOM_AUX_CTRL, &SWord);
-					i++;
-					/* Limit retries; else machine may hang. */
-				} while (SWord == 0xFFFF && i < 500000);
+			/*
+			 * Workaround BCOM Errata (#10523) for all BCom PHYs.
+			 * Disable Power Management after reset.
+			 */
+			SkXmPhyRead(pAC, IoC, Port, PHY_BCOM_AUX_CTRL, &SWord);
+			
+			SkXmPhyWrite(pAC, IoC, Port, PHY_BCOM_AUX_CTRL,
+				(SK_U16)(SWord | PHY_B_AC_DIS_PM));
+
+			/* PHY LED initialization is done in SkGeXmitLED() */
+		}
+
+		/* Dummy read the Interrupt source register */
+		XM_IN16(IoC, Port, XM_ISRC, &SWord);
+		
+		/*
+		 * The auto-negotiation process starts immediately after
+		 * clearing the reset. The auto-negotiation process should be
+		 * started by the SIRQ, therefore stop it here immediately.
+		 */
+		SkMacInitPhy(pAC, IoC, Port, SK_FALSE);
+
+#ifdef TEST_ONLY
+		/* temp. code: enable signal detect */
+		/* WARNING: do not override GMII setting above */
+		XM_OUT16(IoC, Port, XM_HW_CFG, XM_HW_COM4SIG);
+#endif
+	}
+
+	/*
+	 * configure the XMACs Station Address
+	 * B2_MAC_2 = xx xx xx xx xx x1 is programmed to XMAC A
+	 * B2_MAC_3 = xx xx xx xx xx x2 is programmed to XMAC B
+	 */
+	for (i = 0; i < 3; i++) {
+		/*
+		 * The following 2 statements are together endianess
+		 * independent. Remember this when changing.
+		 */
+		SK_IN16(IoC, (B2_MAC_2 + Port * 8 + i * 2), &SWord);
+		
+		XM_OUT16(IoC, Port, (XM_SA + i * 2), SWord);
+	}
+
+	/* Tx Inter Packet Gap (XM_TX_IPG):	use default */
+	/* Tx High Water Mark (XM_TX_HI_WM):	use default */
+	/* Tx Low Water Mark (XM_TX_LO_WM):	use default */
+	/* Host Request Threshold (XM_HT_THR):	use default */
+	/* Rx Request Threshold (XM_RX_THR):	use default */
+	/* Rx Low Water Mark (XM_RX_LO_WM):	use default */
+
+	/* configure Rx High Water Mark (XM_RX_HI_WM) */
+	XM_OUT16(IoC, Port, XM_RX_HI_WM, SK_XM_RX_HI_WM);
+
+	/* Configure Tx Request Threshold */
+	SWord = SK_XM_THR_SL;				/* for single port */
+
+	if (pAC->GIni.GIMacsFound > 1) {
+		switch (pAC->GIni.GIPortUsage) {
+		case SK_RED_LINK:
+			SWord = SK_XM_THR_REDL;		/* redundant link */
+			break;
+		case SK_MUL_LINK:
+			SWord = SK_XM_THR_MULL;		/* load balancing */
+			break;
+		case SK_JUMBO_LINK:
+			SWord = SK_XM_THR_JUMBO;	/* jumbo frames */
+			break;
+		default:
+			SK_ERR_LOG(pAC, SK_ERRCL_SW, SKERR_HWI_E014, SKERR_HWI_E014MSG);
+			break;
+		}
+	}
+	XM_OUT16(IoC, Port, XM_TX_THR, SWord);
+
+	/* setup register defaults for the Tx Command Register */
+	XM_OUT16(IoC, Port, XM_TX_CMD, XM_TX_AUTO_PAD);
+
+	/* setup register defaults for the Rx Command Register */
+	SWord = XM_RX_STRIP_FCS | XM_RX_LENERR_OK;
+
+	if (pAC->GIni.GIPortUsage == SK_JUMBO_LINK) {
+		SWord |= XM_RX_BIG_PK_OK;
+	}
+
+	if (pPrt->PLinkModeConf == SK_LMODE_HALF) {
+		/*
+		 * If in manual half duplex mode the other side might be in
+		 * full duplex mode, so ignore if a carrier extension is not seen
+		 * on frames received
+		 */
+		SWord |= XM_RX_DIS_CEXT;
+	}
+	
+	XM_OUT16(IoC, Port, XM_RX_CMD, SWord);
+
+	/*
+	 * setup register defaults for the Mode Register
+	 *	- Don't strip error frames to avoid Store & Forward
+	 *	  on the Rx side.
+	 *	- Enable 'Check Station Address' bit
+	 *	- Enable 'Check Address Array' bit
+	 */
+	XM_OUT32(IoC, Port, XM_MODE, XM_DEF_MODE);
+
+	/*
+	 * Initialize the Receive Counter Event Mask (XM_RX_EV_MSK)
+	 *	- Enable all bits excepting 'Octets Rx OK Low CntOv'
+	 *	  and 'Octets Rx OK Hi Cnt Ov'.
+	 */
+	XM_OUT32(IoC, Port, XM_RX_EV_MSK, XMR_DEF_MSK);
+
+	/*
+	 * Initialize the Transmit Counter Event Mask (XM_TX_EV_MSK)
+	 *	- Enable all bits excepting 'Octets Tx OK Low CntOv'
+	 *	  and 'Octets Tx OK Hi Cnt Ov'.
+	 */
+	XM_OUT32(IoC, Port, XM_TX_EV_MSK, XMT_DEF_MSK);
+
+	/*
+	 * Do NOT init XMAC interrupt mask here.
+	 * All interrupts remain disable until link comes up!
+	 */
+
+	/*
+	 * Any additional configuration changes may be done now.
+	 * The last action is to enable the Rx and Tx state machine.
+	 * This should be done after the auto-negotiation process
+	 * has been completed successfully.
+	 */
+}	/* SkXmInitMac */
+
+/******************************************************************************
+ *
+ *	SkGmInitMac() - Initialize the GMAC
+ *
+ * Description:
+ *	Initialize the GMAC of the specified port.
+ *	The GMAC must be reset or stopped before calling this function.
+ *
+ * Note:
+ *	The GMAC's Rx and Tx state machine is still disabled when returning.
+ *
+ * Returns:
+ *	nothing
+ */
+void SkGmInitMac(
+SK_AC	*pAC,		/* adapter context */
+SK_IOC	IoC,		/* IO context */
+int		Port)		/* Port Index (MAC_1 + n) */
+{
+	SK_GEPORT	*pPrt;
+	int			i;
+	SK_U16		SWord;
+	SK_U32		DWord;
+
+	pPrt = &pAC->GIni.GP[Port];
+
+	if (pPrt->PState == SK_PRT_STOP) {
+		/* Port State: SK_PRT_STOP */
+		/* Verify that the reset bit is cleared */
+		SK_IN32(IoC, MR_ADDR(Port, GMAC_CTRL), &DWord);
+		
+		if ((DWord & GMC_RST_SET) != 0) {
+			/* PState does not match HW state */
+			SK_ERR_LOG(pAC, SK_ERRCL_SW, SKERR_HWI_E006, SKERR_HWI_E006MSG);
+			/* Correct it */
+			pPrt->PState = SK_PRT_RESET;
+		}
+	}
+
+	if (pPrt->PState == SK_PRT_RESET) {
+		/* set GPHY Control reset */
+		SK_OUT32(IoC, MR_ADDR(Port, GPHY_CTRL), GPC_RST_SET);
+
+		/* set GMAC Control reset */
+		SK_OUT32(IoC, MR_ADDR(Port, GMAC_CTRL), GMC_RST_SET);
+
+		/* clear GMAC Control reset */
+		SK_OUT32(IoC, MR_ADDR(Port, GMAC_CTRL), GMC_RST_CLR);
+
+		/* set GMAC Control reset */
+		SK_OUT32(IoC, MR_ADDR(Port, GMAC_CTRL), GMC_RST_SET);
+
+		/* set HWCFG_MODE */
+		DWord = GPC_INT_POL_HI | GPC_DIS_FC | GPC_DIS_SLEEP |
+			GPC_ENA_XC | GPC_ANEG_ADV_ALL_M | GPC_ENA_PAUSE |
+			(pAC->GIni.GICopperType ? GPC_HWCFG_GMII_COP :
+			GPC_HWCFG_GMII_FIB);
+
+		/* set GPHY Control reset */
+		SK_OUT32(IoC, MR_ADDR(Port, GPHY_CTRL), DWord | GPC_RST_SET);
+
+		/* release GPHY Control reset */
+		SK_OUT32(IoC, MR_ADDR(Port, GPHY_CTRL), DWord | GPC_RST_CLR);
+
+		/* clear GMAC Control reset */
+		SK_OUT32(IoC, MR_ADDR(Port, GMAC_CTRL), GMC_PAUSE_ON | GMC_RST_CLR);
+
+		SWord = 0;
+
+		/* speed settings */
+		switch (pPrt->PLinkSpeed) {
+		case SK_LSPEED_AUTO:
+		case SK_LSPEED_1000MBPS:
+			SWord |= GM_GPCR_SPEED_1000 | GM_GPCR_SPEED_100;
+			break;
+		case SK_LSPEED_100MBPS:
+			SWord |= GM_GPCR_SPEED_100;
+			break;
+		case SK_LSPEED_10MBPS:
+			break;
+		}
+
+		/* duplex settings */
+		if (pPrt->PLinkMode != SK_LMODE_HALF) {
+			/* set full duplex */
+			SWord |= GM_GPCR_DUP_FULL;
+		}
 
-				CMSMPrintString(
-					pAC->pConfigTable,
-					MSG_TYPE_RUNTIME_INFO,
-					"AUX_CTRL is %x after %d reads.",
-					(void *)SWord,
-					(void *)i);
+		switch (pPrt->PFlowCtrlMode) {
+		case SK_FLOW_MODE_NONE:
+			/* disable Tx & Rx flow-control */
+			SWord |= GM_GPCR_FC_TX_DIS | GM_GPCR_FC_RX_DIS | GM_GPCR_AU_FCT_DIS;
+			break;
+		case SK_FLOW_MODE_LOC_SEND:
+			/* disable Rx flow-control */
+			SWord |= GM_GPCR_FC_RX_DIS | GM_GPCR_AU_FCT_DIS;
+			break;
+		case SK_FLOW_MODE_SYMMETRIC:
+		case SK_FLOW_MODE_SYM_OR_REM:
+			/* enable Tx & Rx flow-control */
+			break;
+		}
 
-				/* Trigger PCI analyzer */
-				/* SK_IN32(IoC, 0x012c, &Reg); */
-			}
-#endif	/* DEBUG */
-			PHY_WRITE(IoC, pPrt, Port, PHY_BCOM_AUX_CTRL,
-				SWord | PHY_B_AC_DIS_PM);
+		/* Auto-negotiation ? */
+		if (pPrt->PLinkMode == SK_LMODE_HALF || pPrt->PLinkMode == SK_LMODE_FULL) {
+			/* Auto-negotiation disabled */
 
-			/* PHY LED initialization is done in SkGeXmitLED(), not here. */
+			/* disable auto-update for speed, duplex and flow-control */
+			SWord |= GM_GPCR_AU_ALL_DIS;
 		}
 
-		/* Dummy read the Interrupt source register */
-		XM_IN16(IoC, Port, XM_ISRC, &SWord);
-		
-		/*
-		 * The autonegotiation process starts immediately after
-		 * clearing the reset. The autonegotiation process should be
-		 * started by the SIRQ, therefore stop it here immediately.
-		 */
-		SkXmInitPhy(pAC, IoC, Port, SK_FALSE);
+		/* setup General Purpose Control Register */
+		GM_OUT16(IoC, Port, GM_GP_CTRL, SWord);
 
-#if 0
-		/* temp. code: enable signal detect */
-		/* WARNING: do not override GMII setting above */
-		XM_OUT16(pAC, Port, XM_HW_CFG, XM_HW_COM4SIG);
-#endif
+		/* dummy read the Interrupt Source Register */
+		SK_IN16(IoC, GMAC_IRQ_SRC, &SWord);
+		
+#ifndef VCPU
+		/* read Id from PHY */
+		SkGmPhyRead(pAC, IoC, Port, PHY_MARV_ID1, &pPrt->PhyId1);
+		
+		SkGmInitPhyMarv(pAC, IoC, Port, SK_FALSE);
+#endif /* VCPU */
 	}
 
+	(void)SkGmResetCounter(pAC, IoC, Port);
+
+	/* setup Transmit Control Register */
+	GM_OUT16(IoC, Port, GM_TX_CTRL, GM_TXCR_COL_THR);
+
+	/* setup Receive Control Register */
+	GM_OUT16(IoC, Port, GM_RX_CTRL, GM_RXCR_UCF_ENA | GM_RXCR_MCF_ENA |
+		GM_RXCR_CRC_DIS);
+
+	/* setup Transmit Flow Control Register */
+	GM_OUT16(IoC, Port, GM_TX_FLOW_CTRL, 0xffff);
+
+	/* setup Transmit Parameter Register */
+#ifdef VCPU
+	GM_IN16(IoC, Port, GM_TX_PARAM, &SWord);
+#endif /* VCPU */
+
+	SWord = JAM_LEN_VAL(3) | JAM_IPG_VAL(11) | IPG_JAM_DATA(26);
+	
+	GM_OUT16(IoC, Port, GM_TX_PARAM, SWord);
+
+	/* configure the Serial Mode Register */
+#ifdef VCPU
+	GM_IN16(IoC, Port, GM_SERIAL_MODE, &SWord);
+#endif /* VCPU */
+	
+	SWord = GM_SMOD_VLAN_ENA | IPG_VAL_FAST_ETH;
+
+	if (pAC->GIni.GIPortUsage == SK_JUMBO_LINK) {
+		/* enable jumbo mode (Max. Frame Length = 9018) */
+		SWord |= GM_SMOD_JUMBO_ENA;
+	}
+	
+	GM_OUT16(IoC, Port, GM_SERIAL_MODE, SWord);
+	
 	/*
-	 * configure the XMACs Station Address
-	 * B2_MAC_2 = xx xx xx xx xx x1 is programed to XMAC A
-	 * B2_MAC_3 = xx xx xx xx xx x2 is programed to XMAC B
+	 * configure the GMACs Station Addresses
+	 * in PROM you can find our addresses at:
+	 * B2_MAC_1 = xx xx xx xx xx x0 virtual address
+	 * B2_MAC_2 = xx xx xx xx xx x1 is programmed to GMAC A
+	 * B2_MAC_3 = xx xx xx xx xx x2 is reserved for DualPort
 	 */
+
 	for (i = 0; i < 3; i++) {
 		/*
 		 * The following 2 statements are together endianess
-		 * independant. Remember this when changing.
+		 * independent. Remember this when changing.
 		 */
+		/* physical address: will be used for pause frames */
 		SK_IN16(IoC, (B2_MAC_2 + Port * 8 + i * 2), &SWord);
-		XM_OUT16(IoC, Port, (XM_SA + i * 2), SWord);
-	}
-
-	/* Tx Inter Packet Gap (XM_TX_IPG):	use default */
-	/* Tx High Water Mark (XM_TX_HI_WM):	use default */
-	/* Tx Low Water Mark (XM_TX_LO_WM):	use default */
-	/* Host Request Threshold (XM_HT_THR):	use default */
-	/* Rx Request Threshold (XM_RX_THR):	use default */
-	/* Rx Low Water Mark (XM_RX_LO_WM):	use default */
 
-	/* configure Rx High Water Mark (XM_RX_HI_WM) */
-	XM_OUT16(IoC, Port, XM_RX_HI_WM, 0x05aa);
+#ifdef WA_DEV_16
+		/* WA for deviation #16 */
+		if (pAC->GIni.GIChipRev == 0) {
+			/* swap the address bytes */
+			SWord = ((SWord & 0xff00) >> 8)	| ((SWord & 0x00ff) << 8);
 
-	if (pAC->GIni.GIMacsFound > 1) {
-		switch (pAC->GIni.GIPortUsage) {
-		case SK_RED_LINK:
-			/* Configure Tx Request Threshold for red. link */
-			XM_OUT16(IoC, Port, XM_TX_THR, SK_XM_THR_REDL);
-			break;
-		case SK_MUL_LINK:
-			/* Configure Tx Request Threshold for load bal. */
-			XM_OUT16(IoC, Port, XM_TX_THR, SK_XM_THR_MULL);
-			break;
-		case SK_JUMBO_LINK:
-			/* Configure Tx Request Threshold for jumbo frames */
-			XM_OUT16(IoC, Port, XM_TX_THR, SK_XM_THR_JUMBO);
-			break;
-		default:
-			SK_ERR_LOG(pAC, SK_ERRCL_SW, SKERR_HWI_E014,
-				SKERR_HWI_E014MSG);
-			break;
+			/* write to register in reversed order */
+			GM_OUT16(IoC, Port, (GM_SRC_ADDR_1L + (2 - i) * 4), SWord);
 		}
-	}
-	else {
-		/* Configure Tx Request Threshold for single port */
-		XM_OUT16(IoC, Port, XM_TX_THR, SK_XM_THR_SL);
-	}
-
-	/*
-	 * setup register defaults for the Rx Command Register
-	 *	- Enable Automatic Frame Padding on Tx side
-	 */
-	XM_OUT16(IoC, Port, XM_TX_CMD, XM_TX_AUTO_PAD);
+		else {
+			GM_OUT16(IoC, Port, (GM_SRC_ADDR_1L + i * 4), SWord);
+		}
+#else		
+		GM_OUT16(IoC, Port, (GM_SRC_ADDR_1L + i * 4), SWord);
+#endif /* WA_DEV_16 */
+		
+		/* virtual address: will be used for data */
+		SK_IN16(IoC, (B2_MAC_1 + Port * 8 + i * 2), &SWord);
 
-	/*
-	 * setup register defaults for the Rx Command Register,
-	 * program value of PRxCmd
-	 */
-	XM_OUT16(IoC, Port, XM_RX_CMD, pPrt->PRxCmd);
+		GM_OUT16(IoC, Port, (GM_SRC_ADDR_2L + i * 4), SWord);
+		
+		/* reset Multicast filtering Hash registers 1-3 */
+		GM_OUT16(IoC, Port, GM_MC_ADDR_H1 + 4*i, 0);
+	}
 
-	/*
-	 * setup register defaults for the Mode Register
-	 *	- Don't strip error frames to avoid Store & Forward
-	 *	  on the rx side.
-	 *	- Enable 'Check Station Address' bit
-	 *	- Enable 'Check Address Array' bit
-	 */
-	XM_OUT32(IoC, Port, XM_MODE, XM_DEF_MODE);
+	/* reset Multicast filtering Hash register 4 */
+	GM_OUT16(IoC, Port, GM_MC_ADDR_H4, 0);
 
-	/*
-	 * Initialize the Receive Counter Event Mask (XM_RX_EV_MSK)
-	 *	- Enable all bits excepting 'Octets Rx OK Low CntOv'
-	 *	  and 'Octets Rx OK Hi Cnt Ov'.
-	 */
-	XM_OUT32(IoC, Port, XM_RX_EV_MSK, XMR_DEF_MSK);
+	/* enable interrupt mask for counter overflows */
+	GM_OUT16(IoC, Port, GM_TX_IRQ_MSK, 0);
+	GM_OUT16(IoC, Port, GM_RX_IRQ_MSK, 0);
+	GM_OUT16(IoC, Port, GM_TR_IRQ_MSK, 0);
 
-	/*
-	 * Initialize the Transmit Counter Event Mask (XM_TX_EV_MSK)
-	 *	- Enable all bits excepting 'Octets Tx OK Low CntOv'
-	 *	  and 'Octets Tx OK Hi Cnt Ov'.
-	 */
-	XM_OUT32(IoC, Port, XM_TX_EV_MSK, XMT_DEF_MSK);
+	/* read General Purpose Status */
+	GM_IN16(IoC, Port, GM_GP_STAT, &SWord);
+	
+	SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_CTRL,
+		("MAC Stat Reg=0x%04X\n", SWord));
 
-	/*
-	 * Do NOT init XMAC interrupt mask here.
-	 * All interrupts remain disable until link comes up!
-	 */
-	pPrt->PState = SK_PRT_INIT;
+#ifdef SK_DIAG
+	c_print("MAC Stat Reg=0x%04X\n", SWord);
+#endif /* SK_DIAG */
 
-	/*
-	 * Any additional configuration changes may be done now.
-	 * The last action is to enable the rx and tx state machine.
-	 * This should be done after the autonegotiation process
-	 * has been completed successfully.
-	 */
-}	/* SkXmInitMac*/
+}	/* SkGmInitMac */
 
 
 /******************************************************************************
@@ -922,9 +1922,9 @@
  *	SkXmInitDupMd() - Initialize the XMACs Duplex Mode
  *
  * Description:
- *	This function initilaizes the XMACs Duplex Mode.
+ *	This function initializes the XMACs Duplex Mode.
  *	It should be called after successfully finishing
- *	the Autonegotiation Process
+ *	the Auto-negotiation Process
  *
  * Returns:
  *	nothing
@@ -939,9 +1939,9 @@
 	case SK_LMODE_STAT_HALF:
 		/* Configuration Actions for Half Duplex Mode */
 		/*
-		 * XM_BURST = default value. We are propable not quick
+		 * XM_BURST = default value. We are probable not quick
 		 * 	enough at the 'XMAC' bus to burst 8kB.
-		 *	The XMAC stopps bursting if no transmit frames
+		 *	The XMAC stops bursting if no transmit frames
 		 *	are available or the burst limit is exceeded.
 		 */
 		/* XM_TX_RT_LIM = default value (15) */
@@ -969,10 +1969,10 @@
  *	SkXmInitPauseMd() - initialize the Pause Mode to be used for this port
  *
  * Description:
- *	This function initilaizes the Pause Mode which should
+ *	This function initializes the Pause Mode which should
  *	be used for this port.
  *	It should be called after successfully finishing
- *	the Autonegotiation Process
+ *	the Auto-negotiation Process
  *
  * Returns:
  *	nothing
@@ -988,22 +1988,26 @@
 
 	pPrt = &pAC->GIni.GP[Port];
 
+	XM_IN16(IoC, Port, XM_MMU_CMD, &Word);
+	
 	if (pPrt->PFlowCtrlStatus == SK_FLOW_STAT_NONE ||
 		pPrt->PFlowCtrlStatus == SK_FLOW_STAT_LOC_SEND) {
 
 		/* Disable Pause Frame Reception */
-		XM_IN16(IoC, Port, XM_MMU_CMD, &Word);
-		XM_OUT16(IoC, Port, XM_MMU_CMD, Word | XM_MMU_IGN_PF);
+		Word |= XM_MMU_IGN_PF;
 	}
 	else {
 		/*
-		 * enabling pause frame reception is required for 1000BT 
+		 * enabling pause frame reception is required for 1000BT
 		 * because the XMAC is not reset if the link is going down
 		 */
 		/* Enable Pause Frame Reception */
-		XM_IN16(IoC, Port, XM_MMU_CMD, &Word);
-		XM_OUT16(IoC, Port, XM_MMU_CMD, Word & ~XM_MMU_IGN_PF);
+		Word &= ~XM_MMU_IGN_PF;
 	}	
+	
+	XM_OUT16(IoC, Port, XM_MMU_CMD, Word);
+
+	XM_IN32(IoC, Port, XM_MODE, &DWord);
 
 	if (pPrt->PFlowCtrlStatus == SK_FLOW_STAT_SYMMETRIC ||
 		pPrt->PFlowCtrlStatus == SK_FLOW_STAT_LOC_SEND) {
@@ -1011,11 +2015,10 @@
 		/*
 		 * Configure Pause Frame Generation
 		 * Use internal and external Pause Frame Generation.
-		 * Sending pause frames is edge triggert. Send a
-		 * Pause frame with the maximum pause time if
-		 * internal oder external FIFO full condition
-		 * occurs. Send a zero pause time frame to
-		 * start transmission again.
+		 * Sending pause frames is edge triggered.
+		 * Send a Pause frame with the maximum pause time if
+		 * internal oder external FIFO full condition occurs.
+		 * Send a zero pause time frame to re-start transmission.
 		 */
 
 		/* XM_PAUSE_DA = '010000C28001' (default) */
@@ -1025,71 +2028,32 @@
 		XM_OUT16(IoC, Port, XM_MAC_PTIME, 0xffff);
 
 		/* Set Pause Mode in Mode Register */
-		XM_IN32(IoC, Port, XM_MODE, &DWord);
-		XM_OUT32(IoC, Port, XM_MODE, DWord | XM_PAUSE_MODE);
+		DWord |= XM_PAUSE_MODE;
 
 		/* Set Pause Mode in MAC Rx FIFO */
-		SK_OUT16(IoC, MR_ADDR(Port,RX_MFF_CTRL1), MFF_ENA_PAUSE);
+		SK_OUT16(IoC, MR_ADDR(Port, RX_MFF_CTRL1), MFF_ENA_PAUSE);
 	}
 	else {
 		/*
-		 * disable pause frame generation is required for 1000BT 
+		 * disable pause frame generation is required for 1000BT
 		 * because the XMAC is not reset if the link is going down
 		 */
 		/* Disable Pause Mode in Mode Register */
-		XM_IN32(IoC, Port, XM_MODE, &DWord);
-		XM_OUT32(IoC, Port, XM_MODE, DWord & ~XM_PAUSE_MODE);
+		DWord &= ~XM_PAUSE_MODE;
 
 		/* Disable Pause Mode in MAC Rx FIFO */
-		SK_OUT16(IoC, MR_ADDR(Port,RX_MFF_CTRL1), MFF_DIS_PAUSE);
+		SK_OUT16(IoC, MR_ADDR(Port, RX_MFF_CTRL1), MFF_DIS_PAUSE);
 	}
+	
+	XM_OUT32(IoC, Port, XM_MODE, DWord);
 }	/* SkXmInitPauseMd*/
 
 
 /******************************************************************************
  *
- *	SkXmInitPhy() - Initialize the XMAC II Phy registers
- *
- * Description:
- *	Initialize all the XMACs Phy registers
- *
- * Note:
- *
- * Returns:
- *	nothing
- */
-void SkXmInitPhy(
-SK_AC	*pAC,		/* adapter context */
-SK_IOC	IoC,		/* IO context */
-int		Port,		/* Port Index (MAC_1 + n) */
-SK_BOOL	DoLoop)		/* Should a Phy LOOback be set-up? */
-{
-	SK_GEPORT	*pPrt;
-
-	pPrt = &pAC->GIni.GP[Port];
-	switch (pPrt->PhyType) {
-	case SK_PHY_XMAC:
-		SkXmInitPhyXmac(pAC, IoC, Port, DoLoop);
-		break;
-	case SK_PHY_BCOM:
-		SkXmInitPhyBcom(pAC, IoC, Port, DoLoop);
-		break;
-	case SK_PHY_LONE:
-		SkXmInitPhyLone(pAC, IoC, Port, DoLoop);
-		break;
-	case SK_PHY_NAT:
-		SkXmInitPhyNat(pAC, IoC, Port, DoLoop);
-		break;
-	}
-}	/* SkXmInitPhy*/
-
-
-/******************************************************************************
- *
- *	SkXmInitPhyXmac() - Initialize the XMAC II Phy registers
+ *	SkXmInitPhyXmac() - Initialize the XMAC Phy registers
  *
- * Description:
- *	Initialize all the XMACs Phy registers
+ * Description:	initializes all the XMACs Phy registers
  *
  * Note:
  *
@@ -1100,32 +2064,32 @@
 SK_AC	*pAC,		/* adapter context */
 SK_IOC	IoC,		/* IO context */
 int		Port,		/* Port Index (MAC_1 + n) */
-SK_BOOL	DoLoop)		/* Should a Phy LOOback be set-up? */
+SK_BOOL	DoLoop)		/* Should a Phy LoopBack be set-up? */
 {
 	SK_GEPORT	*pPrt;
 	SK_U16		Ctrl;
 
 	pPrt = &pAC->GIni.GP[Port];
-
-	/* Autonegotiation ? */
-	if (pPrt->PLinkMode == SK_LMODE_HALF ||
-	    pPrt->PLinkMode == SK_LMODE_FULL) {
-		SK_DBG_MSG(pAC,SK_DBGMOD_HWM,SK_DBGCAT_CTRL,
-			("InitPhyXmac: no autonegotiation Port %d\n", Port));
-		/* No Autonegiotiation */
+	Ctrl = 0;
+	
+	/* Auto-negotiation ? */
+	if (pPrt->PLinkMode == SK_LMODE_HALF || pPrt->PLinkMode == SK_LMODE_FULL) {
+		SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_CTRL,
+			("InitPhyXmac: no auto-negotiation Port %d\n", Port));
 		/* Set DuplexMode in Config register */
-		Ctrl = (pPrt->PLinkMode == SK_LMODE_FULL ? PHY_CT_DUP_MD : 0);
+		if (pPrt->PLinkMode == SK_LMODE_FULL) {
+			Ctrl |= PHY_CT_DUP_MD;
+		}
 
 		/*
-		 * Do NOT enable Autonegotiation here. This would hold
-		 * the link down because no IDLES are transmitted
+		 * Do NOT enable Auto-negotiation here. This would hold
+		 * the link down because no IDLEs are transmitted
 		 */
 	}
 	else {
-		SK_DBG_MSG(pAC,SK_DBGMOD_HWM,SK_DBGCAT_CTRL,
-			("InitPhyXmac: with autonegotiation Port %d\n", Port));
-		/* Set Autonegotiation advertisement */
-		Ctrl = 0;
+		SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_CTRL,
+			("InitPhyXmac: with auto-negotiation Port %d\n", Port));
+		/* Set Auto-negotiation advertisement */
 
 		/* Set Full/half duplex capabilities */
 		switch (pPrt->PLinkMode) {
@@ -1139,8 +2103,8 @@
 			Ctrl |= PHY_X_AN_FD | PHY_X_AN_HD;
 			break;
 		default:
-			SK_ERR_LOG(pAC, SK_ERRCL_SW | SK_ERRCL_INIT,
-				SKERR_HWI_E015, SKERR_HWI_E015MSG);
+			SK_ERR_LOG(pAC, SK_ERRCL_SW | SK_ERRCL_INIT, SKERR_HWI_E015,
+				SKERR_HWI_E015MSG);
 		}
 
 		switch (pPrt->PFlowCtrlMode) {
@@ -1157,14 +2121,14 @@
 			Ctrl |= PHY_X_P_BOTH_MD;
 			break;
 		default:
-			SK_ERR_LOG(pAC, SK_ERRCL_SW | SK_ERRCL_INIT,
-				SKERR_HWI_E016, SKERR_HWI_E016MSG);
+			SK_ERR_LOG(pAC, SK_ERRCL_SW | SK_ERRCL_INIT, SKERR_HWI_E016,
+				SKERR_HWI_E016MSG);
 		}
 
 		/* Write AutoNeg Advertisement Register */
-		PHY_WRITE(IoC, pPrt, Port, PHY_XMAC_AUNE_ADV, Ctrl);
+		SkXmPhyWrite(pAC, IoC, Port, PHY_XMAC_AUNE_ADV, Ctrl);
 
-		/* Restart Autonegotiation */
+		/* Restart Auto-negotiation */
 		Ctrl = PHY_CT_ANE | PHY_CT_RE_CFG;
 	}
 
@@ -1174,16 +2138,15 @@
 	}
 
 	/* Write to the Phy control register */
-	PHY_WRITE(IoC, pPrt, Port, PHY_XMAC_CTRL, Ctrl);
-}	/* SkXmInitPhyXmac*/
+	SkXmPhyWrite(pAC, IoC, Port, PHY_XMAC_CTRL, Ctrl);
+}	/* SkXmInitPhyXmac */
 
 
 /******************************************************************************
  *
  *	SkXmInitPhyBcom() - Initialize the Broadcom Phy registers
  *
- * Description:
- *	Initialize all the Broadcom Phy registers
+ * Description:	initializes all the Broadcom Phy registers
  *
  * Note:
  *
@@ -1194,7 +2157,7 @@
 SK_AC	*pAC,		/* adapter context */
 SK_IOC	IoC,		/* IO context */
 int		Port,		/* Port Index (MAC_1 + n) */
-SK_BOOL	DoLoop)		/* Should a Phy LOOback be set-up? */
+SK_BOOL	DoLoop)		/* Should a Phy LoopBack be set-up? */
 {
 	SK_GEPORT	*pPrt;
 	SK_U16		Ctrl1;
@@ -1203,130 +2166,497 @@
 	SK_U16		Ctrl4;
 	SK_U16		Ctrl5;
 
-	Ctrl1 = PHY_B_CT_SP1000;
-	Ctrl2 = 0;
-	Ctrl3 = PHY_SEL_TYPE;
-	Ctrl4 = PHY_B_PEC_EN_LTR;
-	Ctrl5 = PHY_B_AC_TX_TST;
+	Ctrl1 = PHY_CT_SP1000;
+	Ctrl2 = 0;
+	Ctrl3 = PHY_SEL_TYPE;
+	Ctrl4 = PHY_B_PEC_EN_LTR;
+	Ctrl5 = PHY_B_AC_TX_TST;
+
+	pPrt = &pAC->GIni.GP[Port];
+
+	/* manually Master/Slave ? */
+	if (pPrt->PMSMode != SK_MS_MODE_AUTO) {
+		Ctrl2 |= PHY_B_1000C_MSE;
+		
+		if (pPrt->PMSMode == SK_MS_MODE_MASTER) {
+			Ctrl2 |= PHY_B_1000C_MSC;
+		}
+	}
+	/* Auto-negotiation ? */
+	if (pPrt->PLinkMode == SK_LMODE_HALF || pPrt->PLinkMode == SK_LMODE_FULL) {
+		SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_CTRL,
+			("InitPhyBcom: no auto-negotiation Port %d\n", Port));
+		/* Set DuplexMode in Config register */
+		Ctrl1 |= (pPrt->PLinkMode == SK_LMODE_FULL ? PHY_CT_DUP_MD : 0);
+
+		/* Determine Master/Slave manually if not already done */
+		if (pPrt->PMSMode == SK_MS_MODE_AUTO) {
+			Ctrl2 |= PHY_B_1000C_MSE;	/* set it to Slave */
+		}
+
+		/*
+		 * Do NOT enable Auto-negotiation here. This would hold
+		 * the link down because no IDLES are transmitted
+		 */
+	}
+	else {
+		SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_CTRL,
+			("InitPhyBcom: with auto-negotiation Port %d\n", Port));
+		/* Set Auto-negotiation advertisement */
+
+		/*
+		 * Workaround BCOM Errata #1 for the C5 type.
+		 * 1000Base-T Link Acquisition Failure in Slave Mode
+		 * Set Repeater/DTE bit 10 of the 1000Base-T Control Register
+		 */
+		Ctrl2 |= PHY_B_1000C_RD;
+		
+		 /* Set Full/half duplex capabilities */
+		switch (pPrt->PLinkMode) {
+		case SK_LMODE_AUTOHALF:
+			Ctrl2 |= PHY_B_1000C_AHD;
+			break;
+		case SK_LMODE_AUTOFULL:
+			Ctrl2 |= PHY_B_1000C_AFD;
+			break;
+		case SK_LMODE_AUTOBOTH:
+			Ctrl2 |= PHY_B_1000C_AFD | PHY_B_1000C_AHD;
+			break;
+		default:
+			SK_ERR_LOG(pAC, SK_ERRCL_SW | SK_ERRCL_INIT, SKERR_HWI_E015,
+				SKERR_HWI_E015MSG);
+		}
+
+		switch (pPrt->PFlowCtrlMode) {
+		case SK_FLOW_MODE_NONE:
+			Ctrl3 |= PHY_B_P_NO_PAUSE;
+			break;
+		case SK_FLOW_MODE_LOC_SEND:
+			Ctrl3 |= PHY_B_P_ASYM_MD;
+			break;
+		case SK_FLOW_MODE_SYMMETRIC:
+			Ctrl3 |= PHY_B_P_SYM_MD;
+			break;
+		case SK_FLOW_MODE_SYM_OR_REM:
+			Ctrl3 |= PHY_B_P_BOTH_MD;
+			break;
+		default:
+			SK_ERR_LOG(pAC, SK_ERRCL_SW | SK_ERRCL_INIT, SKERR_HWI_E016,
+				SKERR_HWI_E016MSG);
+		}
+
+		/* Restart Auto-negotiation */
+		Ctrl1 |= PHY_CT_ANE | PHY_CT_RE_CFG;
+	}
+	
+	/* Initialize LED register here? */
+	/* No. Please do it in SkDgXmitLed() (if required) and swap
+	   init order of LEDs and XMAC. (MAl) */
+	
+	/* Write 1000Base-T Control Register */
+	SkXmPhyWrite(pAC, IoC, Port, PHY_BCOM_1000T_CTRL, Ctrl2);
+	SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_CTRL,
+		("1000B-T Ctrl Reg=0x%04X\n", Ctrl2));
+	
+	/* Write AutoNeg Advertisement Register */
+	SkXmPhyWrite(pAC, IoC, Port, PHY_BCOM_AUNE_ADV, Ctrl3);
+	SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_CTRL,
+		("Auto-Neg. Adv. Reg=0x%04X\n", Ctrl3));
+	
+	if (DoLoop) {
+		/* Set the Phy Loopback bit, too */
+		Ctrl1 |= PHY_CT_LOOP;
+	}
+
+	if (pAC->GIni.GIPortUsage == SK_JUMBO_LINK) {
+		/* configure FIFO to high latency for transmission of ext. packets */
+		Ctrl4 |= PHY_B_PEC_HIGH_LA;
+
+		/* configure reception of extended packets */
+		Ctrl5 |= PHY_B_AC_LONG_PACK;
+
+		SkXmPhyWrite(pAC, IoC, Port, PHY_BCOM_AUX_CTRL, Ctrl5);
+	}
+
+	/* Configure LED Traffic Mode and Jumbo Frame usage if specified */
+	SkXmPhyWrite(pAC, IoC, Port, PHY_BCOM_P_EXT_CTRL, Ctrl4);
+	
+	/* Write to the Phy control register */
+	SkXmPhyWrite(pAC, IoC, Port, PHY_BCOM_CTRL, Ctrl1);
+	SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_CTRL,
+		("PHY Control Reg=0x%04X\n", Ctrl1));
+}	/* SkXmInitPhyBcom */
+
+
+/******************************************************************************
+ *
+ *	SkGmInitPhyMarv() - Initialize the Marvell Phy registers
+ *
+ * Description:	initializes all the Marvell Phy registers
+ *
+ * Note:
+ *
+ * Returns:
+ *	nothing
+ */
+static void SkGmInitPhyMarv(
+SK_AC	*pAC,		/* adapter context */
+SK_IOC	IoC,		/* IO context */
+int		Port,		/* Port Index (MAC_1 + n) */
+SK_BOOL	DoLoop)		/* Should a Phy LoopBack be set-up? */
+{
+	SK_GEPORT	*pPrt;
+	SK_U16		PhyCtrl;
+	SK_U16		C1000BaseT;
+	SK_U16		AutoNegAdv;
+	SK_U16		ExtPhyCtrl;
+	SK_U16		PhyStat;
+	SK_U16		PhyStat1;
+	SK_U16		PhySpecStat;
+	SK_U16		LedCtrl;
+	SK_BOOL		AutoNeg;
+
+	pPrt = &pAC->GIni.GP[Port];
+
+	/* Auto-negotiation ? */
+	if (pPrt->PLinkMode == SK_LMODE_HALF || pPrt->PLinkMode == SK_LMODE_FULL) {
+		AutoNeg = SK_FALSE;
+	}
+	else {
+		AutoNeg = SK_TRUE;
+	}
+	
+#ifdef VCPU
+	VCPUprintf(0, "SkGmInitPhyMarv(), Port=%u, DoLoop=%u\n",
+		Port, DoLoop);
+#else /* VCPU */
+	
+	if (DoLoop) {
+		/* Set 'MAC Power up'-bit, set Manual MDI configuration */
+		SkGmPhyWrite(pAC, IoC, Port, PHY_MARV_PHY_CTRL,
+			PHY_M_PC_MAC_POW_UP);
+	}
+	else {
+		/* Read Ext. PHY Specific Control */
+		SkGmPhyRead(pAC, IoC, Port, PHY_MARV_EXT_CTRL, &ExtPhyCtrl);
+		
+		ExtPhyCtrl &= ~(PHY_M_EC_M_DSC_MSK | PHY_M_EC_S_DSC_MSK |
+			PHY_M_EC_MAC_S_MSK);
+		
+		ExtPhyCtrl |= PHY_M_EC_M_DSC(1) | PHY_M_EC_S_DSC(1) |
+			PHY_M_EC_MAC_S(MAC_TX_CLK_25_MHZ);
+	
+		SkGmPhyWrite(pAC, IoC, Port, PHY_MARV_EXT_CTRL, ExtPhyCtrl);
+		SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_CTRL,
+			("Ext.PHYCtrl=0x%04X\n", ExtPhyCtrl));
+	}
+
+	/* Read PHY Control */
+	SkGmPhyRead(pAC, IoC, Port, PHY_MARV_CTRL, &PhyCtrl);
 
-	pPrt = &pAC->GIni.GP[Port];
+	PhyCtrl |= PHY_CT_RESET;
+	/* Assert software reset */
+	SkGmPhyWrite(pAC, IoC, Port, PHY_MARV_CTRL, PhyCtrl);
+
+#endif /* VCPU */
+
+	PhyCtrl = 0 /* PHY_CT_COL_TST */;
+	C1000BaseT = 0;
+	AutoNegAdv = PHY_SEL_TYPE;
 
 	/* manually Master/Slave ? */
 	if (pPrt->PMSMode != SK_MS_MODE_AUTO) {
-		Ctrl2 |= PHY_B_1000C_MSE;
+		/* enable Manual Master/Slave */
+		C1000BaseT |= PHY_M_1000C_MSE;
+		
 		if (pPrt->PMSMode == SK_MS_MODE_MASTER) {
-			Ctrl2 |= PHY_B_1000C_MSC;
+			C1000BaseT |= PHY_M_1000C_MSC;	/* set it to Master */
 		}
 	}
-	/* Autonegotiation ? */
-	if (pPrt->PLinkMode == SK_LMODE_HALF ||
-	    pPrt->PLinkMode == SK_LMODE_FULL) {
-		SK_DBG_MSG(pAC,SK_DBGMOD_HWM,SK_DBGCAT_CTRL,
-			("InitPhyBcom: no autonegotiation Port %d\n", Port));
-		/* No Autonegiotiation */
-		/* Set DuplexMode in Config register */
-		Ctrl1 |= (pPrt->PLinkMode == SK_LMODE_FULL ? PHY_CT_DUP_MD : 0);
+	
+	/* Auto-negotiation ? */
+	if (!AutoNeg) {
+		SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_CTRL,
+			("InitPhyMarv: no auto-negotiation Port %d\n", Port));
+		
+		if (pPrt->PLinkMode == SK_LMODE_FULL) {
+			/* Set Full Duplex Mode */
+			PhyCtrl |= PHY_CT_DUP_MD;
+		}
 
-		/* Determine Master/Slave manually if not already done. */
+		/* Set Master/Slave manually if not already done */
 		if (pPrt->PMSMode == SK_MS_MODE_AUTO) {
-			Ctrl2 |= PHY_B_1000C_MSE;	/* set it to Slave */
+			C1000BaseT |= PHY_M_1000C_MSE;	/* set it to Slave */
 		}
 
-		/*
-		 * Do NOT enable Autonegotiation here. This would hold
-		 * the link down because no IDLES are transmitted
-		 */
-	}
-	else {
-		SK_DBG_MSG(pAC,SK_DBGMOD_HWM,SK_DBGCAT_CTRL,
-			("InitPhyBcom: with autonegotiation Port %d\n", Port));
-		/* Set Autonegotiation advertisement */
-
-		/* Set Full/half duplex capabilities */
-		switch (pPrt->PLinkMode) {
-		case SK_LMODE_AUTOHALF:
-			Ctrl2 |= PHY_B_1000C_AHD;
+		/* Set Speed */
+		switch (pPrt->PLinkSpeed) {
+		case SK_LSPEED_AUTO:
+		case SK_LSPEED_1000MBPS:
+			PhyCtrl |= PHY_CT_SP1000;
 			break;
-		case SK_LMODE_AUTOFULL:
-			Ctrl2 |= PHY_B_1000C_AFD;
+		case SK_LSPEED_100MBPS:
+			PhyCtrl |= PHY_CT_SP100;
 			break;
-		case SK_LMODE_AUTOBOTH:
-			Ctrl2 |= PHY_B_1000C_AFD | PHY_B_1000C_AHD;
+		case SK_LSPEED_10MBPS:
 			break;
 		default:
-			SK_ERR_LOG(pAC, SK_ERRCL_SW | SK_ERRCL_INIT,
-				SKERR_HWI_E015, SKERR_HWI_E015MSG);
+			SK_ERR_LOG(pAC, SK_ERRCL_SW | SK_ERRCL_INIT, SKERR_HWI_E019,
+				SKERR_HWI_E019MSG);
 		}
 
-		switch (pPrt->PFlowCtrlMode) {
-		case SK_FLOW_MODE_NONE:
-			Ctrl3 |= PHY_B_P_NO_PAUSE;
-			break;
-		case SK_FLOW_MODE_LOC_SEND:
-			Ctrl3 |= PHY_B_P_ASYM_MD;
-			break;
-		case SK_FLOW_MODE_SYMMETRIC:
-			Ctrl3 |= PHY_B_P_SYM_MD;
-			break;
-		case SK_FLOW_MODE_SYM_OR_REM:
-			Ctrl3 |= PHY_B_P_BOTH_MD;
-			break;
-		default:
-			SK_ERR_LOG(pAC, SK_ERRCL_SW | SK_ERRCL_INIT,
-				SKERR_HWI_E016, SKERR_HWI_E016MSG);
+		if (!DoLoop) {
+			PhyCtrl |= PHY_CT_RESET;
 		}
+		/*
+		 * Do NOT enable Auto-negotiation here. This would hold
+		 * the link down because no IDLES are transmitted
+		 */
+	}
+	else {
+		SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_CTRL,
+			("InitPhyMarv: with auto-negotiation Port %d\n", Port));
+		
+		PhyCtrl |= PHY_CT_ANE;
+		
+		if (pAC->GIni.GICopperType) {
+			/* Set Speed capabilities */
+			switch (pPrt->PLinkSpeed) {
+			case SK_LSPEED_AUTO:
+				C1000BaseT |= PHY_M_1000C_AHD | PHY_M_1000C_AFD;
+				AutoNegAdv |= PHY_M_AN_100_FD | PHY_M_AN_100_HD |
+					PHY_M_AN_10_FD | PHY_M_AN_10_HD;
+				break;
+			case SK_LSPEED_1000MBPS:
+				C1000BaseT |= PHY_M_1000C_AHD | PHY_M_1000C_AFD;
+				break;
+			case SK_LSPEED_100MBPS:
+				AutoNegAdv |= PHY_M_AN_100_FD | PHY_M_AN_100_HD |
+					PHY_M_AN_10_FD | PHY_M_AN_10_HD;
+				break;
+			case SK_LSPEED_10MBPS:
+				AutoNegAdv |= PHY_M_AN_10_FD | PHY_M_AN_10_HD;
+				break;
+			default:
+				SK_ERR_LOG(pAC, SK_ERRCL_SW | SK_ERRCL_INIT, SKERR_HWI_E019,
+					SKERR_HWI_E019MSG);
+			}
 
-		/* Restart Autonegotiation */
-		Ctrl1 |= PHY_CT_ANE | PHY_CT_RE_CFG;
+			/* Set Full/half duplex capabilities */
+			switch (pPrt->PLinkMode) {
+			case SK_LMODE_AUTOHALF:
+				C1000BaseT &= ~PHY_M_1000C_AFD;
+				AutoNegAdv &= ~(PHY_M_AN_100_FD | PHY_M_AN_10_FD);
+				break;
+			case SK_LMODE_AUTOFULL:
+				C1000BaseT &= ~PHY_M_1000C_AHD;
+				AutoNegAdv &= ~(PHY_M_AN_100_HD | PHY_M_AN_10_HD);
+				break;
+			case SK_LMODE_AUTOBOTH:
+				break;
+			default:
+				SK_ERR_LOG(pAC, SK_ERRCL_SW | SK_ERRCL_INIT, SKERR_HWI_E015,
+					SKERR_HWI_E015MSG);
+			}
+			
+			/* Set Auto-negotiation advertisement */
+			switch (pPrt->PFlowCtrlMode) {
+			case SK_FLOW_MODE_NONE:
+				AutoNegAdv |= PHY_B_P_NO_PAUSE;
+				break;
+			case SK_FLOW_MODE_LOC_SEND:
+				AutoNegAdv |= PHY_B_P_ASYM_MD;
+				break;
+			case SK_FLOW_MODE_SYMMETRIC:
+				AutoNegAdv |= PHY_B_P_SYM_MD;
+				break;
+			case SK_FLOW_MODE_SYM_OR_REM:
+				AutoNegAdv |= PHY_B_P_BOTH_MD;
+				break;
+			default:
+				SK_ERR_LOG(pAC, SK_ERRCL_SW | SK_ERRCL_INIT, SKERR_HWI_E016,
+					SKERR_HWI_E016MSG);
+			}
+		}
+		else {	/* special defines for FIBER (88E1011S only) */
+			
+			/* Set Full/half duplex capabilities */
+			switch (pPrt->PLinkMode) {
+			case SK_LMODE_AUTOHALF:
+				AutoNegAdv |= PHY_M_AN_1000X_AHD;
+				break;
+			case SK_LMODE_AUTOFULL:
+				AutoNegAdv |= PHY_M_AN_1000X_AFD;
+				break;
+			case SK_LMODE_AUTOBOTH:
+				AutoNegAdv |= PHY_M_AN_1000X_AHD | PHY_M_AN_1000X_AFD;
+				break;
+			default:
+				SK_ERR_LOG(pAC, SK_ERRCL_SW | SK_ERRCL_INIT, SKERR_HWI_E015,
+					SKERR_HWI_E015MSG);
+			}
+			
+			/* Set Auto-negotiation advertisement */
+			switch (pPrt->PFlowCtrlMode) {
+			case SK_FLOW_MODE_NONE:
+				AutoNegAdv |= PHY_M_P_NO_PAUSE_X;
+				break;
+			case SK_FLOW_MODE_LOC_SEND:
+				AutoNegAdv |= PHY_M_P_ASYM_MD_X;
+				break;
+			case SK_FLOW_MODE_SYMMETRIC:
+				AutoNegAdv |= PHY_M_P_SYM_MD_X;
+				break;
+			case SK_FLOW_MODE_SYM_OR_REM:
+				AutoNegAdv |= PHY_M_P_BOTH_MD_X;
+				break;
+			default:
+				SK_ERR_LOG(pAC, SK_ERRCL_SW | SK_ERRCL_INIT, SKERR_HWI_E016,
+					SKERR_HWI_E016MSG);
+			}
+		}
 
+		if (!DoLoop) {
+			/* Restart Auto-negotiation */
+			PhyCtrl |= PHY_CT_RE_CFG;
+		}
 	}
 	
-	/* Initialize LED register here? */
-	/* No. Please do it in SkDgXmitLed() (if required) and swap
-	   init order of LEDs and XMAC. (MAl) */
+#ifdef VCPU
+	/*
+	 * E-mail from Gu Lin (08-03-2002):
+	 */
+	
+	/* Program PHY register 30 as 16'h0708 for simulation speed up */
+	SkGmPhyWrite(pAC, IoC, Port, 30, 0x0708);
+	
+	VCpuWait(2000);
+
+#else /* VCPU */
 	
 	/* Write 1000Base-T Control Register */
-	PHY_WRITE(IoC, pPrt, Port, PHY_BCOM_1000T_CTRL, Ctrl2);
-	SK_DBG_MSG(pAC,SK_DBGMOD_HWM,SK_DBGCAT_CTRL,
-		("1000Base-T Control Reg = %x\n", Ctrl2));
+	SkGmPhyWrite(pAC, IoC, Port, PHY_MARV_1000T_CTRL, C1000BaseT);
+	SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_CTRL,
+		("1000B-T Ctrl=0x%04X\n", C1000BaseT));
 	
 	/* Write AutoNeg Advertisement Register */
-	PHY_WRITE(IoC, pPrt, Port, PHY_BCOM_AUNE_ADV, Ctrl3);
-	SK_DBG_MSG(pAC,SK_DBGMOD_HWM,SK_DBGCAT_CTRL,
-		("AutoNeg Advertisment Reg = %x\n", Ctrl3));
+	SkGmPhyWrite(pAC, IoC, Port, PHY_MARV_AUNE_ADV, AutoNegAdv);
+	SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_CTRL,
+		("Auto-Neg.Ad.=0x%04X\n", AutoNegAdv));
+#endif /* VCPU */
 	
-
 	if (DoLoop) {
-		/* Set the Phy Loopback bit, too */
-		Ctrl1 |= PHY_CT_LOOP;
+		/* Set the PHY Loopback bit */
+		PhyCtrl |= PHY_CT_LOOP;
+
+		/* Program PHY register 16 as 16'h0400 to force link good */
+		SkGmPhyWrite(pAC, IoC, Port, PHY_MARV_PHY_CTRL, PHY_M_PC_FL_GOOD);
+
+		if (pPrt->PLinkSpeed != SK_LSPEED_AUTO) {
+			/* Write Ext. PHY Specific Control */
+			SkGmPhyWrite(pAC, IoC, Port, PHY_MARV_EXT_CTRL,
+				(SK_U16)((pPrt->PLinkSpeed + 2) << 4));
+		}
+	}
+#ifdef TEST_ONLY
+	else if (pPrt->PLinkSpeed == SK_LSPEED_10MBPS) {
+			/* Write PHY Specific Control */
+			SkGmPhyWrite(pAC, IoC, Port, PHY_MARV_PHY_CTRL,
+				PHY_M_PC_EN_DET_MSK);
 	}
+#endif
 
-	if (pAC->GIni.GIPortUsage == SK_JUMBO_LINK) {
-		/* configure fifo to high latency for xmission of ext. packets*/
-		Ctrl4 |= PHY_B_PEC_HIGH_LA;
+	/* Write to the PHY Control register */
+	SkGmPhyWrite(pAC, IoC, Port, PHY_MARV_CTRL, PhyCtrl);
 
-		/* configure reception of extended packets */
-		Ctrl5 |= PHY_B_AC_LONG_PACK;
+#ifdef VCPU
+	VCpuWait(2000);
+#else
+
+	LedCtrl = PHY_M_LED_PULS_DUR(PULS_170MS) | PHY_M_LED_BLINK_RT(BLINK_84MS);
 
-		PHY_WRITE(IoC, pPrt, Port, PHY_BCOM_AUX_CTRL, Ctrl5);
+	if ((pAC->GIni.GILedBlinkCtrl & SK_ACT_LED_BLINK) != 0) {
+		LedCtrl |= PHY_M_LEDC_RX_CTRL | PHY_M_LEDC_TX_CTRL;
 	}
 
-	/* Configure LED Traffic Mode and Jumbo Frame usage if specified */
-	PHY_WRITE(IoC, pPrt, Port, PHY_BCOM_P_EXT_CTRL, Ctrl4);
+	if ((pAC->GIni.GILedBlinkCtrl & SK_DUP_LED_NORMAL) != 0) {
+		LedCtrl |= PHY_M_LEDC_DP_CTRL;
+	}
 	
-	/* Write to the Phy control register */
-	PHY_WRITE(IoC, pPrt, Port, PHY_BCOM_CTRL, Ctrl1);
-	SK_DBG_MSG(pAC,SK_DBGMOD_HWM,SK_DBGCAT_CTRL,
-		("PHY Control Reg = %x\n", Ctrl1));
-}	/* SkXmInitPhyBcom */
+	SkGmPhyWrite(pAC, IoC, Port, PHY_MARV_LED_CTRL, LedCtrl);
+
+	if ((pAC->GIni.GILedBlinkCtrl & SK_LED_LINK100_ON) != 0) {
+		/* only in forced 100Mbps mode */
+		if (!AutoNeg && pPrt->PLinkSpeed == SK_LSPEED_100MBPS) {
+
+			SkGmPhyWrite(pAC, IoC, Port, PHY_MARV_LED_OVER,
+				PHY_M_LED_MO_100(MO_LED_ON));
+		}
+	}
+
+#ifdef SK_DIAG
+	c_print("Set PHY Ctrl=0x%04X\n", PhyCtrl);
+	c_print("Set 1000 B-T=0x%04X\n", C1000BaseT);
+	c_print("Set Auto-Neg=0x%04X\n", AutoNegAdv);
+	c_print("Set Ext Ctrl=0x%04X\n", ExtPhyCtrl);
+#endif /* SK_DIAG */
+
+#if defined(SK_DIAG) || defined(DEBUG)
+	/* Read PHY Control */
+	SkGmPhyRead(pAC, IoC, Port, PHY_MARV_CTRL, &PhyCtrl);
+	SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_CTRL,
+		("PHY Ctrl Reg.=0x%04X\n", PhyCtrl));
+	
+	/* Read 1000Base-T Control Register */
+	SkGmPhyRead(pAC, IoC, Port, PHY_MARV_1000T_CTRL, &C1000BaseT);
+	SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_CTRL,
+		("1000B-T Ctrl =0x%04X\n", C1000BaseT));
+	
+	/* Read AutoNeg Advertisement Register */
+	SkGmPhyRead(pAC, IoC, Port, PHY_MARV_AUNE_ADV, &AutoNegAdv);
+	SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_CTRL,
+		("Auto-Neg. Ad.=0x%04X\n", AutoNegAdv));
+	
+	/* Read Ext. PHY Specific Control */
+	SkGmPhyRead(pAC, IoC, Port, PHY_MARV_EXT_CTRL, &ExtPhyCtrl);
+	SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_CTRL,
+		("Ext PHY Ctrl=0x%04X\n", ExtPhyCtrl));
+	
+	/* Read PHY Status */
+	SkGmPhyRead(pAC, IoC, Port, PHY_MARV_STAT, &PhyStat);
+	SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_CTRL,
+		("PHY Stat Reg.=0x%04X\n", PhyStat));
+	SkGmPhyRead(pAC, IoC, Port, PHY_MARV_STAT, &PhyStat1);
+	SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_CTRL,
+		("PHY Stat Reg.=0x%04X\n", PhyStat1));
+	
+	/* Read PHY Specific Status */
+	SkGmPhyRead(pAC, IoC, Port, PHY_MARV_PHY_STAT, &PhySpecStat);
+	SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_CTRL,
+		("PHY Spec Stat=0x%04X\n", PhySpecStat));
+#endif /* DEBUG */
+
+#ifdef SK_DIAG
+	c_print("PHY Ctrl Reg=0x%04X\n", PhyCtrl);
+	c_print("PHY 1000 Reg=0x%04X\n", C1000BaseT);
+	c_print("PHY AnAd Reg=0x%04X\n", AutoNegAdv);
+	c_print("Ext Ctrl Reg=0x%04X\n", ExtPhyCtrl);
+	c_print("PHY Stat Reg=0x%04X\n", PhyStat);
+	c_print("PHY Stat Reg=0x%04X\n", PhyStat1);
+	c_print("PHY Spec Reg=0x%04X\n", PhySpecStat);
+#endif /* SK_DIAG */
+
+#endif /* VCPU */
+
+}	/* SkGmInitPhyMarv */
 
 
+#ifdef OTHER_PHY
 /******************************************************************************
  *
  *	SkXmInitPhyLone() - Initialize the Level One Phy registers
  *
- * Description:
- *	Initialize all the Level One Phy registers
+ * Description:	initializes all the Level One Phy registers
  *
  * Note:
  *
@@ -1337,14 +2667,14 @@
 SK_AC	*pAC,		/* adapter context */
 SK_IOC	IoC,		/* IO context */
 int		Port,		/* Port Index (MAC_1 + n) */
-SK_BOOL	DoLoop)		/* Should a Phy LOOback be set-up? */
+SK_BOOL	DoLoop)		/* Should a Phy LoopBack be set-up? */
 {
 	SK_GEPORT	*pPrt;
 	SK_U16		Ctrl1;
 	SK_U16		Ctrl2;
 	SK_U16		Ctrl3;
 
-	Ctrl1 = PHY_L_CT_SP1000;
+	Ctrl1 = PHY_CT_SP1000;
 	Ctrl2 = 0;
 	Ctrl3 = PHY_SEL_TYPE;
 
@@ -1353,39 +2683,36 @@
 	/* manually Master/Slave ? */
 	if (pPrt->PMSMode != SK_MS_MODE_AUTO) {
 		Ctrl2 |= PHY_L_1000C_MSE;
+		
 		if (pPrt->PMSMode == SK_MS_MODE_MASTER) {
 			Ctrl2 |= PHY_L_1000C_MSC;
 		}
 	}
-	/* Autonegotiation ? */
-	if (pPrt->PLinkMode == SK_LMODE_HALF ||
-	    pPrt->PLinkMode == SK_LMODE_FULL) {
+	/* Auto-negotiation ? */
+	if (pPrt->PLinkMode == SK_LMODE_HALF || pPrt->PLinkMode == SK_LMODE_FULL) {
 		/*
 		 * level one spec say: "1000Mbps: manual mode not allowed"
 		 * but lets see what happens...
 		 */
-		SK_ERR_LOG(pAC, SK_ERRCL_SW | SK_ERRCL_INIT,
-			0, "Level One PHY only works with Autoneg");
-		SK_DBG_MSG(pAC,SK_DBGMOD_HWM,SK_DBGCAT_CTRL,
-			("InitPhyLone: no autonegotiation Port %d\n", Port));
-		/* No Autonegiotiation */
+		SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_CTRL,
+			("InitPhyLone: no auto-negotiation Port %d\n", Port));
 		/* Set DuplexMode in Config register */
 		Ctrl1 = (pPrt->PLinkMode == SK_LMODE_FULL ? PHY_CT_DUP_MD : 0);
 
-		/* Determine Master/Slave manually if not already done. */
+		/* Determine Master/Slave manually if not already done */
 		if (pPrt->PMSMode == SK_MS_MODE_AUTO) {
 			Ctrl2 |= PHY_L_1000C_MSE;	/* set it to Slave */
 		}
 
 		/*
-		 * Do NOT enable Autonegotiation here. This would hold
+		 * Do NOT enable Auto-negotiation here. This would hold
 		 * the link down because no IDLES are transmitted
 		 */
 	}
 	else {
-		SK_DBG_MSG(pAC,SK_DBGMOD_HWM,SK_DBGCAT_CTRL,
-			("InitPhyLone: with autonegotiation Port %d\n", Port));
-		/* Set Autonegotiation advertisement */
+		SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_CTRL,
+			("InitPhyLone: with auto-negotiation Port %d\n", Port));
+		/* Set Auto-negotiation advertisement */
 
 		/* Set Full/half duplex capabilities */
 		switch (pPrt->PLinkMode) {
@@ -1399,8 +2726,8 @@
 			Ctrl2 |= PHY_L_1000C_AFD | PHY_L_1000C_AHD;
 			break;
 		default:
-			SK_ERR_LOG(pAC, SK_ERRCL_SW | SK_ERRCL_INIT,
-				SKERR_HWI_E015, SKERR_HWI_E015MSG);
+			SK_ERR_LOG(pAC, SK_ERRCL_SW | SK_ERRCL_INIT, SKERR_HWI_E015,
+				SKERR_HWI_E015MSG);
 		}
 
 		switch (pPrt->PFlowCtrlMode) {
@@ -1417,28 +2744,24 @@
 			Ctrl3 |= PHY_L_P_BOTH_MD;
 			break;
 		default:
-			SK_ERR_LOG(pAC, SK_ERRCL_SW | SK_ERRCL_INIT,
-				SKERR_HWI_E016, SKERR_HWI_E016MSG);
+			SK_ERR_LOG(pAC, SK_ERRCL_SW | SK_ERRCL_INIT, SKERR_HWI_E016,
+				SKERR_HWI_E016MSG);
 		}
 
-		/* Restart Autonegotiation */
+		/* Restart Auto-negotiation */
 		Ctrl1 = PHY_CT_ANE | PHY_CT_RE_CFG;
 
 	}
 	
-	/* Initialize LED register here ? */
-	/* No. Please do it in SkDgXmitLed() (if required) and swap
-	   init order of LEDs and XMAC. (MAl) */
-	
 	/* Write 1000Base-T Control Register */
-	PHY_WRITE(IoC, pPrt, Port, PHY_LONE_1000T_CTRL, Ctrl2);
-	SK_DBG_MSG(pAC,SK_DBGMOD_HWM,SK_DBGCAT_CTRL,
-		("1000Base-T Control Reg = %x\n", Ctrl2));
+	SkXmPhyWrite(pAC, IoC, Port, PHY_LONE_1000T_CTRL, Ctrl2);
+	SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_CTRL,
+		("1000B-T Ctrl Reg=0x%04X\n", Ctrl2));
 	
 	/* Write AutoNeg Advertisement Register */
-	PHY_WRITE(IoC, pPrt, Port, PHY_LONE_AUNE_ADV, Ctrl3);
-	SK_DBG_MSG(pAC,SK_DBGMOD_HWM,SK_DBGCAT_CTRL,
-		("AutoNeg Advertisment Reg = %x\n", Ctrl3));
+	SkXmPhyWrite(pAC, IoC, Port, PHY_LONE_AUNE_ADV, Ctrl3);
+	SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_CTRL,
+		("Auto-Neg. Adv. Reg=0x%04X\n", Ctrl3));
 	
 
 	if (DoLoop) {
@@ -1446,26 +2769,18 @@
 		Ctrl1 |= PHY_CT_LOOP;
 	}
 
-	if (pAC->GIni.GIPortUsage == SK_JUMBO_LINK) {
-		/*
-		 * nothing to do for Level one.
-		 * PHY supports frames up to 10k.
-		 */
-	}
-	
 	/* Write to the Phy control register */
-	PHY_WRITE(IoC, pPrt, Port, PHY_LONE_CTRL, Ctrl1);
-	SK_DBG_MSG(pAC,SK_DBGMOD_HWM,SK_DBGCAT_CTRL,
-		("PHY Control Reg = %x\n", Ctrl1));
-}	/* SkXmInitPhyLone*/
+	SkXmPhyWrite(pAC, IoC, Port, PHY_LONE_CTRL, Ctrl1);
+	SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_CTRL,
+		("PHY Control Reg=0x%04X\n", Ctrl1));
+}	/* SkXmInitPhyLone */
 
 
 /******************************************************************************
  *
  *	SkXmInitPhyNat() - Initialize the National Phy registers
  *
- * Description:
- *	Initialize all the National Phy registers
+ * Description:	initializes all the National Phy registers
  *
  * Note:
  *
@@ -1476,103 +2791,99 @@
 SK_AC	*pAC,		/* adapter context */
 SK_IOC	IoC,		/* IO context */
 int		Port,		/* Port Index (MAC_1 + n) */
-SK_BOOL	DoLoop)		/* Should a Phy LOOback be set-up? */
+SK_BOOL	DoLoop)		/* Should a Phy LoopBack be set-up? */
 {
 /* todo: National */
-}	/* SkXmInitPhyNat*/
+}	/* SkXmInitPhyNat */
+#endif /* OTHER_PHY */
 
 
 /******************************************************************************
  *
- *	SkXmAutoNegLipaXmac() - Decides whether Link Partner could do autoneg
+ *	SkMacInitPhy() - Initialize the PHY registers
  *
- *	This function analyses the Interrupt status word. If any of the
- *	Autonegotiating interrupt bits are set, the PLipaAutoNeg variable
- *	is set true.
- */
-void	SkXmAutoNegLipaXmac(
-SK_AC	*pAC,		/* adapter context */
-SK_IOC	IoC,		/* IO context */
-int		Port,		/* Port Index (MAC_1 + n) */
-SK_U16	IStatus)	/* Interrupt Status word to analyse */
-{
-	SK_GEPORT	*pPrt;
-
-	pPrt = &pAC->GIni.GP[Port];
-
-	if (pPrt->PLipaAutoNeg != SK_LIPA_AUTO &&
-		(IStatus & (XM_IS_LIPA_RC|XM_IS_RX_PAGE|XM_IS_AND))) {
-
-		SK_DBG_MSG(pAC,SK_DBGMOD_HWM,SK_DBGCAT_CTRL,
-			("AutoNegLipa: AutoNeg detected on port %d %x\n", Port, IStatus));
-		pPrt->PLipaAutoNeg = SK_LIPA_AUTO;
-	}
-}	/* SkXmAutoNegLipaXmac*/
-
-
-/******************************************************************************
+ * Description:	calls the Init PHY routines dep. on board type
  *
- *	SkXmAutoNegLipaBcom() - Decides whether Link Partner could do autoneg
+ * Note:
  *
- *	This function analyses the PHY status word. If any of the
- *	Autonegotiating bits are set, The PLipaAutoNeg variable
- *	is set true.
+ * Returns:
+ *	nothing
  */
-void	SkXmAutoNegLipaBcom(
+void SkMacInitPhy(
 SK_AC	*pAC,		/* adapter context */
 SK_IOC	IoC,		/* IO context */
 int		Port,		/* Port Index (MAC_1 + n) */
-SK_U16	PhyStat)	/* PHY Status word to analyse */
+SK_BOOL	DoLoop)		/* Should a Phy LoopBack be set-up? */
 {
 	SK_GEPORT	*pPrt;
 
 	pPrt = &pAC->GIni.GP[Port];
 
-	if (pPrt->PLipaAutoNeg != SK_LIPA_AUTO && (PhyStat & PHY_ST_AN_OVER)) {
-		SK_DBG_MSG(pAC,SK_DBGMOD_HWM,SK_DBGCAT_CTRL,
-			("AutoNegLipa: AutoNeg detected on port %d %x\n", Port, PhyStat));
-		pPrt->PLipaAutoNeg = SK_LIPA_AUTO;
+	if (pAC->GIni.GIGenesis) {
+		
+		switch (pPrt->PhyType) {
+		case SK_PHY_XMAC:
+			SkXmInitPhyXmac(pAC, IoC, Port, DoLoop);
+			break;
+		case SK_PHY_BCOM:
+			SkXmInitPhyBcom(pAC, IoC, Port, DoLoop);
+			break;
+#ifdef OTHER_PHY
+		case SK_PHY_LONE:
+			SkXmInitPhyLone(pAC, IoC, Port, DoLoop);
+			break;
+		case SK_PHY_NAT:
+			SkXmInitPhyNat(pAC, IoC, Port, DoLoop);
+			break;
+#endif /* OTHER_PHY */
+		}
+	}
+	else {
+		
+		SkGmInitPhyMarv(pAC, IoC, Port, DoLoop);
 	}
-}	/* SkXmAutoNegLipaBcom*/
+}	/* SkMacInitPhy */
 
 
+#ifndef SK_DIAG
 /******************************************************************************
  *
- *	SkXmAutoNegLipaLone() - Decides whether Link Partner could do autoneg
+ *	SkXmAutoNegLipaXmac() - Decides whether Link Partner could do auto-neg
  *
- *	This function analyses the PHY status word. If any of the
- *	Autonegotiating bits are set, The PLipaAutoNeg variable
+ *	This function analyses the Interrupt status word. If any of the
+ *	Auto-negotiating interrupt bits are set, the PLipaAutoNeg variable
  *	is set true.
  */
-void	SkXmAutoNegLipaLone(
+void SkXmAutoNegLipaXmac(
 SK_AC	*pAC,		/* adapter context */
 SK_IOC	IoC,		/* IO context */
-int	Port,		/* Port Index (MAC_1 + n) */
-SK_U16	PhyStat)	/* PHY Status word to analyse */
+int		Port,		/* Port Index (MAC_1 + n) */
+SK_U16	IStatus)	/* Interrupt Status word to analyse */
 {
 	SK_GEPORT	*pPrt;
 
 	pPrt = &pAC->GIni.GP[Port];
 
 	if (pPrt->PLipaAutoNeg != SK_LIPA_AUTO &&
-		(PhyStat & (PHY_ST_AN_OVER))) {
+		(IStatus & (XM_IS_LIPA_RC | XM_IS_RX_PAGE | XM_IS_AND)) != 0) {
 
-		SK_DBG_MSG(pAC,SK_DBGMOD_HWM,SK_DBGCAT_CTRL,
-			("AutoNegLipa: AutoNeg detected on port %d %x\n", Port, PhyStat));
+		SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_CTRL,
+			("AutoNegLipa: AutoNeg detected on Port %d, IStatus=0x%04x\n",
+			Port, IStatus));
 		pPrt->PLipaAutoNeg = SK_LIPA_AUTO;
 	}
-}	/* SkXmAutoNegLipaLone*/
+}	/* SkXmAutoNegLipaXmac */
 
 
 /******************************************************************************
  *
- *	SkXmAutoNegLipaNat() - Decides whether Link Partner could do autoneg
+ *	SkMacAutoNegLipaPhy() - Decides whether Link Partner could do auto-neg
  *
- *	This function analyses the PHY status word. If any of the
- *	Autonegotiating bits are set, The PLipaAutoNeg variable
+ *	This function analyses the PHY status word.
+ *  If any of the Auto-negotiating bits are set, the PLipaAutoNeg variable
  *	is set true.
  */
-void	SkXmAutoNegLipaNat(
+void SkMacAutoNegLipaPhy(
 SK_AC	*pAC,		/* adapter context */
 SK_IOC	IoC,		/* IO context */
 int		Port,		/* Port Index (MAC_1 + n) */
@@ -1583,67 +2894,30 @@
 	pPrt = &pAC->GIni.GP[Port];
 
 	if (pPrt->PLipaAutoNeg != SK_LIPA_AUTO &&
-		(PhyStat & (PHY_ST_AN_OVER))) {
+		(PhyStat & PHY_ST_AN_OVER) != 0) {
 
-		SK_DBG_MSG(pAC,SK_DBGMOD_HWM,SK_DBGCAT_CTRL,
-			("AutoNegLipa: AutoNeg detected on port %d %x\n", Port, PhyStat));
+		SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_CTRL,
+			("AutoNegLipa: AutoNeg detected on Port %d, PhyStat=0x%04x\n",
+			Port, PhyStat));
 		pPrt->PLipaAutoNeg = SK_LIPA_AUTO;
 	}
-}	/* SkXmAutoNegLipaNat*/
+}	/* SkMacAutoNegLipaPhy */
+#endif /* SK_DIAG */
 
 
 /******************************************************************************
  *
- *	SkXmAutoNegDone() - Auto negotiation handling
+ *	SkXmAutoNegDoneXmac() - Auto-negotiation handling
  *
  * Description:
- *	This function handles the autonegotiation if the Done bit is set.
- *
- * Note:
- *	o The XMACs interrupt source register is NOT read here.
- *	o This function is public because it is used in the diagnostics
- *	  tool, too.
- *
- * Returns:
- *	SK_AND_OK	o.k.
- *	SK_AND_DUP_CAP 	Duplex capability error happened
- *	SK_AND_OTHER 	Other error happened
- */
-int	SkXmAutoNegDone(
-SK_AC	*pAC,		/* adapter context */
-SK_IOC	IoC,		/* IO context */
-int		Port)		/* Port Index (MAC_1 + n) */
-{
-	switch (pAC->GIni.GP[Port].PhyType) {
-	case SK_PHY_XMAC:
-		return (SkXmAutoNegDoneXmac(pAC, IoC, Port));
-	case SK_PHY_BCOM:
-		return (SkXmAutoNegDoneBcom(pAC, IoC, Port));
-	case SK_PHY_LONE:
-		return (SkXmAutoNegDoneLone(pAC, IoC, Port));
-	case SK_PHY_NAT:
-		return (SkXmAutoNegDoneNat(pAC, IoC, Port));
-	}
-	return (SK_AND_OTHER);
-}	/* SkXmAutoNegDone*/
-
-
-/******************************************************************************
- *
- *	SkXmAutoNegDoneXmac() - Auto negotiation handling
- *
- * Description:
- *	This function handles the autonegotiation if the Done bit is set.
- *
- * Note:
- *	o The XMACs interrupt source register is NOT read here.
+ *	This function handles the auto-negotiation if the Done bit is set.
  *
  * Returns:
  *	SK_AND_OK	o.k.
  *	SK_AND_DUP_CAP 	Duplex capability error happened
  *	SK_AND_OTHER 	Other error happened
  */
-static int	SkXmAutoNegDoneXmac(
+static int SkXmAutoNegDoneXmac(
 SK_AC	*pAC,		/* adapter context */
 SK_IOC	IoC,		/* IO context */
 int		Port)		/* Port Index (MAC_1 + n) */
@@ -1652,22 +2926,22 @@
 	SK_U16		ResAb;		/* Resolved Ability */
 	SK_U16		LPAb;		/* Link Partner Ability */
 
-	SK_DBG_MSG(pAC,SK_DBGMOD_HWM,SK_DBGCAT_CTRL, ("AutoNegDoneXmac"
-		"Port %d\n",Port));
+	SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_CTRL,
+		("AutoNegDoneXmac, Port %d\n",Port));
 
 	pPrt = &pAC->GIni.GP[Port];
 
 	/* Get PHY parameters */
-	PHY_READ(IoC, pPrt, Port, PHY_XMAC_AUNE_LP, &LPAb);
-	PHY_READ(IoC, pPrt, Port, PHY_XMAC_RES_ABI, &ResAb);
+	SkXmPhyRead(pAC, IoC, Port, PHY_XMAC_AUNE_LP, &LPAb);
+	SkXmPhyRead(pAC, IoC, Port, PHY_XMAC_RES_ABI, &ResAb);
 
-	if (LPAb & PHY_X_AN_RFB) {
+	if ((LPAb & PHY_X_AN_RFB) != 0) {
 		/* At least one of the remote fault bit is set */
 		/* Error */
-		SK_DBG_MSG(pAC,SK_DBGMOD_HWM,SK_DBGCAT_CTRL,
+		SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_CTRL,
 			("AutoNegFail: Remote fault bit set Port %d\n", Port));
 		pPrt->PAutoNegFail = SK_TRUE;
-		return (SK_AND_OTHER);
+		return(SK_AND_OTHER);
 	}
 
 	/* Check Duplex mismatch */
@@ -1679,10 +2953,10 @@
 	}
 	else {
 		/* Error */
-		SK_DBG_MSG(pAC,SK_DBGMOD_HWM,SK_DBGCAT_CTRL,
-			("AutoNegFail: Duplex mode mismatch port %d\n", Port));
+		SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_CTRL,
+			("AutoNegFail: Duplex mode mismatch Port %d\n", Port));
 		pPrt->PAutoNegFail = SK_TRUE;
-		return (SK_AND_DUP_CAP);
+		return(SK_AND_DUP_CAP);
 	}
 
 	/* Check PAUSE mismatch */
@@ -1690,7 +2964,7 @@
 	/* We are using IEEE 802.3z/D5.0 Table 37-4 */
 	if ((pPrt->PFlowCtrlMode == SK_FLOW_MODE_SYMMETRIC ||
 	     pPrt->PFlowCtrlMode == SK_FLOW_MODE_SYM_OR_REM) &&
-	    (LPAb & PHY_X_P_SYM_MD)) {
+	    (LPAb & PHY_X_P_SYM_MD) != 0) {
 		/* Symmetric PAUSE */
 		pPrt->PFlowCtrlStatus = SK_FLOW_STAT_SYMMETRIC;
 	}
@@ -1708,31 +2982,25 @@
 		/* PAUSE mismatch -> no PAUSE */
 		pPrt->PFlowCtrlStatus = SK_FLOW_STAT_NONE;
 	}
+	pPrt->PLinkSpeedUsed = SK_LSPEED_STAT_1000MBPS;
 
-	/* We checked everything and may now enable the link */
-	pPrt->PAutoNegFail = SK_FALSE;
-
-	SkXmRxTxEnable(pAC, IoC, Port);
-	return (SK_AND_OK);
-}	/* SkXmAutoNegDoneXmac*/
+	return(SK_AND_OK);
+}	/* SkXmAutoNegDoneXmac */
 
 
 /******************************************************************************
  *
- *	SkXmAutoNegDoneBcom() - Auto negotiation handling
+ *	SkXmAutoNegDoneBcom() - Auto-negotiation handling
  *
  * Description:
- *	This function handles the autonegotiation if the Done bit is set.
- *
- * Note:
- *	o The XMACs interrupt source register is NOT read here.
+ *	This function handles the auto-negotiation if the Done bit is set.
  *
  * Returns:
  *	SK_AND_OK	o.k.
  *	SK_AND_DUP_CAP 	Duplex capability error happened
  *	SK_AND_OTHER 	Other error happened
  */
-static int	SkXmAutoNegDoneBcom(
+static int SkXmAutoNegDoneBcom(
 SK_AC	*pAC,		/* adapter context */
 SK_IOC	IoC,		/* IO context */
 int		Port)		/* Port Index (MAC_1 + n) */
@@ -1741,110 +3009,204 @@
 	SK_U16		LPAb;		/* Link Partner Ability */
 	SK_U16		AuxStat;	/* Auxiliary Status */
 
-#if 0
+#ifdef TEST_ONLY
 01-Sep-2000 RA;:;:
 	SK_U16		ResAb;		/* Resolved Ability */
 #endif	/* 0 */
 
-	SK_DBG_MSG(pAC,SK_DBGMOD_HWM,SK_DBGCAT_CTRL,
+	SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_CTRL,
 		("AutoNegDoneBcom, Port %d\n", Port));
 	pPrt = &pAC->GIni.GP[Port];
 
-	/* Get PHY parameters. */
-	PHY_READ(IoC, pPrt, Port, PHY_BCOM_AUNE_LP, &LPAb);
-#if 0
+	/* Get PHY parameters */
+	SkXmPhyRead(pAC, IoC, Port, PHY_BCOM_AUNE_LP, &LPAb);
+#ifdef TEST_ONLY
 01-Sep-2000 RA;:;:
-	PHY_READ(IoC, pPrt, Port, PHY_BCOM_1000T_STAT, &ResAb);
+	SkXmPhyRead(pAC, IoC, Port, PHY_BCOM_1000T_STAT, &ResAb);
 #endif	/* 0 */
-	PHY_READ(IoC, pPrt, Port, PHY_BCOM_AUX_STAT, &AuxStat);
+	
+	SkXmPhyRead(pAC, IoC, Port, PHY_BCOM_AUX_STAT, &AuxStat);
 
-	if (LPAb & PHY_B_AN_RF) {
-		/* Remote fault bit is set: Error. */
+	if ((LPAb & PHY_B_AN_RF) != 0) {
+		/* Remote fault bit is set: Error */
 		SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_CTRL,
 			("AutoNegFail: Remote fault bit set Port %d\n", Port));
 		pPrt->PAutoNegFail = SK_TRUE;
-		return (SK_AND_OTHER);
+		return(SK_AND_OTHER);
 	}
 
-	/* Check Duplex mismatch. */
-	if ((AuxStat & PHY_B_AS_AN_RES) == PHY_B_RES_1000FD) {
+	/* Check Duplex mismatch */
+	if ((AuxStat & PHY_B_AS_AN_RES_MSK) == PHY_B_RES_1000FD) {
 		pPrt->PLinkModeStatus = SK_LMODE_STAT_AUTOFULL;
 	}
-	else if ((AuxStat & PHY_B_AS_AN_RES) == PHY_B_RES_1000HD) {
+	else if ((AuxStat & PHY_B_AS_AN_RES_MSK) == PHY_B_RES_1000HD) {
 		pPrt->PLinkModeStatus = SK_LMODE_STAT_AUTOHALF;
 	}
 	else {
-		/* Error. */
-		SK_DBG_MSG(pAC,SK_DBGMOD_HWM,SK_DBGCAT_CTRL,
-			("AutoNegFail: Duplex mode mismatch port %d\n", Port));
+		/* Error */
+		SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_CTRL,
+			("AutoNegFail: Duplex mode mismatch Port %d\n", Port));
 		pPrt->PAutoNegFail = SK_TRUE;
-		return (SK_AND_DUP_CAP);
+		return(SK_AND_DUP_CAP);
 	}
 	
-#if 0
+#ifdef TEST_ONLY
 01-Sep-2000 RA;:;:
-	/* Check Master/Slave resolution. */
-	if (ResAb & PHY_B_1000S_MSF) {
-		/* Error. */
+	/* Check Master/Slave resolution */
+	if ((ResAb & PHY_B_1000S_MSF) != 0) {
+		SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_CTRL,
+			("Master/Slave Fault Port %d\n", Port));
+		pPrt->PAutoNegFail = SK_TRUE;
+		pPrt->PMSStatus = SK_MS_STAT_FAULT;
+		return(SK_AND_OTHER);
+	}
+	
+	pPrt->PMSStatus = ((ResAb & PHY_B_1000S_MSR) != 0) ?
+		SK_MS_STAT_MASTER : SK_MS_STAT_SLAVE;
+#endif	/* 0 */
+
+	/* Check PAUSE mismatch ??? */
+	/* We are using IEEE 802.3z/D5.0 Table 37-4 */
+	if ((AuxStat & PHY_B_AS_PAUSE_MSK) == PHY_B_AS_PAUSE_MSK) {
+		/* Symmetric PAUSE */
+		pPrt->PFlowCtrlStatus = SK_FLOW_STAT_SYMMETRIC;
+	}
+	else if ((AuxStat & PHY_B_AS_PAUSE_MSK) == PHY_B_AS_PRR) {
+		/* Enable PAUSE receive, disable PAUSE transmit */
+		pPrt->PFlowCtrlStatus = SK_FLOW_STAT_REM_SEND;
+	}
+	else if ((AuxStat & PHY_B_AS_PAUSE_MSK) == PHY_B_AS_PRT) {
+		/* Disable PAUSE receive, enable PAUSE transmit */
+		pPrt->PFlowCtrlStatus = SK_FLOW_STAT_LOC_SEND;
+	}
+	else {
+		/* PAUSE mismatch -> no PAUSE */
+		pPrt->PFlowCtrlStatus = SK_FLOW_STAT_NONE;
+	}
+	pPrt->PLinkSpeedUsed = SK_LSPEED_STAT_1000MBPS;
+
+	return(SK_AND_OK);
+}	/* SkXmAutoNegDoneBcom */
+
+
+/******************************************************************************
+ *
+ *	SkGmAutoNegDoneMarv() - Auto-negotiation handling
+ *
+ * Description:
+ *	This function handles the auto-negotiation if the Done bit is set.
+ *
+ * Returns:
+ *	SK_AND_OK	o.k.
+ *	SK_AND_DUP_CAP 	Duplex capability error happened
+ *	SK_AND_OTHER 	Other error happened
+ */
+static int SkGmAutoNegDoneMarv(
+SK_AC	*pAC,		/* adapter context */
+SK_IOC	IoC,		/* IO context */
+int		Port)		/* Port Index (MAC_1 + n) */
+{
+	SK_GEPORT	*pPrt;
+	SK_U16		LPAb;		/* Link Partner Ability */
+	SK_U16		ResAb;		/* Resolved Ability */
+	SK_U16		AuxStat;	/* Auxiliary Status */
+
+	SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_CTRL,
+		("AutoNegDoneMarv, Port %d\n", Port));
+	pPrt = &pAC->GIni.GP[Port];
+
+	/* Get PHY parameters */
+	SkGmPhyRead(pAC, IoC, Port, PHY_MARV_AUNE_LP, &LPAb);
+	
+	if ((LPAb & PHY_M_AN_RF) != 0) {
+		SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_CTRL,
+			("AutoNegFail: Remote fault bit set Port %d\n", Port));
+		pPrt->PAutoNegFail = SK_TRUE;
+		return(SK_AND_OTHER);
+	}
+
+	SkGmPhyRead(pAC, IoC, Port, PHY_MARV_1000T_STAT, &ResAb);
+	
+	/* Check Master/Slave resolution */
+	if ((ResAb & PHY_B_1000S_MSF) != 0) {
 		SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_CTRL,
-			("Master/Slave Fault port %d\n", Port));
+			("Master/Slave Fault Port %d\n", Port));
 		pPrt->PAutoNegFail = SK_TRUE;
 		pPrt->PMSStatus = SK_MS_STAT_FAULT;
-		return (SK_AND_OTHER);
+		return(SK_AND_OTHER);
+	}
+	
+	pPrt->PMSStatus = ((ResAb & PHY_B_1000S_MSR) != 0) ?
+		(SK_U8)SK_MS_STAT_MASTER : (SK_U8)SK_MS_STAT_SLAVE;
+	
+	/* Read PHY Specific Status */
+	SkGmPhyRead(pAC, IoC, Port, PHY_MARV_PHY_STAT, &AuxStat);
+	
+	/* Check Speed & Duplex resolved */
+	if ((AuxStat & PHY_M_PS_SPDUP_RES) == 0) {
+		SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_CTRL,
+			("AutoNegFail: Speed & Duplex not resolved Port %d\n", Port));
+		pPrt->PAutoNegFail = SK_TRUE;
+		pPrt->PLinkModeStatus = SK_LMODE_STAT_UNKNOWN;
+		return(SK_AND_DUP_CAP);
 	}
-	else if (ResAb & PHY_B_1000S_MSR) {
-		pPrt->PMSStatus = SK_MS_STAT_MASTER;
+	
+	if ((AuxStat & PHY_M_PS_FULL_DUP) != 0) {
+		pPrt->PLinkModeStatus = SK_LMODE_STAT_AUTOFULL;
 	}
 	else {
-		pPrt->PMSStatus = SK_MS_STAT_SLAVE;
+		pPrt->PLinkModeStatus = SK_LMODE_STAT_AUTOHALF;
 	}
-#endif	/* 0 */
-
-	/* Check PAUSE mismatch. */
-	/* We are NOT using chapter 4.23 of the Xaqti manual. */
-	/* We are using IEEE 802.3z/D5.0 Table 37-4. */
-	if ((AuxStat & (PHY_B_AS_PRR | PHY_B_AS_PRT)) == 
-		(PHY_B_AS_PRR | PHY_B_AS_PRT)) {
-		/* Symmetric PAUSE. */
+	
+	/* Check PAUSE mismatch ??? */
+	/* We are using IEEE 802.3z/D5.0 Table 37-4 */
+	if ((AuxStat & PHY_M_PS_PAUSE_MSK) == PHY_M_PS_PAUSE_MSK) {
+		/* Symmetric PAUSE */
 		pPrt->PFlowCtrlStatus = SK_FLOW_STAT_SYMMETRIC;
 	}
-	else if ((AuxStat & (PHY_B_AS_PRR | PHY_B_AS_PRT)) == PHY_B_AS_PRR) {
-		/* Enable PAUSE receive, disable PAUSE transmit. */
+	else if ((AuxStat & PHY_M_PS_PAUSE_MSK) == PHY_M_PS_RX_P_EN) {
+		/* Enable PAUSE receive, disable PAUSE transmit */
 		pPrt->PFlowCtrlStatus = SK_FLOW_STAT_REM_SEND;
 	}
-	else if ((AuxStat & (PHY_B_AS_PRR | PHY_B_AS_PRT)) == PHY_B_AS_PRT) {
-		/* Disable PAUSE receive, enable PAUSE transmit. */
+	else if ((AuxStat & PHY_M_PS_PAUSE_MSK) == PHY_M_PS_TX_P_EN) {
+		/* Disable PAUSE receive, enable PAUSE transmit */
 		pPrt->PFlowCtrlStatus = SK_FLOW_STAT_LOC_SEND;
 	}
 	else {
-		/* PAUSE mismatch -> no PAUSE. */
+		/* PAUSE mismatch -> no PAUSE */
 		pPrt->PFlowCtrlStatus = SK_FLOW_STAT_NONE;
 	}
+	
+	/* set used link speed */
+	switch ((unsigned)(AuxStat & PHY_M_PS_SPEED_MSK)) {
+	case (unsigned)PHY_M_PS_SPEED_1000:
+		pPrt->PLinkSpeedUsed = SK_LSPEED_STAT_1000MBPS;
+		break;
+	case PHY_M_PS_SPEED_100:
+		pPrt->PLinkSpeedUsed = SK_LSPEED_STAT_100MBPS;
+		break;
+	default:
+		pPrt->PLinkSpeedUsed = SK_LSPEED_STAT_10MBPS;
+	}
 
-	/* We checked everything and may now enable the link. */
-	pPrt->PAutoNegFail = SK_FALSE;
-
-	SkXmRxTxEnable(pAC, IoC, Port);
-	return (SK_AND_OK);
-}	/* SkXmAutoNegDoneBcom*/
+	return(SK_AND_OK);
+}	/* SkGmAutoNegDoneMarv */
 
 
+#ifdef OTHER_PHY
 /******************************************************************************
  *
- *	SkXmAutoNegDoneLone() - Auto negotiation handling
+ *	SkXmAutoNegDoneLone() - Auto-negotiation handling
  *
  * Description:
- *	This function handles the autonegotiation if the Done bit is set.
- *
- * Note:
- *	o The XMACs interrupt source register is NOT read here.
+ *	This function handles the auto-negotiation if the Done bit is set.
  *
  * Returns:
  *	SK_AND_OK	o.k.
  *	SK_AND_DUP_CAP 	Duplex capability error happened
  *	SK_AND_OTHER 	Other error happened
  */
-static int	SkXmAutoNegDoneLone(
+static int SkXmAutoNegDoneLone(
 SK_AC	*pAC,		/* adapter context */
 SK_IOC	IoC,		/* IO context */
 int		Port)		/* Port Index (MAC_1 + n) */
@@ -1854,26 +3216,26 @@
 	SK_U16		LPAb;		/* Link Partner Ability */
 	SK_U16		QuickStat;	/* Auxiliary Status */
 
-	SK_DBG_MSG(pAC,SK_DBGMOD_HWM,SK_DBGCAT_CTRL, ("AutoNegDoneLone"
-		"Port %d\n",Port));
+	SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_CTRL,
+		("AutoNegDoneLone, Port %d\n",Port));
 	pPrt = &pAC->GIni.GP[Port];
 
 	/* Get PHY parameters */
-	PHY_READ(IoC, pPrt, Port, PHY_LONE_AUNE_LP, &LPAb);
-	PHY_READ(IoC, pPrt, Port, PHY_LONE_1000T_STAT, &ResAb);
-	PHY_READ(IoC, pPrt, Port, PHY_LONE_Q_STAT, &QuickStat);
+	SkXmPhyRead(pAC, IoC, Port, PHY_LONE_AUNE_LP, &LPAb);
+	SkXmPhyRead(pAC, IoC, Port, PHY_LONE_1000T_STAT, &ResAb);
+	SkXmPhyRead(pAC, IoC, Port, PHY_LONE_Q_STAT, &QuickStat);
 
-	if (LPAb & PHY_L_AN_RF) {
+	if ((LPAb & PHY_L_AN_RF) != 0) {
 		/* Remote fault bit is set */
 		/* Error */
-		SK_DBG_MSG(pAC,SK_DBGMOD_HWM,SK_DBGCAT_CTRL,
+		SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_CTRL,
 			("AutoNegFail: Remote fault bit set Port %d\n", Port));
 		pPrt->PAutoNegFail = SK_TRUE;
-		return (SK_AND_OTHER);
+		return(SK_AND_OTHER);
 	}
 
 	/* Check Duplex mismatch */
-	if (QuickStat & PHY_L_QS_DUP_MOD) {
+	if ((QuickStat & PHY_L_QS_DUP_MOD) != 0) {
 		pPrt->PLinkModeStatus = SK_LMODE_STAT_AUTOFULL;
 	}
 	else {
@@ -1881,13 +3243,13 @@
 	}
 	
 	/* Check Master/Slave resolution */
-	if (ResAb & (PHY_L_1000S_MSF)) {
+	if ((ResAb & PHY_L_1000S_MSF) != 0) {
 		/* Error */
-		SK_DBG_MSG(pAC,SK_DBGMOD_HWM,SK_DBGCAT_CTRL,
-			("Master/Slave Fault port %d\n", Port));
+		SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_CTRL,
+			("Master/Slave Fault Port %d\n", Port));
 		pPrt->PAutoNegFail = SK_TRUE;
 		pPrt->PMSStatus = SK_MS_STAT_FAULT;
-		return (SK_AND_OTHER);
+		return(SK_AND_OTHER);
 	}
 	else if (ResAb & PHY_L_1000S_MSR) {
 		pPrt->PMSStatus = SK_MS_STAT_MASTER;
@@ -1897,7 +3259,6 @@
 	}
 
 	/* Check PAUSE mismatch */
-	/* We are NOT using chapter 4.23 of the Xaqti manual */
 	/* We are using IEEE 802.3z/D5.0 Table 37-4 */
 	/* we must manually resolve the abilities here */
 	pPrt->PFlowCtrlStatus = SK_FLOW_STAT_NONE;
@@ -1913,7 +3274,7 @@
 		}
 		break;
 	case SK_FLOW_MODE_SYMMETRIC:
-		if ((QuickStat & PHY_L_QS_PAUSE) == PHY_L_QS_PAUSE) {
+		if ((QuickStat & PHY_L_QS_PAUSE) != 0) {
 			/* Symmetric PAUSE */
 			pPrt->PFlowCtrlStatus = SK_FLOW_STAT_SYMMETRIC;
 		}
@@ -1924,154 +3285,546 @@
 			/* Enable PAUSE receive, disable PAUSE transmit */
 			pPrt->PFlowCtrlStatus = SK_FLOW_STAT_REM_SEND;
 		}
-		else if ((QuickStat & PHY_L_QS_PAUSE) == PHY_L_QS_PAUSE) {
+		else if ((QuickStat & PHY_L_QS_PAUSE) != 0) {
 			/* Symmetric PAUSE */
 			pPrt->PFlowCtrlStatus = SK_FLOW_STAT_SYMMETRIC;
 		}
 		break;
 	default:
-		SK_ERR_LOG(pAC, SK_ERRCL_SW | SK_ERRCL_INIT,
-			SKERR_HWI_E016, SKERR_HWI_E016MSG);
+		SK_ERR_LOG(pAC, SK_ERRCL_SW | SK_ERRCL_INIT, SKERR_HWI_E016,
+			SKERR_HWI_E016MSG);
 	}
-
-	/* We checked everything and may now enable the link */
-	pPrt->PAutoNegFail = SK_FALSE;
-
-	SkXmRxTxEnable(pAC, IoC, Port);
-	return (SK_AND_OK);
+	
+	return(SK_AND_OK);
 }	/* SkXmAutoNegDoneLone */
 
 
 /******************************************************************************
  *
- *	SkXmAutoNegDoneNat() - Auto negotiation handling
+ *	SkXmAutoNegDoneNat() - Auto-negotiation handling
  *
  * Description:
- *	This function handles the autonegotiation if the Done bit is set.
- *
- * Note:
- *	o The XMACs interrupt source register is NOT read here.
- *	o This function is public because it is used in the diagnostics
- *	  tool, too.
+ *	This function handles the auto-negotiation if the Done bit is set.
  *
  * Returns:
  *	SK_AND_OK	o.k.
  *	SK_AND_DUP_CAP 	Duplex capability error happened
  *	SK_AND_OTHER 	Other error happened
  */
-static int	SkXmAutoNegDoneNat(
+static int SkXmAutoNegDoneNat(
 SK_AC	*pAC,		/* adapter context */
 SK_IOC	IoC,		/* IO context */
 int		Port)		/* Port Index (MAC_1 + n) */
 {
 /* todo: National */
-	return (SK_AND_OK);
-}	/* SkXmAutoNegDoneNat*/
+	return(SK_AND_OK);
+}	/* SkXmAutoNegDoneNat */
+#endif /* OTHER_PHY */
+
+
+/******************************************************************************
+ *
+ *	SkMacAutoNegDone() - Auto-negotiation handling
+ *
+ * Description:	calls the auto-negotiation done routines dep. on board type
+ *
+ * Returns:
+ *	SK_AND_OK	o.k.
+ *	SK_AND_DUP_CAP 	Duplex capability error happened
+ *	SK_AND_OTHER 	Other error happened
+ */
+int	SkMacAutoNegDone(
+SK_AC	*pAC,		/* adapter context */
+SK_IOC	IoC,		/* IO context */
+int		Port)		/* Port Index (MAC_1 + n) */
+{
+	SK_GEPORT	*pPrt;
+	int	Rtv;
+
+	pPrt = &pAC->GIni.GP[Port];
+
+	if (pAC->GIni.GIGenesis) {
+		switch (pPrt->PhyType) {
+		case SK_PHY_XMAC:
+			Rtv = SkXmAutoNegDoneXmac(pAC, IoC, Port);
+			break;
+		case SK_PHY_BCOM:
+			Rtv = SkXmAutoNegDoneBcom(pAC, IoC, Port);
+			break;
+#ifdef OTHER_PHY
+		case SK_PHY_LONE:
+			Rtv = SkXmAutoNegDoneLone(pAC, IoC, Port);
+			break;
+		case SK_PHY_NAT:
+			Rtv = SkXmAutoNegDoneNat(pAC, IoC, Port);
+			break;
+#endif /* OTHER_PHY */
+		default:
+			return(SK_AND_OTHER);
+		}
+	}
+	else {
+		Rtv = SkGmAutoNegDoneMarv(pAC, IoC, Port);
+	}
+	
+	if (Rtv != SK_AND_OK) {
+		return(Rtv);
+	}
+
+	/* We checked everything and may now enable the link */
+	pPrt->PAutoNegFail = SK_FALSE;
+
+	SkMacRxTxEnable(pAC, IoC, Port);
+	
+	return(SK_AND_OK);
+}	/* SkMacAutoNegDone */
 
 
 /******************************************************************************
  *
- *	SkXmRxTxEnable() - Enable RxTx activity if port is up
+ *	SkXmSetRxTxEn() - Special Set Rx/Tx Enable and some features in XMAC
  *
  * Description:
+ *  sets MAC or PHY LoopBack and Duplex Mode in the MMU Command Reg.
+ *  enables Rx/Tx
  *
- * Note:
- *	o The XMACs interrupt source register is NOT read here.
+ * Returns: N/A
+ */
+static void SkXmSetRxTxEn(
+SK_AC	*pAC,		/* Adapter Context */
+SK_IOC	IoC,		/* IO context */
+int		Port,		/* Port Index (MAC_1 + n) */
+int		Para)		/* Parameter to set: MAC or PHY LoopBack, Duplex Mode */
+{
+	SK_U16	Word;
+
+	XM_IN16(IoC, Port, XM_MMU_CMD, &Word);
+
+	switch (Para & (SK_MAC_LOOPB_ON | SK_MAC_LOOPB_OFF)) {
+	case SK_MAC_LOOPB_ON:
+		Word |= XM_MMU_MAC_LB;
+		break;
+	case SK_MAC_LOOPB_OFF:
+		Word &= ~XM_MMU_MAC_LB;
+		break;
+	}
+
+	switch (Para & (SK_PHY_LOOPB_ON | SK_PHY_LOOPB_OFF)) {
+	case SK_PHY_LOOPB_ON:
+		Word |= XM_MMU_GMII_LOOP;
+		break;
+	case SK_PHY_LOOPB_OFF:
+		Word &= ~XM_MMU_GMII_LOOP;
+		break;
+	}
+	
+	switch (Para & (SK_PHY_FULLD_ON | SK_PHY_FULLD_OFF)) {
+	case SK_PHY_FULLD_ON:
+		Word |= XM_MMU_GMII_FD;
+		break;
+	case SK_PHY_FULLD_OFF:
+		Word &= ~XM_MMU_GMII_FD;
+		break;
+	}
+	
+	XM_OUT16(IoC, Port, XM_MMU_CMD, Word | XM_MMU_ENA_RX | XM_MMU_ENA_TX);
+
+	/* dummy read to ensure writing */
+	XM_IN16(IoC, Port, XM_MMU_CMD, &Word);
+
+}	/* SkXmSetRxTxEn */
+
+
+/******************************************************************************
+ *
+ *	SkGmSetRxTxEn() - Special Set Rx/Tx Enable and some features in GMAC
+ *
+ * Description:
+ *  sets MAC LoopBack and Duplex Mode in the General Purpose Control Reg.
+ *  enables Rx/Tx
+ *
+ * Returns: N/A
+ */
+static void SkGmSetRxTxEn(
+SK_AC	*pAC,		/* Adapter Context */
+SK_IOC	IoC,		/* IO context */
+int		Port,		/* Port Index (MAC_1 + n) */
+int		Para)		/* Parameter to set: MAC LoopBack, Duplex Mode */
+{
+	SK_U16	Ctrl;
+	
+	GM_IN16(IoC, Port, GM_GP_CTRL, &Ctrl);
+
+	switch (Para & (SK_MAC_LOOPB_ON | SK_MAC_LOOPB_OFF)) {
+	case SK_MAC_LOOPB_ON:
+		Ctrl |= GM_GPCR_LOOP_ENA;
+		break;
+	case SK_MAC_LOOPB_OFF:
+		Ctrl &= ~GM_GPCR_LOOP_ENA;
+		break;
+	}
+
+	switch (Para & (SK_PHY_FULLD_ON | SK_PHY_FULLD_OFF)) {
+	case SK_PHY_FULLD_ON:
+		Ctrl |= GM_GPCR_DUP_FULL;
+		break;
+	case SK_PHY_FULLD_OFF:
+		Ctrl &= ~GM_GPCR_DUP_FULL;
+		break;
+	}
+	
+	GM_OUT16(IoC, Port, GM_GP_CTRL, Ctrl | GM_GPCR_RX_ENA | GM_GPCR_TX_ENA);
+
+	/* dummy read to ensure writing */
+	GM_IN16(IoC, Port, GM_GP_CTRL, &Ctrl);
+
+}	/* SkGmSetRxTxEn */
+
+
+/******************************************************************************
+ *
+ *	SkMacSetRxTxEn() - Special Set Rx/Tx Enable and parameters
+ *
+ * Description:	calls the Special Set Rx/Tx Enable routines dep. on board type
+ *
+ * Returns: N/A
+ */
+void SkMacSetRxTxEn(
+SK_AC	*pAC,		/* Adapter Context */
+SK_IOC	IoC,		/* IO context */
+int		Port,		/* Port Index (MAC_1 + n) */
+int		Para)
+{
+	if (pAC->GIni.GIGenesis) {
+		
+		SkXmSetRxTxEn(pAC, IoC, Port, Para);
+	}
+	else {
+		
+		SkGmSetRxTxEn(pAC, IoC, Port, Para);
+	}
+
+}	/* SkMacSetRxTxEn */
+
+
+/******************************************************************************
+ *
+ *	SkMacRxTxEnable() - Enable Rx/Tx activity if port is up
+ *
+ * Description:	enables Rx/Tx dep. on board type
  *
  * Returns:
  *	0	o.k.
  *	!= 0	Error happened
  */
-int SkXmRxTxEnable(
+int SkMacRxTxEnable(
 SK_AC	*pAC,		/* adapter context */
 SK_IOC	IoC,		/* IO context */
 int		Port)		/* Port Index (MAC_1 + n) */
 {
 	SK_GEPORT	*pPrt;
-	SK_U16		Reg;		/* 16bit register value */
-	SK_U16		IntMask;	/* XMac interrupt mask */
+	SK_U16		Reg;		/* 16-bit register value */
+	SK_U16		IntMask;	/* MAC interrupt mask */
 	SK_U16		SWord;
 
 	pPrt = &pAC->GIni.GP[Port];
 
 	if (!pPrt->PHWLinkUp) {
 		/* The Hardware link is NOT up */
-		return (0);
+		return(0);
 	}
 
 	if ((pPrt->PLinkMode == SK_LMODE_AUTOHALF ||
 	     pPrt->PLinkMode == SK_LMODE_AUTOFULL ||
 	     pPrt->PLinkMode == SK_LMODE_AUTOBOTH) &&
 	     pPrt->PAutoNegFail) {
-		/* Autonegotiation is not done or failed */
-		return (0);
+		/* Auto-negotiation is not done or failed */
+		return(0);
 	}
 
-	/* Set Dup Mode and Pause Mode */
-	SkXmInitDupMd (pAC, IoC, Port);
-	SkXmInitPauseMd (pAC, IoC, Port);
-
-	/*
-	 * Initialize the Interrupt Mask Register. Default IRQs are...
-	 *	- Link Asynchronous Event
-	 *	- Link Partner requests config
-	 *	- Auto Negotiation Done
-	 *	- Rx Counter Event Overflow
-	 *	- Tx Counter Event Overflow
-	 *	- Transmit FIFO Underrun
-	 */
-	if (pPrt->PhyType == SK_PHY_XMAC) {
+	if (pAC->GIni.GIGenesis) {
+		/* set Duplex Mode and Pause Mode */
+		SkXmInitDupMd(pAC, IoC, Port);
+		
+		SkXmInitPauseMd(pAC, IoC, Port);
+	
+		/*
+		 * Initialize the Interrupt Mask Register. Default IRQs are...
+		 *	- Link Asynchronous Event
+		 *	- Link Partner requests config
+		 *	- Auto Negotiation Done
+		 *	- Rx Counter Event Overflow
+		 *	- Tx Counter Event Overflow
+		 *	- Transmit FIFO Underrun
+		 */
 		IntMask = XM_DEF_MSK;
+
+#ifdef DEBUG
+		/* add IRQ for Receive FIFO Overflow */
+		IntMask &= ~XM_IS_RXF_OV;
+#endif /* DEBUG */
+		
+		if (pPrt->PhyType != SK_PHY_XMAC) {
+			/* disable GP0 interrupt bit */
+			IntMask |= XM_IS_INP_ASS;
+		}
+		XM_OUT16(IoC, Port, XM_IMSK, IntMask);
+	
+		/* get MMU Command Reg. */
+		XM_IN16(IoC, Port, XM_MMU_CMD, &Reg);
+		
+		if (pPrt->PhyType != SK_PHY_XMAC &&
+			(pPrt->PLinkModeStatus == SK_LMODE_STAT_FULL ||
+			 pPrt->PLinkModeStatus == SK_LMODE_STAT_AUTOFULL)) {
+			/* set to Full Duplex */
+			Reg |= XM_MMU_GMII_FD;
+		}
+		
+		switch (pPrt->PhyType) {
+		case SK_PHY_BCOM:
+			/*
+			 * Workaround BCOM Errata (#10523) for all BCom Phys
+			 * Enable Power Management after link up
+			 */
+			SkXmPhyRead(pAC, IoC, Port, PHY_BCOM_AUX_CTRL, &SWord);
+			SkXmPhyWrite(pAC, IoC, Port, PHY_BCOM_AUX_CTRL,
+				(SK_U16)(SWord & ~PHY_B_AC_DIS_PM));
+			SkXmPhyWrite(pAC, IoC, Port, PHY_BCOM_INT_MASK, PHY_B_DEF_MSK);
+			break;
+#ifdef OTHER_PHY
+		case SK_PHY_LONE:
+			SkXmPhyWrite(pAC, IoC, Port, PHY_LONE_INT_ENAB, PHY_L_DEF_MSK);
+			break;
+		case SK_PHY_NAT:
+			/* todo National:
+			SkXmPhyWrite(pAC, IoC, Port, PHY_NAT_INT_MASK, PHY_N_DEF_MSK); */
+			/* no interrupts possible from National ??? */
+			break;
+#endif /* OTHER_PHY */
+		}
+		
+		/* enable Rx/Tx */
+		XM_OUT16(IoC, Port, XM_MMU_CMD, Reg | XM_MMU_ENA_RX | XM_MMU_ENA_TX);
+	}
+	else {
+		/*
+		 * Initialize the Interrupt Mask Register. Default IRQs are...
+		 *	- Rx Counter Event Overflow
+		 *	- Tx Counter Event Overflow
+		 *	- Transmit FIFO Underrun
+		 */
+		IntMask = GMAC_DEF_MSK;
+
+#ifdef DEBUG
+		/* add IRQ for Receive FIFO Overrun */
+		IntMask |= GM_IS_RX_FF_OR;
+#endif /* DEBUG */
+		
+		SK_OUT8(IoC, GMAC_IRQ_MSK, (SK_U8)IntMask);
+		
+		/* get General Purpose Control */
+		GM_IN16(IoC, Port, GM_GP_CTRL, &Reg);
+		
+		if (pPrt->PLinkModeStatus == SK_LMODE_STAT_FULL ||
+			pPrt->PLinkModeStatus == SK_LMODE_STAT_AUTOFULL) {
+			/* set to Full Duplex */
+			Reg |= GM_GPCR_DUP_FULL;
+		}
+		
+		/* enable Rx/Tx */
+		GM_OUT16(IoC, Port, GM_GP_CTRL, Reg | GM_GPCR_RX_ENA | GM_GPCR_TX_ENA);
+
+#ifndef VCPU
+		/* Enable all PHY interrupts */
+		SkGmPhyWrite(pAC, IoC, Port, PHY_MARV_INT_MASK, PHY_M_DEF_MSK);
+#endif /* VCPU */
+	}
+					
+	return(0);
+
+}	/* SkMacRxTxEnable */
+
+
+/******************************************************************************
+ *
+ *	SkMacRxTxDisable() - Disable Receiver and Transmitter
+ *
+ * Description:	disables Rx/Tx dep. on board type
+ *
+ * Returns: N/A
+ */
+void SkMacRxTxDisable(
+SK_AC	*pAC,		/* Adapter Context */
+SK_IOC	IoC,		/* IO context */
+int		Port)		/* Port Index (MAC_1 + n) */
+{
+	SK_U16	Word;
+
+	if (pAC->GIni.GIGenesis) {
+		
+		XM_IN16(IoC, Port, XM_MMU_CMD, &Word);
+		
+		XM_OUT16(IoC, Port, XM_MMU_CMD, Word & ~(XM_MMU_ENA_RX | XM_MMU_ENA_TX));
+	
+		/* dummy read to ensure writing */
+		XM_IN16(IoC, Port, XM_MMU_CMD, &Word);
+	}
+	else {
+		
+		GM_IN16(IoC, Port, GM_GP_CTRL, &Word);
+
+		GM_OUT16(IoC, Port, GM_GP_CTRL, Word & ~(GM_GPCR_RX_ENA | GM_GPCR_TX_ENA));
+
+		/* dummy read to ensure writing */
+		GM_IN16(IoC, Port, GM_GP_CTRL, &Word);
+	}
+}	/* SkMacRxTxDisable */
+
+
+/******************************************************************************
+ *
+ *	SkMacIrqDisable() - Disable IRQ from MAC
+ *
+ * Description:	sets the IRQ-mask to disable IRQ dep. on board type
+ *
+ * Returns: N/A
+ */
+void SkMacIrqDisable(
+SK_AC	*pAC,		/* Adapter Context */
+SK_IOC	IoC,		/* IO context */
+int		Port)		/* Port Index (MAC_1 + n) */
+{
+	SK_GEPORT	*pPrt;
+	SK_U16		Word;
+
+	pPrt = &pAC->GIni.GP[Port];
+
+	if (pAC->GIni.GIGenesis) {
+		
+		/* disable all XMAC IRQs */
+		XM_OUT16(IoC, Port, XM_IMSK, 0xffff);	
+		
+		/* Disable all PHY interrupts */
+		switch (pPrt->PhyType) {
+			case SK_PHY_BCOM:
+				/* Make sure that PHY is initialized */
+				if (pPrt->PState != SK_PRT_RESET) {
+					/* NOT allowed if BCOM is in RESET state */
+					/* Workaround BCOM Errata (#10523) all BCom */
+					/* Disable Power Management if link is down */
+					SkXmPhyRead(pAC, IoC, Port, PHY_BCOM_AUX_CTRL, &Word);
+					SkXmPhyWrite(pAC, IoC, Port, PHY_BCOM_AUX_CTRL,
+						(SK_U16)(Word | PHY_B_AC_DIS_PM));
+					SkXmPhyWrite(pAC, IoC, Port, PHY_BCOM_INT_MASK, 0xffff);
+				}
+				break;
+#ifdef OTHER_PHY
+			case SK_PHY_LONE:
+				SkXmPhyWrite(pAC, IoC, Port, PHY_LONE_INT_ENAB, 0);
+				break;
+			case SK_PHY_NAT:
+				/* todo: National
+				SkXmPhyWrite(pAC, IoC, Port, PHY_NAT_INT_MASK, 0xffff); */
+				break;
+#endif /* OTHER_PHY */
+		}
+	}
+	else {
+		/* disable all GMAC IRQs */
+		SK_OUT8(IoC, GMAC_IRQ_MSK, 0);
+		
+#ifndef VCPU
+		/* Disable all PHY interrupts */
+		SkGmPhyWrite(pAC, IoC, Port, PHY_MARV_INT_MASK, 0);
+#endif /* VCPU */
+	}
+}	/* SkMacIrqDisable */
+
+
+#ifdef SK_DIAG
+/******************************************************************************
+ *
+ *	SkXmSendCont() - Enable / Disable Send Continuous Mode
+ *
+ * Description:	enable / disable Send Continuous Mode on XMAC
+ *
+ * Returns:
+ *	nothing
+ */
+void SkXmSendCont(
+SK_AC	*pAC,	/* adapter context */
+SK_IOC	IoC,	/* IO context */
+int		Port,	/* Port Index (MAC_1 + n) */
+SK_BOOL	Enable)	/* Enable / Disable */
+{
+	SK_U32	MdReg;
+
+	XM_IN32(IoC, Port, XM_MODE, &MdReg);
+
+	if (Enable) {
+		MdReg |= XM_MD_TX_CONT;
+	}
+	else {
+		MdReg &= ~XM_MD_TX_CONT;
+	}
+	/* setup Mode Register */
+	XM_OUT32(IoC, Port, XM_MODE, MdReg);
+
+}	/* SkXmSendCont*/
+
+/******************************************************************************
+ *
+ *	SkMacTimeStamp() - Enable / Disable Time Stamp
+ *
+ * Description:	enable / disable Time Stamp generation for Rx packets
+ *
+ * Returns:
+ *	nothing
+ */
+void SkMacTimeStamp(
+SK_AC	*pAC,	/* adapter context */
+SK_IOC	IoC,	/* IO context */
+int		Port,	/* Port Index (MAC_1 + n) */
+SK_BOOL	Enable)	/* Enable / Disable */
+{
+	SK_U32	MdReg;
+	SK_U8	TimeCtrl;
+
+	if (pAC->GIni.GIGenesis) {
+
+		XM_IN32(IoC, Port, XM_MODE, &MdReg);
+
+		if (Enable) {
+			MdReg |= XM_MD_ATS;
+		}
+		else {
+			MdReg &= ~XM_MD_ATS;
+		}
+		/* setup Mode Register */
+		XM_OUT32(IoC, Port, XM_MODE, MdReg);
 	}
 	else {
-		/* disable GP0 interrupt bit */
-		IntMask = XM_DEF_MSK | XM_IS_INP_ASS;
-	}
-	XM_OUT16(IoC, Port, XM_IMSK, IntMask);
-
-	/* RX/TX enable */
-	XM_IN16(IoC, Port, XM_MMU_CMD, &Reg);
-	if (pPrt->PhyType != SK_PHY_XMAC &&
-		(pPrt->PLinkModeStatus == SK_LMODE_STAT_FULL || 
-		 pPrt->PLinkModeStatus == SK_LMODE_STAT_AUTOFULL)) {
-		Reg |= XM_MMU_GMII_FD;
+		if (Enable) {
+			TimeCtrl = GMT_ST_START | GMT_ST_CLR_IRQ;
+		}
+		else {
+			TimeCtrl = GMT_ST_STOP | GMT_ST_CLR_IRQ;
+		}
+		/* Start/Stop Time Stamp Timer */
+		SK_OUT8(IoC, GMAC_TI_ST_CTRL, TimeCtrl);
 	}
-	switch (pPrt->PhyType) {
-	case SK_PHY_BCOM:
-		/* Workaround BCOM Errata (#10523) for all BCom Phys */
-		/* Enable Power Management after link up */
-		PHY_READ(IoC, pPrt, Port, PHY_BCOM_AUX_CTRL, &SWord);
-		PHY_WRITE(IoC, pPrt, Port, PHY_BCOM_AUX_CTRL, SWord & ~PHY_B_AC_DIS_PM);
-		PHY_WRITE(IoC, pPrt, Port, PHY_BCOM_INT_MASK, PHY_B_DEF_MSK);
-		break;
-	case SK_PHY_LONE:
-		PHY_WRITE(IoC, pPrt, Port, PHY_LONE_INT_ENAB, PHY_L_DEF_MSK);
-		break;
-	case SK_PHY_NAT:
-		/* todo National:
-		PHY_WRITE(IoC, pPrt, Port, PHY_NAT_INT_MASK, 
-			PHY_N_DEF_MSK); */
-		/* no interrupts possible from National ??? */
-		break;
-	}
-	XM_OUT16(IoC, Port, XM_MMU_CMD, Reg | XM_MMU_ENA_RX | XM_MMU_ENA_TX);
-				      
-	return (0);
-}	/* SkXmRxTxEnable*/
+}	/* SkMacTimeStamp*/
 
-#ifndef SK_DIAG
+#else /* SK_DIAG */
 
 /******************************************************************************
  *
- *	SkXmIrq() - Interrupt service routine
+ *	SkXmIrq() - Interrupt Service Routine
  *
- * Description:
- *	Services an Interrupt of the XMAC II
+ * Description:	services an Interrupt Request of the XMAC
  *
  * Note:
- *	The XMACs interrupt source register is NOT read here.
- *	With an external PHY, some interrupt bits are not meaningfull
- *	any more:
+ *	With an external PHY, some interrupt bits are not meaningfull any more:
  *	- LinkAsyncEvent (bit #14)              XM_IS_LNK_AE
  *	- LinkPartnerReqConfig (bit #10)	XM_IS_LIPA_RC
  *	- Page Received (bit #9)		XM_IS_RX_PAGE
@@ -2086,124 +3839,592 @@
 void SkXmIrq(
 SK_AC	*pAC,		/* adapter context */
 SK_IOC	IoC,		/* IO context */
-int		Port,		/* Port Index (MAC_1 + n) */
-SK_U16	IStatus)	/* Interrupt status read from the XMAC */
+int		Port)		/* Port Index (MAC_1 + n) */
 {
 	SK_GEPORT	*pPrt;
 	SK_EVPARA	Para;
+	SK_U16		IStatus;	/* Interrupt status read from the XMAC */
 	SK_U16		IStatus2;
 
 	pPrt = &pAC->GIni.GP[Port];
 	
-	if (pPrt->PhyType != SK_PHY_XMAC) {
+	XM_IN16(IoC, Port, XM_ISRC, &IStatus);
+	
+	/* LinkPartner Auto-negable? */
+	if (pPrt->PhyType == SK_PHY_XMAC) {
+		SkXmAutoNegLipaXmac(pAC, IoC, Port, IStatus);
+	}
+	else {
 		/* mask bits that are not used with ext. PHY */
 		IStatus &= ~(XM_IS_LNK_AE | XM_IS_LIPA_RC |
 			XM_IS_RX_PAGE | XM_IS_TX_PAGE |
 			XM_IS_AND | XM_IS_INP_ASS);
 	}
 	
-	/*
-	 * LinkPartner Autonegable?
-	 */
-	if (pPrt->PhyType == SK_PHY_XMAC) {
-		SkXmAutoNegLipaXmac(pAC, IoC, Port, IStatus);
-	}
-
 	SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_IRQ,
-		("XmacIrq Port %d Isr %x\n", Port, IStatus));
+		("XmacIrq Port %d Isr 0x%04x\n", Port, IStatus));
 
 	if (!pPrt->PHWLinkUp) {
 		/* Spurious XMAC interrupt */
 		SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_IRQ,
-			("SkXmIrq: spurious interrupt on port %d\n", Port));
+			("SkXmIrq: spurious interrupt on Port %d\n", Port));
 		return;
 	}
 
-	if (IStatus & XM_IS_INP_ASS) {
+	if ((IStatus & XM_IS_INP_ASS) != 0) {
 		/* Reread ISR Register if link is not in sync */
 		XM_IN16(IoC, Port, XM_ISRC, &IStatus2);
 
 		SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_IRQ,
-			("SkXmIrq: Link async. Double check port %d %x %x\n",
+			("SkXmIrq: Link async. Double check Port %d 0x%04x 0x%04x\n",
 			 Port, IStatus, IStatus2));
 		IStatus &= ~XM_IS_INP_ASS;
 		IStatus |= IStatus2;
-
 	}
 
-	if (IStatus & XM_IS_LNK_AE) {
-		/* not used GP0 is used instead */
+	if ((IStatus & XM_IS_LNK_AE) != 0) {
+		/* not used, GP0 is used instead */
 	}
 
-	if (IStatus & XM_IS_TX_ABORT) {
+	if ((IStatus & XM_IS_TX_ABORT) != 0) {
 		/* not used */
 	}
 
-	if (IStatus & XM_IS_FRC_INT) {
-		/* not used. use ASIC IRQ instead if needed */
+	if ((IStatus & XM_IS_FRC_INT) != 0) {
+		/* not used, use ASIC IRQ instead if needed */
 	}
 
-	if (IStatus & (XM_IS_INP_ASS | XM_IS_LIPA_RC | XM_IS_RX_PAGE)) {
+	if ((IStatus & (XM_IS_INP_ASS | XM_IS_LIPA_RC | XM_IS_RX_PAGE)) != 0) {
 		SkHWLinkDown(pAC, IoC, Port);
 
 		/* Signal to RLMT */
-		Para.Para32[0] = (SK_U32) Port;
+		Para.Para32[0] = (SK_U32)Port;
 		SkEventQueue(pAC, SKGE_RLMT, SK_RLMT_LINK_DOWN, Para);
 
 		/* Start workaround Errata #2 timer */
-		SkTimerStart(pAC, IoC, &pAC->GIni.GP[Port].PWaTimer,
-			SK_WA_INA_TIME, SKGE_HWAC, SK_HWEV_WATIM, Para);
+		SkTimerStart(pAC, IoC, &pPrt->PWaTimer, SK_WA_INA_TIME,
+			SKGE_HWAC, SK_HWEV_WATIM, Para);
 	}
 
-	if (IStatus & XM_IS_RX_PAGE) {
+	if ((IStatus & XM_IS_RX_PAGE) != 0) {
 		/* not used */
 	}
 
-	if (IStatus & XM_IS_TX_PAGE) {
+	if ((IStatus & XM_IS_TX_PAGE) != 0) {
 		/* not used */
 	}
 
-	if (IStatus & XM_IS_AND) {
-		SK_DBG_MSG(pAC,SK_DBGMOD_HWM,SK_DBGCAT_IRQ,
-			("SkXmIrq: AND on link that is up port %d\n", Port));
+	if ((IStatus & XM_IS_AND) != 0) {
+		SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_IRQ,
+			("SkXmIrq: AND on link that is up Port %d\n", Port));
 	}
 
-	if (IStatus & XM_IS_TSC_OV) {
+	if ((IStatus & XM_IS_TSC_OV) != 0) {
 		/* not used */
 	}
 
-	if (IStatus & XM_IS_RXC_OV) {
-		Para.Para32[0] = (SK_U32) Port;
-		Para.Para32[1] = (SK_U32) IStatus;
+	/* Combined Tx & Rx Counter Overflow SIRQ Event */
+	if ((IStatus & (XM_IS_RXC_OV | XM_IS_TXC_OV)) != 0) {
+		Para.Para32[0] = (SK_U32)Port;
+		Para.Para32[1] = (SK_U32)IStatus;
 		SkPnmiEvent(pAC, IoC, SK_PNMI_EVT_SIRQ_OVERFLOW, Para);
 	}
 
-	if (IStatus & XM_IS_TXC_OV) {
-		Para.Para32[0] = (SK_U32) Port;
-		Para.Para32[1] = (SK_U32) IStatus;
+	if ((IStatus & XM_IS_RXF_OV) != 0) {
+		/* normal situation -> no effect */
+#ifdef DEBUG
+		pPrt->PRxOverCnt++;
+#endif /* DEBUG */
+	}
+
+	if ((IStatus & XM_IS_TXF_UR) != 0) {
+		/* may NOT happen -> error log */
+		SK_ERR_LOG(pAC, SK_ERRCL_HW, SKERR_SIRQ_E020, SKERR_SIRQ_E020MSG);
+	}
+
+	if ((IStatus & XM_IS_TX_COMP) != 0) {
+		/* not served here */
+	}
+
+	if ((IStatus & XM_IS_RX_COMP) != 0) {
+		/* not served here */
+	}
+}	/* SkXmIrq */
+
+
+/******************************************************************************
+ *
+ *	SkGmIrq() - Interrupt Service Routine
+ *
+ * Description:	services an Interrupt Request of the GMAC
+ *
+ * Note:
+ *
+ * Returns:
+ *	nothing
+ */
+void SkGmIrq(
+SK_AC	*pAC,		/* adapter context */
+SK_IOC	IoC,		/* IO context */
+int		Port)		/* Port Index (MAC_1 + n) */
+{
+	SK_GEPORT	*pPrt;
+	SK_EVPARA	Para;
+	SK_U8		IStatus;	/* Interrupt status */
+
+	pPrt = &pAC->GIni.GP[Port];
+	
+	SK_IN8(IoC, GMAC_IRQ_SRC, &IStatus);
+	
+	/* LinkPartner Auto-negable? */
+	SkMacAutoNegLipaPhy(pAC, IoC, Port, IStatus);
+	
+	SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_IRQ,
+		("GmacIrq Port %d Isr 0x%04x\n", Port, IStatus));
+
+	/* Combined Tx & Rx Counter Overflow SIRQ Event */
+	if (IStatus & (GM_IS_RX_CO_OV | GM_IS_TX_CO_OV)) {
+		/* these IRQs will be cleared by reading GMACs register */
+		Para.Para32[0] = (SK_U32)Port;
+		Para.Para32[1] = (SK_U32)IStatus;
 		SkPnmiEvent(pAC, IoC, SK_PNMI_EVT_SIRQ_OVERFLOW, Para);
 	}
 
-	if (IStatus & XM_IS_RXF_OV) {
-		/* normal situation -> no effect */
+	if (IStatus & GM_IS_RX_FF_OR) {
+		/* clear GMAC Rx FIFO Overrun IRQ */
+		SK_OUT8(IoC, MR_ADDR(Port, RX_GMF_CTRL_T), (SK_U8)GMF_CLI_RX_FO);
+#ifdef DEBUG
+		pPrt->PRxOverCnt++;
+#endif /* DEBUG */
 	}
 
-	if (IStatus & XM_IS_TXF_UR) {
+	if (IStatus & GM_IS_TX_FF_UR) {
+		/* clear GMAC Tx FIFO Underrun IRQ */
+		SK_OUT8(IoC, MR_ADDR(Port, TX_GMF_CTRL_T), (SK_U8)GMF_CLI_TX_FU);
 		/* may NOT happen -> error log */
-		SK_ERR_LOG(pAC, SK_ERRCL_HW , SKERR_SIRQ_E020,
-			SKERR_SIRQ_E020MSG);
+		SK_ERR_LOG(pAC, SK_ERRCL_HW, SKERR_SIRQ_E020, SKERR_SIRQ_E020MSG);
 	}
 
-	if (IStatus & XM_IS_TX_COMP) {
+	if (IStatus & GM_IS_TX_COMPL) {
 		/* not served here */
 	}
 
-	if (IStatus & XM_IS_RX_COMP) {
+	if (IStatus & GM_IS_RX_COMPL) {
 		/* not served here */
 	}
+}	/* SkGmIrq */
+
+/******************************************************************************
+ *
+ *	SkMacIrq() - Interrupt Service Routine for MAC
+ *
+ * Description:	calls the Interrupt Service Routine dep. on board type
+ *
+ * Returns:
+ *	nothing
+ */
+void SkMacIrq(
+SK_AC	*pAC,		/* adapter context */
+SK_IOC	IoC,		/* IO context */
+int		Port)		/* Port Index (MAC_1 + n) */
+{
 
-}	/* SkXmIrq*/
+	if (pAC->GIni.GIGenesis) {
+		/* IRQ from XMAC */
+		SkXmIrq(pAC, IoC, Port);
+	}
+	else {
+		/* IRQ from GMAC */
+		SkGmIrq(pAC, IoC, Port);
+	}
+}	/* SkMacIrq */
 
 #endif /* !SK_DIAG */
 
+/******************************************************************************
+ *
+ *	SkXmUpdateStats() - Force the XMAC to output the current statistic
+ *
+ * Description:
+ *	The XMAC holds its statistic internally. To obtain the current
+ *	values a command must be sent so that the statistic data will
+ *	be written to a predefined memory area on the adapter.
+ *
+ * Returns:
+ *	0:  success
+ *	1:  something went wrong
+ */
+int SkXmUpdateStats(
+SK_AC	*pAC,		/* adapter context */
+SK_IOC	IoC,		/* IO context */
+unsigned int Port)	/* Port Index (MAC_1 + n) */
+{
+	SK_GEPORT	*pPrt;
+	SK_U16		StatReg;
+	int			WaitIndex;
+
+	pPrt = &pAC->GIni.GP[Port];
+	WaitIndex = 0;
+
+	/* Send an update command to XMAC specified */
+	XM_OUT16(IoC, Port, XM_STAT_CMD, XM_SC_SNP_TXC | XM_SC_SNP_RXC);
+
+	/*
+	 * It is an auto-clearing register. If the command bits
+	 * went to zero again, the statistics are transferred.
+	 * Normally the command should be executed immediately.
+	 * But just to be sure we execute a loop.
+	 */
+	do {
+
+		XM_IN16(IoC, Port, XM_STAT_CMD, &StatReg);
+		
+		if (++WaitIndex > 10) {
+
+			SK_ERR_LOG(pAC, SK_ERRCL_HW, SKERR_HWI_E021, SKERR_HWI_E021MSG);
+
+			return(1);
+		}
+	} while ((StatReg & (XM_SC_SNP_TXC | XM_SC_SNP_RXC)) != 0);
+	
+	return(0);
+}	/* SkXmUpdateStats */
+
+/******************************************************************************
+ *
+ *	SkGmUpdateStats() - Force the GMAC to output the current statistic
+ *
+ * Description:
+ *	Empty function for GMAC. Statistic data is accessible in direct way.
+ *
+ * Returns:
+ *	0:  success
+ *	1:  something went wrong
+ */
+int SkGmUpdateStats(
+SK_AC	*pAC,		/* adapter context */
+SK_IOC	IoC,		/* IO context */
+unsigned int Port)	/* Port Index (MAC_1 + n) */
+{
+	return(0);
+}
+
+/******************************************************************************
+ *
+ *	SkXmMacStatistic() - Get XMAC counter value
+ *
+ * Description:
+ *	Gets the 32bit counter value. Except for the octet counters
+ *	the lower 32bit are counted in hardware and the upper 32bit
+ *	must be counted in software by monitoring counter overflow interrupts.
+ *
+ * Returns:
+ *	0:  success
+ *	1:  something went wrong
+ */
+int SkXmMacStatistic(
+SK_AC	*pAC,		/* adapter context */
+SK_IOC	IoC,		/* IO context */
+unsigned int Port,	/* Port Index (MAC_1 + n) */
+SK_U16	StatAddr,	/* MIB counter base address */
+SK_U32	*pVal)		/* ptr to return statistic value */
+{
+	if ((StatAddr < XM_TXF_OK) || (StatAddr > XM_RXF_MAX_SZ)) {
+		
+		SK_ERR_LOG(pAC, SK_ERRCL_SW, SKERR_HWI_E022, SKERR_HWI_E022MSG);
+		
+		return(1);
+	}
+	
+	XM_IN32(IoC, Port, StatAddr, pVal);
+
+	return(0);
+}	/* SkXmMacStatistic */
+
+/******************************************************************************
+ *
+ *	SkGmMacStatistic() - Get GMAC counter value
+ *
+ * Description:
+ *	Gets the 32bit counter value. Except for the octet counters
+ *	the lower 32bit are counted in hardware and the upper 32bit
+ *	must be counted in software by monitoring counter overflow interrupts.
+ *
+ * Returns:
+ *	0:  success
+ *	1:  something went wrong
+ */
+int SkGmMacStatistic(
+SK_AC	*pAC,		/* adapter context */
+SK_IOC	IoC,		/* IO context */
+unsigned int Port,	/* Port Index (MAC_1 + n) */
+SK_U16	StatAddr,	/* MIB counter base address */
+SK_U32	*pVal)		/* ptr to return statistic value */
+{
+
+	if ((StatAddr < GM_RXF_UC_OK) || (StatAddr > GM_TXE_FIFO_UR)) {
+		
+		SK_ERR_LOG(pAC, SK_ERRCL_SW, SKERR_HWI_E022, SKERR_HWI_E022MSG);
+		
+		SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_CTRL,
+			("SkGmMacStat: wrong MIB counter 0x%04X\n", StatAddr));
+		return(1);
+	}
+		
+	GM_IN32(IoC, Port, StatAddr, pVal);
+
+	return(0);
+}	/* SkGmMacStatistic */
+
+/******************************************************************************
+ *
+ *	SkXmResetCounter() - Clear MAC statistic counter
+ *
+ * Description:
+ *	Force the XMAC to clear its statistic counter.
+ *
+ * Returns:
+ *	0:  success
+ *	1:  something went wrong
+ */
+int SkXmResetCounter(
+SK_AC	*pAC,		/* adapter context */
+SK_IOC	IoC,		/* IO context */
+unsigned int Port)	/* Port Index (MAC_1 + n) */
+{
+	XM_OUT16(IoC, Port, XM_STAT_CMD, XM_SC_CLR_RXC | XM_SC_CLR_TXC);
+	/* Clear two times according to Errata #3 */
+	XM_OUT16(IoC, Port, XM_STAT_CMD, XM_SC_CLR_RXC | XM_SC_CLR_TXC);
+
+	return(0);
+}	/* SkXmResetCounter */
+
+/******************************************************************************
+ *
+ *	SkGmResetCounter() - Clear MAC statistic counter
+ *
+ * Description:
+ *	Force GMAC to clear its statistic counter.
+ *
+ * Returns:
+ *	0:  success
+ *	1:  something went wrong
+ */
+int SkGmResetCounter(
+SK_AC	*pAC,		/* adapter context */
+SK_IOC	IoC,		/* IO context */
+unsigned int Port)	/* Port Index (MAC_1 + n) */
+{
+	SK_U16	Reg;	/* Phy Address Register */
+	SK_U16	Word;
+	int		i;
+
+	GM_IN16(IoC, Port, GM_PHY_ADDR, &Reg);
+
+#ifndef VCPU
+	/* set MIB Clear Counter Mode */
+	GM_OUT16(IoC, Port, GM_PHY_ADDR, Reg | GM_PAR_MIB_CLR);
+	
+	/* read all MIB Counters with Clear Mode set */
+	for (i = 0; i < GM_MIB_CNT_SIZE; i++) {
+		/* the reset is performed only when the lower 16 bits are read */
+		GM_IN16(IoC, Port, GM_MIB_CNT_BASE + 8*i, &Word);
+	}
+	
+	/* clear MIB Clear Counter Mode */
+	GM_OUT16(IoC, Port, GM_PHY_ADDR, Reg);
+#endif /* !VCPU */
+	
+	return(0);
+}	/* SkGmResetCounter */
+
+/******************************************************************************
+ *
+ *	SkXmOverflowStatus() - Gets the status of counter overflow interrupt
+ *
+ * Description:
+ *	Checks the source causing an counter overflow interrupt. On success the
+ *	resulting counter overflow status is written to <pStatus>, whereas the
+ *	upper dword stores the XMAC ReceiveCounterEvent register and the lower
+ *	dword the XMAC TransmitCounterEvent register.
+ *
+ * Note:
+ *	For XMAC the interrupt source is a self-clearing register, so the source
+ *	must be checked only once. SIRQ module does another check to be sure
+ *	that no interrupt get lost during process time.
+ *
+ * Returns:
+ *	0:  success
+ *	1:  something went wrong
+ */
+int SkXmOverflowStatus(
+SK_AC	*pAC,		/* adapter context */
+SK_IOC	IoC,		/* IO context */
+unsigned int Port,	/* Port Index (MAC_1 + n) */
+SK_U16  IStatus,	/* Interupt Status from MAC */
+SK_U64	*pStatus)	/* ptr for return overflow status value */
+{
+	SK_U64	Status;	/* Overflow status */
+	SK_U32	RegVal;
+
+	Status = 0;
+
+	if ((IStatus & XM_IS_RXC_OV) != 0) {
+
+		XM_IN32(IoC, Port, XM_RX_CNT_EV, &RegVal);
+		Status |= (SK_U64)RegVal << 32;
+	}
+	
+	if ((IStatus & XM_IS_TXC_OV) != 0) {
+
+		XM_IN32(IoC, Port, XM_TX_CNT_EV, &RegVal);
+		Status |= (SK_U64)RegVal;
+	}
+
+	*pStatus = Status;
+
+	return(0);
+}	/* SkXmOverflowStatus */
+
+
+/******************************************************************************
+ *
+ *	SkGmOverflowStatus() - Gets the status of counter overflow interrupt
+ *
+ * Description:
+ *	Checks the source causing an counter overflow interrupt. On success the
+ *	resulting counter overflow status is written to <pStatus>, whereas the
+ *	the following bit coding is used:
+ *	63:56 - unused
+ *	55:48 - TxRx interrupt register bit7:0
+ *	32:47 - Rx interrupt register
+ *	31:24 - unused
+ *	23:16 - TxRx interrupt register bit15:8
+ *	15:0  - Tx interrupt register
+ *
+ * Returns:
+ *	0:  success
+ *	1:  something went wrong
+ */
+int SkGmOverflowStatus(
+SK_AC	*pAC,		/* adapter context */
+SK_IOC	IoC,		/* IO context */
+unsigned int Port,	/* Port Index (MAC_1 + n) */
+SK_U16  IStatus,	/* Interupt Status from MAC */
+SK_U64	*pStatus)	/* ptr for return overflow status value */
+{
+	SK_U64	Status;		/* Overflow status */
+	SK_U16	RegVal;
+
+	Status = 0;
+
+	if ((IStatus & GM_IS_RX_CO_OV) != 0) {
+		/* this register is self-clearing after read */
+		GM_IN16(IoC, Port, GM_RX_IRQ_SRC, &RegVal);
+		Status |= (SK_U64)RegVal << 32;
+	}
+	
+	if ((IStatus & GM_IS_TX_CO_OV) != 0) {
+		/* this register is self-clearing after read */
+		GM_IN16(IoC, Port, GM_TX_IRQ_SRC, &RegVal);
+		Status |= (SK_U64)RegVal;
+	}
+	
+	/* this register is self-clearing after read */
+	GM_IN16(IoC, Port, GM_TR_IRQ_SRC, &RegVal);
+	/* Rx overflow interrupt register bits (LoByte)*/
+	Status |= (SK_U64)((SK_U8)RegVal) << 48;
+	/* Tx overflow interrupt register bits (HiByte)*/
+	Status |= (SK_U64)(RegVal >> 8) << 16;
+
+	*pStatus = Status;
+
+	return(0);
+}	/* SkGmOverflowStatus */
+
+/******************************************************************************
+ *
+ *	SkGmCableDiagStatus() - Starts / Gets status of cable diagnostic test
+ *
+ * Description:
+ *  starts the cable diagnostic test if 'StartTest' is true
+ *  gets the results if 'StartTest' is true
+ *
+ * NOTE:	this test is meaningful only when link is down
+ *	
+ * Returns:
+ *	0:  success
+ *	1:	no YUKON copper
+ *	2:	test in progress
+ */
+int SkGmCableDiagStatus(
+SK_AC	*pAC,		/* adapter context */
+SK_IOC	IoC,   		/* IO context */
+int		Port,		/* Port Index (MAC_1 + n) */
+SK_BOOL	StartTest)	/* flag for start / get result */
+{
+	int		i;
+	SK_U16	RegVal;
+	SK_GEPORT	*pPrt;
+
+	pPrt = &pAC->GIni.GP[Port];
+
+	if (pPrt->PhyType != SK_PHY_MARV_COPPER) {
+		
+		return(1);
+	}
+
+	if (StartTest) {
+		/* only start the cable test */
+		if ((pPrt->PhyId1 & PHY_I1_REV_MSK) < 4) {
+			/* apply TDR workaround from Marvell */
+			SkGmPhyWrite(pAC, IoC, Port, 29, 0x001e);
+			
+			SkGmPhyWrite(pAC, IoC, Port, 30, 0xcc00);
+			SkGmPhyWrite(pAC, IoC, Port, 30, 0xc800);
+			SkGmPhyWrite(pAC, IoC, Port, 30, 0xc400);
+			SkGmPhyWrite(pAC, IoC, Port, 30, 0xc000);
+			SkGmPhyWrite(pAC, IoC, Port, 30, 0xc100);
+		}
+
+		/* set address to 0 for MDI[0] */
+		SkGmPhyWrite(pAC, IoC, Port, PHY_MARV_EXT_ADR, 0);
+
+		/* Read Cable Diagnostic Reg */
+		SkGmPhyRead(pAC, IoC, Port, PHY_MARV_CABLE_DIAG, &RegVal);
+
+		/* start Cable Diagnostic Test */
+		SkGmPhyWrite(pAC, IoC, Port, PHY_MARV_CABLE_DIAG,
+			(SK_U16)(RegVal | PHY_M_CABD_ENA_TEST));
+	
+		return(0);
+	}
+	
+	/* Read Cable Diagnostic Reg */
+	SkGmPhyRead(pAC, IoC, Port, PHY_MARV_CABLE_DIAG, &RegVal);
+
+	SK_DBG_MSG(pAC, SK_DBGMOD_HWM, SK_DBGCAT_CTRL,
+		("PHY Cable Diag.=0x%04X\n", RegVal));
+
+	if ((RegVal & PHY_M_CABD_ENA_TEST) != 0) {
+		/* test is running */
+		return(2);
+	}
+
+	/* get the test results */
+	for (i = 0; i < 4; i++)  {
+		/* set address to i for MDI[i] */
+		SkGmPhyWrite(pAC, IoC, Port, PHY_MARV_EXT_ADR, (SK_U16)i);
+
+		/* get Cable Diagnostic values */
+		SkGmPhyRead(pAC, IoC, Port, PHY_MARV_CABLE_DIAG, &RegVal);
+
+		pPrt->PMdiPairLen[i] = (SK_U8)(RegVal & PHY_M_CABD_DIST_MSK);
+
+		pPrt->PMdiPairSts[i] = (SK_U8)((RegVal & PHY_M_CABD_STAT_MSK) >> 13);
+	}
+
+	return(0);
+}	/* SkGmCableDiagStatus */
+
 /* End of file */
diff -ruN linux/drivers/pci/pci.ids linuxn/drivers/pci/pci.ids
--- linux/drivers/pci/pci.ids	Fri Nov 29 00:53:14 2002
+++ linuxn/drivers/pci/pci.ids	Tue May 20 12:17:54 2003
@@ -2095,6 +2095,9 @@
 	1006  MINI PCI type 3B Data Fax Modem
 	1007  Mini PCI 56k Winmodem
 		10b7 615c  Mini PCI 56K Modem
+	1700  Gigabit Ethernet Adapter
+		10b7 0010  3Com 3C940 Gigabit LOM Ethernet Adapter
+		10b7 0020  3Com 3C941 Gigabit LOM Ethernet Adapter
 	3390  3c339 TokenLink Velocity
 	3590  3c359 TokenLink Velocity XL
 		10b7 3590  TokenLink Velocity XL Adapter (3C359/359B)
@@ -3047,15 +3050,43 @@
 		1148 5843  FDDI SK-5843 (SK-NET FDDI-LP64)
 		1148 5844  FDDI SK-5844 (SK-NET FDDI-LP64 DAS)
 	4200  Token Ring adapter
-	4300  Gigabit Ethernet
-		1148 9821  SK-9821 (1000Base-T single link)
-		1148 9822  SK-9822 (1000Base-T dual link)
-		1148 9841  SK-9841 (1000Base-LX single link)
-		1148 9842  SK-9842 (1000Base-LX dual link)
-		1148 9843  SK-9843 (1000Base-SX single link)
-		1148 9844  SK-9844 (1000Base-SX dual link)
-		1148 9861  SK-9861 (1000Base-SX VF45 single link)
-		1148 9862  SK-9862 (1000Base-SX VF45 dual link)
+	4300  SK-98xx Gigabit Ethernet Server Adapter
+		1148 9821  SK-9821 Gigabit Ethernet Server Adapter (SK-NET GE-T)
+		1148 9822  SK-9822 Gigabit Ethernet Server Adapter (SK-NET GE-T dual link)
+		1148 9841  SK-9841 Gigabit Ethernet Server Adapter (SK-NET GE-LX)
+		1148 9842  SK-9842 Gigabit Ethernet Server Adapter (SK-NET GE-LX dual link)
+		1148 9843  SK-9843 Gigabit Ethernet Server Adapter (SK-NET GE-SX)
+		1148 9844  SK-9844 Gigabit Ethernet Server Adapter (SK-NET GE-SX dual link)
+		1148 9861  SK-9861 Gigabit Ethernet Server Adapter (SK-NET GE-SX Volition)
+		1148 9862  SK-9862 Gigabit Ethernet Server Adapter (SK-NET GE-SX Volition dual link)
+		1148 9871  SK-9871 Gigabit Ethernet Server Adapter (SK-NET GE-ZX)
+		1148 9872  SK-9872 Gigabit Ethernet Server Adapter (SK-NET GE-ZX dual link)
+		1259 2970  Allied Telesyn AT-2970SX Gigabit Ethernet Adapter
+		1259 2971  Allied Telesyn AT-2970LX Gigabit Ethernet Adapter
+		1259 2972  Allied Telesyn AT-2970TX Gigabit Ethernet Adapter
+		1259 2973  Allied Telesyn AT-2971SX Gigabit Ethernet Adapter
+		1259 2974  Allied Telesyn AT-2971T Gigabit Ethernet Adapter
+		1259 2975  Allied Telesyn AT-2970SX/2SC Gigabit Ethernet Adapter
+		1259 2976  Allied Telesyn AT-2970LX/2SC Gigabit Ethernet Adapter
+		1259 2977  Allied Telesyn AT-2970TX/2TX Gigabit Ethernet Adapter
+	4320  SK-98xx V2.0 Gigabit Ethernet Adapter
+		1148 0121  Marvell RDK-8001 Adapter
+		1148 0221  Marvell RDK-8002 Adapter
+		1148 0321  Marvell RDK-8003 Adapter
+		1148 0421  Marvell RDK-8004 Adapter
+		1148 0621  Marvell RDK-8006 Adapter
+		1148 0721  Marvell RDK-8007 Adapter
+		1148 0821  Marvell RDK-8008 Adapter
+		1148 0921  Marvell RDK-8009 Adapter
+		1148 1121  Marvell RDK-8011 Adapter
+		1148 1221  Marvell RDK-8012 Adapter
+		1148 5021  SK-9821 V2.0 Gigabit Ethernet 10/100/1000Base-T Adapter
+		1148 5041  SK-9841 V2.0 Gigabit Ethernet 1000Base-LX Adapter
+		1148 5043  SK-9843 V2.0 Gigabit Ethernet 1000Base-SX Adapter
+		1148 5051  SK-9851 V2.0 Gigabit Ethernet 1000Base-SX Adapter
+		1148 5061  SK-9861 V2.0 Gigabit Ethernet 1000Base-SX Adapter
+		1148 5071  SK-9871 V2.0 Gigabit Ethernet 1000Base-ZX Adapter
+		1148 9521  SK-9521 10/100/1000Base-T Adapter
 	4400  Gigabit Ethernet
 1149  Win System Corporation
 114a  VMIC
@@ -3265,6 +3296,8 @@
 	1340  DFE-690TXD CardBus PC Card
 	1561  DRP-32TXD Cardbus PC Card
 	4000  DL2K Ethernet
+	4c00  Gigabit Ethernet Adapter
+		1186 4c00  DGE-530T Gigabit Ethernet Adapter
 1187  Advanced Technology Laboratories, Inc.
 1188  Shima Seiki Manufacturing Ltd.
 1189  Matsushita Electronics Co Ltd
@@ -3342,6 +3375,8 @@
 11aa  Actel
 11ab  Galileo Technology Ltd.
 	0146  GT-64010
+	4320  Gigabit Ethernet Adapter
+		11ab 9521  Marvell Yukon Gigabit Ethernet 10/100/1000Base-T Adapter
 	4801  GT-48001
 	f003  GT-64010 Primary Image Piranha Image Generator
 11ac  Canon Information Systems Research Aust.
@@ -4529,6 +4564,8 @@
 136f  Applied Magic Inc
 1370  ATL Products
 1371  CNet Technology Inc
+	434e  GigaCard Network Adapter
+		1371 434e  N-Way PCI-Bus Giga-Card 1000/100/10Mbps(L)
 1373  Silicon Vision Inc
 1374  Silicom Ltd
 1375  Argosystems Inc
@@ -5561,6 +5598,11 @@
 16f6  VideoTele.com, Inc.
 170b  NetOctave Inc
 170c  YottaYotta Inc.
+1737  Linksys
+	1032  Gigabit Network Adapter
+		1737 0015  EG1032 v2 Instant Gigabit Network Adapter
+	1064  Gigabit Network Adapter
+		1737 0016  EG1064 v2 Instant Gigabit Network Adapter
 173b  Altima (nee Broadcom)
 	03e8  AC1000 Gigabit Ethernet
 	03ea  AC9100 Gigabit Ethernet
