***************************************************************************************
This patch was taken from the kernel-image-2.4.17-ia64-011226.13 Debian source package,
where it was named patch.gpt-guidcleanup
***************************************************************************************
diff -ur linux.pre-matt/Documentation/Configure.help linux/Documentation/Configure.help
--- linux.pre-matt/Documentation/Configure.help	Tue Apr  2 00:06:01 2002
+++ linux/Documentation/Configure.help	Tue Apr  2 00:13:54 2002
@@ -14833,12 +14833,6 @@
   were partitioned using EFI GPT.  Presently only useful on the
   IA-64 platform.
 
-/dev/guid support (EXPERIMENTAL)
-CONFIG_DEVFS_GUID
-  Say Y here if you would like to access disks and partitions by
-  their Globally Unique Identifiers (GUIDs) which will appear as
-  symbolic links in /dev/guid.
-
 Ultrix partition table support
 CONFIG_ULTRIX_PARTITION
   Say Y here if you would like to be able to read the hard disk
diff -ur linux.pre-matt/arch/ia64/defconfig linux/arch/ia64/defconfig
--- linux.pre-matt/arch/ia64/defconfig	Tue Apr  2 00:06:01 2002
+++ linux/arch/ia64/defconfig	Tue Apr  2 00:12:40 2002
@@ -963,7 +963,6 @@
 # CONFIG_SOLARIS_X86_PARTITION is not set
 # CONFIG_UNIXWARE_DISKLABEL is not set
 CONFIG_EFI_PARTITION=y
-# CONFIG_DEVFS_GUID is not set
 # CONFIG_LDM_PARTITION is not set
 # CONFIG_SGI_PARTITION is not set
 # CONFIG_ULTRIX_PARTITION is not set
diff -ur linux.pre-matt/arch/ia64/hp/zx1/hpzx1_misc.c linux/arch/ia64/hp/zx1/hpzx1_misc.c
--- linux.pre-matt/arch/ia64/hp/zx1/hpzx1_misc.c	Tue Apr  2 00:06:01 2002
+++ linux/arch/ia64/hp/zx1/hpzx1_misc.c	Tue Apr  2 00:42:16 2002
@@ -179,7 +179,7 @@
 #define HP_CCSR_LENGTH 0x21
 #define HP_CCSR_TYPE 0x2
 #define HP_CCSR_GUID \
-    ((efi_guid_t) { 0x69e9adf9, 0x924f, 0xab5f, { 0xf6, 0x4a, 0x24, 0xd2, 0x01, 0x37, 0x0e, 0xad }})
+    EFI_GUID(  0x69e9adf9, 0x924f, 0xab5f, 0xf6, 0x4a, 0x24, 0xd2, 0x01, 0x37, 0x0e, 0xad )
 
 extern acpi_status acpi_get_crs(acpi_handle, acpi_buffer *);
 extern acpi_resource *acpi_get_crs_next(acpi_buffer *, int *);
diff -ur linux.pre-matt/arch/ia64/kernel/efivars.c linux/arch/ia64/kernel/efivars.c
--- linux.pre-matt/arch/ia64/kernel/efivars.c	Fri Dec 21 17:41:53 2001
+++ linux/arch/ia64/kernel/efivars.c	Tue Apr  2 00:17:00 2002
@@ -29,6 +29,14 @@
  *
  * Changelog:
  *
+ *  25 Mar 2002 - Matt Domsch <Matt_Domsch@dell.com>
+ *   move uuid_unparse() to include/asm-ia64/efi.h:efi_guid_unparse()
+ *
+ *  12 Feb 2002 - Matt Domsch <Matt_Domsch@dell.com>
+ *   use list_for_each_safe when deleting vars.
+ *   remove ifdef CONFIG_SMP around include <linux/smp.h>
+ *   v0.04 release to linux-ia64@linuxia64.org
+ *
  *  20 April 2001 - Matt Domsch <Matt_Domsch@dell.com>
  *   Moved vars from /proc/efi to /proc/efi/vars, and made
  *   efi.c own the /proc/efi directory.
@@ -56,18 +64,16 @@
 #include <linux/sched.h>		/* for capable() */
 #include <linux/mm.h>
 #include <linux/module.h>
+#include <linux/smp.h>
 
 #include <asm/efi.h>
 #include <asm/uaccess.h>
-#ifdef CONFIG_SMP
-#include <linux/smp.h>
-#endif
 
 MODULE_AUTHOR("Matt Domsch <Matt_Domsch@Dell.com>");
 MODULE_DESCRIPTION("/proc interface to EFI Variables");
 MODULE_LICENSE("GPL");
 
-#define EFIVARS_VERSION "0.03 2001-Apr-20"
+#define EFIVARS_VERSION "0.05 2002-Mar-26"
 
 static int
 efivar_read(char *page, char **start, off_t off,
@@ -138,20 +144,6 @@
 	return len;
 }
 
-
-static void
-uuid_unparse(efi_guid_t *guid, char *out)
-{
-	sprintf(out, "%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x",
-		guid->data1, guid->data2, guid->data3,
-		guid->data4[0], guid->data4[1], guid->data4[2], guid->data4[3],
-		guid->data4[4], guid->data4[5], guid->data4[6], guid->data4[7]);
-}
-
-
-
-
-
 /*
  * efivar_create_proc_entry()
  * Requires:
@@ -194,7 +186,7 @@
 	   private variables from another's.         */
 
 	*(short_name + strlen(short_name)) = '-';
-	uuid_unparse(vendor_guid, short_name + strlen(short_name));
+	efi_guid_unparse(vendor_guid, short_name + strlen(short_name));
 
 
 	/* Create the entry in proc */
@@ -265,7 +257,7 @@
 {
 	unsigned long strsize1, strsize2;
 	int found=0;
-	struct list_head *pos;
+	struct list_head *pos, *n;
 	unsigned long size = sizeof(efi_variable_t);
 	efi_status_t status;
 	efivar_entry_t *efivar = data, *search_efivar = NULL;
@@ -297,7 +289,7 @@
 	   This allows any properly formatted data structure to
 	   be written to any of the files in /proc/efi/vars and it will work.
 	*/
-	list_for_each(pos, &efivar_list) {
+	list_for_each_safe(pos, n, &efivar_list) {
 		search_efivar = efivar_entry(pos);
 		strsize1 = utf8_strsize(search_efivar->var.VariableName, 1024);
 		strsize2 = utf8_strsize(var_data->VariableName, 1024);
@@ -413,12 +405,12 @@
 static void __exit
 efivars_exit(void)
 {
-	struct list_head *pos;
+	struct list_head *pos, *n;
 	efivar_entry_t *efivar;
 
 	spin_lock(&efivars_lock);
 
-	list_for_each(pos, &efivar_list) {
+	list_for_each_safe(pos, n, &efivar_list) {
 		efivar = efivar_entry(pos);
 		remove_proc_entry(efivar->entry->name, efi_vars_dir);
 		list_del(&efivar->list);
diff -ur linux.pre-matt/arch/ia64/kernel/mca.c linux/arch/ia64/kernel/mca.c
--- linux.pre-matt/arch/ia64/kernel/mca.c	Fri Nov  9 22:26:17 2001
+++ linux/arch/ia64/kernel/mca.c	Tue Apr  2 00:18:39 2002
@@ -3,6 +3,9 @@
  * Purpose:	Generic MCA handling layer
  *
  * Updated for latest kernel
+ * Copyright (C) 2002 Dell Computer Corporation
+ * Copyright (C) Matt Domsch (Matt_Domsch@dell.com)
+ *
  * Copyright (C) 2001 Intel
  * Copyright (C) Fred Lewis (frederick.v.lewis@intel.com)
  *
@@ -12,6 +15,8 @@
  * Copyright (C) 1999 Silicon Graphics, Inc.
  * Copyright (C) Vijay Chander(vijay@engr.sgi.com)
  *
+ * 02/03/25 M. Domsch	GUID cleanups
+ *
  * 01/01/03 F. Lewis    Added setup of CMCI and CPEI IRQs, logging of corrected
  *                      platform errors, completed code for logging of
  *                      corrected & uncorrected machine check errors, and
@@ -329,17 +334,13 @@
 verify_guid (efi_guid_t *test, efi_guid_t *target)
 {
 	int     rc;
+	char out[40];
 
-	if ((rc = memcmp((void *)test, (void *)target, sizeof(efi_guid_t)))) {
-		IA64_MCA_DEBUG("ia64_mca_print: invalid guid = "
-			       "{ %08x, %04x, %04x, { %#02x, %#02x, %#02x, %#02x, "
-			       "%#02x, %#02x, %#02x, %#02x, } } \n ",
-			       test->data1, test->data2, test->data3, test->data4[0],
-			       test->data4[1], test->data4[2], test->data4[3],
-			       test->data4[4], test->data4[5], test->data4[6],
-			       test->data4[7]);
+	if ((rc = efi_guidcmp(*test, *target))) {
+		IA64_MCA_DEBUG(KERN_DEBUG
+			       "verify_guid: invalid GUID = %s\n",
+			       efi_guid_unparse(test, out));
 	}
-
 	return rc;
 }
 
@@ -825,11 +826,8 @@
 void
 ia64_log_prt_guid (efi_guid_t *p_guid, prfunc_t prfunc)
 {
-	printk("GUID = { %08x, %04x, %04x, { %#02x, %#02x, %#02x, %#02x, "
-	       "%#02x, %#02x, %#02x, %#02x, } } \n ", p_guid->data1,
-	       p_guid->data2, p_guid->data3, p_guid->data4[0], p_guid->data4[1],
-	       p_guid->data4[2], p_guid->data4[3], p_guid->data4[4],
-	       p_guid->data4[5], p_guid->data4[6], p_guid->data4[7]);
+	char out[40];
+	printk(KERN_DEBUG "GUID = %s\n", efi_guid_unparse(p_guid, out));
 }
 
 static void
@@ -1716,7 +1714,7 @@
 		ia64_log_prt_section_header(slsh, prfunc);
 #endif  // MCA_PRT_XTRA_DATA for test only @FVL
 
-		if (verify_guid((void *)&slsh->guid, (void *)&(SAL_PROC_DEV_ERR_SECT_GUID))) {
+		if (verify_guid(&slsh->guid, &(SAL_PROC_DEV_ERR_SECT_GUID))) {
 			IA64_MCA_DEBUG("ia64_mca_log_print: unsupported record section\n");
 			continue;
 		}
diff -ur linux.pre-matt/fs/devfs/base.c linux/fs/devfs/base.c
--- linux.pre-matt/fs/devfs/base.c	Tue Apr  2 00:05:24 2002
+++ linux/fs/devfs/base.c	Tue Apr  2 00:12:40 2002
@@ -2169,27 +2169,6 @@
     return master->slave;
 }   /*  End Function devfs_get_unregister_slave  */
 
-#ifdef CONFIG_DEVFS_GUID
-/**
- *	devfs_unregister_slave - remove the slave that is unregistered when @master is unregistered.
- *      Destroys the connection established by devfs_auto_unregister.
- *
- *	@master: The master devfs entry.
- */
-
-void devfs_unregister_slave (devfs_handle_t master)
-{
-	devfs_handle_t slave;
-
-	if (master == NULL) return;
-
-	slave = master->slave;
-	if (slave) {
-		master->slave = NULL;
-		unregister (slave);
-	};
-}
-#endif /* CONFIG_DEVFS_GUID */
 
 /**
  *	devfs_get_name - Get the name for a device entry in its parent directory.
@@ -2370,9 +2349,6 @@
 EXPORT_SYMBOL(devfs_register_blkdev);
 EXPORT_SYMBOL(devfs_unregister_chrdev);
 EXPORT_SYMBOL(devfs_unregister_blkdev);
-#ifdef CONFIG_DEVFS_GUID
-EXPORT_SYMBOL(devfs_unregister_slave);
-#endif
 
 
 /**
diff -ur linux.pre-matt/fs/partitions/Config.in linux/fs/partitions/Config.in
--- linux.pre-matt/fs/partitions/Config.in	Tue Apr  2 00:05:24 2002
+++ linux/fs/partitions/Config.in	Tue Apr  2 00:12:40 2002
@@ -24,8 +24,6 @@
       bool '    Minix subpartition support' CONFIG_MINIX_SUBPARTITION
       bool '    Solaris (x86) partition table support' CONFIG_SOLARIS_X86_PARTITION
       bool '    Unixware slices support' CONFIG_UNIXWARE_DISKLABEL
-      bool '    EFI GUID Partition support' CONFIG_EFI_PARTITION
-      dep_bool '    /dev/guid support (EXPERIMENTAL)' CONFIG_DEVFS_GUID $CONFIG_DEVFS_FS $CONFIG_EFI_PARTITION
    fi
    dep_bool '  Windows Logical Disk Manager (Dynamic Disk) support' CONFIG_LDM_PARTITION $CONFIG_EXPERIMENTAL
    if [ "$CONFIG_LDM_PARTITION" = "y" ]; then
@@ -34,6 +32,7 @@
    bool '  SGI partition support' CONFIG_SGI_PARTITION
    bool '  Ultrix partition table support' CONFIG_ULTRIX_PARTITION
    bool '  Sun partition tables support' CONFIG_SUN_PARTITION
+   bool '  EFI GUID Partition support' CONFIG_EFI_PARTITION
 else
    if [ "$ARCH" = "alpha" ]; then
       define_bool CONFIG_OSF_PARTITION y
diff -ur linux.pre-matt/fs/partitions/check.c linux/fs/partitions/check.c
--- linux.pre-matt/fs/partitions/check.c	Tue Apr  2 00:05:24 2002
+++ linux/fs/partitions/check.c	Tue Apr  2 00:12:40 2002
@@ -79,20 +79,6 @@
 	NULL
 };
 
-#ifdef CONFIG_DEVFS_GUID
-static devfs_handle_t guid_top_handle;
-
-#define GUID_UNPARSED_LEN 36
-static void
-uuid_unparse_1(efi_guid_t *guid, char *out)
-{
-	sprintf(out, "%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x",
-		guid->data1, guid->data2, guid->data3,
- 		guid->data4[0], guid->data4[1], guid->data4[2], guid->data4[3],
-		guid->data4[4], guid->data4[5], guid->data4[6], guid->data4[7]);
-}
-#endif
-
 /*
  *	This is ucking fugly but its probably the best thing for 2.4.x
  *	Take it as a clear reminder than we should put the device name
@@ -285,103 +271,6 @@
 	devfs_register_partitions (hd, i, hd->sizes ? 0 : 1);
 }
 
-#ifdef CONFIG_DEVFS_GUID
-/*
-  devfs_register_guid: create a /dev/guid entry for a disk or partition
-                       if it has a GUID.
-
-  The /dev/guid entry will be a symlink to the "real" devfs device.
-  It is marked as "slave" of the real device,
-  to be automatically unregistered by devfs if that device is unregistered.
-
-  If the partition already had a /dev/guid entry, delete (unregister) it.
-  (If the disk was repartitioned, it's likely the old GUID entry will be wrong).
-
-  dev, minor:  Device for which an entry is to be created.
-
-  Prerequisites: dev->part[minor].guid must be either NULL or point
-                 to a valid kmalloc'ed GUID.
-*/
-
-static void devfs_register_guid (struct gendisk *dev, int minor)
-{
-	efi_guid_t *guid = dev->part[minor].guid;
-	devfs_handle_t guid_handle, slave,
-		real_master = dev->part[minor].de;
-	devfs_handle_t master = real_master;
-	char guid_link[GUID_UNPARSED_LEN + 1];
-	char dirname[128];
-	int pos, st;
-
-	if (!guid_top_handle)
-		guid_top_handle = devfs_mk_dir (NULL, "guid", NULL);
-
-	if (!guid || !master) return;
-
-	do {
-		slave = devfs_get_unregister_slave (master);
-		if (slave) {
-			if (slave == master || slave == real_master) {
-				printk (KERN_WARNING
-					"devfs_register_guid: infinite slave loop!\n");
-				return;
-			} else if (devfs_get_parent (slave) == guid_top_handle) {
-				printk (KERN_INFO
-					"devfs_register_guid: unregistering %s\n",
-					devfs_get_name (slave, NULL));
-				devfs_unregister_slave (master);
-				slave = NULL;
-			} else
-				master = slave;
-		};
-	} while (slave);
-
-	uuid_unparse_1 (guid, guid_link);
-	pos = devfs_generate_path (real_master, dirname + 3,
-				   sizeof (dirname) - 3);
-	if (pos < 0) {
-		printk (KERN_WARNING
-			"devfs_register_guid: error generating path: %d\n",
-			pos);
-		return;
-	};
-
-	strncpy (dirname + pos, "../", 3);
-
-	st = devfs_mk_symlink (guid_top_handle, guid_link,
-			       DEVFS_FL_DEFAULT,
-			       dirname + pos, &guid_handle, NULL);
-
-	if (st < 0) {
-		printk ("Error %d creating symlink\n", st);
-	} else {
-		devfs_auto_unregister (master, guid_handle);
-	};
-};
-
-/*
-  free_disk_guids: kfree all guid data structures alloced for
-  the disk device specified by (dev, minor) and all its partitions.
-
-  This function does not remove symlinks in /dev/guid.
-*/
-static void free_disk_guids (struct gendisk *dev, int minor)
-{
-	int i;
-	efi_guid_t *guid;
-
-	for (i = 0; i < dev->max_p; i++) {
-		guid = dev->part[minor + i].guid;
-		if (!guid) continue;
-		kfree (guid);
-		dev->part[minor + i].guid = NULL;
-	};
-}
-#else
-#define devfs_register_guid(dev, minor)
-#define free_disk_guids(dev, minor)
-#endif /* CONFIG_DEVFS_GUID */
-
 #ifdef CONFIG_DEVFS_FS
 static void devfs_register_partition (struct gendisk *dev, int minor, int part)
 {
@@ -390,11 +279,7 @@
 	unsigned int devfs_flags = DEVFS_FL_DEFAULT;
 	char devname[16];
 
-	/* Even if the devfs handle is still up-to-date,
-	   the GUID entry probably isn't */
-	if (dev->part[minor + part].de)
-		goto do_guid;
-
+	if (dev->part[minor + part].de) return;
 	dir = devfs_get_parent (dev->part[minor].de);
 	if (!dir) return;
 	if ( dev->flags && (dev->flags[devnum] & GENHD_FL_REMOVABLE) )
@@ -405,9 +290,6 @@
 			    dev->major, minor + part,
 			    S_IFBLK | S_IRUSR | S_IWUSR,
 			    dev->fops, NULL);
- do_guid:
-	devfs_register_guid (dev, minor + part);
-	return;
 }
 
 static struct unique_numspace disc_numspace = UNIQUE_NUMBERSPACE_INITIALISER;
@@ -421,9 +303,7 @@
 	char dirname[64], symlink[16];
 	static devfs_handle_t devfs_handle;
 
-	if (dev->part[minor].de)
-		goto do_guid;
-
+	if (dev->part[minor].de) return;
 	if ( dev->flags && (dev->flags[devnum] & GENHD_FL_REMOVABLE) )
 		devfs_flags |= DEVFS_FL_REMOVABLE;
 	if (dev->de_arr) {
@@ -451,10 +331,6 @@
 	devfs_auto_unregister (dev->part[minor].de, slave);
 	if (!dev->de_arr)
 		devfs_auto_unregister (slave, dir);
-
- do_guid:
-	devfs_register_guid (dev, minor);
-	return;
 }
 #endif  /*  CONFIG_DEVFS_FS  */
 
@@ -478,7 +354,6 @@
 		dev->part[minor].de = NULL;
 		devfs_dealloc_unique_number (&disc_numspace,
 					     dev->part[minor].number);
-		free_disk_guids (dev, minor);
 	}
 #endif  /*  CONFIG_DEVFS_FS  */
 }
@@ -496,21 +371,8 @@
 void register_disk(struct gendisk *gdev, kdev_t dev, unsigned minors,
 	struct block_device_operations *ops, long size)
 {
-	int i;
-
 	if (!gdev)
 		return;
-
-#ifdef CONFIG_DEVFS_GUID
-	/* Initialize all guid fields to NULL (=^ not kmalloc'ed).
-	   It is assumed that drivers call register_disk after
-	   allocating the gen_hd structure, and call grok_partitions
-	   directly for a revalidate event, as those drives I've inspected
-	   (among which hd and sd) do. */
-	for (i = 0; i < gdev->max_p; i++)
-		gdev->part[MINOR(dev) + i].guid = NULL;
-#endif
-
 	grok_partitions(gdev, MINOR(dev)>>gdev->minor_shift, minors, size);
 }
 
@@ -527,12 +389,6 @@
 	/* No such device or no minors to use for partitions */
 	if (!size || minors == 1)
 		return;
-
-	/* In case this is a revalidation, free GUID memory.
-	   On the first call for this device,
-	   register_disk has set all entries to NULL,
-	   and nothing will happen. */
-	free_disk_guids (dev, first_minor);
 
 	if (dev->sizes) {
 		dev->sizes[first_minor] = size >> (BLOCK_SIZE_BITS - 9);
diff -ur linux.pre-matt/fs/partitions/efi.c linux/fs/partitions/efi.c
--- linux.pre-matt/fs/partitions/efi.c	Tue Apr  2 00:06:02 2002
+++ linux/fs/partitions/efi.c	Tue Apr  2 00:21:24 2002
@@ -3,13 +3,7 @@
  * Per Intel EFI Specification v1.02
  * http://developer.intel.com/technology/efi/efi.htm
  * efi.[ch] by Matt Domsch <Matt_Domsch@dell.com>
- *   Copyright 2000,2001 Dell Computer Corporation
- *
- * Note, the EFI Specification, v1.02, has a reference to
- * Dr. Dobbs Journal, May 1994 (actually it's in May 1992)
- * but that isn't the CRC function being used by EFI.  Intel's
- * EFI Sample Implementation shows that they use the same function
- * as was COPYRIGHT (C) 1986 Gary S. Brown.
+ *   Copyright 2000,2001,2002 Dell Computer Corporation
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License as published by
@@ -29,6 +23,36 @@
  * TODO:
  *
  * Changelog:
+ * Wed  Mar 27 2002 Matt Domsch <Matt_Domsch@dell.com>
+ * - Ported to 2.5.7-pre1 and 2.4.18
+ * - Applied patch to avoid fault in alternate header handling
+ * - cleaned up find_valid_gpt
+ * - On-disk structure and copy in memory is *always* LE now - 
+ *   swab fields as needed
+ * - remove print_gpt_header()
+ * - only use first max_p partition entries, to keep the kernel minor number
+ *   and partition numbers tied.
+ * - 2.4.18 patch needs own crc32() function - there's no official
+ *   lib/crc32.c in 2.4.x.
+ *
+ * Mon  Feb 04 2002 Matt Domsch <Matt_Domsch@dell.com>
+ * - Removed __PRIPTR_PREFIX - not being used
+ *
+ * Mon  Jan 14 2002 Matt Domsch <Matt_Domsch@dell.com>
+ * - Ported to 2.5.2-pre11 + library crc32 patch Linus applied
+ *
+ * Thu Dec 6 2001 Matt Domsch <Matt_Domsch@dell.com>
+ * - Added compare_gpts().
+ * - moved le_efi_guid_to_cpus() back into this file.  GPT is the only
+ *   thing that keeps EFI GUIDs on disk.
+ * - Changed gpt structure names and members to be simpler and more Linux-like.
+ * 
+ * Wed Oct 17 2001 Matt Domsch <Matt_Domsch@dell.com>
+ * - Removed CONFIG_DEVFS_VOLUMES_UUID code entirely per Martin Wilck
+ *
+ * Wed Oct 10 2001 Matt Domsch <Matt_Domsch@dell.com>
+ * - Changed function comments to DocBook style per Andreas Dilger suggestion.
+ *
  * Mon Oct 08 2001 Matt Domsch <Matt_Domsch@dell.com>
  * - Change read_lba() to use the page cache per Al Viro's work.
  * - print u64s properly on all architectures
@@ -46,8 +70,8 @@
  * - Added kernel command line option 'gpt' to override valid PMBR test.
  *
  * Wed Jun  6 2001 Martin Wilck <Martin.Wilck@Fujitsu-Siemens.com>
- * - added devfs GUID support (/dev/guid) for mounting file systems
- *   by the partition GUID. 
+ * - added devfs volume UUID support (/dev/volumes/uuids) for
+ *   mounting file systems by the partition GUID. 
  *
  * Tue Dec  5 2000 Matt Domsch <Matt_Domsch@dell.com>
  * - Moved crc32() to linux/lib, added efi_crc32().
@@ -74,7 +98,6 @@
 #include <linux/blkpg.h>
 #include <linux/slab.h>
 #include <linux/smp_lock.h>
-#include <linux/crc32.h>
 #include <linux/init.h>
 #include <asm/system.h>
 #include <asm/byteorder.h>
@@ -86,11 +109,13 @@
 #endif
 
 /* Handle printing of 64-bit values */
-#if BITS_PER_LONG == 64
-#define PU64X "%lx"
-#else
-#define PU64X "%llx"
-#endif
+/* Borrowed from /usr/include/inttypes.h */
+# if BITS_PER_LONG == 64 
+#  define __PRI64_PREFIX	"l"
+# else
+#  define __PRI64_PREFIX	"ll"
+# endif
+# define PRIx64		__PRI64_PREFIX "x"
 
 
 #undef EFI_DEBUG
@@ -104,92 +129,119 @@
  * the test for invalid PMBR.  Not __initdata because reloading
  * the partition tables happens after init too.
  */
-static int forcegpt;
-static int __init force_gpt(char *str)
+static int force_gpt;
+static int __init
+force_gpt_fn(char *str)
 {
-	forcegpt = 1;
+	force_gpt = 1;
 	return 1;
 }
-
-__setup("gpt", force_gpt);
-
+__setup("gpt", force_gpt_fn);
 
 
+/*
+ * There are multiple 16-bit CRC polynomials in common use, but this is
+ * *the* standard CRC-32 polynomial, first popularized by Ethernet.
+ * x^32+x^26+x^23+x^22+x^16+x^12+x^11+x^10+x^8+x^7+x^5+x^4+x^2+x^1+x^0
+ */
+#define CRCPOLY_LE 0xedb88320
+/* How many bits at a time to use.  Requires a table of 4<<CRC_xx_BITS bytes. */
+/* For less performance-sensitive, use 4 */
+#define CRC_LE_BITS 8
+static u32 *crc32table_le;
 
-/************************************************************
- * efi_crc32()
- * Requires:
- *  - a buffer of length len
- * Modifies: nothing
- * Returns:
- *  EFI-style CRC32 value for buf
+/**
+ * crc32init_le() - allocate and initialize LE table data
  *
- * This function uses the crc32 function by Gary S. Brown,
- * but seeds the function with ~0, and xor's with ~0 at the end.
- ************************************************************/
+ * crc is the crc of the byte i; other entries are filled in based on the
+ * fact that crctable[i^j] = crctable[i] ^ crctable[j].
+ *
+ */
+static int __init crc32init_le(void)
+{
+	unsigned i, j;
+	u32 crc = 1;
+
+	crc32table_le =
+	    kmalloc((1 << CRC_LE_BITS) * sizeof(u32), GFP_KERNEL);
+	if (!crc32table_le)
+		return 1;
+	crc32table_le[0] = 0;
+
+	for (i = 1 << (CRC_LE_BITS - 1); i; i >>= 1) {
+		crc = (crc >> 1) ^ ((crc & 1) ? CRCPOLY_LE : 0);
+		for (j = 0; j < 1 << CRC_LE_BITS; j += 2 * i)
+			crc32table_le[i + j] = crc ^ crc32table_le[j];
+	}
+	return 0;
+}
 
-static inline u32 efi_crc32(const void *buf, unsigned long len)
+/**
+ * crc32cleanup_le(): free LE table data
+ */
+static void __exit crc32cleanup_le(void)
 {
-	return (crc32(buf, len, ~0L) ^ ~0L);
+	if (crc32table_le) kfree(crc32table_le);
+	crc32table_le = NULL;
 }
 
+__initcall(crc32init_le);
+__exitcall(crc32cleanup_le);
 
-/************************************************************
- * le_guid_to_cpus()
- * Requires: guid
- * Modifies: guid in situ
- * Returns: nothing
- *
- * This function converts a little endian efi_guid_t to the
- * native cpu representation.  The EFI Spec. declares that all 
- * on-disk structures are stored in little endian format.
+/**
+ * crc32_le() - Calculate bitwise little-endian Ethernet AUTODIN II CRC32
+ * @crc - seed value for computation.  ~0 for Ethernet, sometimes 0 for
+ *        other uses, or the previous crc32 value if computing incrementally.
+ * @p   - pointer to buffer over which CRC is run
+ * @len - length of buffer @p
  * 
- ************************************************************/
-
-static void le_guid_to_cpus(efi_guid_t * guid)
+ */
+static u32 crc32_le(u32 crc, unsigned char const *p, size_t len)
 {
-	le32_to_cpus(guid->data1);
-	le16_to_cpus(guid->data2);
-	le16_to_cpus(guid->data3);
-	/* no need to change data4. It's already an array of chars */
-	return;
+	while (len--) {
+		crc = (crc >> 8) ^ crc32table_le[(crc ^ *p++) & 255];
+	}
+	return crc;
 }
 
-/************************************************************
- * le_part_attributes_to_cpus()
- * Requires: attributes
- * Modifies: attributes in situ
- * Returns: nothing
+
+/**
+ * efi_crc32() - EFI version of crc32 function
+ * @buf: buffer to calculate crc32 of
+ * @len - length of buf
  *
- * This function converts a little endian partition attributes
- * struct to the native cpu representation.
+ * Description: Returns EFI-style CRC32 value for @buf
  * 
- ************************************************************/
-
-static void le_part_attributes_to_cpus(GuidPartitionEntryAttributes_t * a)
+ * This function uses the little endian Ethernet polynomial
+ * but seeds the function with ~0, and xor's with ~0 at the end.
+ * Note, the EFI Specification, v1.02, has a reference to
+ * Dr. Dobbs Journal, May 1994 (actually it's in May 1992).
+ */
+static inline u32
+efi_crc32(const void *buf, unsigned long len)
 {
-	u64 *b = (u64 *) a;
-	*b = le64_to_cpu(*b);
+	return (crc32_le(~0L, buf, len) ^ ~0L);
 }
 
-/************************************************************
- * is_pmbr_valid()
- * Requires:
- *  - mbr is a pointer to a legacy mbr structure
- * Modifies: nothing
- * Returns:
- *  1 on true
- *  0 on false
- ************************************************************/
-static int is_pmbr_valid(LegacyMBR_t * mbr)
+/**
+ * is_pmbr_valid(): test Protective MBR for validity
+ * @mbr: pointer to a legacy mbr structure
+ *
+ * Description: Returns 1 if PMBR is valid, 0 otherwise.
+ * Validity depends on two things:
+ *  1) MSDOS signature is in the last two bytes of the MBR
+ *  2) One partition of type 0xEE is found
+ */
+static int
+is_pmbr_valid(legacy_mbr *mbr)
 {
 	int i, found = 0, signature = 0;
 	if (!mbr)
 		return 0;
-	signature = (le16_to_cpu(mbr->Signature) == MSDOS_MBR_SIGNATURE);
+	signature = (le16_to_cpu(mbr->signature) == MSDOS_MBR_SIGNATURE);
 	for (i = 0; signature && i < 4; i++) {
-		if (mbr->PartitionRecord[i].OSType ==
-		    EFI_PMBR_OSTYPE_EFI_GPT) {
+		if (mbr->partition_record[i].sys_ind ==
+                    EFI_PMBR_OSTYPE_EFI_GPT) {
 			found = 1;
 			break;
 		}
@@ -197,43 +249,35 @@
 	return (signature && found);
 }
 
-
-/************************************************************
- * last_lba()
- * Requires:
- *  - struct gendisk hd
- *  - struct block_device *bdev
- * Modifies: nothing
- * Returns:
- *  Last LBA value on success.  This is stored (by sd and
- *  ide-geometry) in
+/**
+ * last_lba(): return number of last logical block of device
+ * @hd: gendisk with partition list
+ * @bdev: block device
+ * 
+ * Description: Returns last LBA value on success, 0 on error.
+ * This is stored (by sd and ide-geometry) in
  *  the part[0] entry for this disk, and is the number of
  *  physical sectors available on the disk.
- *  0 on error
- ************************************************************/
-static u64 last_lba(struct gendisk *hd, struct block_device *bdev)
+ */
+static u64
+last_lba(struct gendisk *hd, struct block_device *bdev)
 {
 	if (!hd || !hd->part || !bdev)
 		return 0;
 	return hd->part[MINOR(to_kdev_t(bdev->bd_dev))].nr_sects - 1;
 }
 
-
-/************************************************************
- * read_lba()
- * Requires:
- *  - hd is our disk device.
- *  - bdev is our device major number
- *  - lba is the logical block address desired (disk hardsector number)
- *  - buffer is a buffer of size size into which data copied
- *  - size_t count is size of the read (in bytes)
- * Modifies:
- *  - buffer
- * Returns:
- *  - count of bytes read
- *  - 0 on error
- ************************************************************/
-
+/**
+ * read_lba(): Read bytes from disk, starting at given LBA
+ * @hd
+ * @bdev
+ * @lba
+ * @buffer
+ * @size_t
+ *
+ * Description:  Reads @count bytes from @bdev into @buffer.
+ * Returns number of bytes read on success, 0 on error.
+ */
 static size_t
 read_lba(struct gendisk *hd, struct block_device *bdev, u64 lba,
 	 u8 * buffer, size_t count)
@@ -259,8 +303,7 @@
 
 		bytesread =
 		    PAGE_CACHE_SIZE - (data -
-				       (unsigned char *) page_address(sect.
-								      v));
+				       (unsigned char *) page_address(sect.v));
 		bytesread = min(bytesread, count);
 		memcpy(buffer, data, bytesread);
 		put_dev_sector(sect);
@@ -274,57 +317,27 @@
 }
 
 
-
-static void print_gpt_header(GuidPartitionTableHeader_t * gpt)
-{
-	Dprintk("GUID Partition Table Header\n");
-	if (!gpt)
-		return;
-	Dprintk("Signature      : " PU64X "\n", gpt->Signature);
-	Dprintk("Revision       : %x\n", gpt->Revision);
-	Dprintk("HeaderSize     : %x\n", gpt->HeaderSize);
-	Dprintk("HeaderCRC32    : %x\n", gpt->HeaderCRC32);
-	Dprintk("MyLBA          : " PU64X "\n", gpt->MyLBA);
-	Dprintk("AlternateLBA   : " PU64X "\n", gpt->AlternateLBA);
-	Dprintk("FirstUsableLBA : " PU64X "\n", gpt->FirstUsableLBA);
-	Dprintk("LastUsableLBA  : " PU64X "\n", gpt->LastUsableLBA);
-
-	Dprintk("PartitionEntryLBA : " PU64X "\n", gpt->PartitionEntryLBA);
-	Dprintk("NumberOfPartitionEntries : %x\n",
-		gpt->NumberOfPartitionEntries);
-	Dprintk("SizeOfPartitionEntry : %x\n", gpt->SizeOfPartitionEntry);
-	Dprintk("PartitionEntryArrayCRC32 : %x\n",
-		gpt->PartitionEntryArrayCRC32);
-
-	return;
-}
-
-
-
-/************************************************************
- * alloc_read_gpt_entries()
- * Requires:
- *  - hd, bdev, gpt
- * Modifies:
- *  - nothing
- * Returns:
- *   ptes on success
- *   NULL on error
+/**
+ * alloc_read_gpt_entries(): reads partition entries from disk
+ * @hd
+ * @bdev
+ * @gpt - GPT header
+ * 
+ * Description: Returns ptes on success,  NULL on error.
+ * Allocates space for PTEs based on information found in @gpt.
  * Notes: remember to free pte when you're done!
- ************************************************************/
-static GuidPartitionEntry_t *
+ */
+static gpt_entry *
 alloc_read_gpt_entries(struct gendisk *hd,
-                       struct block_device *bdev,
-                       GuidPartitionTableHeader_t *gpt)
+		       struct block_device *bdev, gpt_header *gpt)
 {
-	u32 i, j;
 	size_t count;
-	GuidPartitionEntry_t *pte;
+	gpt_entry *pte;
 	if (!hd || !bdev || !gpt)
 		return NULL;
 
-	count = gpt->NumberOfPartitionEntries * gpt->SizeOfPartitionEntry;
-	Dprintk("ReadGPTEs() kmallocing %x bytes\n", count);
+	count = le32_to_cpu(gpt->num_partition_entries) *
+                le32_to_cpu(gpt->sizeof_partition_entry);
 	if (!count)
 		return NULL;
 	pte = kmalloc(count, GFP_KERNEL);
@@ -332,108 +345,62 @@
 		return NULL;
 	memset(pte, 0, count);
 
-	if (read_lba(hd, bdev, gpt->PartitionEntryLBA, (u8 *) pte,
+	if (read_lba(hd, bdev, le64_to_cpu(gpt->partition_entry_lba),
+                     (u8 *) pte,
 		     count) < count) {
 		kfree(pte);
+                pte=NULL;
 		return NULL;
 	}
-	/* Fixup endianness */
-	for (i = 0; i < gpt->NumberOfPartitionEntries; i++) {
-		le_guid_to_cpus(&pte[i].PartitionTypeGuid);
-		le_guid_to_cpus(&pte[i].UniquePartitionGuid);
-		le64_to_cpus(pte[i].StartingLBA);
-		le64_to_cpus(pte[i].EndingLBA);
-		le_part_attributes_to_cpus(&pte[i].Attributes);
-		for (j = 0; j < (72 / sizeof(efi_char16_t)); j++) {
-			le16_to_cpus((u16) (pte[i].PartitionName[j]));
-		}
-	}
-
 	return pte;
 }
 
-
-
-/************************************************************
- * alloc_read_gpt_header()
- * Requires:
- *  - hd is our struct gendisk
- *  - dev is our device major number
- *  - lba is the Logical Block Address of the partition table
- *  - gpt is a buffer into which the GPT will be put
- *  - pte is a buffer into which the PTEs will be put
- * Modifies:
- *  - gpt and pte
- * Returns:
- *   1 on success
- *   0 on error
- ************************************************************/
-
-static GuidPartitionTableHeader_t *alloc_read_gpt_header(struct gendisk
-							 *hd,
-							 struct
-							 block_device
-							 *bdev, u64 lba)
+/**
+ * alloc_read_gpt_header(): Allocates GPT header, reads into it from disk
+ * @hd
+ * @bdev
+ * @lba is the Logical Block Address of the partition table
+ * 
+ * Description: returns GPT header on success, NULL on error.   Allocates
+ * and fills a GPT header starting at @ from @bdev.
+ * Note: remember to free gpt when finished with it.
+ */
+static gpt_header *
+alloc_read_gpt_header(struct gendisk *hd, struct block_device *bdev, u64 lba)
 {
-	GuidPartitionTableHeader_t *gpt;
+	gpt_header *gpt;
 	if (!hd || !bdev)
 		return NULL;
 
-	gpt = kmalloc(sizeof(GuidPartitionTableHeader_t), GFP_KERNEL);
+	gpt = kmalloc(sizeof (gpt_header), GFP_KERNEL);
 	if (!gpt)
 		return NULL;
-	memset(gpt, 0, sizeof(GuidPartitionTableHeader_t));
+	memset(gpt, 0, sizeof (gpt_header));
 
-	Dprintk("GPTH() calling read_lba().\n");
 	if (read_lba(hd, bdev, lba, (u8 *) gpt,
-		     sizeof(GuidPartitionTableHeader_t)) <
-	    sizeof(GuidPartitionTableHeader_t)) {
-		Dprintk("ReadGPTH(" PU64X ") read failed.\n", lba);
+		     sizeof (gpt_header)) < sizeof (gpt_header)) {
 		kfree(gpt);
+                gpt=NULL;
 		return NULL;
 	}
 
-	/* Fixup endianness */
-	le64_to_cpus(gpt->Signature);
-	le32_to_cpus(gpt->Revision);
-	le32_to_cpus(gpt->HeaderSize);
-	le32_to_cpus(gpt->HeaderCRC32);
-	le32_to_cpus(gpt->Reserved1);
-	le64_to_cpus(gpt->MyLBA);
-	le64_to_cpus(gpt->AlternateLBA);
-	le64_to_cpus(gpt->FirstUsableLBA);
-	le64_to_cpus(gpt->LastUsableLBA);
-	le_guid_to_cpus(&gpt->DiskGUID);
-	le64_to_cpus(gpt->PartitionEntryLBA);
-	le32_to_cpus(gpt->NumberOfPartitionEntries);
-	le32_to_cpus(gpt->SizeOfPartitionEntry);
-	le32_to_cpus(gpt->PartitionEntryArrayCRC32);
-
-	print_gpt_header(gpt);
-
 	return gpt;
 }
 
-
-
-/************************************************************
- * is_gpt_valid()
- * Requires:
- *  - gd points to our struct gendisk
- *  - dev is our device major number
- *  - lba is the logical block address of the GPTH to test
- *  - gpt is a GPTH if it's valid
- *  - ptes is a PTEs if it's valid
- * Modifies:
- *  - gpt and ptes
- * Returns:
- *   1 if valid
- *   0 on error
- ************************************************************/
+/**
+ * is_gpt_valid() - tests one GPT header and PTEs for validity
+ * @hd
+ * @bdev
+ * @lba is the logical block address of the GPT header to test
+ * @gpt is a GPT header ptr, filled on return.
+ * @ptes is a PTEs ptr, filled on return.
+ *
+ * Description: returns 1 if valid,  0 on error.
+ * If valid, returns pointers to newly allocated GPT header and PTEs.
+ */
 static int
 is_gpt_valid(struct gendisk *hd, struct block_device *bdev, u64 lba,
-	     GuidPartitionTableHeader_t ** gpt,
-	     GuidPartitionEntry_t ** ptes)
+	     gpt_header **gpt, gpt_entry **ptes)
 {
 	u32 crc, origcrc;
 
@@ -442,10 +409,10 @@
 	if (!(*gpt = alloc_read_gpt_header(hd, bdev, lba)))
 		return 0;
 
-	/* Check the GUID Partition Table Signature */
-	if ((*gpt)->Signature != GPT_HEADER_SIGNATURE) {
-		Dprintk("GUID Partition Table Header Signature is wrong: "
-			PU64X " != " PU64X "\n", (*gpt)->Signature,
+	/* Check the GUID Partition Table signature */
+	if (le64_to_cpu((*gpt)->signature) != GPT_HEADER_SIGNATURE) {
+		Dprintk("GUID Partition Table Header signature is wrong: %"
+			PRIx64 " != %" PRIx64 "\n", le64_to_cpu((*gpt)->signature),
 			GPT_HEADER_SIGNATURE);
 		kfree(*gpt);
 		*gpt = NULL;
@@ -453,34 +420,31 @@
 	}
 
 	/* Check the GUID Partition Table CRC */
-	origcrc = (*gpt)->HeaderCRC32;
-	(*gpt)->HeaderCRC32 = 0;
-	crc =
-	    efi_crc32((const unsigned char *) (*gpt), (*gpt)->HeaderSize);
-
+	origcrc = le32_to_cpu((*gpt)->header_crc32);
+	(*gpt)->header_crc32 = 0;
+	crc = efi_crc32((const unsigned char *) (*gpt), le32_to_cpu((*gpt)->header_size));
 
 	if (crc != origcrc) {
 		Dprintk
 		    ("GUID Partition Table Header CRC is wrong: %x != %x\n",
-		     (*gpt)->HeaderCRC32, origcrc);
+		     crc, origcrc);
 		kfree(*gpt);
 		*gpt = NULL;
 		return 0;
 	}
-	(*gpt)->HeaderCRC32 = origcrc;
+	(*gpt)->header_crc32 = cpu_to_le32(origcrc);
 
-	/* Check that the MyLBA entry points to the LBA that contains
+	/* Check that the my_lba entry points to the LBA that contains
 	 * the GUID Partition Table */
-	if ((*gpt)->MyLBA != lba) {
-		Dprintk("GPT MyLBA incorrect: " PU64X " != " PU64X "\n",
-			(*gpt)->MyLBA, lba);
+	if (le64_to_cpu((*gpt)->my_lba) != lba) {
+		Dprintk("GPT my_lba incorrect: %" PRIx64 " != %" PRIx64 "\n",
+			le64_to_cpu((*gpt)->my_lba), lba);
 		kfree(*gpt);
 		*gpt = NULL;
 		return 0;
 	}
 
 	if (!(*ptes = alloc_read_gpt_entries(hd, bdev, *gpt))) {
-		Dprintk("read PTEs failed.\n");
 		kfree(*gpt);
 		*gpt = NULL;
 		return 0;
@@ -488,12 +452,11 @@
 
 	/* Check the GUID Partition Entry Array CRC */
 	crc = efi_crc32((const unsigned char *) (*ptes),
-			(*gpt)->NumberOfPartitionEntries *
-			(*gpt)->SizeOfPartitionEntry);
+			le32_to_cpu((*gpt)->num_partition_entries) *
+			le32_to_cpu((*gpt)->sizeof_partition_entry));
 
-	if (crc != (*gpt)->PartitionEntryArrayCRC32) {
-		Dprintk
-		    ("GUID Partitition Entry Array CRC check failed.\n");
+	if (crc != le32_to_cpu((*gpt)->partition_entry_array_crc32)) {
+		Dprintk("GUID Partitition Entry Array CRC check failed.\n");
 		kfree(*gpt);
 		*gpt = NULL;
 		kfree(*ptes);
@@ -501,163 +464,231 @@
 		return 0;
 	}
 
-
 	/* We're done, all's well */
 	return 1;
 }
 
+/**
+ * compare_gpts() - Search disk for valid GPT headers and PTEs
+ * @pgpt is the primary GPT header
+ * @agpt is the alternate GPT header
+ * @lastlba is the last LBA number
+ * Description: Returns nothing.  Sanity checks pgpt and agpt fields
+ * and prints warnings on discrepancies.
+ * 
+ */
+static void
+compare_gpts(gpt_header *pgpt, gpt_header *agpt, u64 lastlba)
+{
+	int error_found = 0;
+	if (!pgpt || !agpt)
+		return;
+	if (le64_to_cpu(pgpt->my_lba) != le64_to_cpu(agpt->alternate_lba)) {
+		printk(KERN_WARNING
+		       "GPT:Primary header LBA != Alt. header alternate_lba\n");
+		printk(KERN_WARNING "GPT:%" PRIx64 " != %" PRIx64 "\n",
+		       le64_to_cpu(pgpt->my_lba),
+                       le64_to_cpu(agpt->alternate_lba));
+		error_found++;
+	}
+	if (le64_to_cpu(pgpt->alternate_lba) != le64_to_cpu(agpt->my_lba)) {
+		printk(KERN_WARNING
+		       "GPT:Primary header alternate_lba != Alt. header my_lba\n");
+		printk(KERN_WARNING "GPT:%" PRIx64 " != %" PRIx64 "\n",
+		       le64_to_cpu(pgpt->alternate_lba),
+                       le64_to_cpu(agpt->my_lba));
+		error_found++;
+	}
+	if (le64_to_cpu(pgpt->first_usable_lba) !=
+            le64_to_cpu(agpt->first_usable_lba)) {
+		printk(KERN_WARNING "GPT:first_usable_lbas don't match.\n");
+		printk(KERN_WARNING "GPT:%" PRIx64 " != %" PRIx64 "\n",
+		       le64_to_cpu(pgpt->first_usable_lba),
+                       le64_to_cpu(agpt->first_usable_lba));
+		error_found++;
+	}
+	if (le64_to_cpu(pgpt->last_usable_lba) !=
+            le64_to_cpu(agpt->last_usable_lba)) {
+		printk(KERN_WARNING "GPT:last_usable_lbas don't match.\n");
+		printk(KERN_WARNING "GPT:%" PRIx64 " != %" PRIx64 "\n",
+		       le64_to_cpu(pgpt->last_usable_lba),
+                       le64_to_cpu(agpt->last_usable_lba));
+		error_found++;
+	}
+	if (efi_guidcmp(pgpt->disk_guid, agpt->disk_guid)) {
+		printk(KERN_WARNING "GPT:disk_guids don't match.\n");
+		error_found++;
+	}
+	if (le32_to_cpu(pgpt->num_partition_entries) !=
+            le32_to_cpu(agpt->num_partition_entries)) {
+		printk(KERN_WARNING "GPT:num_partition_entries don't match: "
+		       "0x%x != 0x%x\n",
+		       le32_to_cpu(pgpt->num_partition_entries),
+		       le32_to_cpu(agpt->num_partition_entries));
+		error_found++;
+	}
+	if (le32_to_cpu(pgpt->sizeof_partition_entry) !=
+            le32_to_cpu(agpt->sizeof_partition_entry)) {
+		printk(KERN_WARNING
+		       "GPT:sizeof_partition_entry values don't match: "
+		       "0x%x != 0x%x\n",
+                       le32_to_cpu(pgpt->sizeof_partition_entry),
+		       le32_to_cpu(agpt->sizeof_partition_entry));
+		error_found++;
+	}
+	if (le32_to_cpu(pgpt->partition_entry_array_crc32) !=
+            le32_to_cpu(agpt->partition_entry_array_crc32)) {
+		printk(KERN_WARNING
+		       "GPT:partition_entry_array_crc32 values don't match: "
+		       "0x%x != 0x%x\n",
+                       le32_to_cpu(pgpt->partition_entry_array_crc32),
+		       le32_to_cpu(agpt->partition_entry_array_crc32));
+		error_found++;
+	}
+	if (le64_to_cpu(pgpt->alternate_lba) != lastlba) {
+		printk(KERN_WARNING
+		       "GPT:Primary header thinks Alt. header is not at the end of the disk.\n");
+		printk(KERN_WARNING "GPT:%" PRIx64 " != %" PRIx64 "\n",
+		       le64_to_cpu(pgpt->alternate_lba), lastlba);
+		error_found++;
+	}
+
+	if (le64_to_cpu(agpt->my_lba) != lastlba) {
+		printk(KERN_WARNING
+		       "GPT:Alternate GPT header not at the end of the disk.\n");
+		printk(KERN_WARNING "GPT:%" PRIx64 " != %" PRIx64 "\n",
+		       le64_to_cpu(agpt->my_lba), lastlba);
+		error_found++;
+	}
 
+	if (error_found)
+		printk(KERN_WARNING
+		       "GPT: Use GNU Parted to correct GPT errors.\n");
+	return;
+}
 
-/************************************************************
- * find_valid_gpt()
- * Requires:
- *  - gd points to our struct gendisk
- *  - dev is our device major number
- *  - gpt is a GPTH if it's valid
- *  - ptes is a PTE
- * Modifies:
- *  - gpt & ptes
- * Returns:
- *   1 if valid
- *   0 on error
- ************************************************************/
+/**
+ * find_valid_gpt() - Search disk for valid GPT headers and PTEs
+ * @hd
+ * @bdev
+ * @gpt is a GPT header ptr, filled on return.
+ * @ptes is a PTEs ptr, filled on return.
+ * Description: Returns 1 if valid, 0 on error.
+ * If valid, returns pointers to newly allocated GPT header and PTEs.
+ * Validity depends on finding either the Primary GPT header and PTEs valid,
+ * or the Alternate GPT header and PTEs valid, and the PMBR valid.
+ */
 static int
 find_valid_gpt(struct gendisk *hd, struct block_device *bdev,
-	       GuidPartitionTableHeader_t ** gpt,
-	       GuidPartitionEntry_t ** ptes)
+	       gpt_header **gpt, gpt_entry **ptes)
 {
 	int good_pgpt = 0, good_agpt = 0, good_pmbr = 0;
-	GuidPartitionTableHeader_t *pgpt = NULL, *agpt = NULL;
-	GuidPartitionEntry_t *pptes = NULL, *aptes = NULL;
-	LegacyMBR_t *legacyMbr = NULL;
+	gpt_header *pgpt = NULL, *agpt = NULL;
+	gpt_entry *pptes = NULL, *aptes = NULL;
+	legacy_mbr *legacymbr = NULL;
 	u64 lastlba;
 	if (!hd || !bdev || !gpt || !ptes)
 		return 0;
 
 	lastlba = last_lba(hd, bdev);
-	/* Check the Primary GPT */
 	good_pgpt = is_gpt_valid(hd, bdev, GPT_PRIMARY_PARTITION_TABLE_LBA,
 				 &pgpt, &pptes);
-	if (good_pgpt) {
-		/* Primary GPT is OK, check the alternate and warn if bad */
-		good_agpt = is_gpt_valid(hd, bdev, pgpt->AlternateLBA,
+        if (good_pgpt) {
+		good_agpt = is_gpt_valid(hd, bdev,
+                                         le64_to_cpu(pgpt->alternate_lba),
 					 &agpt, &aptes);
-		if (!good_agpt) {
-			printk(KERN_WARNING
-			       "Alternate GPT is invalid, using primary GPT.\n");
-		}
+                if (!good_agpt) {
+                        good_agpt = is_gpt_valid(hd, bdev, lastlba,
+                                                 &agpt, &aptes);
+                }
+        }
+        else {
+                good_agpt = is_gpt_valid(hd, bdev, lastlba,
+                                         &agpt, &aptes);
+        }
+
+        /* The obviously unsuccessful case */
+        if (!good_pgpt && !good_agpt) {
+                goto fail;
+        }
 
-		*gpt = pgpt;
-		*ptes = pptes;
-		if (agpt) {
-			kfree(agpt);
-			agpt = NULL;
-		}
-		if (aptes) {
-			kfree(aptes);
-			aptes = NULL;
-		}
-	} /* if primary is valid */
-	else {
-		/* Primary GPT is bad, check the Alternate GPT */
-		good_agpt = is_gpt_valid(hd, bdev, lastlba, &agpt, &aptes);
-		if (good_agpt) {
-			/* Primary is bad, alternate is good.
-			   Return values from the alternate and warn.
-			 */
-			printk(KERN_WARNING
-			       "Primary GPT is invalid, using alternate GPT.\n");
-			*gpt = agpt;
-			*ptes = aptes;
-		}
-	}
-
-	/* Now test for valid PMBR */
 	/* This will be added to the EFI Spec. per Intel after v1.02. */
-	if (good_pgpt || good_agpt) {
-		legacyMbr = kmalloc(sizeof(*legacyMbr), GFP_KERNEL);
-		if (legacyMbr) {
-			memset(legacyMbr, 0, sizeof(*legacyMbr));
-			read_lba(hd, bdev, 0, (u8 *) legacyMbr,
-				 sizeof(*legacyMbr));
-			good_pmbr = is_pmbr_valid(legacyMbr);
-			kfree(legacyMbr);
-		}
-		if (good_pmbr)
-			return 1;
-		if (!forcegpt) {
-			printk
-			    (" Warning: Disk has a valid GPT signature but invalid PMBR.\n");
-			printk(KERN_WARNING
-			       "  Assuming this disk is *not* a GPT disk anymore.\n");
-			printk(KERN_WARNING
-			       "  Use gpt kernel option to override.  Use GNU Parted to correct disk.\n");
-		} else {
-			printk(KERN_WARNING
-			       "  Warning: Disk has a valid GPT signature but invalid PMBR.\n");
-			printk(KERN_WARNING
-			       "  Use GNU Parted to correct disk.\n");
-			printk(KERN_WARNING
-			       "  gpt option taken, disk treated as GPT.\n");
-			return 1;
-		}
-	}
-
-	/* Both primary and alternate GPTs are bad, and/or PMBR is invalid.
-	 * This isn't our disk, return 0.
-	 */
-	*gpt = *ptes = NULL;
-
-	if (pgpt) {
-		kfree(pgpt);
-		pgpt = NULL;
-	}
-	if (agpt) {
-		kfree(agpt);
-		agpt = NULL;
-	}
-	if (pptes) {
-		kfree(pptes);
-		pptes = NULL;
-	}
-	if (aptes) {
-		kfree(aptes);
-		aptes = NULL;
-	}
-	return 0;
-}
-
-#ifdef CONFIG_DEVFS_GUID
-/* set_partition_guid */
-/* Fill in the GUID field of the partition.
-   It is set to NULL by register_disk before. */
-static void
-set_partition_guid(struct gendisk *hd,
-		   const int minor, const efi_guid_t * guid)
-{
-	efi_guid_t *part_guid = hd->part[minor].guid;
-
-	if (!guid || !hd)
-		return;
-
-	part_guid = kmalloc(sizeof(efi_guid_t), GFP_KERNEL);
-
-	if (part_guid) {
-		memcpy(part_guid, guid, sizeof(efi_guid_t));
-	} else {
-		printk(KERN_WARNING
-		       "add_gpt_partitions: cannot allocate GUID memory!\n");
-	};
-
-	hd->part[minor].guid = part_guid;
-}
-#else
-#define set_partition_guid(hd, minor, guid)
-#endif				/* CONFIG_DEVFS_GUID */
-
-/*
- * Create devices for each entry in the GUID Partition Table Entries.
- * The first block of each partition is a Legacy MBR.
+        legacymbr = kmalloc(sizeof (*legacymbr), GFP_KERNEL);
+        if (legacymbr) {
+                memset(legacymbr, 0, sizeof (*legacymbr));
+                read_lba(hd, bdev, 0, (u8 *) legacymbr,
+                         sizeof (*legacymbr));
+                good_pmbr = is_pmbr_valid(legacymbr);
+                kfree(legacymbr);
+                legacymbr=NULL;
+        }
+
+        /* Failure due to bad PMBR */
+        if ((good_pgpt || good_agpt) && !good_pmbr && !force_gpt) {
+                printk(KERN_WARNING 
+                       "  Warning: Disk has a valid GPT signature "
+                       "but invalid PMBR.\n");
+                printk(KERN_WARNING
+                       "  Assuming this disk is *not* a GPT disk anymore.\n");
+                printk(KERN_WARNING
+                       "  Use gpt kernel option to override.  "
+                       "Use GNU Parted to correct disk.\n");
+                goto fail;
+        }
+
+        /* Would fail due to bad PMBR, but force GPT anyhow */
+        if ((good_pgpt || good_agpt) && !good_pmbr && force_gpt) {
+                printk(KERN_WARNING
+                       "  Warning: Disk has a valid GPT signature but "
+                       "invalid PMBR.\n");
+                printk(KERN_WARNING
+                       "  Use GNU Parted to correct disk.\n");
+                printk(KERN_WARNING
+                       "  gpt option taken, disk treated as GPT.\n");
+        }
+
+        compare_gpts(pgpt, agpt, lastlba);
+
+        /* The good cases */
+        if (good_pgpt && (good_pmbr || force_gpt)) {
+                *gpt  = pgpt;
+                *ptes = pptes;
+                if (agpt)  { kfree(agpt);   agpt = NULL; }
+                if (aptes) { kfree(aptes); aptes = NULL; }
+                if (!good_agpt) {
+                        printk(KERN_WARNING 
+			       "Alternate GPT is invalid, "
+                               "using primary GPT.\n");
+                }
+                return 1;
+        }
+        else if (good_agpt && (good_pmbr || force_gpt)) {
+                *gpt  = agpt;
+                *ptes = aptes;
+                if (pgpt)  { kfree(pgpt);   pgpt = NULL; }
+                if (pptes) { kfree(pptes); pptes = NULL; }
+                printk(KERN_WARNING 
+                       "Primary GPT is invalid, using alternate GPT.\n");
+                return 1;
+        }
+
+ fail:
+        if (pgpt)  { kfree(pgpt);   pgpt=NULL; }
+        if (agpt)  { kfree(agpt);   agpt=NULL; }
+        if (pptes) { kfree(pptes); pptes=NULL; }
+        if (aptes) { kfree(aptes); aptes=NULL; }
+        *gpt = NULL;
+        *ptes = NULL;
+        return 0;
+}
+
+/**
+ * add_gpt_partitions(struct gendisk *hd, struct block_device *bdev,
+ * @hd
+ * @bdev
+ *
+ * Description: Create devices for each entry in the GUID Partition Table
+ * Entries.
  *
  * We do not create a Linux partition for GPT, but
  * only for the actual data partitions.
@@ -667,69 +698,69 @@
  *  1 if successful
  *
  */
-
 static int
-add_gpt_partitions(struct gendisk *hd, struct block_device *bdev,
-		   int nextminor)
+add_gpt_partitions(struct gendisk *hd, struct block_device *bdev, int nextminor)
 {
-	GuidPartitionTableHeader_t *gpt = NULL;
-	GuidPartitionEntry_t *ptes = NULL;
-	u32 i, nummade = 0;
-
-	efi_guid_t unusedGuid = UNUSED_ENTRY_GUID;
-#if CONFIG_BLK_DEV_MD
-	efi_guid_t raidGuid = PARTITION_LINUX_RAID_GUID;
-#endif
+	gpt_header *gpt = NULL;
+	gpt_entry *ptes = NULL;
+	u32 i;
+	int max_p; 
 
 	if (!hd || !bdev)
 		return -1;
 
 	if (!find_valid_gpt(hd, bdev, &gpt, &ptes) || !gpt || !ptes) {
-		if (gpt)
+		if (gpt) {
 			kfree(gpt);
-		if (ptes)
+                        gpt = NULL;
+                }
+		if (ptes) {
 			kfree(ptes);
+                        ptes = NULL;
+                }
 		return 0;
 	}
 
 	Dprintk("GUID Partition Table is valid!  Yea!\n");
 
-	set_partition_guid(hd, nextminor - 1, &(gpt->DiskGUID));
-
-	for (i = 0; i < gpt->NumberOfPartitionEntries &&
-	     nummade < (hd->max_p - 1); i++) {
-		if (!efi_guidcmp(unusedGuid, ptes[i].PartitionTypeGuid))
+	max_p = (1 << hd->minor_shift) - 1;
+	for (i = 0; i < le32_to_cpu(gpt->num_partition_entries) && i < max_p; i++) {
+		if (!efi_guidcmp(ptes[i].partition_type_guid, NULL_GUID))
 			continue;
 
-		add_gd_partition(hd, nextminor, ptes[i].StartingLBA,
-				 (ptes[i].EndingLBA - ptes[i].StartingLBA +
+		add_gd_partition(hd, nextminor+i,
+                                 le64_to_cpu(ptes[i].starting_lba),
+				 (le64_to_cpu(ptes[i].ending_lba) -
+                                  le64_to_cpu(ptes[i].starting_lba) +
 				  1));
 
-		set_partition_guid(hd, nextminor,
-				   &(ptes[i].UniquePartitionGuid));
-
 		/* If there's this is a RAID volume, tell md */
 #if CONFIG_BLK_DEV_MD
-		if (!efi_guidcmp(raidGuid, ptes[i].PartitionTypeGuid)) {
-			md_autodetect_dev(MKDEV
-					  (MAJOR(to_kdev_t(bdev->bd_dev)),
-					   nextminor));
+		if (!efi_guidcmp(ptes[i].partition_type_guid,
+                                 PARTITION_LINUX_RAID_GUID)) {
+                        md_autodetect_dev(MKDEV
+                                          (MAJOR(to_kdev_t(bdev->bd_dev)),
+                                           nextminor));
 		}
 #endif
-		nummade++;
-		nextminor++;
-
 	}
 	kfree(ptes);
+        ptes=NULL;
 	kfree(gpt);
+        gpt=NULL;
 	printk("\n");
 	return 1;
-
 }
 
-
-/*
- * efi_partition()
+/**
+ * efi_partition(): EFI GPT partition handling entry function
+ * @hd
+ * @bdev
+ * @first_sector: unused
+ * @first_part_minor: minor number assigned to first GPT partition found
+ *
+ * Description: called from check.c, if the disk contains GPT
+ * partitions, sets up partition entries in the kernel.
  *
  * If the first block on the disk is a legacy MBR,
  * it will get handled by msdos_partition().
@@ -744,9 +775,7 @@
  * -1 if unable to read the partition table
  *  0 if this isn't our partitoin table
  *  1 if successful
- *
  */
-
 int
 efi_partition(struct gendisk *hd, struct block_device *bdev,
 	      unsigned long first_sector, int first_part_minor)
@@ -759,7 +788,7 @@
 
 	/* Need to change the block size that the block layer uses */
 	if (blksize_size[MAJOR(dev)]) {
-		orig_blksize_size = blksize_size[MAJOR(dev)][MINOR(dev)];
+                orig_blksize_size = blksize_size[MAJOR(dev)][MINOR(dev)];
 	}
 
 	if (orig_blksize_size != hardblocksize)
@@ -773,7 +802,6 @@
 
 	return rc;
 }
-
 
 /*
  * Overrides for Emacs so that we follow Linus's tabbing style.
diff -ur linux.pre-matt/fs/partitions/efi.h linux/fs/partitions/efi.h
--- linux.pre-matt/fs/partitions/efi.h	Tue Apr  2 00:05:24 2002
+++ linux/fs/partitions/efi.h	Tue Apr  2 00:12:40 2002
@@ -39,7 +39,6 @@
  */
 #include <asm-ia64/efi.h>
 
-
 #define MSDOS_MBR_SIGNATURE 0xaa55
 #define EFI_PMBR_OSTYPE_EFI 0xEF
 #define EFI_PMBR_OSTYPE_EFI_GPT 0xEE
@@ -49,90 +48,73 @@
 #define GPT_HEADER_REVISION_V1 0x00010000
 #define GPT_PRIMARY_PARTITION_TABLE_LBA 1
 
-#define UNUSED_ENTRY_GUID    \
-    ((efi_guid_t) { 0x00000000, 0x0000, 0x0000, { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }})
 #define PARTITION_SYSTEM_GUID \
-((efi_guid_t) { 0xC12A7328, 0xF81F, 0x11d2, { 0xBA, 0x4B, 0x00, 0xA0, 0xC9, 0x3E, 0xC9, 0x3B }})
+    EFI_GUID( 0xC12A7328, 0xF81F, 0x11d2, \
+              0xBA, 0x4B, 0x00, 0xA0, 0xC9, 0x3E, 0xC9, 0x3B) 
 #define LEGACY_MBR_PARTITION_GUID \
-    ((efi_guid_t) { 0x024DEE41, 0x33E7, 0x11d3, { 0x9D, 0x69, 0x00, 0x08, 0xC7, 0x81, 0xF3, 0x9F }})
+    EFI_GUID( 0x024DEE41, 0x33E7, 0x11d3, \
+              0x9D, 0x69, 0x00, 0x08, 0xC7, 0x81, 0xF3, 0x9F)
 #define PARTITION_MSFT_RESERVED_GUID \
-    ((efi_guid_t) { 0xE3C9E316, 0x0B5C, 0x4DB8, { 0x81, 0x7D, 0xF9, 0x2D, 0xF0, 0x02, 0x15, 0xAE }})
+    EFI_GUID( 0xE3C9E316, 0x0B5C, 0x4DB8, \
+              0x81, 0x7D, 0xF9, 0x2D, 0xF0, 0x02, 0x15, 0xAE)
 #define PARTITION_BASIC_DATA_GUID \
-    ((efi_guid_t) { 0xEBD0A0A2, 0xB9E5, 0x4433, { 0x87, 0xC0, 0x68, 0xB6, 0xB7, 0x26, 0x99, 0xC7 }})
+    EFI_GUID( 0xEBD0A0A2, 0xB9E5, 0x4433, \
+              0x87, 0xC0, 0x68, 0xB6, 0xB7, 0x26, 0x99, 0xC7)
 #define PARTITION_LINUX_RAID_GUID \
-    ((efi_guid_t) { 0xa19d880f, 0x05fc, 0x4d3b, { 0xa0, 0x06, 0x74, 0x3f, 0x0f, 0x84, 0x91, 0x1e  }})
+    EFI_GUID( 0xa19d880f, 0x05fc, 0x4d3b, \
+              0xa0, 0x06, 0x74, 0x3f, 0x0f, 0x84, 0x91, 0x1e)
 #define PARTITION_LINUX_SWAP_GUID \
-    ((efi_guid_t) { 0x0657fd6d, 0xa4ab, 0x43c4, { 0x84, 0xe5, 0x09, 0x33, 0xc8, 0x4b, 0x4f, 0x4f  }})
+    EFI_GUID( 0x0657fd6d, 0xa4ab, 0x43c4, \
+              0x84, 0xe5, 0x09, 0x33, 0xc8, 0x4b, 0x4f, 0x4f)
 #define PARTITION_LINUX_LVM_GUID \
-    ((efi_guid_t) { 0xe6d6d379, 0xf507, 0x44c2, { 0xa2, 0x3c, 0x23, 0x8f, 0x2a, 0x3d, 0xf9, 0x28 }})
-
-typedef struct _GuidPartitionTableHeader_t {
-	u64 Signature;
-	u32 Revision;
-	u32 HeaderSize;
-	u32 HeaderCRC32;
-	u32 Reserved1;
-	u64 MyLBA;
-	u64 AlternateLBA;
-	u64 FirstUsableLBA;
-	u64 LastUsableLBA;
-	efi_guid_t DiskGUID;
-	u64 PartitionEntryLBA;
-	u32 NumberOfPartitionEntries;
-	u32 SizeOfPartitionEntry;
-	u32 PartitionEntryArrayCRC32;
-	u8 Reserved2[GPT_BLOCK_SIZE - 92];
-} __attribute__ ((packed)) GuidPartitionTableHeader_t;
-
-typedef struct _GuidPartitionEntryAttributes_t {
-	u64 RequiredToFunction:1;
-	u64 Reserved:63;
-} __attribute__ ((packed)) GuidPartitionEntryAttributes_t;
-
-typedef struct _GuidPartitionEntry_t {
-	efi_guid_t PartitionTypeGuid;
-	efi_guid_t UniquePartitionGuid;
-	u64 StartingLBA;
-	u64 EndingLBA;
-	GuidPartitionEntryAttributes_t Attributes;
-	efi_char16_t PartitionName[72 / sizeof(efi_char16_t)];
-} __attribute__ ((packed)) GuidPartitionEntry_t;
-
-typedef struct _PartitionRecord_t {
-	u8 BootIndicator;	/* Not used by EFI firmware. Set to 0x80 to indicate that this
-				   is the bootable legacy partition. */
-	u8 StartHead;		/* Start of partition in CHS address, not used by EFI firmware. */
-	u8 StartSector;		/* Start of partition in CHS address, not used by EFI firmware. */
-	u8 StartTrack;		/* Start of partition in CHS address, not used by EFI firmware. */
-	u8 OSType;		/* OS type. A value of 0xEF defines an EFI system partition.
-				   Other values are reserved for legacy operating systems, and
-				   allocated independently of the EFI specification. */
-	u8 EndHead;		/* End of partition in CHS address, not used by EFI firmware. */
-	u8 EndSector;		/* End of partition in CHS address, not used by EFI firmware. */
-	u8 EndTrack;		/* End of partition in CHS address, not used by EFI firmware. */
-	u32 StartingLBA;	/* Starting LBA address of the partition on the disk. Used by
-				   EFI firmware to define the start of the partition. */
-	u32 SizeInLBA;		/* Size of partition in LBA. Used by EFI firmware to determine
-				   the size of the partition. */
-} PartitionRecord_t;
-
-typedef struct _LegacyMBR_t {
-	u8 BootCode[440];
-	u32 UniqueMBRSignature;
-	u16 Unknown;
-	PartitionRecord_t PartitionRecord[4];
-	u16 Signature;
-} __attribute__ ((packed)) LegacyMBR_t;
-
+    EFI_GUID( 0xe6d6d379, 0xf507, 0x44c2, \
+              0xa2, 0x3c, 0x23, 0x8f, 0x2a, 0x3d, 0xf9, 0x28)
 
+typedef struct _gpt_header {
+	u64 signature;
+	u32 revision;
+	u32 header_size;
+	u32 header_crc32;
+	u32 reserved1;
+	u64 my_lba;
+	u64 alternate_lba;
+	u64 first_usable_lba;
+	u64 last_usable_lba;
+	efi_guid_t disk_guid;
+	u64 partition_entry_lba;
+	u32 num_partition_entries;
+	u32 sizeof_partition_entry;
+	u32 partition_entry_array_crc32;
+	u8 reserved2[GPT_BLOCK_SIZE - 92];
+} __attribute__ ((packed)) gpt_header;
+
+typedef struct _gpt_entry_attributes {
+	u64 required_to_function:1;
+	u64 reserved:47;
+        u64 type_guid_specific:16;
+} __attribute__ ((packed)) gpt_entry_attributes;
+
+typedef struct _gpt_entry {
+	efi_guid_t partition_type_guid;
+	efi_guid_t unique_partition_guid;
+	u64 starting_lba;
+	u64 ending_lba;
+	gpt_entry_attributes attributes;
+	efi_char16_t partition_name[72 / sizeof (efi_char16_t)];
+} __attribute__ ((packed)) gpt_entry;
+
+typedef struct _legacy_mbr {
+	u8 boot_code[440];
+	u32 unique_mbr_signature;
+	u16 unknown;
+	struct partition partition_record[4];
+	u16 signature;
+} __attribute__ ((packed)) legacy_mbr;
 
 /* Functions */
 extern int
-efi_partition(struct gendisk *hd, struct block_device *bdev,
+ efi_partition(struct gendisk *hd, struct block_device *bdev,
 	      unsigned long first_sector, int first_part_minor);
-
-
-
 
 #endif
 
diff -ur linux.pre-matt/fs/partitions/msdos.c linux/fs/partitions/msdos.c
--- linux.pre-matt/fs/partitions/msdos.c	Tue Apr  2 00:05:24 2002
+++ linux/fs/partitions/msdos.c	Tue Apr  2 00:12:40 2002
@@ -35,10 +35,7 @@
 
 #include "check.h"
 #include "msdos.h"
-
-#ifdef CONFIG_EFI_PARTITION
 #include "efi.h"
-#endif
 
 #if CONFIG_BLK_DEV_MD
 extern void md_autodetect_dev(kdev_t dev);
diff -ur linux.pre-matt/include/asm-ia64/efi.h linux/include/asm-ia64/efi.h
--- linux.pre-matt/include/asm-ia64/efi.h	Tue Apr  2 00:06:02 2002
+++ linux/include/asm-ia64/efi.h	Tue Apr  2 00:39:59 2002
@@ -32,13 +32,18 @@
 typedef u8 efi_bool_t;
 typedef u16 efi_char16_t;		/* UNICODE character */
 
+
 typedef struct {
-	u32 data1;
-	u16 data2;
-	u16 data3;
-	u8 data4[8];
+	u8 b[16];
 } efi_guid_t;
 
+#define EFI_GUID(a,b,c,d0,d1,d2,d3,d4,d5,d6,d7) \
+((efi_guid_t) \
+{{ (a) & 0xff, ((a) >> 8) & 0xff, ((a) >> 16) & 0xff, ((a) >> 24) & 0xff, \
+  (b) & 0xff, ((b) >> 8) & 0xff, \
+  (c) & 0xff, ((c) >> 8) & 0xff, \
+  (d0), (d1), (d2), (d3), (d4), (d5), (d6), (d7) }})
+
 /*
  * Generic EFI table header
  */
@@ -165,24 +170,26 @@
 /*
  *  EFI Configuration Table and GUID definitions
  */
+#define NULL_GUID \
+    EFI_GUID(  0x00000000, 0x0000, 0x0000, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 )
 
 #define MPS_TABLE_GUID    \
-    ((efi_guid_t) { 0xeb9d2d2f, 0x2d88, 0x11d3, { 0x9a, 0x16, 0x0, 0x90, 0x27, 0x3f, 0xc1, 0x4d }})
+    EFI_GUID(  0xeb9d2d2f, 0x2d88, 0x11d3, 0x9a, 0x16, 0x0, 0x90, 0x27, 0x3f, 0xc1, 0x4d )
 
 #define ACPI_TABLE_GUID    \
-    ((efi_guid_t) { 0xeb9d2d30, 0x2d88, 0x11d3, { 0x9a, 0x16, 0x0, 0x90, 0x27, 0x3f, 0xc1, 0x4d }})
+    EFI_GUID(  0xeb9d2d30, 0x2d88, 0x11d3, 0x9a, 0x16, 0x0, 0x90, 0x27, 0x3f, 0xc1, 0x4d )
 
 #define ACPI_20_TABLE_GUID    \
-    ((efi_guid_t) { 0x8868e871, 0xe4f1, 0x11d3, { 0xbc, 0x22, 0x0, 0x80, 0xc7, 0x3c, 0x88, 0x81 }})
+    EFI_GUID(  0x8868e871, 0xe4f1, 0x11d3, 0xbc, 0x22, 0x0, 0x80, 0xc7, 0x3c, 0x88, 0x81 )
 
 #define SMBIOS_TABLE_GUID    \
-    ((efi_guid_t) { 0xeb9d2d31, 0x2d88, 0x11d3, { 0x9a, 0x16, 0x0, 0x90, 0x27, 0x3f, 0xc1, 0x4d }})
+    EFI_GUID(  0xeb9d2d31, 0x2d88, 0x11d3, 0x9a, 0x16, 0x0, 0x90, 0x27, 0x3f, 0xc1, 0x4d )
 
 #define SAL_SYSTEM_TABLE_GUID    \
-    ((efi_guid_t) { 0xeb9d2d32, 0x2d88, 0x11d3, { 0x9a, 0x16, 0x0, 0x90, 0x27, 0x3f, 0xc1, 0x4d }})
+    EFI_GUID(  0xeb9d2d32, 0x2d88, 0x11d3, 0x9a, 0x16, 0x0, 0x90, 0x27, 0x3f, 0xc1, 0x4d )
 
 #define HCDP_TABLE_GUID	\
-    ((efi_guid_t) { 0xf951938d, 0x620b, 0x42ef, {0x82, 0x79, 0xa8, 0x4b, 0x79, 0x61, 0x78, 0x98}})
+    EFI_GUID(  0xf951938d, 0x620b, 0x42ef, 0x82, 0x79, 0xa8, 0x4b, 0x79, 0x61, 0x78, 0x98 )
 
 typedef struct {
 	efi_guid_t guid;
@@ -235,6 +242,17 @@
 efi_guidcmp (efi_guid_t left, efi_guid_t right)
 {
 	return memcmp(&left, &right, sizeof (efi_guid_t));
+}
+
+static inline char *
+efi_guid_unparse(efi_guid_t *guid, char *out)
+{
+	sprintf(out, "%02x%02x%02x%02x-%02x%02x-%02x%02x-%02x%02x-%02x%02x%02x%02x%02x%02x",
+		guid->b[0], guid->b[1], guid->b[2], guid->b[3],
+		guid->b[4], guid->b[5], guid->b[6], guid->b[7],
+		guid->b[8], guid->b[9], guid->b[10], guid->b[11],
+		guid->b[12], guid->b[13], guid->b[14], guid->b[15]);
+        return out;
 }
 
 extern void efi_init (void);
diff -ur linux.pre-matt/include/asm-ia64/sal.h linux/include/asm-ia64/sal.h
--- linux.pre-matt/include/asm-ia64/sal.h	Tue Apr  2 00:05:24 2002
+++ linux/include/asm-ia64/sal.h	Tue Apr  2 00:12:40 2002
@@ -234,32 +234,32 @@
 
 /* SAL Error Record Section GUID Definitions */
 #define SAL_PROC_DEV_ERR_SECT_GUID  \
-    ((efi_guid_t) { 0xe429faf1, 0x3cb7, 0x11d4, { 0xbc, 0xa7, 0x0, 0x80, \
-                    0xc7, 0x3c, 0x88, 0x81 }} )
+    EFI_GUID ( 0xe429faf1, 0x3cb7, 0x11d4,  0xbc, 0xa7, 0x0, 0x80, \
+                    0xc7, 0x3c, 0x88, 0x81 )
 #define SAL_PLAT_MEM_DEV_ERR_SECT_GUID  \
-    ((efi_guid_t) { 0xe429faf2, 0x3cb7, 0x11d4, { 0xbc, 0xa7, 0x0, 0x80, \
-                    0xc7, 0x3c, 0x88, 0x81 }} )
+    EFI_GUID(  0xe429faf2, 0x3cb7, 0x11d4,  0xbc, 0xa7, 0x0, 0x80, \
+                    0xc7, 0x3c, 0x88, 0x81 )
 #define SAL_PLAT_SEL_DEV_ERR_SECT_GUID  \
-    ((efi_guid_t) { 0xe429faf3, 0x3cb7, 0x11d4, { 0xbc, 0xa7, 0x0, 0x80, \
-                    0xc7, 0x3c, 0x88, 0x81 }} )
+    EFI_GUID(  0xe429faf3, 0x3cb7, 0x11d4, 0xbc, 0xa7, 0x0, 0x80, \
+                    0xc7, 0x3c, 0x88, 0x81 )
 #define SAL_PLAT_PCI_BUS_ERR_SECT_GUID  \
-    ((efi_guid_t) { 0xe429faf4, 0x3cb7, 0x11d4, { 0xbc, 0xa7, 0x0, 0x80, \
-                    0xc7, 0x3c, 0x88, 0x81 }} )
+    EFI_GUID(  0xe429faf4, 0x3cb7, 0x11d4, 0xbc, 0xa7, 0x0, 0x80, \
+                    0xc7, 0x3c, 0x88, 0x81 )
 #define SAL_PLAT_SMBIOS_DEV_ERR_SECT_GUID  \
-    ((efi_guid_t) { 0xe429faf5, 0x3cb7, 0x11d4, { 0xbc, 0xa7, 0x0, 0x80, \
-                    0xc7, 0x3c, 0x88, 0x81 }} )
+    EFI_GUID(  0xe429faf5, 0x3cb7, 0x11d4, 0xbc, 0xa7, 0x0, 0x80, \
+                    0xc7, 0x3c, 0x88, 0x81 )
 #define SAL_PLAT_PCI_COMP_ERR_SECT_GUID  \
-    ((efi_guid_t) { 0xe429faf6, 0x3cb7, 0x11d4, { 0xbc, 0xa7, 0x0, 0x80, \
-                    0xc7, 0x3c, 0x88, 0x81 }} )
+    EFI_GUID(  0xe429faf6, 0x3cb7, 0x11d4, 0xbc, 0xa7, 0x0, 0x80, \
+                    0xc7, 0x3c, 0x88, 0x81 )
 #define SAL_PLAT_SPECIFIC_ERR_SECT_GUID  \
-    ((efi_guid_t) { 0xe429faf7, 0x3cb7, 0x11d4, { 0xbc, 0xa7, 0x0, 0x80, \
-                    0xc7, 0x3c, 0x88, 0x81 }} )
+    EFI_GUID(  0xe429faf7, 0x3cb7, 0x11d4, 0xbc, 0xa7, 0x0, 0x80, \
+                    0xc7, 0x3c, 0x88, 0x81 )
 #define SAL_PLAT_HOST_CTLR_ERR_SECT_GUID  \
-    ((efi_guid_t) { 0xe429faf8, 0x3cb7, 0x11d4, { 0xbc, 0xa7, 0x0, 0x80, \
-                    0xc7, 0x3c, 0x88, 0x81 }} )
+    EFI_GUID(  0xe429faf8, 0x3cb7, 0x11d4, 0xbc, 0xa7, 0x0, 0x80, \
+                    0xc7, 0x3c, 0x88, 0x81 )
 #define SAL_PLAT_BUS_ERR_SECT_GUID  \
-    ((efi_guid_t) { 0xe429faf9, 0x3cb7, 0x11d4, { 0xbc, 0xa7, 0x0, 0x80, \
-                    0xc7, 0x3c, 0x88, 0x81 }} )
+    EFI_GUID(  0xe429faf9, 0x3cb7, 0x11d4, 0xbc, 0xa7, 0x0, 0x80, \
+                    0xc7, 0x3c, 0x88, 0x81 )
 
 #define MAX_CACHE_ERRORS			6
 #define MAX_TLB_ERRORS				6
diff -ur linux.pre-matt/include/linux/devfs_fs_kernel.h linux/include/linux/devfs_fs_kernel.h
--- linux.pre-matt/include/linux/devfs_fs_kernel.h	Tue Apr  2 00:05:24 2002
+++ linux/include/linux/devfs_fs_kernel.h	Tue Apr  2 00:12:40 2002
@@ -101,9 +101,6 @@
 extern devfs_handle_t devfs_get_next_sibling (devfs_handle_t de);
 extern void devfs_auto_unregister (devfs_handle_t master,devfs_handle_t slave);
 extern devfs_handle_t devfs_get_unregister_slave (devfs_handle_t master);
-#ifdef CONFIG_DEVFS_GUID
-extern void devfs_unregister_slave (devfs_handle_t master);
-#endif
 extern const char *devfs_get_name (devfs_handle_t de, unsigned int *namelen);
 extern int devfs_register_chrdev (unsigned int major, const char *name,
 				  struct file_operations *fops);
diff -ur linux.pre-matt/include/linux/genhd.h linux/include/linux/genhd.h
--- linux.pre-matt/include/linux/genhd.h	Tue Apr  2 00:05:24 2002
+++ linux/include/linux/genhd.h	Tue Apr  2 00:12:40 2002
@@ -13,10 +13,6 @@
 #include <linux/types.h>
 #include <linux/major.h>
 
-#ifdef CONFIG_DEVFS_GUID
-#include <asm-ia64/efi.h>
-#endif
-
 enum {
 /* These three have identical behaviour; use the second one if DOS fdisk gets
    confused about extended/logical partitions starting past cylinder 1023. */
@@ -66,9 +62,6 @@
 	unsigned long nr_sects;
 	devfs_handle_t de;              /* primary (master) devfs entry  */
 	int number;                     /* stupid old code wastes space  */
-#ifdef CONFIG_DEVFS_GUID
-	efi_guid_t *guid;
-#endif
 };
 
 #define GENHD_FL_REMOVABLE  1

