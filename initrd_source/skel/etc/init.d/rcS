#!/bin/sh

#
# "SystemImager" - Copyright (C) 1999-2001 Brian Elliott Finley <brian@systemimager.org>
#
#   Others who have contributed to this code:
#     Curtis Zinzilieta <czinzilieta@valinux.com>
#     dann frazier <dannf@fc.hp.com>
#
# This file is: rcS
#

. /etc/boel_lib

# Mount file systems in /etc/fstab.
mount proc /proc -t proc

if [ -x /bin/hostname ]; then
  hostname 'SystemImager-autoinstall-system'
fi

# Create and mount ram filesystem for extra executables
echo "BEGIN Creating ram disk for /tmp to hold extra binaries"
mke2fs /dev/ram1
mount /dev/ram1 -t ext2 /tmp
echo "END Creating ram disk for /tmp to hold extra binaries"

# Configure loopback interface (may as well)
ifconfig lo 127.0.0.1

### BEGIN look for local.cfg file ###
# This code inspired by Ian McLeod <ian@valinux.com>
#
# BEGIN try hard drive
#
# this must be on two lines in order to substitute the newline
cat /proc/cmdline | sed "s/ /\\
/g" | sed -n "s/=/=/p" > /tmp/last_root.$$
# suck in variable
. /tmp/last_root.$$
if [ ! -z "$LAST_ROOT" ]; then
  echo "Checking for configuration file on hard drive..."
  mkdir /last_root
  # kernel must have autoconfig/autostart enabled in order to
  # pull local.cfg off a software raid drive
  echo "Mounting hard drive..."
  mount $LAST_ROOT /last_root -o ro > /dev/null 2>&1 || echo "Couldn't mount hard drive."
  if [ -f /last_root/local.cfg ]; then
    echo "Found /local.cfg on hard drive..."
    echo "Reading configuration from /local.cfg on hard drive..."
    . /last_root/local.cfg
  else
    echo "No /local.cfg on hard drive..."
  fi
  echo "Unmounting hard drive..."
  umount /last_root || shellout
fi
# END try hard drive

# BEGIN try floppy
echo "Checking for configuration file on floppy..."
echo
mkdir /floppy
mount /dev/fd0 /floppy -o ro > /dev/null 2>&1 || echo "No floppy in drive."
if [ -f /floppy/local.cfg ]; then
  echo
  echo "Reading local configuration from floppy..."
  . /floppy/local.cfg
else
  echo
  echo "No /local.cfg on floppy drive..."
fi
# END try floppy

# in case someone is using the deprecated DHCPSIADDR in their local.cfg file...
[ ! -z $DHCPSIADDR ] && IMAGESERVER=$DHCPSIADDR

if [ ! -z $IPADDR ]; then
  # configure interface and add default gateway
  ifconfig $DEVICE $IPADDR  netmask $NETMASK  broadcast $BROADCAST
  route add default gw $GATEWAY

  if [ $? != 0 ]; then
    echo
    echo "I couldn't configure the network interface using the local.cfg file."
    echo "Check the entries in the local.cfg file on your floppy."
    echo
    shellout
  fi
### END look for local.cfg file ###

else
  ### BEGIN dhcp ###
  echo "IP Address not set by local.cfg.  I will use DHCP."

  ### BEGIN ether sleep ###
  # Give the switch time to start passing packets.  Some switches won't
  # forward packets until 30 seconds or so after an interface comes up.
  # This means the dhcp server won't even get the request for 30 seconds.
  # Many ethernet cards aren't considered "up" by the switch until the
  # driver is loaded.  Because the driver is compiled directly into the
  # kernel here, the driver is definitely loaded at this point.
  count=35
  echo
  echo "sleep $count:  This is to give your switch (if you're using one) time to"
  echo "           recognize your ethernet card before we try the network."
  echo
  I=1; while [ $I != $(( $count + 1)) ]; do echo -n "$I "; sleep 1s; I=$(( $I + 1 )) ; done
  echo
  ### END ether sleep ###

  # create directory to catch dhcp information
  mkdir /var/dhcp

  # combine systemimager code to the stock debian dhclient-script
  # and make executable
  cat /etc/dhclient-script.systemimager-prefix \
      /etc/dhclient-script.debian-dist \
      > /etc/dhclient-script
  chmod +x /etc/dhclient-script

  # get info via dhcp
  echo
  echo "dhclient"
  dhclient
  if [ ! -s /var/dhcp/dhclient.leases ]; then
    echo
    echo "I couldn't configure the network interface using DHCP."
    echo
    shellout
  fi

  # Figure out which interface actually got configured.
  # Suggested by James Oakley.
  INTERFACE=`grep interface /var/dhcp/dhclient.leases | mawk -F'"' '{print $2; exit}'`

  # read dhcp info in as variables -- this file will be created by 
  # the /etc/dhclient-start script that is run automatically by
  # dhclient.
  . /tmp/dhcp_info.${INTERFACE} || shellout
  ### END dhcp ###
fi

# in case someone is using a dhcpd.conf created by an older makedhcpserver
# (that doesn't contain explicit specification of the imageserver)
[ -z $IMAGESERVER ] && IMAGESERVER=$DHCPSIADDR

### BEGIN ping test for switch initialization ###
# ping test code submitted by Grant Noruschat <grant@eigen.ee.ualberta.ca>
# modified slightly by <brian@systemimager.org>
echo
echo "  Pinging image server \"$IMAGESERVER\""
echo "  to ensure we have network connectivity."
echo

PING_COUNT=1
PING_EXIT_STATUS=1

while [ $PING_EXIT_STATUS != 0 ]
do
  echo "  Ping attempt number $PING_COUNT: "
  ping -c 1 $IMAGESERVER; PING_EXIT_STATUS=$?; PING_COUNT=$(( $PING_COUNT + 1 ))
  if [ $PING_COUNT = 21 ]; then
    echo
    echo "  FATAL:  Cannot ping the image server \"$IMAGESERVER\""
    echo "          Be sure that your networking equipment is"
    echo "          working properly!"
    echo
    shellout
  fi
done

if [ $PING_EXIT_STATUS = 0 ]; then
  echo
  echo "  We have connectivity to the Image Server!"
  echo
fi
### END ping test ###

### BEGIN Are we installing over SSH?
if [ ! -z $SSH_DOWNLOAD_URL ]; then
  echo
  echo "SSH_DOWNLOAD_URL variable is set, so we will install over SSH!"

  # Remove possible trailing / from URL
  SSH_DOWNLOAD_URL=`echo $SSH_DOWNLOAD_URL | sed 's/\/$//'`

  # download second stage ramdisk
  file="stage2rd-ssh.gz"
  echo
  echo "snarfing $SSH_DOWNLOAD_URL/$file..."
  snarf $SSH_DOWNLOAD_URL/$file /tmp/$file

  if [ $? != 0 ]; then
    echo
    echo "snarf of $file failed!!!"
    echo
    shellout
  fi
  echo "Decompressing second stage ramdisk (ssh version)..."
  gunzip < /tmp/stage2rd-ssh.gz | dd of=/dev/ram2 || shellout
### END Are we installing over SSH?

else
  echo "Using rsync to copy $IMAGESERVER::$ARCH-boot/stage2rd.gz..."
  rsync -aL $IMAGESERVER::$ARCH-boot/stage2rd.gz /tmp/
  echo "Decompressing second stage ramdisk..."
  gunzip < /tmp/stage2rd.gz | dd of=/dev/ram2 || shellout
fi

echo "Mounting second stage ramdisk..."
mkdir /stage2
mount /dev/ram2 -t ext2 /stage2

# pass variables to second stage script
write_variables || shellout
# and make sure we bring the old resolv.conf with us...
cp /etc/resolv.conf /stage2/etc/resolv.conf

echo "Pivoting into second stage ramdisk..."

# why this sequence?  man pivot_root
mkdir /stage2/oldroot
cd /stage2
pivot_root . oldroot
exec chroot . /bin/stage2.sh

exit 0
