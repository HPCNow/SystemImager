<chapter>
  <title>Using SystemImager</title>
  
  <section>

    <title>Installation Procedures Overview</title>
   
   <orderedlist>
	<listitem>
	<para>
	  Using the instructions in Chapter 2, install the 
	  <application>SystemImager</application> server package
	  on the machine you have chosen as your image server.  
	</para>
      </listitem>

	<listitem>
	<para>
	Install Linux on your golden client and customize as desired.
	</para>
	</listitem>

	<listitem>
	<para>
	Using the instructions in Chapter 2, install the SystemImager
	client software on the golden client.  
	</para>
      </listitem>

	<listitem>
	<para>
	Run the <command>prepareclient</command> command on your golden client.
	</para>
      </listitem>

	<listitem>
	<para>
	Choose and configure the method for assigning IP addresses to your autoinstall
	clients.  This information is required for the <command>getimage</command> command
	in the next step; however, you can change these settings later by running
	the <command>mkautoinstallscript</command> command.
	</para>

	</listitem>
	<listitem>
	<para>
	Run <command>getimage</command> on the image server to pull the golden
	client to the image server.
	</para>
	</listitem>

	<listitem>
	<para>
	Run <command>addclients</command> on the image server to tell it which clients will
	receive what image and to populate the image server's <filename>/etc/hosts</filename>
	and <filename>/var/lib/systemimager/scripts/hosts</filename> file.
	</para>
	</listitem>



	<listitem>
	<para>
	Autoinstall the golden image on other machines.
	</para>
	</listitem>

   </orderedlist>
	<note>
	<para>
	  See the SystemImager Tools section in this chapter for detailed tool
	descriptions and functions.
	</para>
	</note>

<section>
	<title>Detailed Installation Instructions</title> 

  <orderedlist>

      <listitem>
	<para>
	  Install the <application>SystemImager</application> server package
	  on the machine you have chosen as your image server, using the instructions
	  in Chapter 2.
	</para>
      </listitem>
      
      <listitem>
	<para>
	  Install Linux on your "golden client"  and customize
	  as desired.  Remember that the software installed will
	  eventually constitute the golden image for all other nodes installed
	  with <application>SystemImager</application>.  Don't worry too much
	  about getting it exactly right the first time, as you can easily
	  use <application>SystemImager</application> to make incremental
	  changes to your image and deploy those changes without doing a
	  complete re-install.
	</para>
	
      </listitem>

	<listitem>
	<para>Install the SystemImager client software on the golden client using the
	instructions in Chapter 2.
	</para>
      </listitem>

	<listitem>
	    <para>
	      On the golden client, run the command
	      <command>prepareclient</command> as root.  This will create
	      various files in your /etc/systemimager directory that contain
	      information on your disk partition scheme, filesystem types, etc.
	      <command>prepareclient</command> will also start an rsync daemon
	      to allow its files to be transferred to a server.  Your golden client 
		is now ready to have its image pulled by an image server.
	    </para>
	    <warning>
	      <para>
		If you are not in ssh mode, all files on your
		golden client are openly accessible to anyone on your network.  
		Once you have pulled the image from your golden client, you can 
	      deactivate the <command>rsync</command> daemon by killing the
		<command>rsync</command> process or by simply rebooting the
		golden client.  This <command>rsync</command> server will not
		start automatically on future reboots.
	      </para>
	    </warning>
	  </listitem>

	<listitem>
	<para>
	  Choose and configure the method for assigning IP addresses to your 
	  autoinstall clients.
	</para>
	
	<para>
	  The most common way to assign IP addresses to autoinstall clients is
	  DHCP.  To simplify the configuration of the DHCP configuration file
	  (<filename>/etc/dhcpd.conf</filename>), SystemImager includes a
	  utility called <command>mkdhcpserver</command>.  
	  This utility asks you for all the information it needs 
	  to create a DHCP configuration file that 
	  is appropriate for your installation of SystemImager.  After installation, you can 
	  use DHCP to assign static IP addresses to your clients on
	  an ongoing basis by running the 
	  <command>mkdhcpstatic</command> command after your
	  clients have booted and received an IP address.  <command>mkdhcpstatic</command>
	  will modify your <filename>/etc/dhcpd.conf</filename>
	  file on the imageserver to include static entries for each of your
	  hosts.
	</para>
	
	<para>
	  Alternately, you can put hostname, imageserver, and networking information
	  in a configuration file on a floppy diskette. The format of the configuration 
	  file is simply <filename>VARIABLE=value</filename> for all the appropriate 
	  settings. The name of this file must be <filename>local.cfg</filename> and it 
	  must exist on the root of the floppy 
	  or hard drive.  The floppy can be formatted with either ext2 or fat.  An example local.cfg file,
	  such as the one below, can be 
	  found with the documentation files that are usually installed 
	  in <filename>/usr/share/doc</filename>.</para> 

<example>
	  <title>
	    Contents of an example <filename>local.cfg</filename> provided with SystemImager:
	  </title>
	  <programlisting>
	    HOSTNAME=www1
	    DOMAINNAME=systemimager.org
	    DEVICE=eth0
	    IPADDR=10.0.0.99
	    NETMASK=255.255.255.0
	    NETWORK=10.0.0.0
	    BROADCAST=10.0.0.255
	    GATEWAY=10.0.0.1
   	    GATEWAYDEV=eth0
	    IMAGESERVER=10.0.0.3
	    IMAGENAME=oracle_db_server-1.0 
	  </programlisting>
</example>


	<para>
	  Alternatively, if you are using a running system's hard drive as the boot media, you can run 
	  <command>updateclient -autoinstall -server &lt;imageserver&gt; -configure-from eth0
	  </command>, which will create a <filename>local.cfg</filename> file at the root of the client's hard
	  drive containing the existing live network settings. When the autoinstall client 
	  boots, it will look for this file and use the provided values instead of getting 
	  them from DHCP and the <filename>/var/lib/systemimager/scripts/hosts</filename> file on the
	  image server.
	</para>
	
	<para>
	  A <filename>local.cfg</filename> file on a floppy will work with any
	  of the autoinstall media.  You can even put the configuration file on
	  the autoinstall floppy itself.  If you use a
	  <filename>local.cfg</filename> file on a hard drive and on a floppy,
	  the settings on the floppy will override the settings on the hard
	  drive.
	</para>

	<para>
	  </para>

	<example>
	  <title>Running mkdhcpserver</title>
	  <programlisting>
[root@imageserver]# mkdhcpserver
	  </programlisting>
	</example>

	<example>
	  <title>
	    Running updateclient with the "-autoinstall" and "-config" options
	  </title>
	  <para>
	    Note that the options <parameter>-autoinstall</parameter>,
	    <parameter>-server</parameter>, and
	    <parameter>-configure-from</parameter> are
	    abbreviated below as <parameter>-a</parameter>,
	    <parameter>-s</parameter>,
	    and <parameter>-c</parameter>.  You can abbreviate 
	    options to minimum uniqueness with most SystemImager commands.  
	  </para>
	  
	  <para>
	    Minimum uniqueness means that if two options for a single 
	    command are similar, such as the <parameter>-image</parameter>
	    and <parameter>-ip-assignment</parameter> options to
	    <command>getimage,</command> you can abbreviate them to
	    <parameter>-im</parameter> and <parameter>-ip</parameter>.
	  </para>
	  <programlisting>
[root@server7]# updateclient -a -s imageserver -c eth0
Retrieving SystemImager kernel...
Retrieving SystemImager initial ramdisk...
Adding SystemImager entry in /etc/lilo.conf...
running /sbin/lilo -d 50 -D systemimager ...
Ignoring entry 'delay'
Ignoring entry 'default'
Added linux
Added systemimager *

&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Below are the contents of your /local.cfg file.  Make sure that all
the variables are filled in and that they contain the proper values.
You may edit the file directly if you need to change any of the values.
&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

#
# "SystemImager"
#
#  Copyright (C) 1999-2002 Bald Guy Software &lt;brian.finley@baldguysoftware.com&gt;
#
# This file is: /local.cfg
#
HOSTNAME=server7
DOMAINNAME=mydomain.com
DEVICE=eth0
IPADDR=192.168.1.7
NETMASK=255.255.255.0
NETWORK=192.168.1.0
BROADCAST=192.168.1.255
GATEWAY=192.168.1.254
GATEWAYDEV=eth0
IMAGESERVER=192.168.1.203
	  </programlisting>
        </example>
      </listitem>

      <listitem>
	<para>
	  Run <command>getimage</command> on the image server to pull the image
	  from the golden client to the image server.
	</para>
	
	<example>
	  <title>Pull the golden client's image to the image server</title>
	  <mediaobject>
	    <imageobject>
	      <imagedata format="jpg" fileref="images/si_image3.jpg">
	    </imageobject>
	    <imageobject>
	      <imagedata format="eps" fileref="images/si_image3.eps">
	    </imageobject>
	    <textobject>
	      <phrase>
		Pull the "golden client's" image to the image server
	      </phrase>
	    </textobject>
	  </mediaobject>
	</example>
	
	<para>
	  The basic syntax is: "<command>getimage</command> <command>-golden-client</command> [client_hostname] <command>-image</command> [image_name]"
	</para>
	<para>
	  Where [client_hostname] is the hostname or IP address of the
	  "golden client" and [image_name] is the name you want to give
	  to this image.  You can see many other options with
	  "<command>man getimage</command>."
	</para>
	
	<example>
	  <title>Running getimage</title>
	  <programlisting>
	    [root@imageserver]# getimage -golden-client my-golden-client -image web_server_image_v1
	  </programlisting>
	</example>

	<para><command>getimage</command> contacts the golden client and
	  requests its <filename>/etc/systemimager/mounted_filesystems</filename> file,
	  which contains the list of mounted filesystems and their mount
	  points.  <command>getimage</command> pulls out the mount points for the filesystems that
	  are unsupported and creates an exclusion list.  The filesystems
	  SystemImager currently supports are ext2, ext3 and reiserfs.
	  All other filesytems will be ignored, including proc, nfs,
	  devpts, iso9660, etc.
	</para>
      </listitem>
      
      <listitem>
        <para>
          <command>addclients</command> creates a symbolic link to the master 
          script for the image to which each specified autoinstall client is 
          assigned.  <command>addclients</command> also
	  populates the image server's <filename>/etc/hosts</filename> and 
	  <filename>/var/lib/systemimager/scripts/hosts</filename> files.  The
	  hosts file provides the default mechanism used by autoinstall clients
	  to look up their hostnames.
	</para>
	<para>
	  When <command>addclients</command> is run without arguments, it 
	  takes you through three configuration screens interactively.
	</para>
	<orderedlist>
	  <listitem>
	    <para>
	      In the first configuration screen <command>addclients</command>,
		asks you to specify the hostname pattern of your autoinstall clients.  
		Autoinstall client hostnames are comprised
		of [basename][number].
		For example, if you choose "proxy" as your basename, and
	      3-10 as your range, you will define the following
	      autoinstall clients:
	    </para>
	    <simplelist>
	      <member>proxy3</member>
	      <member>proxy4</member>
	      <member>proxy5</member>
	      <member>proxy6</member>
	      <member>proxy7</member>
	      <member>proxy8</member>
	      <member>proxy9</member>
	      <member>proxy10</member>
	    </simplelist>
	  </listitem>
	  <listitem>
	    <para>
	      In the second screen, you map the clients defined in Section 1 to an image.
	    </para>
	    <note>
	      <para>
		Each invocation of <command>addclients</command> allows you
		to map a single range of clients to an image.
		If you want to map non-consecutive ranges of clients to an
		image, or want to map different client ranges to different
		images, you must execute the
		<command>addclients</command> command multiple times.
	      </para>
	    </note>
	  </listitem>
	  <listitem>
	    <para>
	      In the third configuration screen, the <command>addclients</command> command asks
	      you for a range of IP addresses from which it populates your
	      <filename>/etc/hosts</filename> and
	      <filename>/var/lib/systemimager/scripts/hosts</filename> files.
	      When an autoinstall clients boots, it will attempt to retrieve
	      the latter file from the image server and use it to look up its
	      hostname.  If this step fails, the client will attempt to do
	      a reverse DNS lookup.  If you have PTR records configured for
	      each of your autoinstall clients, you can skip the third configuration
		step; however, it is recommended to complete it because it is more robust.
	    </para>
	<example>
	  <title>Entries in /etc/hosts created by addclients</title>
        <para>
          If you give <command>addclients</command>
          a range of IPs from 192.168.1.1-192.168.1.99, a base
          hostname server, and a hostname extension range of 1-99,
          then it would generate the following <filename>/etc/hosts</filename>
          file:
	  <programlisting>
192.168.1.1    server1.mydomain.com  server1
192.168.1.2    server2.mydomain.com  server2
192.168.1.3    server3.mydomain.com  server3
192.168.1.4    server4.mydomain.com  server4
192.168.1.5    server5.mydomain.com  server5
192.168.1.6    server6.mydomain.com  server6
192.168.1.7    server7.mydomain.com  server7
192.168.1.8    server8.mydomain.com  server8
192.168.1.9    server9.mydomain.com  server9
192.168.1.10   server10.mydomain.com  server10
192.168.1.11   server11.mydomain.com  server11

[ ... etc, etc, etc ... ]

192.168.1.97    server97.mydomain.com  server97
192.168.1.98    server98.mydomain.com  server98
192.168.1.99    server99.mydomain.com  server99
	  </programlisting>
        </para>
      </example>


      </listitem>
      </orderedlist>
      </listitem>
      
      <listitem>
	<para>
	  Autoinstall the golden image on other machines.
	</para>
	
	<para>
	  You can use one of four methods to autoinstall the clients:
	</para>
	<itemizedlist>
	  <listitem>
	    <para>
	      Boot the system from a floppy diskette.
	    </para>
	    
	    <para>
	      Run <command>mkautoinstalldiskette</command> to create an
	      autoinstall diskette that you can use with any
	      machine unless you add a customized
	      <filename>/local.cfg</filename> file to the diskette.
	    </para>
	  </listitem>
	  <listitem>
	    <para>
	      Boot the system from a CDROM.
	    </para>
	    
	    <para>
	      Run <command>mkautoinstallcd</command> to create an ISO image
	      that can be burned to CDROM.  You can use the CDROM to boot
	      your autoinstall clients and use it with any machine.
	    </para>
	  </listitem>
	  
	  <listitem>
	    <para>
	      Boot the system from its own hard drive.
	    </para>
	    
	    <para>
	      If your client is already running Linux and uses LILO as its
	      boot loader, you can simply copy the
	      <command>updateclient</command> command and run it with the
	      <parameter>-autoinstall</parameter> option.
	    </para>
	    <example>
	      <title>
		Booting the autoinstall media from a system's hard drive
	      </title>
	      <programlisting>
		[root@server7]# updateclient -a -s imageserver -c eth0
	      </programlisting>
	    </example>
	  </listitem>
	  
	  <listitem>
	    <para>
	      Boot the system from the network. If your systems are network-boot
		capable, using PXE for example, you can start an autoinstall without
		using local media.    
	    </para>
	    
	    <para>
	      PXE is usually enabled through a BIOS setting.  Booting can be 
		unstable and client side firmware is not
	      consistent.  If you must boot without physically touching
	      your machines, try the
	      <parameter>-autoinstall</parameter> option to
	      <command>updateclient</command> first.
	    </para>
	    
	    <para>
              <application>SystemImager</application> comes with the
	      <command>mkbootserver</command> utility to help configure a
              PXE server.  Running <command>mkbootserver</command> is an
	      iterative process.  It will attempt to generate an appropriate
	      tftproot directory, configure your tftp server, and run various
	      tests to see if things are functioning properly.  Once
	      <command>mkbootserver</command> detects an error, it will fail
	      out and generate an error message.  When you have corrected the error, you can
	      re-execute <command>mkbootserver</command>, and repeat until it exits successfully.
	      <command>mkbootserver</command> will probably not work with all PXE
	      clients.  If it fails to work with your configuration, please
	      submit a bug report to http://sourceforge.net/tracker/?group_id=259&amp;atid=100259.
	    </para>
	  </listitem>
	  
	</itemizedlist>
	
      </listitem>
    </orderedlist>
  </section>

    <section>
      <title>SystemImager Tools</title>
      <section>
	<title>the <command>prepareclient</command> command</title>
	<itemizedlist>
	  <listitem>
	    <para>
	    After configuring the golden client, run the <command>prepareclient</command> command 
	    to create a file with the partition information from your disks and put it in the 
	    <filename>/etc/systemimager/partitionschemes</filename> directory. 
	    </para>
	  </listitem>
	  
	  <listitem>
	    <para>
	      <command>prepareclient</command> will also create an rsync(1) configuration file (/tmp/rsyncd.conf) and start 
	      rsync in server mode (rsync--daemon).  This step allows the image server to pull the image 
	      from the client but will not cause the rsync daemon to be restarted after the golden 
	      client is rebooted, helping avoid security concerns from sharing a golden client's root 
	      filesystem via rsync.
	    </para>
	  </listitem>
	</itemizedlist>
	</section>

	<section>
	<title>The <command>getimage</command> command</title>
	<itemizedlist>
	  <listitem>
	    <para>
	      After running <command>prepareclient</command>, run the the <command>getimage</command>
	      command on the image server. For example :
	      <command>getimage -golden-client 192.168.1.1 -image my_webserver_image_v1</command>
	    </para>
	  </listitem>
	  <listitem>
	    <para>
	      <command>getimage</command> contacts the golden client and requests its 
	      <filename>/etc/systemimager/mounted_filesystems</filename> 
	      file, which contains the list of mounted filesystems and the devices on which they are 
	      mounted.  It pulls out the mount points for the filesystems that are unsupported and 
	      creates an exclusion list. Currently supported filesystems are ext2, 
	      ext3, and reiserfs. 
	      All other filesystems are unsupported, including proc, 
	      devpts, iso9660, etc.
	    </para>
	  </listitem>
	  <listitem>
	    <para>
	      <command>getimage</command> then pulls the golden client's entire system image, excluding the filesystems 
	      in the exclusion list, by connecting to the rsync daemon running on the golden client.  
	      All the files from the client will be copied over, recreating the file and directory 
	      hierarchy in the image directory.
	    </para>
	  </listitem>
	  <listitem>
	    <para>
	      You can also use <command>getimage</command> to update an existing image by simply specifying an 
	      existing image name, for example,
	      <command>getimage -golden-client 192.168.1.1. -image &lt;imagename&gt;.</command>
	      <command> getimage</command> then updates the image to match the files on your golden client. 
	      When you do this, only the parts of files that are different will be copied over.  Files that exist 
	      in the old image but not on the golden client will be deleted, and files that exist in both places but have 
	      changed will be updated.  <command>getimage</command> is one way to update an image when new 
	      security patches or other system updates come out. However, this method is revision control on an 
	      image-by-image basis, and not true revision control where individual file revisions are 
	      tracked on a line-by-line basis. The recommended method is never to overwrite a known 
	      working image. Revision control on an image-by-image basis also ties in to the <command>updateclient</command>
	      command.  By default, all images are stored in the parent directory of 
	      <filename>/var/lib/systemimager/images/</filename> in a directory that bears the 
	      image name. For example: <filename>/var/lib/systemimager/images/my_webserver_image_v1/</filename>
	    </para>
	  </listitem>
	</itemizedlist>
      </section>
      
      <section>
	<title>Autoinstall scripts</title>
	<itemizedlist>
	  <listitem>
	    <para>
	      After <command>getimage</command> has pulled the files to the image directory on the imageserver, it creates 
	      a customized autoinstall script.  The autoinstall script in this example is named 
	      "my_webserver_image_v1.master".  All autoinstall scripts are placed in the 
	      <filename>/var/lib/systemimager/scripts</filename> directory.
	    </para>
	  </listitem>
	  <listitem>
	    <para>
	      The disk partitioning information left behind by the <command>prepareclient</command> command adds 
	      the necessary commands to re-partition the disk(s) on the autoinstall clients.
	      </para>
	  </listitem>
	  <listitem>
	    <para>
	      File system information is taken from the <filename>/etc/fstab</filename> file in the image (i.e.: 
	    <filename>/var/lib/systemimager/images/my_webserver_image_v1/etc/fstab)</filename> 
	      and used to determine the appropriate file system creation commands and to determine 
	      mount points for the autoinstall process. Networking information is added to the 
	      autoinstall script based on command line options passed to <command>getimage</command> or information it 
	      prompts you for.  This information is added in variable form as the autoinstall client will 
	      determine the values for things such as its hostname and IP address during the autoinstall 
	      process.
	    </para>
	  </listitem>
	</itemizedlist>
      </section>
      
      <section>
	<title>The <command>addclients</command> Command</title>
	<itemizedlist>
	  <listitem>
	    <para>
	      After running <command>getimage</command>, run the <command>addclients</command> command, 
	      which asks you for the series of hostnames you will be installing by combining a base host name and a number 
	      range.  For example, if your base host name is "www", and your number range is from "1" 
	      to "3," then the resultant host names would be "www1, www2, www3". <command>addclients</command> 
	      then prompts you to choose the image that will be installed to these hosts and creates soft 
	      links for each hostname that point to the master autoinstall script for that image. For 
	      example: "www3.sh -> web_server_image_v1.master".
	    </para>
	  </listitem>
	  <listitem>
	    <para>
	      If the image is updated and you allow <command>getimage</command> to update the master autoinstall script 
	      also, then each of the associated soft links will point to the updated autoinstall script.  If 
	      individual host configuration is necessary, the soft link for that host can be removed and 
	      replaced with a copy of the master autoinstall script that can then be customized for that 
	      host.  This customization is a manual process and is up to the system administrator.
	    </para>
	  </listitem>
	</itemizedlist>
      </section>

	<section>
	<title>Additional Installation Information</title>
	<itemizedlist>
	<listitem>
	    <para>
	      The unattended install procedure is flexible and works with almost any available hardware. 
	      You can also easily modify it to work with new or special hardware. 
	      A miniature Linux distribution called Brian's Own Embedded Linux (boel) is used for autoinstalls.  
	      It consists of a customized kernel and an initial ram disk that contains only the specific 
	      commands and utilities necessary to perform autoinstalls. The same kernel and initial ram disk 
	      (<filename>initrd.gz</filename>) can be used to boot from floppy disks, CDROMs, the network, or any running Linux 
	      system's local hard drive.
	    </para>
	    <para>
	      The <command>mkautoinstalldiskette</command> and <command>mkautoinstallcd</command> commands 
	      use the <command>syslinux(2)</command> utility to create floppies and CDROMs that will boot the 
	      SystemImager kernel and initial ram disk. <command>pxelinux(2)</command>, 
	      which is a sister tool to <command>syslinux</command>, allows the same kernel and initial ram disk to 
	      boot PXE capable machines from the network. Both <command>syslinux</command> and <command>pxelinux</command>
	      need a configuraton file, but the two tools can use the same one and <application>SystemImager</application>
	      handles this for you.
	    </para>
	</listitem>

	  <listitem>
	    <para>
	      The autoinstall kernel contains all the necessary drivers for the majority of systems.  Custom kernels 
	      can be compiled to meet special disk and network driver requirements.  To use a custom kernel, simply 
	      copy it to <filename>/tftpboot/kernel</filename>.  All of the autoinstall media is created from 
	      <filename>/tftpboot/kernel</filename> and <filename>/tftpboot/initrd.gz</filename> 
	      on the image server.
	    </para>
	</listitem>
	<listitem>
	  <para>Once the kernel has booted, it mounts the initial ram disk as its root filesystem. The kernel then executes 
	  an initialization script on the ram disk that has been written to do <application>SystemImager</application>-specific
	  tasks.  This script will use either a configuration file (<filename>/local.cfg</filename>) or a combination of 
	  DHCP and the <filename>/var/lib/systemimager/scripts</filename> file pulled from the image server to determine 
	  the autoinstall client's IP address and hostname information.</para>

	  <para>
            If DHCP is used, the client parses the hosts file which was 
            retrieved from the image server to find its IP address and 
            determine its hostname.  Finally, the client retrieves an 
            autoinstall script from the image server based on its hostname and
            executes it.  The autoinstall script is image specific, 
            determining which image a client will receive. Following is a 
            summary: 
	    IP address -> hostname -> image specific autoinstall script named 
            with hostname.
          </para>
	</listitem>
	</itemizedlist>
	</section>

	<section><title>How to Update an Image</title>
	<itemizedlist>
	  <listitem>
	    <para>
	      If you want to update an image on your image server, you can use one of the two following methods:
	    </para>
	    <orderedlist>
	      <listitem>
		<para>
		  Directly edit the files in the image directory.  The best way to do this is to <command>chroot</command>
		  into the image directory. You can then work with the image as if it were a running machine.  You 
		  can even install packages with <command>apt-get</command> or <command>RPM</command>, for example.
		</para>
	      </listitem>
	      <listitem>
		<para>
		  Run the <command>getimage</command> command again, specifying a golden client that has been modified 
		  in the desired way.  Again, only the parts of the files that have changed will be pulled across.  
		  Files that have been deleted on the golden client will also be deleted in the image. You have the 
		  option to update the master autoinstall script for the image or leave it alone.  The advantages of running the 
		  <command>getimage</command> command are that you can verify that your new configuration works on the golden client 
		  and that the master autoinstall script is updated.
		</para>
              </listitem>
            </orderedlist>
	  </listitem>
	    <listitem>
	      <para>
		Once a system has been autoinstalled, you can use the <command>updateclient</command> 
		  command to update a client system to match a new or updated image on the image server. So, for 
		  example, if you've installed your company's 300 web servers and a security patch comes 
		  out the next day, you can simply update the image on the image server and run 
		  <command>updateclient</command> on each of your web servers.  Only the modified files are pulled over, 
		  so your site is patched very quickly. You should create an entirely new image with a new 
		  version number so that you have some form of revision control.  This way, if you find out 
		  that the patch you applied corrupted your entire web farm, you can simply do an 
		  <command>updateclient</command> back to the last known working image.
	      </para>
	    </listitem>
	    <listitem>
	      <para>
		  By incorporating some modifications submitted by A. L. Lambert of epicRealm, you can 
		  use the <command>updateclient</command> command with the <option>-autoinstall</option> option to copy the 
		  autoinstall kernel and initial ram disk to the local hard drive of an autoinstall client that is 
		  currently running but needs to be re-deployed. <command>updateclient</command> then modifies the 
		  <filename>/etc/lilo.conf</filename> file to include an appropriate entry for the new kernel and initial 
		  ram disk and makes this new kernel the default.  The next time the client system boots, it 
		  loads the SystemImager kernel and initial ram disk, which begins the autoinstall process. 
		  You can therefore remotely redeploy any running Linux machine without feeding the 
		  machine a floppy or CD and without having to reconfigure the BIOS to boot off the 
		  network, which can be quite problematic with some BIOSes.
	      </para>
	    </listitem>
	</itemizedlist>
      </section>
    </section>
  </section>
</chapter>
<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:nil
sgml-shorttag:t
sgml-namecase-general:t
sgml-general-insert-case:lower
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:2
sgml-indent-data:t
sgml-parent-document:nil
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
-->
