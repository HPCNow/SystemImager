<chapter>
  <title>Developing SystemImager<superscript>&#174;</superscript></title>
  <section>
    <title>Design Goals</title>
    <para>
      The design goal for SystemImager was to create a tool that was both easy
      and fast to use, allowing system administrators to perform incremental
      upgrades that minimized system disruptions and provided software
      independent of any packaging system.  The specific requirements follow:
    </para>
    <itemizedlist>
      <listitem>
	<para>
	  Images should be pulled from a working system.
	</para>
      </listitem>
      
      <listitem>
	<para>
	  Unattended installs are a must.
	</para>
      </listitem>
      
      <listitem>
	<para>
	  The unattended install system has to be able to repartition the 
	  destination drive(s).
	</para>
      </listitem>
      
      <listitem>
	<para>
	  System administrators who don't completely understand the tool should
	  be able to use it.
	</para>
      </listitem>
      
      <listitem>
	<para>
	  The install should be easy and quick so that it can be useful
	  immediately without a lot of site-specific customization.  
	</para>
      </listitem>
      
	<listitem>
	<para>
	  Images should be stored as normal files to allow for incremental
	  upgrades, as opposed to "dd" style block level images of physical 
	  disks.
	</para>
      </listitem>
      
      <listitem>
	<para>
	  The SystemImager software should be independent of any and all
	  packaging systems (such as RPM) in order to easily accommodate
	  different distributions.
	</para>
      </listitem>
      
      <listitem>
	<para>
	  SystemImager should be able to store multiple images for different
	  types of systems and for revision control.
	</para>
      </listitem>
      
      <listitem>
	<para>
	  A mechanism should be available to let unattended install clients
	  know which image to install. 
	</para>
      </listitem>
      
      <listitem>
	<para>
	  An installed client  should be able to update itself to a new or
	  modified image.
	</para>
      </listitem>
      
      <listitem>
	<para>
	  SystemImager should have a command line interface that can easily be
	  wrapped with a GUI.
	</para>
      </listitem>
      
    </itemizedlist>
  </section>
  <section>
    <title>Development of SystemImager Architecture</title>
    <para>
      Minimal system requirements were a top priority for SystemImager, which
      began as a series of utilities written as shell scripts.  However, shell
      scripts were inadequate as SystemImager matured and its utilities became
      more complex.  Perl, part of most Linux installs and possessing minimal system
      requirements, then replaced shell scripts.  Using Perl, developers have
      been able to generate cleaner, more advanced code.
    </para>
    
    <para>
      SystemImager architecture was designed to be open to modification at
      every level.  The protocol for transferring files during installs
      and updates is currently <filename>rsync(1)</filename>, but the modular
      code easily allows drop-in replacements as is appropriate.  All unicast
      file transfer mechanisms, including <filename>rsync(1)</filename> are 
      implemented in a "pull" fashion, which is generally considered to be 
      superior to a "push," because it is much easier to monitor the state of 
      the receiving system prior to and during the file transfers.
    </para>
  </section>

  
  <section>
    <title>Version Strings</title>
    <para>
      SystemImager releases use an X.Y.Z numbering scheme similar to that
	used by the Linux kernel.  X is a major
      feature release revision incremented to show significant architecture 
      changes.  Y is a minor release revision, incremented to show the
      addition of new features.  Z is a bug-fix revision.  If Y is an
      odd number, the release is a development release.  If Y is even, it is a
      stable release.
    </para>
    <para>
      Using this scheme, you can see that 2.1.3 is a development release
      because 1 is odd.  You can assume that the only changes between 2.0.3
      and 2.0.4 were bug fixes, because only the last digit was incremented.
    </para>
  </section>
  <section>
    <title>Using SVN</title>
    <para>
      SystemImager is maintained in SVN at
      <ulink url="http://svn.systemimager.org">
      http://svn.systemimager.org
      </ulink>.

      To submit patches for future releases, generate them against
      the code in SVN.  There are typically two active branches at any given
      time - the current stable branch and the current development branch.  If you are fixing
      a bug that exists in the current stable release, generate
      a patch against the stable branch.  If you are adding a new feature
      or fixing a bug that is only in the development branch,
      use the development branch.
    </para>
    <para>
      Instructions for accessing the SVN repository can be found at
      <ulink url="http://svn.systemimager.org">
      http://svn.systemimager.org
      </ulink>.
    </para>
  </section>
  <section>
    <title>Submitting Patches</title>
    <para>
      Following are suggested guidelines for submitting packages for a future
	release that make it easier to incorporate the changes.
    </para>
    <itemizedlist>
      <listitem>
	<para>
	  Patches should be in unified diff form.  If your changes are 
	  localized to one file, you can create a patch using a command such as:
	</para>
	<para><command>diff -u si_getimage.orig si_getimage</command></para>
	<para>
	  If your changes are in multiple files, you can create a patch using
	  a command such as:
	</para>
	<para>
	  <command>diff -urN systemimager.orig/ systemimager/</command>
	</para>
      </listitem>
      <listitem>
	<para>
	  Review your patches to make sure you aren't changing other
	  things.  Even if the additional changes are just whitespace changes,
	  they can make the patch more difficult to review and reduce the
	  chances it can cleanly apply against a slightly different tree.
	</para>
      </listitem>
      <listitem>
	<para>
	  It's easiest if patches are against the code in an up-to-date tree of 
	  the code branch you're changing.  For example, if you've fixed a bug
	  in 3.0.0, check out the v3_0_x branch and create your diff against
	  that tree to prevent you from fixing a bug that has already
	  been fixed and committed or from creating a patch against a version that
	  is different enough that it won't apply cleanly to the current code.
	</para>
      </listitem>
      <listitem>
	<para>
	  Please submit patches to SystemImager code that do not affect
	  other components of the System Installation suite to
	  systemimager-devel@lists.sourceforge.net.  For patches relevant 
	  to the rest of the System Installation
	  Suite, submit to sisuite-devel@lists.sourceforge.net.  Use the latter if unsure 
	  which one to use.
	</para>
      </listitem>
    </itemizedlist>
  </section>
  <section>
    <title>Tour of the Source Tree</title>
    <section>
      <title>Makefile Overview</title>
      <para>
	Currently, the make system is a single Makefile that
	includes make snippets from other places in the tree.  This setup allows
	you to easily depend on other make rules but also means all rules
	must exist in a flat namespace.  Notice that the rules and
	variables in each .rul file use a common prefix.  For example,
	every rule in the parted.rul file begins with "parted_", and every
	variable begins with "PARTED_".  Another thing to keep in mind when
	working within this system is that all paths are relevant to the
	toplevel.  We may change to a recursive make style build system at 
	some point.
      </para>
    </section>
    <section>
      <title>Third Party Software</title>
      <para>
	The SystemImager build system builds a mini Linux distribution called BOEL
	that runs on clients during an autoinstall  (See "Additional Installation
	Information" in Chapter 3 for more information on BOEL). The <filename>initrd.img</filename> 
	file contains a subset of BOEL that is small enough to allow a fast startup of the clients
	After the client has booted and
	brought up networking, it receives the 
	<filename>boel_binaries.tar.gz</filename> file and extracts it over
	the root of the filesystem,  providing an additional set of
	commands, libraries, and kernel modules that may be needed during the
	installation.
      </para>
    </section>
  </section>
</chapter>
  
<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-namecase-general:t
sgml-general-insert-case:lower
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:2
sgml-indent-data:t
sgml-parent-document:nil
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
-->
