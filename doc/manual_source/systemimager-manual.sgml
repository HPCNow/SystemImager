<!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook V3.1//EN"> 

<article id=index>

 <artheader>
  <title>VA SystemImager v1.4.0 Documentation</title>
   <pubdate>v1.3 12 Feb, 2001</pubdate>
    <author>
     <firstname>Greg</firstname>
     <surname>Pratt</surname>
     <affiliation>
      <orgname>VA Linux Systems</orgname>
      <address><email>gpratt@valinux.com</email></address>
     </affiliation>
    </author>
    <author>
     <firstname>Dann</firstname>
     <surname>Frazier</surname>
     <affiliation>
      <orgname>Hewlett Packard</orgname>
      <address><email>daniel_frazier@hp.com</email></address>
     </affiliation>
    </author>

    <revhistory>
     <revision>
      <revnumber>v0.1</revnumber>
      <date>15 September 2000</date>
      <authorinitials>gap</authorinitials>
      <revremark>
       Original document creation without FAQ Section
      </revremark>
     </revision>
     <revision>
      <revnumber>v1.0</revnumber>
      <date>05 January 2001</date>
      <authorinitials>gap</authorinitials>
      <revremark>
       Added Sample Install
      </revremark>
     </revision>
     <revision>
      <revnumber>v1.1</revnumber>
      <date>10 January 2000</date>
      <authorinitials>gap</authorinitials>
      <revremark>
       Completed FAQ Section
      </revremark>
     </revision>
     <revision>
      <revnumber>v1.2</revnumber>
      <date>14 January 2000</date>
      <authorinitials>gap</authorinitials>
      <revremark>
       Added several images and clarification in key areas
      </revremark>
     </revision>
     <revision>
      <revnumber>v1.3</revnumber>
      <date>12 February 2000</date>
      <authorinitials>gap</authorinitials>
      <revremark>
       Modified Acknowledgement Section
      </revremark>
     </revision>
   </revhistory>

  <abstract>
    <indexterm>
      <primary>Abstract</primary>
    </indexterm>

    <para>
     This document has been prepared to aid in the installation, configuration 
     and on-going administration of the 
     <application>VA SystemImager</application> product. 
    </para>

    <para><ulink url="systemimager-manual.sgml">SGML source</ulink>
    for this document is available and should be consulted while reading.
    </para>
  </abstract>
 </artheader>

 <sect1 id="acknowledgements">
  <title>Acknowledgments and Thanks</title>
   <para>
    Thanks to everyone that gave comments as I was writing this. This 
    includes (in alphabetical order):
   </para>
   <itemizedlist>
    <listitem>
     <para>
      Paonia Ezrine <email>paonia@home.welcomehome.org</email>
     </para>
    </listitem>
    <listitem>
     <para>
      Brian Finley <email>brian@thefinleys.com</email>
     </para>
    </listitem>
    <listitem>
     <para>
      Dann Frazier <email>daniel_frazier@hp.com</email>
     </para>
    </listitem>
    <listitem>
     <para>
      Austin Gonyou <email>austin@coremetrics.com</email>
     </para>
    </listitem>
    <listitem>
     <para>
      Ari Jort <email>ajort@valinux.com</email>
     </para>
    </listitem>
    <listitem>
     <para>
      Jason R. Mastaler <email>jasonrm@lanl.gov</email>
     </para>
    </listitem>
    <listitem>
     <para>
      Ben Spade <email>spade@radik.com</email>
     </para>
    </listitem>
   </itemizedlist>
   <para>
    <application>SystemImager</application> was conceived and developed by
    Brian Finley.  It's initial implementation was known as
    <application>Pterodactyl</application> and was used for software and 
    password updates to <productname>Solaris</productname> boxes of varying
    hardware and OS versions 
    across a nation wide enterprise network.  Over time it evolved into the 
    Linux specific autoinstall and software distribution tool that it is 
    today.  Many of the design decisions for
    <application>SystemImager</application> were based on 
    perceived short comings in other automated install tools for systems 
    such as Solaris, RedHat Linux, and Windows.
   </para>
   <para>
    Be sure to view the <ulink url="CREDITS">CREDITS</ulink> file for a 
    listing of other people who have contributed code or documentation 
    that has been incorporated.  Many thanks go to these people as their
    relentless pursuit in the discovery of bugs and the occasional code
    contribution are invaluable.
   </para>

 </sect1>

 <sect1 id=Intro>
  <title>Introduction</title>
  <para>
   <application>VA SystemImager</application> is software that makes the 
   installation of Linux to masses of similar machines relatively easy.  
   It also makes software distribution, configuration, and operating 
   system updates easy.  You can even update from one Linux release or  
   version to another!  <application>VA SystemImager</application> can  
   also be used for content management on web servers.  
  </para>

  <para>
   It is most useful in environments where you have large numbers of 
   identical machines.  Some typical environments include: Internet 
   server farms, high performance clusters, computer labs, or corporate 
   desktop environments where all workstations have the same basic 
   hardware configuration.
  </para>

  <example><title>A typical Cluster or Server Farm</title>
   <mediaobject>
    <imageobject>
     <imagedata format="jpg" fileref="images/cluster.jpg">
    </imageobject>
    <imageobject>
     <imagedata format="eps" fileref="images/cluster.eps">
    </imageobject>
    <textobject>
     <phrase>
      A typical Cluster or Server Farm 
     </phrase>
    </textobject>
   </mediaobject>
  </example>
 </sect1>

 <sect1 id=Who>
  <title>Who Should Use This Guide</title>
  <para>
   This guide is for system administrators whose responsibility it is to 
   install and configure one or more systems in a networked environment.
  </para>

  <para>
   Typical organizations that see a benefit from using 
   <application>VA SystemImager</application> include:
  </para>
   <itemizedlist>
    <listitem>
     <para>
      organizations that have Internet server farms
     </para>
    </listitem>
    <listitem>
     <para>
      organizations that manage many workstations or servers for a 
      department or for the entire company
     </para>
    </listitem>
    <listitem>
     <para>
      organizations that are doing super-computing/clustering with Linux
     </para>
    </listitem>
    <listitem>
     <para>
      anyone who needs to maintain identical configurations on a a large 
      number of machines
     </para>
    </listitem>
   </itemizedlist>
 </sect1>

 <sect1 id=Sect2>
  <title>Supported Distributions</title>
  <para>
   <application>VA SystemImager</application> is designed to work with 
   most any Linux distribution.  However, there are parts of 
   <application>VA SystemImager</application> that may need to be customized 
   to deal with particular distributions.   If you are using an untested 
   distribution, you may find that the networking and hostname information are
   not configured properly after doing an autoinstall.  If you try 
   <application>VA SystemImager</application> with your favourite distribution
   and it doesn't work properly, please submit a 
   <ulink url="http://sourceforge.net/bugs/?group_id=259">bug report</ulink>, 
   preferably with
   patches you've created to fix the problem.  Appropriate credit is given to 
   all who find and submit valid bugs or contribute code or documentation that 
   is used.
  </para>

  <para>
   Here is an incomplete list of distributions known to work with 
   <application>VA SystemImager</application>.  If you are successfully 
   using <application>VA SystemImager</application> with a distribution or 
   version not listed here, please submit a
   <ulink url="http://sourceforge.net/bugs/?group_id=259">bug report</ulink>, 
   so we can add them to the list.  (Not a bug I know, but this is the best
   way to report success!)
  </para>

<table frame="all">
    <title>Author Tested and Supported Distributions</title>
        <tgroup cols="2">
          <colspec colname="column1">
          <colspec colname="column2">
          <spanspec namest="column2" nameend="column2" spanname="span-horiz" align="center">
            <thead>
             <row>
              <entry>Distribution</entry>
              <entry spanname="span-horiz">Versions</entry>
             </row>
            </thead>
            <tbody>
<row> <entry>Debian</entry>                            <entry>2.1 ('slink' with 2.2.x kernel), 2.2 ('potato'), ('woody')</entry> </row>
<row> <entry>Kondara</entry>                           <entry>1.1</entry>                                               </row>
<row> <entry>RedHat</entry>                            <entry>6.0, 6.1, 6.2, 7.0</entry>                                </row>
<row> <entry>RedHat with VA Linux Enhancements</entry> <entry>6.0.x, 6.1.x, 6.2.x, 7.0.x</entry>                        </row>
<row> <entry>Storm</entry>                             <entry>1.4</entry>                                               </row>
            </tbody>
        </tgroup>
</table>

<table frame="all">
    <title>Other Distributions Reported to Work</title>
        <tgroup cols="3">
          <colspec colname="column1">
          <colspec colname="column2">
          <colspec colname="column3">
            <thead>
             <row>
              <entry>Distribution</entry>
              <entry>Versions</entry>
              <entry>Reported by</entry>
             </row>
            </thead>
            <tbody>
<row> <entry>Mandrake</entry>          <entry>7.1</entry> <entry>Ben Spade (spade@radik.com) </entry> </row>
<row> <entry>TurboLinux Server</entry> <entry>6.0</entry> <entry>unknown</entry>                     </row>
            </tbody>
        </tgroup>
</table>

  <para>
   Linux-2.0.x based distributions are not supported at this time.  
   Currently there are no plans to add support for Linux 2.0.x based 
   distributions.
  </para>
 </sect1>

 <sect1 id=Sect3>
  <title>System Requirements</title>
   <itemizedlist>
    <listitem>
     <para>
      Your image server must have enough disk space to hold the images
      to be installed on your client systems.
     </para>
    </listitem>
    <listitem>
     <para>
      All of the clients that will use the same image should have hardware 
      that is as similar as possible.  Most importantly they should use the 
      same chipset on the network device(s) and the same number and kind of
      hard drive(s) (IDE, SCSI, Mylex Hardware RAID, etc.)  The hard drives
      may be of different capacities.  Devices may be larger with no problem
      and can be smaller within reason.
     </para>
    </listitem>
    <listitem>
     <para>
      For PXE installations, you will need a compatible tftp server running on 
      the boot server (usually the image/DHCP server).  H. Peter Anvin 
      maintains the <application>tftp-hpa</application> package, which 
      provides the required functionality.  RedHat 7.0 includes this server
      in their tftp-server package, but the tftp package included with earlier 
      RedHat releases doesn't provide the required functionality.  Debian
      provides this server in the tftpd-hpa package.  PXE 
      network-based installations may also require a pxe daemon to be running 
      on your image server.  This requirement depends on the firmware used on 
      the client side, and the capabilities of your DHCP server.
     </para>
    </listitem>
   </itemizedlist>
 </sect1>

 <sect1 id=HowDoesItWork>
  <title>How Does it Work? (summary)</title>
   <para>
    The basic idea behind <application>VA SystemImager</application> is 
    to retrieve the entire system image from a "golden client" to an 
    "image server".  This image can then be replicated to any number of 
    client systems.
   </para>

   <para>
    Once your client systems have had the initial image replicated to them,
    they can be updated/upgraded by syncing them to an updated image on the
    image server.  During an update, only the modified parts of files are 
    pulled to the client.  This makes for a fast, efficient, and accurate mass 
    update.
   </para>
 </sect1>

 <sect1 id=Terminology>
  <title>SystemImager Terminology</title>
   <itemizedlist>
    <listitem>
     <para>
      autoinstall media - The media that is used to boot an autoinstall client 
      in order to begin the autoinstall process.  This media can be a floppy, 
      a CDROM, the network, or the local hard drive of the autoinstall client.
     </para>
    </listitem>
    <listitem>
     <para>
      local.cfg - A configuration file that can be used for autoinstall clients
      in lieu of DHCP and the
      <filename>/tftpboot/systemimager/hosts</filename> file on the image
      server.
     </para>
    </listitem>
    
    <listitem>
     <para>
      updateclient - A command that is executed on client systems allowing
      them to be updated or synchronized to a new or updated image after the
      initial autoinstall.  <command>updateclient</command> enables software
      and content distribution.
     </para>
    </listitem>
      
    <listitem>
     <para>
      image server - The machine that will hold and distribute the images. 
     </para>
    </listitem>
      
    <listitem>
     <para>
      golden client - A machine from which an image is taken.  Golden clients
      are manually installed and customized to taste.
     </para>
    </listitem>
      
    <listitem>
     <para>
      getimage - This command is run from the image server to pull a system 
      image from a golden client. 
     </para>
    </listitem>
      
    <listitem>
     <para>
      prepareclient - This command is run on the golden client immediately 
      prior to running <command>getimage</command> on the image server.
     </para>
    </listitem>
      
    <listitem>
     <para>
      makedhcpserver - An easy way to create a SystemImager appropriate 
      <filename>/etc/dhcpd.conf</filename> file.  DHCP can be used to assign
      IP addresses to autoinstall clients. 
     </para>
    </listitem>
      
    <listitem>
     <para>
      makedhcpstatic - Used to modify the <filename>/etc/dhcpd.conf</filename>
      file, adding static entries for autoinstall clients based on the IP
      addresses handed out to these clients by the DHCP server.
     </para>
    </listitem>

    <listitem>
     <para>
      autoinstall script - A unique autoinstall script is created for each 
      image and is used by the autoinstall client as part of the autoinstall 
      process.  The names of autoinstall scripts begin with the image name 
      and end in .master.  For example:  "my_webserver_image_v1.master"
     </para>
    </listitem>

    <listitem>
     <para>
      addclients - Tells your image server which image to install on your 
      autoinstall clients.  It does so by creating soft links to the 
      master autoinstall script with the name of each host that will 
      receive that image.  It also allows you to populate the 
      <filename>/etc/hosts</filename> 
      file with sequential host names and IP addresses.  This information 
      in <filename>/etc/hosts</filename> is necessary for certain SystemImager 
      operations.
     </para>
    </listitem>

    <listitem>
     <para>
      <ulink url="http://www.dictionary.com/cgi-bin/dict.pl?term=daemon">daemon</ulink>
      - This is not specifically a SystemImager term, but it really
      bugs me when people pronounce this word as "daymen".  It is just another,
      more interesting, less evil appearing way of spelling demon.  And just to
      be clear, in computer terms, a daemon is a program that lies in wait for
      something to trigger it into action.  An example of this is a web server 
      daemon waiting for someone to request a web page. -Brian
     </para>
    </listitem>

   </itemizedlist>
 </sect1>

 <sect1 id=Overview>
  <title>Overview of SystemImager Installation and Usage</title>
   <orderedlist>

    <listitem>
     <para>
      Install the <application>VA SystemImager</application> server package 
      on the machine you have chosen as your image server. 
     </para>
    </listitem>

    <listitem>
     <para>
      Install Linux on your "golden client", and customize as you desire.
     </para>
    </listitem>

    <listitem>
     <para>
      Install the VA SystemImager client software on your "golden client" and 
      run the <command>prepareclient</command> command.
     </para>
    </listitem>

    <listitem>
     <para>
      Run <command>getimage</command> on the image server to pull the image 
      from the "golden client" to the image server.
     </para>
    </listitem>

    <listitem>
     <para>
      Run <command>addclients</command> on the image server to tell it
      which clients will receive which image, and to populate the 
      image server's <filename>/etc/hosts</filename> and 
      <filename>/tftpboot/systemimager/hosts</filename> files.
     </para>
    </listitem>

    <listitem>
     <para>
      Choose and configure the method for assigning IP addresses to your 
      autoinstall clients.
     </para>
    </listitem>

    <listitem>
     <para>
      Autoinstall the "golden" image on other machines.
     </para>
    </listitem>

   </orderedlist>
 </sect1>
 
 <sect1 id=TheActualStep-by-StepHOWTO>
  <title>The Actual Step-by-Step HOWTO</title>
   <orderedlist>

    <listitem>
     <para>
      Install the <application>VA SystemImager</application> server package 
      on the machine you have chosen as your image server.  
     </para>
     <example>
      <title>
       Often times, a machine that is already performing some kind of 
       management function is a good choice for your image server.
      </title>
      <mediaobject>
       <imageobject>
        <imagedata format="jpg" fileref="images/si_image1.jpg">
       </imageobject>
       <imageobject>
        <imagedata format="eps" fileref="images/si_image1.eps">
       </imageobject>
       <textobject>
        <phrase>
         Install the Image Server 
        </phrase>
       </textobject>
      </mediaobject>
     </example>
     <para>
      You can find the SystemImager packages and links to some of the 
      dependent packages that may not be a part of your Linux distribution at 
      <ulink url="http://systemimager.org/"></ulink>.
     </para>
     <para>
      The SystemImager server software is available in tar ball format and 
      may be available in other distribution specific packaged formats.  The 
      example below is for installing from a tar ball.  The software is the 
      same regardless of the packaging format.
     </para>
     <example><title>Installing the SystemImager server software</title>
      <programlisting>
[root@imageserver]# bzcat va-systemimager-server-x.x.x.tar.bz2 | tar -x
[root@imageserver]# cd va-systemimager-server-x.x.x
[root@imageserver]# ./install
Welcome to VA SystemImager.

This install script may modify the following files and/or directories:

 /tftpboot/systemimager/ -- create if necessary and add appropriate files/links
 /tftpboot/pxelinux.cfg/ -- create if necessary and add appropriate files/links
 /etc/services           -- add rsync and/or tftp entries if necessary
 /etc/inetd.conf         -- remove rsync entry if necessary and
                            add or modify tftp entry if necessary
 /etc/rsyncd.conf        -- it is assumed that VA SystemImager will manage this
                            file and that it will not be used for anything else

 All modified files will be backed up with the .beforesystemimager extension.

 See "install -help" for command line options.

Install VA SystemImager? (y/[n]) y
Ok. Installing VA SystemImager...

Installing files in /usr/sbin/
Installing files in /etc/init.d/
Installing files in /tftpboot/
Installing files in /tftpboot/pxelinux.cfg/
Installing files in /tftpboot/systemimager/
Installing files in /var/spool/systemimager/images/
rsync entries already enabled in /etc/services...
tftp entry already enabled in /etc/inetd.conf...
VA SystemImager brand /etc/rsyncd.conf file already exists...
creating soft links to rsync init script...
running rsync init script...
Stopping rsync daemon: rsync.
Starting rsync daemon: rsync.
Installing files in /usr/share/doc/va-systemimager-x.x.x/

All done!  Please read the manual before using SystemImager.
See /usr/share/doc/va-systemimager-x.x.x/ for all documentation.
      </programlisting>
     </example>
    </listitem>

    <listitem>
     <para>
      Install Linux on your "golden client", and customize as you desire.
     </para>
     <para>
      Select a machine which will be the "golden client".  This machine's 
      image is the image you will replicate to other machines.  
     </para>
     <para>
      Configure this "golden client" as you normally would any machine. 
      Install Linux on this node with the understanding that the software
      installed will eventually constitute the image for all other nodes
      installed with <application>VA SystemImager</application>.
      Don't worry too much about getting it exactly right the first time, 
      since you can easily use <application>VA SystemImager</application> 
      to make incremental changes to your image and distribute those changes
      without doing a complete re-install.
     </para>

     <example><title>Install the "golden client"</title>
      <mediaobject>
       <imageobject>
        <imagedata format="jpg" fileref="images/si_image2.jpg">
       </imageobject>
       <imageobject>
        <imagedata format="eps" fileref="images/si_image2.eps">
       </imageobject>
       <textobject>
        <phrase>
         Install the "golden client" 
        </phrase>
       </textobject>
      </mediaobject>
     </example>
     </listitem>

    <listitem>
     <para>
      Install the VA SystemImager client software on your "golden client" and run
      the <command>prepareclient</command> command.
     </para>

     <para>
      The SystemImager client software is available in tar ball format and may be
      available in other distribution specific packaged formats.  The example below
      is for installing from a tar ball.  The software is the same regardless of 
      the packaging format.
     </para>

     <example><title>Installing the SystemImager client software</title>
      <programlisting>
[root@imageserver]# bzcat va-systemimager-client-x.x.x.tar.bz2 | tar -x
[root@imageserver]# cd va-systemimager-client-x.x.x
[root@imageserver]# ./installclient 
Install VA SystemImager client? (y/[n]) y
Ok. Installing VA SystemImager client...

Installing files in /usr/share/doc/va-systemimager-x.x.x/

All done!  Please read the manual before using SystemImager.
See /usr/share/doc/va-systemimager-x.x.x/ for all documentation.

You must run "prepareclient" before you can retrieve this clients image.
Do you want to run "prepareclient" now? (y/[n]) n
"prepareclient" not run.
Be sure to run "prepareclient" before you run "getimage" on the imageserver.
      </programlisting>
     </example>

     <example><title>Running prepareclient</title>
      <programlisting>
[root@imageserver]# <command>prepareclient</command>

Welcome to the VA SystemImager prepareclient command.  This command
may modify the following files to prepare your client for having it's
image retrieved by the imageserver.  It will also create the 
/etc/systemimager directory and fill it with information about your 
golden client, such as the disk partitioning scheme(s). 
 
 /etc/services    -- add rsync line if necessary
 /etc/inetd.conf  -- comment out rsync line if necessary
                     (rsync will run as a daemon until shutdown)
 /tmp/rsyncd.conf -- create a temporary rsyncd.conf file with a
                     [root] entry in it.
 
All modified files will be backed up with the .beforesystemimager 
extension.

See "prepareclient -help" for command line options.

Prepare client for VA SystemImager? (y/[n]): y
Ok. Preparing client for VA SystemImager...

Creating /tmp/rsyncd.conf ...
Starting or re-starting rsync as a daemon.....done!

This client is ready to have it's image retrieved.
You must now run the "getimage" command on the imageserver.
      </programlisting>
     </example>
    </listitem>

    <listitem>
     <para>
      Run <command>getimage</command> on the image server to pull the image 
      from the "golden client" to the image server.
     </para>

    <example><title>Pull the "golden client's" image to the image server</title>
     <mediaobject>
      <imageobject>
       <imagedata format="jpg" fileref="images/si_image3.jpg">
      </imageobject>
      <imageobject>
       <imagedata format="eps" fileref="images/si_image3.eps">
      </imageobject>
      <textobject>
       <phrase>
        Pull the "golden client's" image to the image server
       </phrase>
      </textobject>
     </mediaobject>
    </example>

     <para>
      The basic syntax is: "<command>getimage</command> <command>-golden-client</command> [client_hostname] <command>-image</command> [image_name]"
     </para>
     <para>
      Where [client_hostname] is the hostname or IP address of the "golden client"
      and [image_name] is the name that you want to give to this image.
      There are many other options that can be seen with "<command>getimage -help</command>".
     </para>

     <example><title>Running getimage</title>
      <programlisting>
[root@imageserver]# getimage -g my-golden-client -image web_server_image_v1

This program will get the "web_server_image_v1" system image from "my-golden-client"
making the assumption that all filesystems considered part
of the system image are using ext2, ext3, or reiserfs.

This program will not get /proc, NFS, or other filesystems
not mentioned above.

See "getimage -help" for command line options.

Continue? ([y]/n): y

Retrieving /etc/systemimager/mounted_filesystems from my-golden-client to check for mounted filesystems...
------------- my-golden-client mounted_filesystems RETRIEVAL PROGRESS -------------
receiving file list ... done
/var/spool/systemimager/images/web_server_image_v1/etc/systemimager/mounted_filesystems
wrote 132 bytes  read 294 bytes  852.00 bytes/sec
total size is 180  speedup is 0.42
------------- my-golden-client mounted_filesystems RETRIEVAL FINISHED -------------


Retrieving image web_server_image_v1 from my-golden-client
------------- web_server_image_v1 IMAGE RETRIEVAL PROGRESS -------------
receiving file list ... done
./
bin/
bin/mt -> /etc/alternatives/mt
bin/pidof -> ../sbin/killall5
bin/rbash -> bash
bin/sh -> bash
boot/
boot/lost+found/
cdrom/
dev/
dev/MAKEDEV -> /sbin/MAKEDEV
dev/agpgart
dev/atibm
dev/audio
dev/audio1
dev/audio2
dev/audio3
dev/audioctl
dev/aztcd0
dev/bpcd

[ ... etc, etc, etc ... ]

var/log/
var/log/exim/
var/log/ksymoops/
var/log/news/
var/run/
var/spool/
var/spool/cron/
var/spool/cron/atjobs/
var/state/
var/state/apt/
var/state/apt/lists/
var/state/logrotate/
var/tmp/
wrote 117490 bytes  read 134577117 bytes  413808.32 bytes/sec
total size is 134072667  speedup is 1.00
------------- web_server_image_v1 IMAGE RETRIEVAL FINISHED -------------

Press &lt;Enter> to continue...

IP Address Assignment
---------------------

There are four ways to assign IP addresses to the client systems on an
ongoing basis:

1) static_dhcp -- A DHCP server will assign the
     same static address each time to clients 
     installed with this image.  Also see the
     "makedhcpstatic" command.

2) dynamic_dhcp -- A DHCP server will assign IP
     addresses dynamically to clients installed
     with this image.  They may be assigned a
     different address each time.

3) static -- The IP address the client uses
     during autoinstall will be permanently
     assigned to that client.

4) replicant -- Don't mess with the network
     settings in this image.  I'm using it as a
     backup and quick restore mechanism for a 
     single machine.

Which method do you prefer? [1]: 3
You have chosen method 3 for assigning IP addresses.

Are you satisfied? ([y]/n): y
Would you like to run the "addclients" utility now? (y/[n]): n
      </programlisting>
     </example>
    </listitem>

    <listitem>
     <para>
      Run <command>addclients</command> on the image server to tell it
      which clients will receive which image, and to populate the 
      image server's <filename>/etc/hosts</filename> and
      <filename>/tftpboot/systemimager/hosts</filename> files.
     </para>
     <example><title>Running addclients</title>
      <programlisting>
[root@imageserver]# addclients

Welcome to the VA SystemImager "addclients" utility  
---------------------------------------------------

This utility has 3 sections.  


"Section 1" will ask you for your hostname information.


"Section 2" will allow you to create softlinks from each
client hostname to your "master" script in the
"/tftpboot/systemimager/" directory.  

Example: www297.sh -> web_server_image_v1.master


"Section 3" will ask you for IP address information that will
be combined with the hostname information provided in Section 1
to create entries in "/etc/hosts" for each of these same clients.
New entries will be appended to the end of "/etc/hosts".  If you 
specify new hostnames for existing IP addresses, those entries 
will be re-written in place to reflect the new host names.


Continue? ([y]/n): 


addclients -- Section 1 (hostname information)
----------------------------------------------

The next series of questions will be used to create a range
of hostnames.  You will be asked for your domain name, the 
base host name, a beginning number, and an ending number.

For example, if you answer:
  domain name     = systemimager.org
  base host name  = www
  starting number = 7
  ending number   = 11

Then the result will be a series of hostnames that looks like this:
  www7.systemimager.org
  www8.systemimager.org
  www9.systemimager.org
  www10.systemimager.org
  www11.systemimager.org


What is your domain name? []: mydomain.com
What is the base host name that you want me to use? []: server
What number should I begin with? []: 1
What number should I end with? []: 99


I will work with hostnames:  server1 through server99
             in the domain:  mydomain.com

Are you satisfied? (y/[n]): y


addclients -- Section 2 (soft links to master script)
-----------------------------------------------------

Would you like me to create soft links to a "master" script so
that hosts:

  server1 through server99

can be autoinstalled with that image? ([y]/n): 

Here is a list of available images:

debian_ide_2.2 
debian_hwraid_ext2 
web_server_image_v1 

Which image would you like these hosts to receive? [web_server_image_v1]: 

Your soft links have been created.

Press &lt;Enter> to continue...


addclients -- Section 3 (adding or modifying /etc/hosts entries)
----------------------------------------------------------------

It is necessary to have an entry for each client in "/etc/hosts".

I will ask you for your clients' IP addresses one subnet at a time.


Would you like me to make these entries for you? ([y]/n): 


addclients -- Section 3 (adding or modifying /etc/hosts entries -- continued...)
--------------------------------------------------------------------------------
subnet 1

The first host in subnet 1 will be: server1
What is the starting IP address for subnet 1? []: 192.168.1.1
What is the ending IP address? []: 192.168.1.99
I will work with IP addresses:  192.168.1.1 through 192.168.1.99

Are you satisfied? (y/[n]): y

These entries have been added to /etc/hosts.

Press &lt;Enter> to continue...
      </programlisting>
     </example>

     <example><title>Entries in /etc/hosts created by addclients</title>
      <programlisting>
192.168.1.1    server1.mydomain.com  server1
192.168.1.2    server2.mydomain.com  server2
192.168.1.3    server3.mydomain.com  server3
192.168.1.4    server4.mydomain.com  server4
192.168.1.5    server5.mydomain.com  server5
192.168.1.6    server6.mydomain.com  server6
192.168.1.7    server7.mydomain.com  server7
192.168.1.8    server8.mydomain.com  server8
192.168.1.9    server9.mydomain.com  server9
192.168.1.10    server10.mydomain.com  server10
192.168.1.11    server11.mydomain.com  server11

[ ... etc, etc, etc ... ]

192.168.1.97    server97.mydomain.com  server97
192.168.1.98    server98.mydomain.com  server98
192.168.1.99    server99.mydomain.com  server99
      </programlisting>
     </example>
    </listitem>

    <listitem>
     <para>
      Choose and configure the method for assigning IP addresses to your 
      autoinstall clients.
     </para>

     <para>
      The most common way to assign IP addresses to autoinstall clients is
      DHCP.  To easify the configuration of the DHCP configuration file
      (<filename>/etc/dhcpd.conf</filename>), SystemImager includes a utility
      called <command>makedhcpserver</command>.  
      This utility asks you for all the information it needs 
      to create a DHCP configuration file that 
      is appropriate for your installation of SystemImager.  It is also
      possible to use DHCP to assign static IP addresses to your clients on
      an ongoing basis after installation.  If you choose to do so, simply
      run the <command>makedhcpstatic</command> command after all of your
      clients have had a chance to boot and be assigned an IP address.  It
      will modify your <filename>/etc/dhcpd.conf</filename>
      file on the imageserver to include static entries for each of your hosts.
     </para>

     <para>
      Alternately, hostname, imageserver, and networking information can be
      put in a configuration file on a floppy diskette.  Or if you are using a
      running system's hard drive as the boot media, you can run 
      "<command>updateclient -autoinstall -server &lt;imageserver> -config eth0</command>"
      which will create a local.cfg file at the root of the client's hard
      drive containing the existing live network settings.
     </para>
    
     <para>
      When the autoinstall client boots, it will look for this 
      file and use the provided values instead of getting them from DHCP and the
      <filename>/tftpboot/systemimager/hosts</filename> file on the image server.
      A <filename>local.cfg</filename> file on a floppy will work with any of the
      autoinstall media.  The configuration file can even be put on the autoinstall
      floppy itself!  If you use a <filename>local.cfg</filename> file
      on a hard drive and on a floppy, the settings on the floppy will override the
      settings on the hard drive.
     </para>
     <example><title>Running makedhcpserver</title>
      <programlisting>
[root@imageserver]# makedhcpserver

Welcome to the VA SystemImager "makedhcpserver" command.  This command
will prepare this computer to be a DHCP server by creating the 
following file:

 /etc/dhcpd.conf

If there is an existing file, it will be backed up as:

 /etc/dhcpd.conf.beforesystemimager

Continue? (y/[n]): y


Type your response or hit &lt;Enter> to accept [defaults].  If you don't
have a response, such as no first or second DNS server, just hit 
&lt;Enter> and none will be used.


What is your domain name? [localdomain.domain]: mydomain.com
What is your network number? [192.168.1.0]: 
What is your netmask? [255.255.255.0]: 
What is the starting IP address for your dhcp range? [192.168.1.1]: 
What is the ending IP address for your dhcp range? [192.168.1.100]: 192.168.1.99
What is the IP address of your first DNS server? []: 192.168.1.200
What is the IP address of your second DNS server? []: 192.168.1.201
What is the IP address of your third DNS server? []: 
What is the IP address of your default gateway? [192.168.1.254]: 
What is the IP address of imageserver? [192.168.1.254]: 192.168.1.203
What is the air speed velocity of the common swallow? []: 


Ahh, but seriously folks...
Here are the values you have chosen:

################################################################
DNS Domain Name:                          mydomain.com
network number:                           192.168.1.0
netmask:                                  255.255.255.0
starting IP address for your dhcp range:  192.168.1.1
ending IP address for your dhcp range:    192.168.1.99
first DNS server:                         192.168.1.200
second DNS server:                        192.168.1.201
third DNS server:                         
default gateway:                          192.168.1.254
imageserver:                              192.168.1.203
################################################################

Are you satisfied? (y/[n]): y


The dhcp server configuration file (/etc/dhcpd.conf) file has been 
created for you.  Please verify it for accuracy.

If this file does not look satisfactory, you can run this command again
to re-create it: "makedhcpserver"

WARNING!:  If you have multiple physical network interfaces, be sure to 
edit the init script that starts dhcpd to specify the interface that 
is connected to your DHCP clients.  Here's an example:

 Change "/usr/sbin/dhcpd" to "/usr/sbin/dhcpd eth1".

Also, be sure to start or restart your dhcpd daemon.  This can usually
be done with a command like "/etc/init.d/dhcpd restart" or similar.
      </programlisting>
     </example>

     <example><title>Running updateclient with the "-autoinstall" and "-config" options</title>
      <para>
       Note that the options <parameter>-autoinstall</parameter>,
       <parameter>-server</parameter>, and <parameter>-configure-from</parameter> are
       abbreviated below as <parameter>-a</parameter>, <parameter>-s</parameter>,
       and <parameter>-c</parameter>.  It is possible to abbreviate 
       options to minimum uniqueness with most SystemImager commands.  
      </para>

      <para>
       Minimum uniqueness means that if you have two options for a single 
       command that are similar, such as the <parameter>-image</parameter> and
       <parameter>-ip-assignment</parameter> options to <command>getimage,</command>
       they can be abbreviated to <parameter>-im</parameter> and
       <parameter>-ip</parameter>.
      </para>
      <programlisting>
[root@server7]# updateclient -a -s imageserver -c eth0
Retrieving SystemImager kernel...
Retrieving SystemImager initial ramdisk...
Adding SystemImager entry in /etc/lilo.conf...
running /sbin/lilo -d 50 -D systemimager ...
Ignoring entry 'delay'
Ignoring entry 'default'
Added linux
Added systemimager *

&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Below are the contents of your /local.cfg file.  Make sure that all
the variables are filled in and that they contain the proper values.
You may edit the file directly if you need to change any of the values.
&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

#
# "VA SystemImager" - Copyright (C) 1999-2001 Brian Elliott Finley &lt;brian@valinux.com>
#
# This file is: /local.cfg
#
HOSTNAME=server7
DOMAINNAME=mydomain.com
DEVICE=eth0
IPADDR=192.168.1.7
NETMASK=255.255.255.0
NETWORK=192.168.1.0
BROADCAST=192.168.1.255
GATEWAY=192.168.1.254
GATEWAYDEV=eth0
IMAGESERVER=192.168.1.203
      </programlisting>
     </example>
    </listitem>

    <listitem>
     <para>
      Autoinstall the "golden" image on other machines.
     </para>

     <para>
      There are four methods to autoinstalling the clients:
     </para>
      <itemizedlist>

       <listitem>
        <para>
         Boot the system from a floppy diskette.
        </para>

	<para>
	 Run <command>makeautoinstalldiskette</command> to create an autoinstall
	 diskette.  Autoinstall diskettes can be used with any machine unless you
	 add a customized <filename>/local.cfg</filename> file to the diskette.
	</para>

       </listitem>

       <listitem>
        <para>
         Boot the system from a CDROM.
        </para>

	<para>
	 Run <command>makeautoinstallcd</command> to create an ISO image that can
	 be burned to CDROM.  This CDROM can then be used to boot your autoinstall
	 clients and can also be used with any machine.
	</para>
       </listitem>

       <listitem>
        <para>
         Boot the system from it's own hard drive.
        </para>

	<para>
	 If your client is already running Linux, and uses LILO as it's boot
	 loader, then you can simply copy over the <command>updateclient</command>
         command and run it with the <parameter>-autoinstall</parameter> option.
	</para>
	<example><title>Copy over the updateclient command</title>
         <programlisting>
[root@server7]# rsync -av imageserver::tftpboot/systemimager/updateclient /usr/sbin
receiving file list ... done
updateclient
wrote 115 bytes  read 14560 bytes  29350.00 bytes/sec
total size is 14445  speedup is 0.98
         </programlisting>
	</example>
	<example><title>Booting the autoinstall media from a system's hard drive</title>
         <programlisting>
[root@server7]# updateclient -a -s imageserver -c eth0
Retrieving SystemImager kernel...
Retrieving SystemImager initial ramdisk...
Adding SystemImager entry in /etc/lilo.conf...
running /sbin/lilo -d 50 -D systemimager ...
Ignoring entry 'delay'
Ignoring entry 'default'
Added linux
Added systemimager *
         </programlisting>
	</example>
       </listitem>

       <listitem>
        <para>
         Boot the system from the network using PXE if your system supports 
         it.  This is usually enabled through a BIOS setting.
        </para>

	<para>
	 PXE booting is flaky and tends to vary wildly in it's hardware 
	 implementation.  If you must boot without physically touching your 
	 machines, may I suggest that you try the <parameter>-autoinstall</parameter>
         option to <command>updateclient</command> first and see if it meets your needs.
	</para>

	<para>
	 That being said, Dann Frazier has put together a fairly comprehensive
	 set of notes below if you want to attempt this most contemptuous method
	 of doing an autoinstall.  
	</para>
       </listitem>

      </itemizedlist>

    </listitem>
   </orderedlist>









     <sect2 id=NetworkBoot>
     <title>Network Booting the System</title>
     <para>
      If you prefer to boot off the network, change the settings in your
      BIOS to boot off your PXE enabled network card, and reboot your
      client system.  It *should* automatically find and boot off the
      image server and begin to autoinstall itself.  Currently, there is no 
      known single configuration that will work with every system.  The next 
      sections describe some configurations that are known to work.  If you
      are successful in configuring a system for PXE autoinstalls,
      and it is in any way different from those already mentioned below (i.e.
      different package versions, latest distribution, etc.), please let us
      know so that it can be included in this document.
     </para>
       <sect3 id=RedHat6.2BootAgent3.x>
       <title>RedHat 6.2 and Intel BootAgent 3.x</title>
       <para>
        This testing was done on HP Netservers with Intel Ether Express Pro 
        cards.  The Netservers ran a typical RedHat 6.2 installation, while 
        the NIC's were running a 3.x version of the Intel BootAgent firmware.
	The relevant software was:
        <itemizedlist>
         <listitem>
          <para>
	   <filename>
           va-systemimager-1.1-1.i386.rpm
	   </filename>
          </para>
         </listitem>
         <listitem>
          <para>
	   <filename>
           pxe-0.1-14.i386.rpm
	   </filename>
          </para>
         </listitem>
         <listitem>
          <para>
	   <filename>
	   dhcp-2.0-5.i386.rpm
	   </filename>
          </para>
         </listitem>
         <listitem>
          <para>
	   <filename>
           tftp-hpa-0.13-1.i386.rpm
	   </filename>
          </para>
         </listitem>
         <listitem>
          <para>
	   <filename>
           inetd-0.16-4.i386.rpm
	   </filename>
          </para>
         </listitem>
         <listitem>
          <para>
	   <filename>
           syslinux-1.48-2.i386.rpm
	   </filename>
          </para>
         </listitem>
        </itemizedlist>
	Taking the following steps should result in a working configuration:
        <orderedlist>
         <listitem>
          <para>
           Install the above packages onto the image server.
          </para>
         </listitem>
         <listitem>
          <para>
           # <command>mv /tftpboot/X86PC/UNDI/linux-install/linux.0 /tftpboot/X86PC/UNDI/linux-install/linux.0.bak</command>
          </para>
         </listitem>
         <listitem>
          <para>
           # <command>cp /tftpboot/pxelinux.bin /tftpboot/X86PC/UNDI/linux-install/linux.0</command>
          </para>
         </listitem>
         <listitem>
          <para>
           # <command>cp -r /tftpboot/kernel /tftpboot/initrd.gz /tftpboot/pxelinux.cfg /tftpboot/X86PC/UNDI/linux-install/</command>
          </para>
         </listitem>
         <listitem>
          <para>
           # <command>cp /tftpboot/pxelinux.cfg/message.txt \
             /tftpboot/X86PC/UNDI/linux-install</command>
          </para>
         </listitem>
         <listitem>
          <para>
           # <command>/etc/rc.d/init.d/pxe start</command>
          </para>
         </listitem>
        </orderedlist>
       </para>
       </sect3>
       <sect3 id=RedHat7.0BootAgent3.x>
       <title>RedHat 7.0 and Intel BootAgent 3.x</title>
       <para>
        This testing was done on HP Netservers with Intel Ether Express Pro 
        cards.  The Netservers ran a typical RedHat 7.0 installation, while 
        the NIC's were running a 3.x version of the Intel BootAgent firmware.
	The relevant software was:
        <itemizedlist>
         <listitem>
          <para>
           <filename>va-systemimager-1.3.0-1.i386.rpm</filename> - This
	   version has a few incompatiblities with RedHat 7.0.  It is unable
	   to parse the LABEL= entries in the golden client's
	   <filename>/etc/fstab</filename> file, and it assumes the
           image server uses <application>inetd</application> instead of
	   <application>xinetd</application>.  These issues have been
           resolved in <application>VA SystemImager 1.4</application>.
          </para>
         </listitem>
         <listitem>
          <para>
	   <filename>
           pxe-0.1-20.i386.rpm
	   </filename>
          </para>
         </listitem>
         <listitem>
          <para>
	   <filename>
	   dhcp-2.0-12.i386.rpm
	   </filename>
          </para>
         </listitem>
         <listitem>
          <para>
           <filename>tftp-server-0.17-5.i386.rpm</filename> - The default
	   <application>xinetd</application> entry for 
	   <application>tftp-server</application> must be modified 
	   for use with <application>VA SystemImager</application>.  This entry
	   is stored in <filename>/etc/xinetd.d/tftp</filename>.  An example
	   of a valid entry is:
	   <example>
	    <title>Sample tftp entry for xinetd</title>
	     <literallayout>
service tftp
{
        socket_type             = dgram
        protocol                = udp
        wait                    = yes
        user                    = root
        server                  = /usr/sbin/tftpd
        server_args             = -s /tftpboot -r blksize
        disable                 = no
}
	    </literallayout>
	   </example>
          </para>
         </listitem>
         <listitem>
          <para>
           <filename>xinetd-2.1.8.9pre11-1.i386.rpm</filename> - this version
	   has a race condition which can prevent the tftp server from
	   responding.  this has supposedly been fixed in version
	   2.1.8.9pre13.
	   <application>xinetd</application> has a default limit on how many
	   connections can be spawned in a 60 second period.  This is
	   configurable, if necessary, by adding the -loop argument in the
	   <filename>/etc/init.d/xinetd</filename> initscript.
          </para>
         </listitem>
         <listitem>
          <para>
           <filename>
	    syslinux-1.48-2.i386.rpm
	   </filename>
          </para>
         </listitem>
        </itemizedlist>
	Taking the following steps should result in a working configuration:
        <orderedlist>
         <listitem>
          <para>
           Install the above packages onto the image server.
          </para>
         </listitem>
         <listitem>
          <para>
           <command>
            # mv /tftpboot/X86PC/UNDI/linux-install/linux.0 
                 /tftpboot/X86PC/UNDI/linux-install/linux.0.bak
           </command>
          </para>
         </listitem>
         <listitem>
          <para>
           <command>
            # cp /tftpboot/pxelinux.bin 
              /tftpboot/X86PC/UNDI/linux-install/linux.0
           </command>
          </para>
         </listitem>
         <listitem>
          <para>
           <command>
            # cp -r /tftpboot/kernel /tftpboot/initrd.gz 
              /tftpboot/pxelinux.cfg /tftpboot/X86PC/UNDI/linux-install/
           </command>
          </para>
         </listitem>
         <listitem>
          <para>
           <command>
            # cp /tftpboot/pxelinux.cfg/message.txt 
              /tftpboot/X86PC/UNDI/linux-install
           </command>
          </para>
         </listitem>
         <listitem>
          <para>
           <command>
            # touch /var/lib/dhcp/dhcpd.leases
           </command>
           </para>
          </listitem>		
         <listitem>
          <para>
           <command>
            # /etc/init.d/pxe start
           </command>
          </para>
         </listitem>
        </orderedlist>
       </para>
       </sect3>
       <sect3 id=RedHat7.0BootAgent4.x>
       <title>RedHat 7.0 and Intel BootAgent 4.x</title>
	<para>
         This configuration is very similar to the section "RedHat 7.0 and 
         Intel BootAgent 3.x".  The only noticable difference is that
	 the pxe package is no longer required.  The entries created in
         <filename>/etc/dhcpd.conf</filename> by
         <command>makedhcpserver</command> are sufficient.
        </para>
       </sect3>
     </sect2>
 </sect1>

 <sect1 id=DesignGoals>
  <title>I Want More Details!  What were the Design Goals?</title>
  <itemizedlist>

   <listitem>
    <para>
     Images should be pulled from a working system.
    </para>
   </listitem>

   <listitem>
    <para>
     Completely unattended installs were a must.
    </para>
   </listitem>
     
   <listitem>
    <para>
     The unattended install system had to be able to repartition the 
     destination drive(s).
    </para>
   </listitem>

   <listitem>
    <para>
     One of the main design goals was ease of use.  This had to be a 
     tool that could be used by a system administrator that didn't 
     necessarily understand how it worked.
    </para>
   </listitem>

   <listitem>
    <para>
     It was also necessary for it to install easily and quickly so 
     that it could be useful right away without alot of site specific
     customization.
    </para>
   </listitem>

   <listitem>
    <para>
     Images should be stored as normal files to allow for incremental
     upgrades as opposed to "dd" style block level images of physical 
     disks.
    </para>
   </listitem>
     
   <listitem>
    <para>
     It had to be independent of any and all packaging systems (such 
     as RPM) in order to easily accomodate different distributions.
    </para>
   </listitem>

   <listitem>
    <para>
     It should be able to store multiple images, for different types 
     of systems and for revision control.
    </para>
   </listitem>
     
   <listitem>
    <para>
     It must provide a mechanism for unattended install clients to
     know which image to install.
    </para>
   </listitem>

   <listitem>
    <para>
     Once a client was installed, it should be able to update itself
     to a new or updated image.
    </para>
   </listitem>
     
   <listitem>
    <para>
     It should have a command line interface that lent itself well to
     being wrapped with a GUI.
    </para>
   </listitem>

  </itemizedlist>
 </sect1>

 <sect1 id=Architecture>
  <title>I Want More Details!  Please Describe the Architecture.</title>
   <para>
    SystemImager began as a series of utilities written as shell scripts.
    Minimal system requirements were considered a top priority.  As SystemImager
    matured, and the utilities became internally more complex, it became clear 
    that shell scripts were falling short of the need.  Perl was chosen to pick
    up the yoke and has allowed for cleaner, more advanced code.  It was
    determined that Perl is installed as part of most "base" Linux installs and 
    therefore was a reasonable choice from a minimal requirements perspective.
   </para>

   <para>
    The architecture was designed to be open to future modification at every 
    level.  The protocol used for transferring files during installs and updates 
    is currently rsync(1).  But the modular code will easily allow for drop-in 
    replacements as is appropriate.  All unicast file transfer mechanisms are 
    implemented in a "pull" fashion, which is generally considered to be superior
    to a "push".  Using a "pull" mechanism, it is much easier to monitor the 
    state of the receiving system prior to and during the file transfers.  In the
    future, multicast may be an option and may need to be implemented as a push.
   </para>

   <para>
    There are other methods available for doing automatic installs, such as 
    RedHat's KickStart which installs systems based on a list of pre-defined
    packages.  But package based installs are very limiting in that they 
    generally don't have an automated way for dealing with non-packaged files.  
    If you re-compile your kernel, add a piece of non-packaged software, or 
    modify certain configuration files, you are usually required to do some sort 
    of scripting or programming to deal with these "special cases".
   </para>

   <para>
    In order keep imaging simple, SystemImager uses images that are based on a 
    working installed system.  We call this system a "golden client".  Just get 
    one of your machines working exactly the way you want and pull it's image to 
    the imageserver with the "getimage" command.  You can re-compile your kernel, 
    install custom software, and do any configuration file tweaking you like.  
    SystemImager will get it all.
   </para>

   <para>
    Now that you have your golden client configured, we need to run the 
    "prepareclient" command.  prepareclient will collect the partition information
    from your disks and put it in the <filename>/etc/partitionschemes</filename> directory.  A file 
    will be created in this directory for each of your disks and will contain that
    disk's partition information.  prepareclient will also create an rsync(1) 
    configuration file (<filename>/tmp/rsyncd.conf</filename>) and start rsync in server mode (<command>rsync 
    --daemon</command>).  This allows the image server to pull the image from the client, 
    but will not cause the rsync daemon to be restarted after the golden client is 
    rebooted.  This helps avoid security concerns of sharing a golden client's 
    root filesystem via rsync.
   </para>

   <para>
    On the imageserver we now run the getimage command.  Here's an example:  
   </para>

   <para>
    "getimage -golden-client 192.168.1.1 -image my_webserver_image_v1"
   </para>

   <para>
    getimage contacts the golden client and requests it's 
    <filename>/etc/systemimager/mounted_filesystems</filename> file.  This
    file contains the list of 
    mounted filesystems and the devices on which they are mounted.  It pulls out 
    the mount points for the filesystems that are unsupported and creates an 
    exclusion list.  Currently supported filesystems are ext2, ext3, and reiserfs.
    Unsupported filesystems are everything else including things like proc, 
    devpts, iso9660, etc.  getimage then pulls the golden client's entire system 
    image, excluding the filesystems in the exclusion list.  The files are pulled 
    by connecting to the rsync daemon running on the golden client.  All the 
    files from the client will be copied over, recreating the file and directory 
    hierarchy in the image directory.
   </para>

   <para>
    getimage can also be used to update an existing image.  By simply specifying
    an existing image name, you are asking getimage to update that image to match
    the files on your golden client.  In this case, only the parts of files that 
    are different will be copied over.  Files that exist in the old image but not 
    on the golden client will be deleted, and files that exist in both places but
    have changed will be updated.  This is one way to keep an image updated when 
    new security patches or other system updates come out.  However, the 
    recommended method is to never overwrite a known working image, so that you 
    have a form a revision control.  This is not true revision control, where 
    individual file revisions are tracked on a line by line basis.  It is 
    revision control on an image by image basis.  This form of revision control 
    also ties in to the updateclient command which will be discussed later.  By 
    default, all images are stored in the parent directory of 
    "/var/spool/systemimager/images/" in a directory that bears the image name.  
    For example: "/var/spool/systemimager/images/my_webserver_image_v1/".
   </para>

   <para>
    After getimage has pulled the files to the image directory on the imageserver
    it creates a customized autoinstall script.  The autoinstall script in our
    example would be named "my_webserver_image_v1.master".  All autoinstall 
    scripts are placed in the "/tftpboot/systemimager/" directory.  The disk 
    partitioning information left behind by the prepareclient command is used to 
    add the necessary commands to re-partition the disk(s) on the autoinstall 
    clients.  File system information is taken from the /etc/fstab file in the 
    image (Ie.: "/var/spool/systemimager/images/my_webserver_image_v1/etc/fstab") 
    and is used to determine the appropriate file system creation commands and to
    determine mount points for the autoinstall process.  Based on command line 
    options passed to getimage or questions it has asked, certain networking 
    information is added to the autoinstall script.  This information is added in 
    variable form as the autoinstall client will determine the values for things 
    such as it's hostname and IP address during the autoinstall process.
   </para>

   <para>
    After running getimage, you will run the addclients command.  addclients will 
    ask you for the series of hostnames that you will be installing by combining 
    a base host name and a number range.  For example, if your base host name is
    "www", and your number range is from "1" to "3", then the resultant host 
    names would be "www1, www2, www3".  It will then prompt you to choose the 
    image that will be installed to these hosts and will create soft links for 
    each hostname that point to the master autoinstall script for that image.  
    For example: "www3.sh -> web_server_image_v1.master".  If the image is 
    updated and you choose to allow getimage to also update the master autoinstall 
    script, then each of the associated soft links therefore point to the updated
    autoinstall script.  If individual host configuration is necessary, the soft 
    link for that host can be removed and replaced with a copy of the master 
    autoinstall script that can then be customized for that host.  This 
    customization is a manual process and is up to the system administrator.  
   </para>

   <para>
    addclients will then prompt you for the IP address information for these hosts
    and will re-write the imageserver's /etc/hosts file accordingly, then copy 
    this file to /tftpboot/systemimager/hosts.  The latter file is used during the 
    autoinstall process for clients using DHCP to determine their host names.
   </para>

   <para>
    The unattended install portion is flexible and can work with most any hardware
    available.  It is also easily modified to work with new or special hardware. 
    A miniature Linux distribution (Brian's Own Embedded Linux) is used for 
    autoinstalls.  It consists of a customized kernel and an initial ram disk
    which contains only the specific commands and utilities necessary to perform
    autoinstalls. The same kernel and initial ram disk (initrd.gz) can be used to 
    boot from floppy disks, CDROMs, the network, or any running Linux system's 
    local hard drive.  The commands "makeautoinstalldiskette" and 
    "makeautoinstallcd" make use of the syslinux(2) utility to create floppies and 
    CDROMs that will boot the SystemImager kernel and initial ram disk.  
    pxelinux(2), which is a sister tool to syslinux, allows the same kernel and 
    initial ram disk to boot PXE capable machines from the network.  A 
    configuration file is needed by syslinux and by pxelinux, but the two tools 
    are able to use the same configuration file and SystemImager handles this for 
    you.
   </para>

   <para>
    The autoinstall kernel is compiled to contain all the necessary drivers for 
    the majority of systems.  Custom kernels can be compiled to meet special 
    disk and network driver requirements.  To use a custom kernel, simply copy it 
    to /tftpboot/kernel.  All of the autoinstall media is created from 
    /tftpboot/kernel and /tftpboot/initrd.gz on the image server.
   </para>

   <para>
    Once the kernel has booted, it mounts the initial ram disk as it's root 
    filesystem.  It then executes an initialization script on the ram disk that 
    has been written to do SystemImager specific things.  This script will use 
    either a configuration file (/local.cfg) or a combination of DHCP and the
    /tftpboot/systemimager/hosts file pulled from the image server to determine
    the autoinstall client's IP address and hostname information.  If DHCP is 
    used, the client parses the hosts file retrieved from the image server to 
    find it's IP address and can therefore determine it's hostname.  Finally it 
    retrieves an autoinstall script from the image server based on it's hostname 
    and executes it.  The autoinstall script is image specific.  This is how a 
    client determines which image it will receive.  Here is a summary:  
    IP address -> hostname -> image specific autoinstall script named with hostname.
   </para>

   <para>
    The most common way to assign IP addresses to autoinstall clients is DHCP.  
    To easify the configuration of the DHCP configuration file (/etc/dhcpd.conf), 
    SystemImager includes a utility called makedhcpserver.  This utility asks 
    you for all the information it needs to create a DHCP configuration file that 
    is appropriate for your installation of SystemImager.  It is also possible to 
    use DHCP to assign static IP addresses to your clients on an ongoing basis 
    after installation.  If you choose to do so, simply run the makedhcpstatic 
    command after all of your clients have had a chance to boot and be assigned
    an IP address.  It will modify your /etc/dhcpd.conf file on the imageserver 
    to include static entries for each of your hosts.
   </para>

   <para>
    Alternately, hostname, imageserver, and networking information can be put in 
    a configuration file on a floppy diskette.  Or if you are using a running 
    system's hard drive as the boot media, you can run 
    "<command>updateclient -autoinstall -server &lt;imageserver> -config eth0</command>"
    which will create a local.cfg file at the root of the client's hard drive 
    containing the existing live network settings.
   </para>
    
   <para>
    When the autoinstall client boots, it will look for this 
    file and use the provided values instead of getting them from DHCP and the
    /tftpboot/systemimager/hosts file on the image server.  A local.cfg file on
    a floppy will work with any of the autoinstall media.  The configuration file 
    can even be put on the autoinstall floppy itself!  If you use a local.cfg file
    on a hard drive and on a floppy, the settings on the floppy will override the
    settings on the hard drive.
   </para>
    
   <para>
    The format of this configuration file is simply VARIABLE=value for all the 
    appropriate settings.  The name of this file must be local.cfg and it must 
    exist on the root of the floppy or hard drive.  The floppy can be formatted 
    with either ext2 or fat.  An example local.cfg file can be found with the 
    documentation files which are usually installed in /usr/share/doc.
   </para>

   <para>
    Sometimes you will want to update an image on your image server.  There are 
    a couple of ways to do this.  The first way is to directly edit the files in 
    the image directory.  The best way to do this is to chroot into the image 
    directory.  Once you have done the chroot, you can work with the image as if 
    it were a running machine.  You can even install packages with apt-get or RPM,
    for example.  The second way is to run the getimage command again, specifying 
    a golden client that has been modified in the desired way.  Again, only the 
    parts of the files that have changed will be pulled across.  Files that have 
    been deleted on the golden client will also be deleted in the image.  You are 
    also given the option to update the master autoinstall script for the image 
    or to leave it alone.  The advantages of this method are that you can verify 
    that your new configuration works on the golden client, and that the
    master autoinstall script is updated.
   </para>
   
   <para>
    Once a system has been autoinstalled, the updateclient command can be used 
    to update a client system to match a new or updated image on the image server.  
    Let's say that you've installed your company's 300 web servers and a security 
    patch comes out the next day.  You simply update the image on the image server 
    and run updateclient on each of your web servers.  Only the modified files are 
    pulled over, so it takes very little time, and your entire site is patched!  
    It is recommended that you create an entirely new image with a new version 
    number so that you have some form of revision control.  This way, if you find 
    out that the patch you applied hosed up your entire web farm, you simply do 
    an updateclient back to the last known working image!
   </para>

   <para>
    By incorporating some modifications sent in by A.L. Lambert of 
    <ulink url="http://epicrealm.com/">epicRealm</ulink>, using the "updateclient"
    command with the -autoinstall option will copy the autoinstall kernel and 
    initial ram disk to the local hard drive of an autoinstall client that is
    currently running, but needs to be re-deployed.  It will then modify the 
    /etc/lilo.conf file to include an appropriate entry for the new kernel and 
    initial ram disk and will make this new kernel the default.  The next time 
    the client system is booted, it will load the SystemImager kernel and initial 
    ram disk, which will begin the autoinstall process!  This means that you can 
    remotely re-deploy any running Linux machine without having to have someone 
    feed the machine a floppy or CD and without having to reconfigure the BIOS 
    to boot off the network (which can be quite 
    <ulink url="http://www.dictionary.com/cgi-bin/dict.pl?term=squirrelly">squirrelly</ulink>
    with some BIOSes).  
   </para>
 </sect1>


 <sect1 id=FAQ>
  <title>Frequently Asked Questions</title>
  <para>
  </para>
  <sect2 id=FAQImages>
  <title>Q: Where are the images stored?</title>
   <para>
    The images are stored in <filename>/var/spool/systemimager/images</filename>  
   </para>
   <para>
    NOTE: If you are short on disk space in this location, move the directory 
    in another location:
   </para>
   <para>
    <command>mv /var/spool/systemimager/images /home/systemimager_images</command>
   </para>
   <para>
      And create a soft link to the new directory.
   </para>
   <para>
    <command>ln -s /home/systemimager_images /var/spool/systemimager/images</command>
   </para>
  </sect2>
  <sect2 id=FAQInstallFloppy>
   <title>Q: How do I make an autoinstalldiskette?</title>
   <para>
    Run the <command>makeautoinstalldiskette</command> command on the 
    image server.
   </para>
  </sect2>
  <sect2 id=FAQInstallCD>
   <title>Q: How do I make an autoinstallcd?</title>
   <para>
    Run the <command>makeautoinstallcd</command> command on the image server.
   </para>
  </sect2>
  <sect2 id=FAQCDNoBoot>
    <title>Q: I made an autoinstallcd, but it didn't boot.  What's wrong?</title>
   <para>
    There was a problem with the following RPM:   
    <filename>syslinux-1.48-1.i386.rpm</filename>
    Download and install a newer syslinux RPM from 
    <ulink url="http://systemimager.org/"></ulink>
   </para>
  </sect2>
  <sect2 id=FAQDHCPServerLocation>
   <title>Q: Does the DHCP server have to be on the image server?</title>
   <para>
    Yes.  At this point in time it does.  After the client gets it's address
    via DHCP, it determines the DHCP server to be the image server and tries
    to connect to the DHCP server with tftp to get it's utilities and it's 
    autoinstall script.
   </para>
  </sect2>

  <sect2 id=FAQAddDriver>
   <title>How do I add a driver for a special card to the autoinstall client?</title>
   <para>
    All you have to do is start with the linux kernel source and the 
    <filename>.config</filename> file that
    you can find in the CVS repository on SourceForge:
   </para>
   <para>
    <ulink url="http://cvs.sourceforge.net/cgi-bin/cvsweb.cgi/~checkout~/systemimager/systemimager/">
    VA SystemImager CVS Repository</ulink>
   </para>
   <para>
    The 1.4.0 autoinstall media is based on Linux 2.2.18 and has various
    patches applied.  You can find this source on the SystemImager web site.
   </para>
   <para>
    Put the <filename>.config</filename> file in your
    <filename>/usr/src/linux</filename> directory
    as <filename>.config</filename> and run <command>make menuconfig</command> 
    or your favourite kernel config utility.  Choose the driver for the card 
    you need.
   </para>
   <para>
    However!  This will probably make the kernel too large for the floppy.  So 
    you will want to de-select drivers for many of the cards that will not be 
    used.  I would recommend de-selecting all of the Ethernet cards except for 
    the ones you need.
   </para>
   <para>
    Do the standard:
   </para>
    <programlisting>
     make dep
     make clean
     make bzImage
    </programlisting>
   <para>
    Please refer to the <ulink url="http://www.caldera.com/LDP/HOWTO/Kernel-HOWTO.html">Kernel-HOWTO</ulink> for more information on recompiling a kernel.
   </para>
   <para>
    Then copy the resultant kernel over the kernel (<filename>
    /tftpboot/kernel</filename>) installed in
    <filename>/tftpboot</filename> by SystemImager.
   </para>
   <para>
    You should now be able to do a <command>makeautoinstalldiskette</command>,
    <command>makeautoinstallcd</command>, or boot off the network.
   </para>
  </sect2>

  <sect2 id=FAQExcludingStuff>
   <title>How do I exclude files or directories during a getimage?</title>
   <para>
    As of 1.4.0 there is not support for this.  Look for this feature soon.
   </para>
  </sect2>
  <sect2 id=FAQPrepareClient>
   <title>Do I have to do anything to prepare a client from which I will get 
    an image? </title>
   <para>
    Yes.  Install the va-systemimager-client package.  If this package is
    already installed, all you have to do is run the
    <command>prepareclient</command> command prior to running
    <command>getimage</command> from the image server.
   </para>
   <para>
    You will also want to add any software, configure any files, and do any 
    tweaking to make the system just how you like it!
   </para>
  </sect2>

  <sect2 id=FAQUseAutoinstallMultiple>
   <title>Can I use the autoinstalldiskette or autoinstallcd on more than one 
    machine?</title>
   <para>
    Yes.  The autoinstall media is generic, and can be on any machine that you 
    want to autoinstall.
   </para>
  </sect2>

  <sect2 id=FAQPushImage>
   <title>How do I push an image to a client?</title>
   <para>
    You don't.  Everything in VA SystemImager is actually based on a pull 
    mechanism which allows for more control over error conditions.
   </para>
  </sect2>

  <sect2 id=FAQPullImage>
   <title>Ok, so how do I pull an image to a client?</title>
   <para>
    If you ran <command>makedhcpserver</command> to configure your dhcp 
    information, and if you answered all the questions you were asked when 
    you did your <command>getimage</command>, including the hostnames and 
    IP addresses, then all you have to do is boot your client with any one 
    of the three forms of autoinstall media.  
   </para>
   <para>
    They are:
   </para>
   <orderedlist>
    <listitem>
     <para>
      <emphasis>autoinstalldiskette</emphasis> - (takes longer to boot and
      floppies are often quite volatile)
     </para>
    </listitem>
    <listitem>
     <para>
      <emphasis>autoinstallcd</emphasis> - (takes slightly less time to boot 
      and is more durable, but you have to have a CD burner and clients that
      can read CD-R's)
     </para>
    </listitem>
    <listitem>
     <para>
      <emphasis>network boot</emphasis> - (dramatically faster boot time, 
      but requires PXE capable network card on the client, and requires mucking 
      about with the BIOS to tell it to boot off the network)
     </para>
    </listitem>
   </orderedlist>
   <para>
    Search this document for <command>makeautoinstallcd</command> and 
    <command>makeautoinstalldiskette</command> for more information.
   </para>
  </sect2>

  <sect2 id=FAQHowClientKnowRightImage>
   <title>How does an autoinstall client know which image to install?</title>
   <para>
    In order to better understand the answer, let me lead up to it with the 
    steps the autoinstall client goes through:
   </para>
   <orderedlist>
    <listitem>
     <para>
      Boots off the autoinstallmedia
     </para>
    </listitem>
    <listitem>
     <para>
      Gets an IP address from DHCP
     </para>
    </listitem>
    <listitem>
     <para>
      Determines the IP address of the image server via DHCP
     </para>
    </listitem>
    <listitem>
     <para>
      Requests a hosts file from the image server
     </para>
    </listitem>
    <listitem>
     <para>
      Finds its hostname in the hosts file based on its IP address
     </para>
    </listitem>
    <listitem>
     <para>
      Requests a script from the image server based on its hostname
      (for example: <command>www237.sh</command>)
     </para>
    </listitem>
    <listitem>
     <para>
      Executes this script
     </para>
    </listitem>
   </orderedlist>
   <para>
    The script in question is typically a soft link pointing at the 
    <filename>$image.master</filename> script that was dynamically created when 
    you ran <command>getimage</command>.  This script explicitly states which image to pull 
    from the image server.  Open it up and take a look!
   </para>
   <para>
    These scripts and the <filename>$image.master</filename> script can be 
    found in <filename>/tftpboot/systemimager</filename>.
   </para>
  </sect2>

  <sect2 id=FAQUpgrade>
   <title>How do I upgrade to a new version?</title>
   <para>
    If you installed VA SystemImager as of 1.0 or later, you can simply 
    install the new version on top.
   </para>
   <para>
    If you last installed a pre-1.0 version then the comments below still apply.
   </para>
   <para>
    VA SystemImager is still changing dynamically, so you can't simply 
    install a new version on top of an old one.  Depending on the version 
    changes, this may work for you, but it is not guaranteed.  If you want 
    to try this method, please check with the <filename>CHANGE.LOG</filename> 
    document to find out what has changed.
   </para>
   <para>
    Currently the recommended method is to move your images directory out of 
    the systemimager directory hierarchy, back up your 
    <filename> /etc/rsyncd.conf</filename> file and any other configuration 
    files you may have changed.  Then install VA SystemImager as if you were 
    installing it for the first time, after which you can move your images 
    directory and <filename>/etc/rsyncd.conf</filename> file back.
   </para>
  </sect2>

  <sect2 id=FAQAutoInstallError>
   <title>When making the autoinstalldiskette, my system gives me an error 
    involving "dd" or "mount".</title>
   <para>
    You are using a pre v0.19 version of VA SystemImager.  Please download the 
    latest version from <ulink url="http://systemimager.org/"></ulink>.
   </para>
   <para>
    If you must use a pre v0.19 version for some reason, be sure that your 
    kernel has "ramdisk" support.  Or that you have ramdisk support with a 
    module.  If you are using a module, be sure that it is loaded with the 
    <command>modprobe</command> command.
   </para>
   <para>
    But it's probably easier to just get the latest version...
   </para>
  </sect2>

  <sect2 id=FAQDHCPFailed>
   <title>My autoinstall client booted up and said "dhcp didn't work", but 
    when I do an ifconfig eth0 it has an IP address.  What happened?</title>
   <para>
    Are you using a pre 1.0 version of VA SystemImager?  If so, please upgrade.
   </para>
   <para>
    If for some reason you can't upgrade, then:
   </para>
   <para>
    Are you connected to a switch?  Most switches will wait a period of time
    (usually 30 seconds) after a connected system's interface has come up 
    before transmitting on that port. Newer versions of the autoinstalldiskette
    bring the ethernet interface up and wait 45 seconds or so before making a 
    dhcp request.  It will then wait 35 seconds or so to give the system time 
    to receive an address.  You could be using an autoinstalldiskette that 
    does not wait the proper time for your switch and is giving up before it 
    should.
   </para>
   <para>
    Be sure that you are using the latest version of VA SystemImager and that 
    you are using the autoinstalldiskette image that comes with that version.  
    Note that the version numbers may not match.  See the 
    <filename>VERSION</filename> file.
   </para>
  </sect2>

  <sect2 id=FAQAutoinstallFail>
   <title>My client failed to autoinstall, and when I run an <command>rsync 
    </command>command on it manually it takes forever for the image server to 
    respond.</title>
   <para>
    Be sure that the image server can look up the client's hostname based on its
    IP address.  The easiest way to do this is to have entry in the 
    image server's <filename>/etc/hosts</filename> file for the client system.
   </para>
  </sect2>

  <sect2 id=FAQStaticIP>
   <title>But I want to assign static IPs to my clients!</title>
   <para>
    You can!  <command>getimage</command> will ask you if you want to assing static IPs.
   </para>
  </sect2>

  <sect2 id=FAQDHCPStatic>
   <title>I want to use DHCP to assign static IPs to my clients, but I don't 
    want to have to manually enter my 1000 mac addresses.  What can I do?
   </title>
   <para>
    VA SystemImager comes with the <command>makedhcpstatic</command> utility.  
    As you boot your client systems, the DHCP server will assign addresses 
    sequentially.  By initially booting your systems in the order you want 
    them to receive their IP addresses, you can ensure that they get the IP 
    address you want them to have.  
   </para>
   <para>
    After booting your systems, run <command>makedhcpstatic</command>.  It 
    will re-write your <filename>/etc/dhcpd.conf</filename> file associating 
    each clients MAC address with its host name.  You should then restart your 
    dhcpd daemon.  Subsequently, each time your clients request an IP address 
    via DHCP, the will always be assigned their appropriate static IP address.
   </para>
   <para>
    Note:  The client's hostname is used, instead of an explicit IP address, 
    so that you simply have to change the <filename>hosts</filename> file on 
    the DHCP server (or DNS, NIS, etc.) to change the IP address that that 
    client recieves.
   </para>
   <para>
    Note:  Static IP addresses, assigned by DHCP, are the author's preferred 
    method for administering IP on a large number of systems, if static IP 
    addresses are actually required.
   </para>
  </sect2>

  <sect2 id=FAQPerformance>
   <title>What kind of performance can I expect?</title>
   <para>
    Here are some unofficial numbers that I came up with.  Your experience may
    be quite different based on the speed of your network, the performance of
    your image server and clients, and the size of the image.
   </para>
   <para>
    If you can send me statistics from your experience, I'll add them below.
   </para>

   <table frame="all">
    <title>VA SystemImager Performance Statistics</title>
        <tgroup cols="4">
          <colspec colname="column1">
          <colspec colname="column2">
          <colspec colname="column3">
          <colspec colname="column4">
          <colspec colname="column5">
            <thead>
             <row>
              <entry>Size of Image</entry>
              <entry>Clients</entry>
              <entry>Network Type</entry>
              <entry>Switched</entry>
              <entry>Elapsed Time</entry>
             </row>
            </thead>
            <tbody>
             <row><entry>2.5 GB</entry><entry>21</entry><entry>100BaseTx</entry><entry>yes</entry><entry>1.5 Hours</entry></row>
             <row><entry>1.5 GB</entry><entry>20</entry><entry>100BaseTx</entry><entry>yes</entry><entry>.5 Hours</entry></row>
            </tbody>
        </tgroup>
   </table>
  </sect2>

  <sect2 id=FAQUpdateImage>
   <title>How do I update an image on the image server?</title>
   <para>
    There are two ways to update an image on the image server:
   </para>
   <orderedlist>
    <listitem>
     <para>
      Make the changes to one of your clients and run the 
      <command>getimage</command> again.  
     </para>
     <para>
     - You can specify the same image name, in which case the current image
       will be updated (only changes are pulled across).
     </para>
     <para>
     - Or you can specify a new image name and have a form of revision control.
       (This is by far the recommended method)
     </para>
     <para>
      Note:  Every time <command>getimage</command> is run, it will recreate 
      the <filename>$image.master</filename> script.  If you have customized 
      your <filename>$image.master</filename> script, be sure to save it before 
      running <command>getimage</command> again.
     </para>
    </listitem>

    <listitem>
     <para>
      Modify the files directly.  You can simply cd into the appropriate image
      directory and edit the files there, or (recommended) you can <command>cd 
      </command>into the image directory and run <command>'chroot . sh'</command>.
      This will change your working root directory to the root of the image you 
      want to manipulate.  You can then run <command>rpm</command> command and 
      other commands on the image and not have to worry about getting 
      confused and damaging the image server.  When you are done, simply type 
      <command>exit</command> and you will be returned to your normal shell.
     </para>
    </listitem>
   </orderedlist>
  </sect2>

  <sect2 id=FAQUpdate2Match>
   <title>How do I update a client to match an image?</title>
   <para>
    Once you have updated an image on the image server, you can then update 
    your clients to reflect this new or modified image.  (It is not necessary 
    to do a complete re-autoinstall.)  You will find the command,
    <command>updateclient</command>, on your clients.  This command takes as 
    its parameters the name of the image server and the name of the image that 
    you want to update the client to.  Run <command>updateclient -help</command>
    to get more information about this command.
   </para>
   <para>
    If you use the revision control method recommended in "How do I update an
    image on the image server?" FAQ, then you will be able to bring your 
    production environment back to a known state (by doing an 
    <command>updateclient</command> to the last working image) after having 
    done an <command>updateclient</command> to a not quite so thoroughly 
    tested image.
   </para>
   <para>
    The file <filename>/etc/systemimager.exclude</filename> on your clients is 
    used to exclude files and directories from being updated by the 
    <command>updateclient</command> command.  Please take a look at this file 
    and modify it to suit your local environment.
   </para>
  </sect2>

  <sect2 id=FAQExclude>
   <title>What is <filename>systemimager.exclude</filename> used for?</title>
   <para>
    It is used by the <command>updateclient</command> command.  See the 
    section, "How do I update a client to match an image?", for more 
    information.
   </para>
  </sect2>

  <sect2 id=FAQBuildNewFrontEnd>
   <title>How do I build a new "front-end" server?</title>
   <para>
    Another way of stating the question or a slight variation may be as 
    follows. We are in the process of building a new "front-end" server for 
    our Linux cluster.  We'd like to try using VA SystemImager as our node 
    cloning software if possible.
   </para>
   <para>
    I've read through the VA SystemImager FAQ and found the following:
    <blockquote> 
     <para>
     All of the clients for a particular image should have an identical
     hardware configuration.  They should at least have the same hard
     drive(s) and the same ethernet card(s).
     </para>
    </blockquote> 
   </para>
   <para>
    This is a problem since our front-end which the image will be captured 
    from has a SCSI hard drive and a Gigabit ethernet card.  Our 64 compute 
    nodes on the other hand have IDE disk drives and fast ethernet cards.  
   </para>
   <para>
    Are we out of luck?
   </para>
   <para>
    Nope.  Just a little customization ahead of you...
   </para>
   <para>
    Once you have done your <command>getimage</command> you will need to 
    edit the <filename>conf.modules</filename> in the image on the image server 
    to load the appropriate module for your ethernet card.
   </para>
   <para>
   <command>vi /var/spool/systemimager/images/$imagename/etc/conf.modules</command>
   </para>
   <para>
    I believe your entry will look like this:
   </para>
   <para>
    <programlisting>
     alias eth0 tulip
    </programlisting>
   </para>
   <para>
    You will need to edit the fstab file in the image:
   </para>
   <para>
   <command>vi /var/spool/systemimager/images/$imagename/etc/fstab"</command>
   </para>
   <para>
    Be sure it says <filename>/dev/hdaN</filename> instead of 
    <filename>/dev/sdaN</filename>.
   </para>
   <para>
    You will need to specify the partition information in the
    <filename>$imagename.master</filename> script that was created when you 
    did your <command>getimage</command>.
   </para>
   <para>
    <command>vi /var/spool/systemimager/installstuff/$imagename.master</command>
   </para>
   <para>
   You will find a section that looks like this:
   </para>
   <para>
    <programlisting>
# Here's an example of how to customize a disk:
# start at the beginning 0, give 20M /dev/sda1 for /boot, assume partition type 83
# start where left off, 512M /dev/sda2 for swap, partition type 82
# start where left off, give the rest of the disk to /dev/sda3 for /, assume partition type 83
#sfdisk -uM /dev/sda &lt;&lt;EOF
#0,20
#,512,82
#,
#;
#EOF

Uncomment the lines from sfdisk down to EOF (EOF must be flush left)
and change the values to specify your partitions according to the
example.

If you don't want to have to think so much, then you can simply do
the following command on a client that is already partitioned correctly:

"sfdisk -d /dev/hda" (Assuming you only have one disk and that disk is /dev/hda.)
    </programlisting>
   </para>
   <para>
    Then copy the output into the <filename>$install.master</filename> script 
    and delete the existing entries for the SCSI disk.
   </para>
   <para>
    Search the <filename>$imagename.master</filename> script for all entries 
    of your old drive <filename>/dev/sda</filename> and be sure that they are 
    changed to the appropriate drive <filename>/dev/hda</filename>.  This 
    will be for the <command>mke2fs</command> and <command>mkswap</command> 
    sections.
   </para>
   <para>
    Proceed as normal.
   </para>
  </sect2>

  <sect2 id=FAQLeaveDisks>
   <title>How do I edit the scripts so only the FIRST disk is sfdisk'ed? I MUST
    leave the other disks alone.</title>
   <para>
    After you run <command>prepareclient</command>, look in the 
    <filename>/etc/partitionschemes</filename>
    directory on that client.  You will find a file that has the partition
    information for each of that clients disks.  Simply delete all except
    for the primary disk.
   </para>
   <para>
    Now you can do your <command>getimage</command> and everything else like 
    normal.
   </para>
   <para>
    The only other thing to verify is that the <filename>fstab</filename> 
    file in the image has no entries for the other disks.
   </para>
   <para>
    <command>vi /var/spool/systemimager/images/$imagename/etc/fstab</command>
   </para>
  </sect2>

  <sect2 id=FAQUpdateSmallSet>
   <title>How can I use VA SystemImager to update a small set of files? For 
   instance, I apply a security patch and I want all boxes to reflect 
   that change.</title>
   <para>
    This is accomplished with the <command>updateclient</command> command on 
    the client.
   </para>
   <para>
   <orderedlist>
    <listitem>
     <para>
      Choose one of the following methods to update the image on the server:
      <orderedlist>
       <listitem>
        <para>
         apply the patch to the image directly
        </para>
       </listitem>
       <listitem>
        <para>
         apply the patch to a client and then do another getimage
         specifying the same imagename (won't take long and will
         update the image).
        </para>
       </listitem>
       <listitem>
        <para>
         apply the patch to a client and then do another getimage
         specifying a _different_ imagename.  This is preferred as it
         allows for revision control.
        </para>
       </listitem>
      </orderedlist>
     </para>
    </listitem>

    <listitem>
     <para>
      Run <command>updateclient</command> on the clients that you want to update.     
      Execute <command>updateclient -help</command> to get the syntax.
     </para>
    </listitem>
   </orderedlist>

   </para>
  </sect2>
  <sect2 id=FAQLogFile>
   <title>Is there a log file where autoinstall client status is kept?</title>
   <para>
    Yes.  <filename>/var/log/systemimager</filename>
   </para>
  </sect2>

  <sect2 id=FAQBaseOn>
   <title>What other software is this based on?</title>
   <para>
    VA SystemImager is based on <filename>rsync(1)</filename> and also makes 
    use of <filename>syslinux(2)</filename> and <filename>pxelinux(3)
    </filename>. Versions 0.23 and earlier made use of <filename>tomsrtbt(4)
    </filename>.
   </para>
  </sect2>
 </sect1>

 <glossary>
  <title>SystemImager Glossary</title>
  <glossentry>
   <glossterm>addclients</glossterm>
   <glossdef>
    <para>
     Tells your image server which image to install on your
     autoinstall clients.  It does so by creating soft links to the 
     master autoinstall script with the name of each host that will 
     receive that image.  It also allows you to populate the /etc/hosts 
     file with sequential host names and IP addresses.  This information
     in <filename>/etc/hosts</filename> is necessary for certain SystemImager
     operations.
    </para>
   </glossdef>
  </glossentry>
  <glossentry>
   <glossterm>autoinstall media</glossterm>
   <glossdef>
    <para>
     The media that is used to boot an autoinstall client in order to begin
     the autoinstall process.  This media can be a floppy, a CDROM, the
     network, or the local hard drive of the autoinstall client.
    </para>
   </glossdef>
  </glossentry>
  <glossentry>
   <glossterm>autoinstall script</glossterm>
   <glossdef>
    <para>
     A unique autoinstall script is created for each 
     image and is used by the autoinstall client as part of the autoinstall
     process.  The names of autoinstall scripts begin with the image name 
     and end in .master.  For example:
     <filename>my_webserver_image_v1.master</filename>
    </para>
   </glossdef>
  </glossentry>
  <glossentry>
   <glossterm>
    <ulink url="http://www.dictionary.com/cgi-bin/dict.pl?term=daemon">
     daemon
    </ulink>
   </glossterm>
   <glossdef>
    <para>
     This is not specifically a SystemImager term, but it really
     bugs me when people pronounce this word as "daymen".  It is just
     another, more interesting, less evil appearing way of spelling demon.
     And just to be clear, in computer terms, a daemon is a program that
     lies in wait for something to trigger it into action.  An example of
     this is a web server daemon waiting for someone to request a web page.
    </para>
   </glossdef>
  </glossentry>
  <glossentry>
   <glossterm>getimage</glossterm>
   <glossdef>
    <para>
     This command is run from the image server to pull a system
     image from a golden client.
    </para>
   </glossdef>
  </glossentry>
  <glossentry>
   <glossterm>golden client</glossterm>
   <glossdef>
    <para>
     A machine from which an image is taken.  Golden clients
     are manually installed and customized to taste.
    </para>
   </glossdef>
  </glossentry>
  <glossentry>
   <glossterm>image server</glossterm>
   <glossdef>
    <para>The machine that will hold and distribute the images.</para>
   </glossdef>
  </glossentry>
  <glossentry>
   <glossterm>local.cfg</glossterm>
   <glossdef>
    <para>
     A configuration file that can be used for autoinstall clients
     in lieu of DHCP and the /tftpboot/systemimager/hosts file on the image
     server.
    </para>
   </glossdef>
  </glossentry>
  <glossentry>
   <glossterm>makedhcpserver</glossterm>
   <glossdef>
    <para>
     An easy way to create a <application>SystemImager</application>
     appropriate <filename>/etc/dhcpd.conf</filename> file.  DHCP can be
     used to assign IP addresses to autoinstall clients.
    </para>
   </glossdef>
  </glossentry>
  <glossentry>
   <glossterm>makedhcpstatic</glossterm>
   <glossdef>
    <para>
     Used to modify the <filename>/etc/dhcpd.conf</filename> file, adding 
     static entries for autoinstall clients based on the IP addresses 
     handed out to these clients by the DHCP server.
    </para>
   </glossdef>
  </glossentry>
  <glossentry>
   <glossterm>prepareclient</glossterm>
   <glossdef>
    <para>
     This command is run on the golden client immediately 
     prior to running getimage on the image server.
    </para>
   </glossdef>
  </glossentry>
  <glossentry>
   <glossterm>updateclient</glossterm>
   <glossdef>
    <para>
     A command that is executed on client systems allowing them 
     to be updated or synchronized to a new or updated image after the
     initial autoinstall.  updateclient enables software and content
     distribution.
    </para>
   </glossdef>
  </glossentry>
 </glossary>
</article>
