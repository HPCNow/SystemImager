#!/usr/bin/perl -w
#
#  "SystemImager"
#
#  Copyright (C) 1999-2004 Andrea Righi <a.righi@cineca.it>

# set version number
my $VERSION = "SYSTEMIMAGER_VERSION_STRING";
my $program_name = "si_monitortk";

use lib "USR_PREFIX/lib/systemimager/perl";
use strict;
use Tk;
use Tk::Label;
use Tk::Balloon;
use Tk::HList;
use Tk::ItemStyle;
use Tk::widgets qw/Dialog ErrorDialog/;
use Fcntl ':flock';
use XML::Simple;
use Getopt::Long qw(:config no_ignore_case bundling);

my $version_info = << "EOF";
$program_name\n(part of SystemImager) v$VERSION

Copyright (C) 2005 Andrea Righi <a.righi\@cineca.it>
This is free software; see the source for copying conditions.  There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
EOF

my $get_help = "\n       Try \"--help\" for more options.";

my $help_info = $version_info . <<"EOF";

Usage: $program_name [OPTION]... -db DATABASENAME

Options: (options can be presented in any order and may be abbreviated)
 --help                 Display this output.

 --version              Display version and copyright information.

 --db DATABASENAME      Get clients informations from the XML file
                        DATABASENAME. This file is generated and
                        updated by the si_monitor daemon.

 --refresh RATE         Set the refresh rate (in sec).

Download, report bugs, and make suggestions at:
http://systemimager.org/
EOF

my $CONFDIR = '/etc/systemimager';

# load resources
my %conf;
my $conffile = "$CONFDIR/$program_name";
if (-r $conffile) {
    Config::Simple->import_from($conffile, \%conf);
}

# Only lock directory is needed.
$conf{'lock_dir'} ||= "/var/lock/systemimager";
die "No such lock directory '$conf{'lock_dir'}'\n"
    if (! -d $conf{'lock_dir'});

my ($help, $version, $quiet, $database, $refresh_rate); 
GetOptions(
        "help"          => \$help,
        "version"       => \$version,
        "db=s"          => \$database,
        "refresh=i"          => \$refresh_rate,
) or die "$help_info";

if ($help) {
	print "$help_info";
	exit(0);
}

if ($version) {
	print "$version_info";
	exit(0);
}

# Database argument is mandatory.
unless ($database) {
        die "\n$program_name: --db DATABASENAME must be specified.\n$get_help\n\n";
} else {
        # Create the database if it doesn't exist.
        unless (-f $database) {
                open(DB, '>', "$database") or
                        die "error: cannot open file \"$database\" for writing!\n";
                close(DB);
        }
}

# Set the refresh rate.
unless ($refresh_rate) {
	$refresh_rate = 5000;
} else {
	$refresh_rate *= 1000;
}

# Define lock files.
my $lock_file = $conf{'lock_dir'} . "/db.si_monitor.lock";

# Graphic stuff.
my ($window, $tab, $timer, $status_bar);

# Create the main window.
$window = MainWindow->new();
$window->title($program_name);
$window->configure(-menu => my $menubar = $window->Menu);
$window->gridRowconfigure(0, -weight => 1);
$window->gridColumnconfigure(0, -weight => 1);

# Use this font.
my $FONT = '-*-Helvetica-Bold-R-Normal--*-120-*-*-*-*-*-*';

# Create the menu bar.
my $file_menu = $menubar->cascade(qw/-label File -underline 0 -menuitems/ => [
	[command => '~Refresh', -command => [\&start_refresh]],
	[command => '~Stop refresh', -command => [\&stop_refresh]],
	'',
	[command => '~Quit', -command => [\&exit]],
]);
my $help_menu = $menubar->cascade(qw/-label Help -underline 0 -menuitems/ => [
	[command => '~About'],
]);
my $DIALOG_ABOUT = $window->Dialog(
	-title          => "About $program_name",
	-bitmap		=> 'info',
	-default_button => 'OK',
	-buttons        => ['OK'],
	-text           => "$version_info",
	-font		=> $FONT,
);
$help_menu->cget(-menu)->entryconfigure('About',
	-command => [$DIALOG_ABOUT => 'Show'],
);

# Define the status bar format.
$status_bar = $window->Label(
	-relief => "sunken", 
	-bd => 1, 
	-anchor => 'sw'
);

# Define the balloon structure.
my $b = $window->Balloon(-statusbar => $status_bar);

# Create the table of nodes status.
$tab = $window->Scrolled(
	'HList',
	-header		=> 1,
	-columns	=> 8,
	-scrollbars	=> 'se',
	-width		=> 100,
	-height		=> 25,
	-selectmode	=> 'browse',
	-selectbackground => 'yellow',
)->grid(qw/-sticky nsew/);

# Create the header.
$tab->header('create', 0, -text => 'MAC address'); 
$tab->header('create', 1, -text => 'IP address'); 
$tab->header('create', 2, -text => 'Hostname'); 
$tab->header('create', 3, -text => 'RAM (MB)'); 
$tab->header('create', 4, -text => 'RAM used'); 
$tab->header('create', 5, -text => 'Time (min)'); 
$tab->header('create', 6, -text => 'Status    '); 
$tab->header('create', 7, -text => 'CPU'); 

# Show the body.
display_nodes();

# Define status bar messages.
$b->attach($tab,
	-statusmsg  => "Status of the nodes",
);

# Display command buttons.
show_command_buttons();

# Main loop.
start_refresh();
MainLoop;

# Well done.
exit(0);

# Usage:
# show_command_buttons(); 
# Description:
#	Display the command buttons panel.
sub show_command_buttons
{
	# Define buttons.
	my $buttons = $window->Frame;
	my $start_refresh_button = $buttons->Button(
		-text      => 'Refresh',
		-underline => 0,
		-command   => [\&start_refresh],
		-pady      => 5,
		-padx      => 5,
	);
	my $stop_refresh_button = $buttons->Button(
		-text      => 'Stop refresh',
		-underline => 0,
		-command   => [\&stop_refresh],
		-pady      => 5,
		-padx      => 5,
	);
	my $quit_button = $buttons->Button(
		-text      => 'Quit',
		-command   => [\&exit],
		-underline => 0,
		-pady      => 5,
		-padx      => 5,
	);
	$buttons->grid(qw/-pady 2m -sticky ew/);
	$buttons->gridColumnconfigure(qw/0 -weight 1/);
	$buttons->gridColumnconfigure(qw/1 -weight 1/);
	$buttons->gridColumnconfigure(qw/2 -weight 1/);
	$start_refresh_button->grid(qw/-row 0 -column 0/);
	$stop_refresh_button->grid(qw/-row 0 -column 1/);
	$quit_button->grid(qw/-row 0 -column 2/);

	# Bind hot-keys to buttons.
	$window->bind("<Alt-r>", sub {$start_refresh_button->invoke;});
	$window->bind("<Alt-s>", sub {$stop_refresh_button->invoke;});
	$window->bind("<Alt-q>", sub {$quit_button->invoke;});

	# Define status bar messages.
	$b->attach($start_refresh_button,
		-statusmsg  => "Start or continue to refresh the status of the nodes",
	);
	$b->attach($stop_refresh_button,
		-statusmsg  => "Stop to refresh the status of the nodes",
	);
	$b->attach($quit_button,
		-statusmsg  => "Quit program",
	);
	
	# Draw status bar.
	$status_bar->grid("-", "-", -sticky => "nesw");
}

# Usage:
# display_nodes(); 
# Description:
#	Fill the main list with the status of all nodes.
sub display_nodes
{
	# If database is empty simply quit.
	return unless (-s $database);

	# Open and read lock the database.
	open(LOCK, ">", "$lock_file") or
		die "error: cannot open lock file \"$lock_file\"!\n";
	flock(LOCK, LOCK_SH);
	
	# Parse XML database.
	my $xml = XMLin($database, KeyAttr => {client => 'name'}, ForceArray => 1);

	# Close and unlock database.
	flock(LOCK, LOCK_UN);
	close(LOCK);

	# Display DB entries.
	my $client = $xml->{'client'};
	foreach my $mac (sort(keys(%{$client}))) {
		# Create the entry.
		my $row = $tab->addchild('');

		# Evaluate the status.
		my $fg;
		my $status = $client->{$mac}->{'status'} || 0;
		if (!$status) {
			$status = 'init';
			$fg = '#0000FF';
		} elsif ($status < 0) {
			$status = 'error!';
			$fg = '#FF0000';
		} elsif ($status == 100) {
			$status = 'done';
			$fg = '#009000';
		} elsif (($status > 0) && ($status < 100)) {
			$status = sprintf('%.2f%%', $status);
			$fg = '#000000';
		} else {
			$status = '???';
			$fg = 'darkgrey';
		}

		# Define the style to display this entry.
		my $style = $tab->ItemStyle('text');
		$style->configure(
			-foreground => $fg,
			-font       => $FONT,
		);
		# Display the node identity.
		$tab->itemCreate(
			$row,
			0,
			-itemtype => 'text',
			-style    => $style,
			-text     => $mac,
		);
		# Display node attributes.
		my @attrs = qw/ip host mem tmpfs time status cpu/;
		for (0 .. $#attrs) {
			if ($attrs[$_] eq 'status') {
				# Display node status.
				$tab->itemCreate(
					$row,
					$_ + 1,
					-itemtype => 'text',
					-style    => $style,
					-text     => $status,
				);
			} else {
				# Display a generic attribute.
				$tab->itemCreate(
					$row,
					$_ + 1,
					-itemtype => 'text',
					-style    => $style,
					-text     => $client->{$mac}->{$attrs[$_]},
				);
			}
		}
	}
}

# Usage:
# refresh();
# Description:
#	Refresh the client label.
sub refresh
{
	$tab->delete('all');
	display_nodes();
}

# Usage:
# start_refresh();
# Description:
#	Begin to refresh the nodes view.
sub start_refresh
{
	# Refresh nodes visualization.
	$timer = Tk::After->new($window, $refresh_rate, 'repeat', \&refresh);
}

# Usage:
# stop_refresh();
# Description:
#	Stop to refresh the nodes view.
sub stop_refresh
{
	# Stop to refresh nodes view.
	$timer->cancel();
}

__END__

=head1 NAME

si_monitortk - systemimager monitor Tk-based GUI

=head1 SYNOPSIS

si_monitortk [OPTIONS]... --db DATABASENAME 

=head1 DESCRIPTION

Report a list of all the clients with a detailed real time
status of their installation.

The B<si_monitortk> is a perl-Tk user interface. It does not collect
directly the client informations, but simply gets that informations
in a file generated and updated by the B<si_monitor> daemon.

This file is defined by the B<--db DATABASENAME> option.

=head1 OPTIONS

=over 8

=item B<--help>

Display a short help.

=item B<--version>

Display version and copyright information.

=item B<--db DATABASENAME>

Perform a periodical polling to the B<DATABASENAME> where B<si_monitor>
stores the clients informations and the current status of the installation
process.

This file is created and kept updated by the B<si_monitor> daemon, so
to use this interface probably you need to start first the B<si_monitor>
daemon.

The option B<--db DATABASENAME> is mandatory.

=item B<--refresh RATE>

If specified this options sets a different refresh rate for the clients
informations displayed in the GUI. This sets the period (in sec) between
two different accesses to the B<DATABASENAME> XML file.

The default value is 5 seconds.

=head1 SEE ALSO

systemimager(8), si_monitor(1)

=head1 AUTHOR

Andrea Righi <a.righi@cineca.it>.

=head1 COPYRIGHT AND LICENSE

Copyright 2003 by Andrea Righi <a.righi@cineca.it>.

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

=cut

