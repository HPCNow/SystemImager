#!/usr/bin/perl -w
#
#   "SystemImager"
#
#   Copyright (C) 2003 Bald Guy Software 
#                      Brian Elliott Finley <brian@bgsw.net>
#
#   $Id$
#

use lib "USR_PREFIX/lib/systemimager/perl";
use strict;
use File::stat;
use POSIX qw(setsid);
use SystemImager::Config;
use SystemImager::Flamethrower;
use vars qw($config $ft_config $VERSION);

my $last_time = 0;
my $conf_file = '/etc/systemimager/flamethrower.conf';
my $pid_file  = "/var/run/flamethrower.pid";
my $state_dir = "/var/state/flamethrower";

$0 = "flamethrowerd";

# Set to 1 to produce debug output
my $debug = 1;
print "debug output turned on\n" if($debug);

# Read the config file
read_config_file($conf_file);

# Should we start up?
if ( $ft_config->start_flamethrower_daemon() ne "yes" ) {
    exit 0;
}

# Create our directory directory, if necessary.
my $dir = $ft_config->get("flamethrower_directory_dir");
if ( ! -e $dir ) {
    mkdir("$dir", 0755) or die("Couddn't mkdir $dir!");
}
unlink <$dir/*>;

# Create our state directory, if necessary, and clean it up.
$dir = $ft_config->get("flamethrower_state_dir");
if ( ! -e $dir ) {
    mkdir("$dir", 0755) or die("Couddn't mkdir $dir!");
}
unlink <$dir/*>;

&update_directory;
&daemonize;

while(1) {
    &main;
    sleep 2;    #XXX change to something like 5 for production
                # 2 gives more interesting output for testing.
}

exit 0;


################################################################################
#
# BEGIN subroutines 
#

# Usage: update_directory();
sub update_directory {

    print STDOUT "update_directory()\n" if ($debug);

    my $flamethrower_directory_dir = $ft_config->get("flamethrower_directory_dir");
    unlink <$flamethrower_directory_dir/*>;

    ############################################################################
    #
    # Get list of explicitly specified portbase numbers so we don't 
    # dynamically use one that already exists.
    #
    my %portbases = $ft_config->varlist('_portbase$');
    foreach (values %portbases) {
        #
        # Make the values the keys, so we can simply to an 
        # if (defined()) in the module loop below.
        #
        $portbases{$_} = $_;
    }

    # Be sure to include the flamethrower_directory port.
    $_ = $ft_config->get("flamethrower_directory_port");
    $portbases{$_} = $_;

    #
    ############################################################################

    ############################################################################
    #
    # Create the Flamethrower "directory" (sourceable files) for each module.
    #
    my $modules = $ft_config->modules();
    foreach my $module ( @$modules ) {

        #
        # Put directory information that is useful to clients in
        # sourceable files.
        #
        my $file = $flamethrower_directory_dir . "/" . $module;
        open(FILE, ">$file") or die("Couldn't open $file for writing!");

            print FILE "MODULE=$module\n";
            
            # DIR
            if ( ! defined($ft_config->get("${module}_dir")) ) {
                die("Please set DIR in flamethrower.conf for [$module]!");
            }
            
            # PORTBASE
            my $portbase;
            if ($ft_config->varlist("${module}_portbase")) {
                
                # portbase is already set
                $portbase = $ft_config->get("${module}_portbase");

            } else {
            
                # Start with flamethrower_directory_port + 2.
                $portbase = $ft_config->get("flamethrower_directory_port") + 2;
            
                # If that port is already in use, increment by two until we
                # get a free one.
                while ( defined($portbases{$portbase}) ) {
                    $portbase += 2;
                }
            
                # Add our new portbase to the existing list.
                $portbases{$portbase} = $portbase;
            
            }
            print FILE "PORTBASE=$portbase\n";

            # ASYNC
            my $async;
            if ($ft_config->varlist("${module}_async")) {
                # async is already set
                $async = $ft_config->get("${module}_async");
            } else {
                # get it from global setting
                $async = $ft_config->get("async");
            }
            print FILE "ASYNC=$async\n";

            # TTL
            my $ttl;
            if ($ft_config->varlist("${module}_ttl")) {
                # ttl is already set
                $ttl = $ft_config->get("${module}_ttl");
            } else {
                # get it from global setting
                $ttl = $ft_config->get("ttl");
            }
            print FILE "TTL=$ttl\n";

            # MCAST_ALL_ADDR
            my $mcast_all_addr;
            if ($ft_config->varlist("${module}_mcast_all_addr")) {
                # mcast_all_addr is already set
                $mcast_all_addr = $ft_config->get("${module}_mcast_all_addr");
            } else {
                # get it from global setting
                if ($ft_config->varlist("^mcast_all_addr")) {
                    $mcast_all_addr = $ft_config->get("mcast_all_addr");
                }
            }
            print FILE "MCAST_ALL_ADDR=$mcast_all_addr\n" if ($mcast_all_addr);


        close(FILE);

    }
    #
    ############################################################################
}

# Usage: main();
sub main {
    print STDOUT "main()\n" if($debug); 
    if(conf_file_updated($conf_file)) {
        read_config_file($conf_file);
        update_directory();
    }
    my $modules = $ft_config->modules();
    foreach my $module ( @$modules ) {
        my $file = $state_dir . "/" . $module;
        unless(-e "$file") {
            print "    touch($file)\n" if($debug);
            touch($file);
                        # In case this happens to get started *immediately* 
            sleep 1;    # after the cast() function does it's unlink, give 
                        # the child time to die.
            cast($module, $file);
        }
    }
}

# Usage: touch($file);
sub touch {
    my $file = shift;
    open(FILE, ">$file") or die("Couldn't touch $file!");
    close(FILE);
}

# Usage: cast($module, $file);
sub cast {

    my $module = shift;
    my $file = shift;

    print STDOUT "cast()\n" if($debug);
    
    # Fork and cast
    my $pid;
    if ($pid = fork) {
    } elsif (defined $pid) { # send the forked child off

        setsid or die "Can't start a new session: $!";

        $0 = "flamethrowerd-$module";

        #fork cast of module
        print STDOUT "    casting $module\n" if($debug);
        sleep length($module);  # Install actual casting stuff here -- sleep just for testing
        print STDOUT "    unlinking $file\n" if($debug);
        unlink($file) or die("Couldn't remove $file!\n");
        #sleep 5;    #XXX remove for production
        exit 0;

    } else {
        die "Can't fork: $!\n";
    }

}

# Usage: read_config_file($file);
sub read_config_file {
    my $file = shift;
    SystemImager::Flamethrower->read_config($file) or die("Couldn't read $file!");
}

# Usage: if(conf_file_updated($conf_file)) {};
sub conf_file_updated {

    my $file = shift;
    #print STDOUT "conf_file_updated($file)\n" if ($debug);

    my $st = stat($file);
    my $this_time = $st->ctime;

    if($this_time ne $last_time) {
        print STDOUT "    $file updated\n" if($debug);
        $last_time = $this_time;
        return 1;
    }
    return undef;
}

# Usage: $SIG{CHLD} = \&REAPER;
sub REAPER {
    $SIG{CHLD} = \&REAPER;
    my $waitedpid = wait;
    print STDERR "    Dead child: $waitedpid\n" if($debug);
}

# Usage: &daemonize;
sub daemonize {

    chdir '/'                  or die "Can't chdir to /: $!";
    open STDIN, '/dev/null'    or die "Can't read /dev/null: $!";
    open STDOUT, '>>/dev/null' or die "Can't write to /dev/null: $!" unless($debug);
    open STDERR, '>>/dev/null' or die "Can't write to /dev/null: $!" unless($debug);
    defined(my $pid = fork)    or die "Can't fork: $!";
    exit if $pid;
    setsid                     or die "Can't start a new session: $!";

    my $file = $pid_file;
    local *FILE;
    open(FILE,">$file") or die ("FATAL: Can't open file: $file\n");
        print FILE "$$\n";
    close(FILE);

    $SIG{CHLD} = \&REAPER;
}

# Usage: fork_caster($module);
sub fork_caster {
    my $pid;
    if ($pid = fork) {
    } elsif (defined $pid) { # send the forked child off
    
        setsid or die "Can't start a new session: $!";
    
        my $file = $pid_file;
        local *FILE;
        open(FILE,">$file") or die ("FATAL: Can't open file: $file\n");
            print FILE "$$\n";
        close(FILE);
    
        # Subroutine(s) here
        main();
    
    } else {
            die "Can't fork: $!\n";
    }
}

#
# END subroutines
#
################################################################################

