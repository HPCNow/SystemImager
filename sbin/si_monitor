#!/usr/bin/perl -w
#
#  "SystemImager"
#
#  Copyright (C) 1999-2004 Andrea Righi <a.righi@cineca.it>

use lib "USR_PREFIX/lib/systemimager/perl";
use strict;
use Fcntl ':flock';
use Socket;
use XML::Simple;
use Getopt::Long;
use SystemImager::Options;
use SystemImager::Config;
use vars qw($config $VERSION);
use constant DEFAULT_PORT => 8181;

my $VERSION = "SYSTEMIMAGER_VERSION_STRING";
my $program_name = "si_monitord";
my $version_info = << "EOF";
$program_name (part of SystemImager) v$VERSION

Copyright (C) 1999-2001 Andrea Righi <a.righi\@cineca.it>
This is free software; see the source for copying conditions.  There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
EOF

my $get_help = "\n       Try \"--help\" for more options.";

my $help_info = $version_info . <<"EOF";

Usage: $program_name [OPTION]... -db DATABASENAME

Options: (options can be presented in any order and may be abbreviated)
 --help                 Display this output.

 --version              Display version and copyright information.

 --db DATABASENAME      Where DATABASENAME is the name of the file
                        where clients informations will be stored.
                        (All the data in this file will be stored in
                        XML format).

 --port PORT            The port used by $program_name for listening
                        client connections (the default port is 8181).

 --log LOGFILE          If specified every log information will be
                        reported in the file LOGFILE.

Download, report bugs, and make suggestions at:
http://systemimager.org/
EOF

my $CONFDIR = '/etc/systemimager';

# load resources
my %conf;
my $conffile = "$CONFDIR/$program_name";
if (-r $conffile) {
    Config::Simple->import_from($conffile, \%conf);
}

# Only lock directory is needed.
$conf{'lock_dir'} ||= "/var/lock/systemimager";
die "No such lock directory '$conf{'lock_dir'}'\n"
    if (! -d $conf{'lock_dir'});

my ($help, $version, $quiet, $port, $database, $log_file);
GetOptions(
	"help"		=> \$help,
	"version"	=> \$version,
	"quiet"		=> \$quiet,
	"port=s"	=> \$port,
	"db=s"		=> \$database,
	"log=s"		=> \$log_file,
) or die "$help_info";

### BEGIN evaluate commad line options ###
if ($help) {
	print "$help_info";
	exit(0);
}

if ($version) {
	print "$version_info";
	exit(0);
}

# Database argument is mandatory.
unless ($database) {
	die "\n$program_name: --db DATABASENAME must be specified.\n$get_help\n\n";
} else {
	# Create the database if it doesn't exist.
	unless (-f $database) {
		open(DB, '>', "$database") or 
			die "error: cannot open file \"$database\" for writing!\n";
		close(DB);
	}
}

# Get the port to listen. 
unless ($port) {
	$port = DEFAULT_PORT;
}

# Get monitor log file.
if ($log_file) {
	open(LOG, ">>$log_file") or 
		die "error: cannot open log file \"$log_file\" for writing!\n";
}
### END evaluate command line options ###

# Define lock files.
my $lock_file = $conf{'lock_dir'} . "/db.si_monitor.lock";

# Remove old locks.
unlink("$lock_file");

# Use TCP protocol;
my $proto = getprotobyname('tcp');

# Open the socket.
socket(IN, PF_INET, SOCK_STREAM, $proto) or 
	die "error: could not create the socket: $!\n";
setsockopt(IN, SOL_SOCKET, SO_REUSEADDR, 1);
my $client_addr = sockaddr_in($port, INADDR_ANY);
bind(IN, $client_addr) or 
	die "error: could not bind to port $port : $!\n";
listen(IN, SOMAXCONN) or 
	die "error: could not listen on port $port : $!\n";

# Begin to accept client connections.
while (accept(CLIENT, IN)) {
	my $pid = fork();
	if ($pid) {
		close(CLIENT);
		next;
	}
	my $other_end = getpeername(CLIENT);
	if ($other_end) {
		# Get client informations.
		# TODO allow only authorized hosts... -AR-
		my ($other_port, $other_iaddr) = unpack_sockaddr_in($other_end);
		my $other_ip_address = inet_ntoa($other_iaddr);
		my $other_host = gethostbyaddr($other_iaddr, AF_INET);

		# Report info in the log if defined.
		print LOG gmtime() . 
			": connection accepted for ${other_host}:${other_port}\n"
			if ($log_file);
	
		# Get the client request.
		$_ = <CLIENT>; chomp;

		# Report the request in the log.
		print LOG gmtime() . 
			": ${other_host} request -> $_\n"
			if ($log_file);

		# Update the database.
		update_db($other_host, $_);

		# Close client connection.
		close(CLIENT);
	} else {
		close(CLIENT);
		print LOG gmtime() . 
			": warning: could not identify other end of a client request, ignoring.\n"
			if ($log_file);
	}
	exit(0);
}

die "error: cannot accept clients connections!\n";

# Usage:
# update_db($hostname, $client_request);
# Description:
#	Update the database according to the client request.
sub update_db
{
	my ($host, $request) = @_;
	my ($client, $mac);

	# Parse the client request.
	my @args = split(/:/, $request);
	foreach (@args) {
		if (s/^mac=//) {
			$mac = $_;
		} elsif (s/^ip=//) {
			$client->{'ip'} = $_;
		} elsif (s/^host=//) {
			$client->{'host'} = $_;
		} elsif (s/^cpu=//) {
			$client->{'cpu'} = $_;
		} elsif (s/^mem=//) {
			$client->{'mem'} = int($_ / 1024);
		} elsif (s/^tmpfs=//) {
			$client->{'tmpfs'} = $_;
		} elsif (s/^time=//) {
			$client->{'time'} = int($_ / 60);
		} elsif (s/^status=//) {
			$client->{'status'} = $_;
		}
	}

	# Check if mac address has been specified.
	unless(defined($mac)) {
		print LOG gmtime() . ": warning: bad request from $host (mac address not specified)!\n"
			if ($log_file);
		return;
	}
	
	open(LOCK, ">", "$lock_file") or 
		die "error: cannot open lock file \"$lock_file\"!\n";
	flock(LOCK, LOCK_EX);
	
	# Open database in mutual exclusion.
	open(DB, '<', $database) or 
		die "error: cannot open \"$database\" for reading!\n";
	
	# Parse XML database.
	my $xml;
	if (-s $database) {
		$xml = XMLin($database, KeyAttr => {client => 'name'}, ForceArray => 1);
	}
	close(DB);
	
	# Update the clients table.
	$xml->{'client'}->{$mac}->{'ip'} = $client->{'ip'}
		if $client->{'ip'};
	$xml->{'client'}->{$mac}->{'host'} = $client->{'host'}
		if $client->{'host'};
	$xml->{'client'}->{$mac}->{'cpu'} = $client->{'cpu'}
		if $client->{'cpu'};
	$xml->{'client'}->{$mac}->{'mem'} = $client->{'mem'}
		if $client->{'mem'};
	$xml->{'client'}->{$mac}->{'tmpfs'} = $client->{'tmpfs'}
		if $client->{'tmpfs'};
	$xml->{'client'}->{$mac}->{'time'} = $client->{'time'}
		|| 0;
	$xml->{'client'}->{$mac}->{'status'} = $client->{'status'}
		|| 0;
	
	open(DB, '>', $database) or
		die "error: cannot open \"$database\" for writing!\n";
	
	# Sync the database.
	print DB XMLout($xml); 

	# Close and unlock database.
	close(DB);
	flock(LOCK, LOCK_UN);
	close(LOCK);
}

__END__

=head1 NAME

si_monitor - systemimager real time monitoring daemon

=head1 SYNOPSIS

si_monitor [OPTIONS]... --db DATABASENAME 

=head1 DESCRIPTION

B<si_monitor> is a tool to perform real-time monitoring
of the clients installation status.
It listen to a specific port and collects informations
periodically sent by clients using plain TCP/IP connections.

All these informations are stored in a XML database, defined with the
options B<--db DATABASENAME>.

=head1 OPTIONS

=over 8

=item B<--help>

Display a short help.

=item B<--version>

Display version and copyright information.

=item B<--db DATABASENAME>

An XML file to store all the informations collected by the
si_monitor daemon. If you run this command for the first time
the file will be initialized to an empty file.

The option B<--db DATABASENAME> is mandatory.

=item B<--port PORT>

The port used by the si_monitor daemon for listening clients
connections.

The default port is 8181.

=item B<--log LOGFILE>

If this option is used every kind of information will be
reported in the file LOGFILE.
This option can be useful to debug clients connections.

=head1 SEE ALSO

systemimager(8), si_monitortk(1)

=head1 AUTHOR

Andrea Righi <a.righi@cineca.it>.

=head1 COPYRIGHT AND LICENSE

Copyright 2003 by Andrea Righi <a.righi@cineca.it>.

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

=cut

