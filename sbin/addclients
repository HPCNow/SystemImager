#!/usr/bin/perl -w

#
# "VA SystemImager" - Copyright (C) 1999-2000 Brian Elliott Finley <brian@valinux.com>
#
# This file is: addclients
#

### BEGIN Subroutines ###
sub get_response {
 my $garbage_out=$_[0];
 my $garbage_in=<STDIN>;
 chomp $garbage_in;
 unless($garbage_in eq "") { $garbage_out = $garbage_in; }
 return $garbage_out;
}

sub dec2bin {
  my $str = unpack("B32", pack("N", shift));
  return $str;
}

sub dec2bin8bit {
  my $str = unpack("B32", pack("N", shift));
  $str = substr($str, -8); # 32bit number -- get last 8 bits (the relevant ones)
  return $str;
}

sub bin2dec {
  return unpack("N", pack("B32", substr("0" x 32 . shift, -32))); # get all 32bits
}

sub ip_quad2ip_dec {
    (my $a, my $b, my $c, my $d) = split(/\./, $_[0]);
    my $a_bin=dec2bin8bit($a);
    my $b_bin=dec2bin8bit($b);
    my $c_bin=dec2bin8bit($c);
    my $d_bin=dec2bin8bit($d);
    return bin2dec(join('', $a_bin, $b_bin, $c_bin, $d_bin));
}

sub ip_dec2ip_quad {
    my $ip_bin = dec2bin($_[0]);
    my $a_dec = bin2dec(substr($ip_bin, 0, 8));
    my $b_dec = bin2dec(substr($ip_bin, 8, 8));
    my $c_dec = bin2dec(substr($ip_bin, 16, 8));
    my $d_dec = bin2dec(substr($ip_bin, 24, 8));
    return join('.', $a_dec, $b_dec, $c_dec, $d_dec);
}

sub numerically { 
    $a <=> $b;
}
### END Subroutines ###

### BEGIN Program ###
# if not run as root this script will surely fail
unless($< == 0) { die "Must be run as root!\n"; }

# give warning
system("clear");
print << 'EOF';

Welcome to the VA SystemImager "addclients" utility  
---------------------------------------------------

This utility has 3 sections.  


"Section 1" will ask you for your hostname information.


"Section 2" will allow you to create softlinks from each
client hostname to your "master" script in the
"/tftpboot/systemimager/" directory.  

Example: www297.sh -> web_server_image_v1.master


"Section 3" will ask you for IP address information that will
be combined with the hostname information provided in Section 1
to create entries in "/etc/hosts" for each of these same clients.
New entries will be appended to the end of "/etc/hosts".  If you 
specify new hostnames for existing IP addresses, those entries 
will be re-written in place to reflect the new host names.


EOF

print "Continue? ([y]/n): ";
$continue=<STDIN>;
chomp $continue;
$continue = lc $continue;
($continue ne "n") or die "\naddclients: No files were modified.\n";

### BEGIN main questionnaire ###

$image="";
$domain_name="";
$base_host_name="";
$starting_number="";
$ending_number="";

$satisfied = "n";
while ($satisfied ne "y") {
 system("clear");

print <<EOF;
addclients -- Section 1 (hostname information)
----------------------------------------------

The next series of questions will be used to create a range
of hostnames.  You will be asked for your domain name, the 
base host name, a beginning number, and an ending number.

For example, if you answer:
  domain name     = systemimager.org
  base host name  = www
  starting number = 7
  ending number   = 11

Then the result will be a series of hostnames that looks like this:
  www7.systemimager.org
  www8.systemimager.org
  www9.systemimager.org
  www10.systemimager.org
  www11.systemimager.org


EOF

 print "What is your domain name? [$domain_name]: ";
 $domain_name=get_response($domain_name);
 $domain_name = lc $domain_name;

 print "What is the base host name that you want me to use? [$base_host_name]: ";
 $base_host_name = get_response($base_host_name);
 $base_host_name = lc $base_host_name;

 print "What number should I begin with? [$starting_number]: ";
 # "+ 0" is to ensure we have a flat number and not "001" or something
 $starting_number = get_response($starting_number) + 0; 

 print "What number should I end with? [$ending_number]: ";
 # "+ 0" is to ensure we have a flat number and not "001" or something
 $ending_number=get_response($ending_number) + 0;

 print "\n\n";
 print "I will work with hostnames:  $base_host_name$starting_number through $base_host_name$ending_number\n"; 
 print "             in the domain:  $domain_name\n";
 print "\nAre you satisfied? (y/[n]): ";
 chomp($satisfied=<STDIN>);
}
### END main questionnaire ###

### BEGIN links questionaire ###
system("clear");

print <<"EOF";
addclients -- Section 2 (soft links to master script)
-----------------------------------------------------

Would you like me to create soft links to a "master" script so
that hosts:

  $base_host_name$starting_number through $base_host_name$ending_number

EOF

print "can be autoinstalled with that image? ([y]/n): ";
$createlinks=<STDIN>;
chomp $createlinks;
$createlinks = lc $createlinks;

unless($createlinks eq "n") {
  $satisfied="n";
  while ($satisfied eq "n") {
    # gather a list of available images
    @files = ();
    opendir ( DIR, "/tftpboot/systemimager" );
    @files = grep { /\.master$/ } readdir (DIR);
    closedir (DIR);

    # display the list of available images
    unless(@files) { die "There are no available images.  Please use getimage to retrieve an image first.\n   -The Mgmt\n"; }
    print qq(\nHere is a list of available images:\n);
    while (<@files>) {
      $_ =~ s/\.master//g;
      print "$_\n";
      $image = $_;
    }
    print qq(\n);

    print "Which image would you like these hosts to receive? [$image]: ";
    $image=get_response($image);
    if ( -f "/tftpboot/systemimager/$image.master" ) {
      foreach $node_number ($starting_number .. $ending_number) {
        system("cd /tftpboot/systemimager; ln -sf $image.master $base_host_name$node_number.sh");
      }
      print "\nYour soft links have been created.\n";
      print "\nPress <Enter> to continue...";
      $satisfied="y";
      <STDIN>;
      system("clear");
    } else {
      print qq(\nImage \"$image\" does not exist...\n);
      print qq(Let's try again, shall we?\n);
      print qq(\nPress <Enter> to continue...);
      $satisfied="n";
      <STDIN>;
      system("clear");
    }
  }
} else {
  print "\nNo links will be created.\n";
  print "\nPress <Enter> to continue...";
  <STDIN>;
}
### END links questionaire ###

### BEGIN hosts questionaire ###
system("clear");
print <<EOF;
addclients -- Section 3 (adding or modifying /etc/hosts entries)
----------------------------------------------------------------

It is necessary to have an entry for each client in "/etc/hosts".

I will ask you for your clients' IP addresses one subnet at a time.


EOF

print "Would you like me to make these entries for you? ([y]/n): ";

$etc_hosts=<STDIN>;
chomp $etc_hosts;
$etc_hosts = lc $etc_hosts;
if($etc_hosts ne "n") {$etc_hosts = "y";}

$node_number = $starting_number;

if($etc_hosts eq "y") {

$subnet_count="0";

  ### BEGIN One Subnet at a time ###
  while ( $node_number <= $ending_number ) {
  $subnet_count = $subnet_count + 1;

    $starting_ip="";
    $ending_ip="";

    ### get IP information ###
    # ne "y" is used instead of eq "n" because the dissatisfied response may be something other than "n".
    $satisfied="n";
    while ($satisfied ne "y") {
    system("clear");
print <<EOF;
addclients -- Section 3 (adding or modifying /etc/hosts entries -- continued...)
--------------------------------------------------------------------------------
EOF
      print "subnet $subnet_count\n\n";
      print "The first host in subnet $subnet_count will be: $base_host_name$node_number\n";
      print "What is the starting IP address for subnet $subnet_count? [$starting_ip]: ";
      $starting_ip = get_response($starting_ip);
      $starting_ip_dec = ip_quad2ip_dec($starting_ip);
    
      print "What is the ending IP address? [$ending_ip]: ";
      $ending_ip = get_response($ending_ip);
      $ending_ip_dec = ip_quad2ip_dec($ending_ip);
    
      print "I will work with IP addresses:  $starting_ip through $ending_ip\n";
      print "\nAre you satisfied? (y/[n]): ";
      chomp($satisfied=<STDIN>);
    }
    ### get IP information ###

    ### read in /etc/hosts and create a hash of lines by ip address and a hash of lines by number
    %etc_hosts_lines_by_ip = ();
    %etc_hosts_lines_by_number = ();
    my $line_number = "1";

    open(ETC_HOSTS, "< /etc/hosts") or die "Couldn't open /etc/hosts for reading: $!\n";
    while (<ETC_HOSTS>) {
      chomp;
      my @fields = split;
      my $ip_quad = $fields[0];
      my $line = $_;
      if ($ip_quad) {
        $etc_hosts_lines_by_ip{$ip_quad} = $line;
      }
      $etc_hosts_lines_by_number{$line_number} = $line;
      $line_number = $line_number + 1;
    }
    close(ETC_HOSTS);
    ### read in /etc/hosts and create a hash of lines by ip address and a hash of lines by number
    
    ### create a hash of new hostnames by ip address 
    %new_hostnames_by_ip = ();
    $ip_dec = $starting_ip_dec;
    until ( $ip_dec > $ending_ip_dec ) {
      my $bitwise = $ip_dec & 255;
      if ( $bitwise == "255" ) { $ip_dec = $ip_dec + 2; }
      my $ip_quad = ip_dec2ip_quad($ip_dec);
      $new_hostnames_by_ip{$ip_quad} = "$base_host_name$node_number";
      $ip_dec = $ip_dec + 1;
      $node_number = $node_number + 1;
      if ( $node_number > $ending_number ) { last; }
    }
    ### create a hash of new hostnames by ip address 

    ### munge new ips and hostname info into %etc_hosts_lines_by_ip
    my @new_ip_addresses = keys %new_hostnames_by_ip;
    foreach my $new_ip_address (@new_ip_addresses) {
        $etc_hosts_lines_by_ip{$new_ip_address} = "$new_ip_address    $new_hostnames_by_ip{$new_ip_address}.$domain_name  $new_hostnames_by_ip{$new_ip_address}";
    }
    ### munge new ips and hostname info into %etc_hosts_lines_by_ip

    ### open temporary /etc/hosts for writing
    $temp_file = "/tmp/.hosts.systemimager";
    open(NEW_ETC_HOSTS, "> $temp_file") or die "Couldn't open $temp_file for writing: $!\n";
    ### open temporary /etc/hosts for writing

    ### replace entries as necessary in numbered /etc/hosts lines and print numbered lines
    foreach my $line_number ( sort numerically ( keys %etc_hosts_lines_by_number )) {
        $_ = $etc_hosts_lines_by_number{$line_number};
        my @words = split;
        my $ip_quad = $words[0];
        if ($ip_quad) {
            $etc_hosts_lines_by_number{$line_number} = $etc_hosts_lines_by_ip{$ip_quad};
            delete $etc_hosts_lines_by_ip{$ip_quad};
        }
        # print numbered hosts entries
        print NEW_ETC_HOSTS "$etc_hosts_lines_by_number{$line_number}\n";
    }
    ### replace entries as necessary in numbered /etc/hosts lines and print numbered lines

    ### create hash of entries by decimal ip (for sorting purposes)
    %etc_hosts_lines_by_ip_decimal = ();
    foreach my $ip_quad ( keys %etc_hosts_lines_by_ip ) {
        $ip_decimal = ip_quad2ip_dec($ip_quad);
        $etc_hosts_lines_by_ip_decimal{$ip_decimal} = $etc_hosts_lines_by_ip{$ip_quad};
    }
    ### create hash of entries by decimal ip (for sorting purposes)

    ### print remaining entries
    print NEW_ETC_HOSTS "\n";
    foreach my $ip_decimal ( sort( keys %etc_hosts_lines_by_ip_decimal )) {
        print NEW_ETC_HOSTS "$etc_hosts_lines_by_ip_decimal{$ip_decimal}\n";
    }
    ### print remaining entries

    ### close temporary /etc/hosts after writing
    close(NEW_ETC_HOSTS);
    ### close temporary /etc/hosts after writing

    ### move new hosts file in to place
    system('mv', '-f', $temp_file, '/etc/hosts');
    if($? != 0) { die "Couldn't move $temp_file to /etc/hosts!\n", "Is the filesystem that contains /etc/ full?"; }
    ### move new hosts file in to place

    ### copy /etc/hosts to /tftpboot/systemimager/hosts to be sure it stays up to date
    system('cp', '-f', '/etc/hosts', '/tftpboot/systemimager/hosts');
    if($? != 0) { die "Couldn't copy /etc/hosts to /tftpboot/systemimager/hosts!\n", "Does /etc/tftpboot/systemimager/ exist?"; }
    ### copy /etc/hosts to /tftpboot/systemimager/hosts to be sure it stays up to date
  }
  ### END One Subnet at a time ###
  if ( $etc_hosts eq "y" ) { print "\nThese entries have been added to /etc/hosts.\n"; }
  print "\nPress <Enter> to continue...";
  <STDIN>;

} else {
  print "\nNo entries will be added.";
}
### END hosts questionaire ###
