#!/usr/bin/perl -w

#
# "SystemImager" - Copyright (C) 1999-2001 Brian Elliott Finley <brian@systemimager.org>
#
#   Others who have contributed to this code (in alphabetical order):
#     Phil Champon <pchampon@valueweb.net>
#     Sean Dague <sean@dague.net>
#     Ian McLeod <ian@valinux.com>
#     James Oakley <joakley@solutioninc.com>
#     Laurence Sherzer <lsherzer@gate.net>
#     Wesley Smith <wessmith@engr.sgi.com>
#     Curtis Zinzilieta <czinzilieta@valinux.com>
#
# This file is: getimage 
#

# set system path for system() calls
$ENV{PATH} = "/usr/sbin:/sbin:/usr/bin:/bin";

# version
$version_number="1.5.0";

# systemimager configuration directory
$systemimagerdir="/etc/systemimager";

# miscellaneous variables and what not
# NIS domain name will be figured out automatically (if it exists)
$nisdomainname="";

# use the long options module to allow us to use, well, long options ;)
use lib "/var/lib/systemimager/perl";
use SystemImager::Server;
use SystemImager::Common;
use Getopt::Long;
use AppConfig;

### BEGIN parse the config file ###

my $config = AppConfig->new(
			    'autoinstalldir' => { ARGCOUNT => 1 },
			    'default_imagedir' => { ARGCOUNT => 1 },
			    'rsyncd_conf' => { ARGCOUNT => 1 },
			    'autoinstall_kernel' => { ARGCOUNT => 1 },
			    'autoinstall_initrd' => { ARGCOUNT => 1 }
			    );
$config->file('/etc/systemimager/config');

my $autoinstalldir = $config->autoinstalldir();
my $rsyncd_conf = $config->rsyncd_conf();
my $default_imagedir = $config->default_imagedir();

if (!$autoinstalldir) { die "AUTOINSTALLDIR not defined in the config file."; }
if (!$rsyncd_conf) { die "RSYNCD_CONF not defined in the config file."; }
if (!$default_imagedir) { die "DEFAULT_IMAGEDIR not defined in the config file."; }

### END parse the config file

### BEGIN Subroutines ###

sub get_response {
    my $garbage_out=$_[0];
    my $garbage_in=<STDIN>;
    chomp $garbage_in;
    unless($garbage_in eq "") { $garbage_out = $garbage_in; }
    return $garbage_out;
}

sub check_if_root{
    unless($< == 0) { die "$program_name: Must be run as root!\n"; }
}

### END Subroutines ###

### BEGIN Program ###

# figure out the program name
$0  =~ /(.*)\/+([^\/]*)$/;
$program_name = $2;

$version_info = <<"EOF";
$program_name (part of SystemImager) v$version_number

Copyright (C) 1999-2001 Brian Elliott Finley <brian\@systemimager.org>
This is free software; see the source for copying conditions.  There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
EOF

$get_help = "          Try \"$program_name -help\" for more options.";
$help_info = $version_info . <<"EOF";

Usage: $program_name [OPTION]...  -golden-client HOSTNAME -image IMAGENAME

Options: (options can be presented in any order and may be abbreviated)

 -help                    Display this output.

 -version                 Display version and copyright information.

 -golden-client HOSTNAME  Hostname or IP address of the \"golden\" client.

 -image IMAGENAME         Where IMAGENAME is the name to assign to the 
                          image you are retrieving.  This can be either
                          the name of a new image if you want to create
                          a new image, or the name of an exisiting image
                          if you want to update an image.  

 -ssh-user USERNAME       Username for ssh connection to the client.
                          Only needed if a secure connection is required.

 -log "STRING"		  Quoted string for log file format.  See the
			  rsyncd.conf man page for options.

 -quiet                   Don\'t ask any questions or print any output
                          (other than errors). In this mode, no warning
                          will be given if the image already exists on
                          the server.

 -directory PATH          The full path and directory name where you want
                          this image to be stored.  The directory bearing
                          the image name itself will be placed inside the
                          directory specified here.

 -exclude PATH            Don\'t pull the contents of PATH from the 
                          golden client.  PATH must be absolute (starting 
			  with a "/").  
			  
			  To exclude a single file use:
			   -exclude /directoryname/filename

                          To exclude a directory and it's contents use:
                           -exclude /directoryname/

			  To exclude the contents of a directory, but
			  pull the directory itself use:
			   -exclude "/directoryname/*"

 -exclude-file FILE       Don\'t pull the PATHs specified in FILE from the
                          golden client.

 -update-script [YES|NO]  Update the \$image.master script?  Defaults to 
                          NO if -quiet.  If not specified you will be
                          prompted to confirm an update.


The following options affect the autoinstall client after autoinstalling:

 -ip-assignment METHOD    Where METHOD can be:

                          static_dhcp -- A DHCP server will assign the
			    same static address each time to clients 
			    installed with this image.  Also see the
			    \"makedhcpstatic\" command.

			  dynamic_dhcp -- A DHCP server will assign IP
			    addresses dynamically to clients installed
			    with this image.  They may be assigned a
			    different address each time.

                          static -- The IP address the client uses
			    during autoinstall will be permanently
			    assigned to that client.

			  replicant -- Don\'t mess with the network
			    settings in this image.  I\'m using it as a
			    backup and quick restore mechanism for a 
			    single machine.

 -post-install ACTION     ACTION can be:

                          beep -- Clients will beep incessantly after 
			    succussful completion of an autoinstall.

			  reboot -- Clients will reboot themselves
			    after successful completion of an 
			    autoinstall.

			  shutdown -- Clients will halt themselves
			    after successful completion of an 
			    autoinstall.


Download, report bugs, and make suggestions at:
http://systemimager.org/
EOF
    

$golden_client = "";
$imageserver = "";
$ip_assignment_method = "";
$image = "";
$exclude = "";
$exclude_file = "";
$update_script = "";
$post_install = "beep"; # the default

### BEGIN evaluate options ###
GetOptions( 
    "golden-client=s" => \$golden_client,
    "server=s" => \$imageserver,
    "image=s" => \$image,
    "directory=s" => \$default_imagedir,
    "ip-assignment=s" => \$ip_assignment_method,
    "exclude=s" => \$exclude,
    "exclude-file=s" => \$exclude_file,
    "update-script=s" => \$update_script,
    "post-install=s" => \$post_install,
    "ssh-user=s" => \$ssh_user,
    "log=s" => \$log,
    "help" => \$help,
    "version" => \$version,
    "quiet" => \$quiet
) || die "$help_info";

$ip_assignment_method = lc $ip_assignment_method;
$update_script = lc $update_script;

#if requested, print help information
if ($help) { 
  print "$help_info";
  exit 0;
}

# if requested, print version and copyright information
if ($version) {
  print "$version_info";
  exit 0;
}

if($imageserver){
  die "\n$program_name: -server is now depricated.  Try cpimage command instead.\n$get_help\n\n";
}

# be sure $golden_client name doesn't start with a hyphen
if ($golden_client) {
  if ($golden_client =~ /^-/) { 
    die "\n$program_name: Golden client name can't start with a hyphen.\n$get_help\n\n";
  }
  $source_host = $golden_client;
}

# both a source host and image must be set.
unless ($source_host and $image) {
    die "\n$program_name: You must specify -golden-client and -image.\n$get_help\n\n";
}


# be sure $image doesn't start with a hyphen
if($image){
  if ($image =~ /^-/) { 
    die "\n$program_name: Image name can't start with a hyphen.\n$get_help\n\n";
  }
}

# be sure $default_imagedir is an absolute path starting with /
unless ($default_imagedir =~ /^\//) { 
  die "\n$program_name: -directory must be an absolute path starting with \"/\".\n$get_help\n\n";
}

# be sure $exclude is an absolute path starting with /
if($exclude){
  unless($exclude =~ /^\//){ 
    die "\n$program_name: -exclude must be an absolute path starting with \"/\".\n$get_help\n\n";
  }
}

# be sure $update_script was passed a proper option
unless(
       ($update_script eq ""   )
    or ($update_script eq "yes")
    or ($update_script eq "no" )
) { die "\n$program_name: -update-script must be yes or no.\n$get_help\n\n"; }

# be sure $ip_assignment_method was passed a proper option
unless(
    ($ip_assignment_method eq "")
    or ($ip_assignment_method eq "static_dhcp")
    or ($ip_assignment_method eq "dynamic_dhcp")
    or ($ip_assignment_method eq "static")
    or ($ip_assignment_method eq "replicant")
) { die "\n$program_name: -ip-assignment must be static, static_dhcp, or dynamic_dhcp.\n$get_help\n\n"; }

# be sure $post_install was passed a proper option
unless(
       ($post_install eq "beep")
    or ($post_install eq "reboot")
    or ($post_install eq "shutdown")
) { die "\n$program_name: -post-install must be beep, reboot, or shutdown.\n$get_help\n\n"; }

# only golden client or server may be set
if ($exclude and $exclude_file) {
  die "\n$program_name: Either use -exclude or -exclude-file but not both.\n$get_help\n\n";
}

# if -exclude-file is used, exclude file must exist
if ($exclude_file) {
  unless(-e $exclude_file){
    die "\n$program_name: I can\'t find the exclude file specified by -exclude-file!\n$get_help\n\n";
  }
}
### END evaluate options ###

# be sure program is run by root
check_if_root();

# fill in variables based on options passed
$master_script = $autoinstalldir . "/systemimager/$image.master";
$final_exclude_file = "/tmp/.exclude.$image";
$imagedir = "$default_imagedir/$image";

$warning =  <<"EOF";
This program will get the \"$image\" system image from \"$source_host\"
making the assumption that all filesystems considered part
of the system image are using ext2, ext3, or reiserfs.

This program will not get /proc, NFS, or other filesystems
not mentioned above.

See \"getimage -help\" for command line options.

EOF

# give warning
if (!$quiet) {
    system("clear");
    print $warning;
    print "Continue? ([y]/n): ";
    $continue = get_response('y');
    ($continue ne "n") or die "$program_name: No files were modified.\n";
    print "\n";
}

if (! -d "$default_imagedir")  {
  mkdir("$default_imagedir", 0750) or die "$program_name: Can't make directory $default_imagedir\n";
}

if (-d "$imagedir") {
  if (!$quiet) {
    print "An image named \"$image\" already exists...\n";
    print "Update exisiting image? ([y]/n): ";
    $continue = get_response('y');
    ($continue ne "n") or die "$program_name: No files were modified.\n";
    print "\n";
  }
} else  {
    mkdir("$imagedir", 0777) || 
	die "$program_name: Can't make directory $imagedir\n";
}

# Set default rsync port number
$port="873";

# If we're using SSH, go ahead and establish port forwarding
if($ssh_user) {
  # Get a random port number (normal rsync port won't work if rsync daemon is running)
  my $port_in_use="yes";
  until ( $port_in_use eq "no" )
  {
    $port_in_use="no";
    $port = rand 60000;
    $port =~ s/\..*//;

    # Be sure port isn't reserved
    $file="/etc/services";
    open (FILE, "<$file") || die ("$0: Couldn't open $file for reading\n");
      while (<FILE>) {
        if (/$port/) { 
          $port_in_use="yes";
          next;
        }
      }
    close FILE;
  
    # Be sure port isn't in use
    open (NETSTAT, "netstat -tn |");
    while (<NETSTAT>) {
      (my $junk, my $port_and_junk) = split (/:/);
      if ($port_and_junk) { 
        (my $netstat_port, my $other_junk) = split (/ +/, $port_and_junk);
        if ($netstat_port = /$port/) { 
          $port_in_use="yes";
          next;
        }
      }
    }
  }

  # Setup the port forwarding
  $command="ssh -f -l $ssh_user -L $port:$source_host:873 $source_host sleep 5";
  $rc = 0xffff & system($command);
  if ($rc != 0) { 
    print "FATAL: Failed to establish secure port forwarding to $source_host!\n";
    die   "       Be sure that you can run \"ssh -l $ssh_user $source_host\" successfully.\n";
  }

  # and change the source host to point to localhost so we can use the port forwarding
  $source_host="127.0.0.1";
}


### BEGIN golden client stuff ###
if($source_host) {
  # get /etc/systemimager/mounted_filesystems from $source_host
  if (!$quiet) {
    print "Retrieving /etc/systemimager/mounted_filesystems from $source_host to check for mounted filesystems...\n";

    my $directory="${imagedir}/etc/";
    unless (-d "$directory") { mkdir("$directory", 0755) || die "$program_name: Can't make directory $directory\n"; }

    $directory="${imagedir}/etc/systemimager/";
    unless (-d "$directory") { mkdir("$directory", 0755) || die "$program_name: Can't make directory $directory\n"; }

    $command = "rsync -av --numeric-ids";
    if ($log) { $command = $command . qq( --log-format="$log"); }
    if ($ssh_user) { $command = $command . " --bwlimit=10000"; }
    $command =  $command . " rsync://${source_host}:${port}/root/etc/systemimager/mounted_filesystems ${imagedir}/etc/systemimager/mounted_filesystems";

    open(RSYNC, "$command|");
    print "------------- $source_host mounted_filesystems RETRIEVAL PROGRESS -------------\n";
    while (<RSYNC>) {
      print;
    }
    print "------------- $source_host mounted_filesystems RETRIEVAL FINISHED -------------\n";
    close(RSYNC);
  } else {

    $directory="${imagedir}/etc/";
    unless (-d "$directory") { mkdir("$directory", 0755) || die "$program_name: Can't make directory $directory\n"; }

    $directory="${imagedir}/etc/systemimager/";
    unless (-d "$directory") { mkdir("$directory", 0755) || die "$program_name: Can't make directory $directory\n"; }

    $command = "rsync -a --numeric-ids";
    if ($log) { $command = $command . qq( --log-format="$log"); }
    if ($ssh_user) { $command = $command . " --bwlimit=10000"; }
    $command = $command . " rsync://${source_host}:${port}/root/etc/systemimager/mounted_filesystems ${imagedir}/etc/systemimager/mounted_filesystems";

    system($command);
  }
  
  # $? is the return value from rsync
  if ($?) {
    print "Failed to retrieve /etc/systemimager/mounted_filesystems from $source_host.\n";
    print "$program_name: Have you run \"prepareclient\" on $source_host?\n";
    print "          If you see the message \"unrecognised option\" above, check\n";
    print "          http://systemimager.org/download/ to be sure that you are running\n";
    die   "          the recommended version of rsync.\n";
  }
  
  # create list of filesystems to *not* get
  $file="${imagedir}/etc/systemimager/mounted_filesystems";
  open (FILE, "<$file") || die ("$program_name: Couldn't open $file for reading!\n");
    @mounted_filesystems = <FILE>;
  close FILE;

  $file="$final_exclude_file";
  open (FINAL_EXCLUDE_FILE, ">$file") || die "$program_name: Couldn't open $file for writing!\n";
    @mounted_filesystems = grep (!/\s+ext2\s+/, @mounted_filesystems);
    @mounted_filesystems = grep (!/\s+ext3\s+/, @mounted_filesystems);
    @mounted_filesystems = grep (!/\s+reiserfs\s+/, @mounted_filesystems);
    print FINAL_EXCLUDE_FILE "\n# Automatic exclusions made by SystemImager.\n";
    foreach (@mounted_filesystems) {
      /\S+\s+\S+\s+(\S+)\s+/;
      my $mount_point=$1;
      print FINAL_EXCLUDE_FILE "$mount_point/*\n";
    }
    if($exclude) { 
      print FINAL_EXCLUDE_FILE "\n# Exclusions from -exclude on the command line.\n";
      print FINAL_EXCLUDE_FILE "$exclude\n";
    }
    if($exclude_file) { 
      print FINAL_EXCLUDE_FILE "\n# Exclusions from -exclude-file.\n";
      $file="$exclude_file";
      open (EXCLUDE_FILE, "<$file") || die "$program_name: Couldn't open $file for reading!\n";
        while(<EXCLUDE_FILE>){
          print FINAL_EXCLUDE_FILE "$_\n";
	}
      close EXCLUDE_FILE;
    }
  close FINAL_EXCLUDE_FILE;

  # compile rsync options
  $options = "--delete --delete-excluded --exclude-from=$final_exclude_file";
  if ($log) { $options = $options . qq( --log-format="$log"); }
  if ($ssh_user) { $options = $options . " --bwlimit=10000"; }
  $options = $options . " rsync://${source_host}:${port}/root/ $imagedir";
}
### END golden client stuff ###

### BEGIN generic image retrieval stuff ###
# Get the image from the specified host
if (!$quiet) {
    print "\n\nRetrieving image $image from $source_host\n";
    open (RSYNC, "rsync -av --numeric-ids $options |");
    print "------------- $image IMAGE RETRIEVAL PROGRESS -------------\n";
    while (<RSYNC>) {
        print $_;
    }
    print "------------- $image IMAGE RETRIEVAL FINISHED -------------\n";
    close (RSYNC);
} else {
    $command = qq(rsync -a --numeric-ids $options);
    system($command);
}

# $? is the return value from rsync
if ($?) {
    die "$program_name: Failed to retrieve image $image from $source_host.\n";
}


if(!$quiet) {
    print "\nPress <Enter> to continue...";
    <STDIN>;
}

unlink $final_exclude_file || die "$program_name: Removal of file $final_exclude_file failed\n";

# Add entry to image server's rsyncd.conf if necessary
open (RSYNCD_CONF, "<$rsyncd_conf");
if (!grep(/\[$image\]/, <RSYNCD_CONF>)) {
    open(RSYNCD_CONF, ">>$rsyncd_conf") || die "$program_name: Cannot open $rsyncd_conf for writing";
    print RSYNCD_CONF <<"EOF";
[$image]
    path = $imagedir
	    
EOF
};
close(RSYNCD_CONF);
### END generic image retrieval stuff ###


### BEGIN Overwrite $image.master? ###
if( (!$quiet) and (!$update_script) and (-e $autoinstalldir . "/systemimager/$image.master") ) {
    system("clear");
    print "Update Autoinstall Script?\n";
    print "--------------------------\n\n";
    print "An autoinstall script for this image already exists.  It is recommended\n";
    print "that you update this autoinstall script, unless you have customized it.\n";
    print "(You will know if you have customized it.)\n\n";
    print "Would you like to update the autoinstall script for this image? ([y]/n): ";

    $update_script = get_response('yes');
    $update_script = lc $update_script;

    # if user actually hits "y", deal with it
    if($update_script eq "y") { $update_script = "yes"; }
}

# If it just ain't there yet, make it and don't even ask about it.
elsif(! -e $autoinstalldir . "/systemimager/$image.master") {
    $update_script="yes";
}

# if we don't need to update the master script, then exit -- we're done
unless($update_script eq "yes") { exit 0; }

### END Overwrite $image.master? ###


### BEGIN Got NIS? ###
$file="$imagedir/etc/sysconfig/network";
if(open (NETWORK, "< $file")) {
    while (<NETWORK>) {
        if (/^NISDOMAIN\s*\=\s*(\S+)/) {
            $nisdomain = $1;
        }
    }
    close (NETWORK);
}
### END Got NIS? ###


### BEGIN IP Assignment Method ###
if((!$quiet) and (!$ip_assignment_method))
{
    $satisfied="n";
    $ip_assignment_method="1";
    until($satisfied eq "y")
    {
        system("clear");
        print << 'EOF';
IP Address Assignment
---------------------

There are four ways to assign IP addresses to the client systems on an
ongoing basis:

1) static_dhcp -- A DHCP server will assign the
     same static address each time to clients 
     installed with this image.  Also see the
     "makedhcpstatic" command.

2) dynamic_dhcp -- A DHCP server will assign IP
     addresses dynamically to clients installed
     with this image.  They may be assigned a
     different address each time.

3) static -- The IP address the client uses
     during autoinstall will be permanently
     assigned to that client.

4) replicant -- Don't mess with the network
     settings in this image.  I'm using it as a
     backup and quick restore mechanism for a 
     single machine.

EOF

        print "Which method do you prefer? [$ip_assignment_method]: ";
        $ip_assignment_method = get_response("$ip_assignment_method");
        print "You have chosen method $ip_assignment_method for assigning IP addresses.\n";
        print "\nAre you satisfied? ([y]/n): ";
        $satisfied=get_response('y');
	unless(
	           ($ip_assignment_method == "1")
                or ($ip_assignment_method == "2")
                or ($ip_assignment_method == "3")
                or ($ip_assignment_method == "4")
	      )
              {
                 # reset to default
                 $ip_assignment_method = "1";
                 # send 'em back through the wringer
                 $satisfied="n" ;
              }
    }

# turn number values into useable string values
if   ($ip_assignment_method == "1") { $ip_assignment_method = "static_dhcp" ; }
elsif($ip_assignment_method == "2") { $ip_assignment_method = "dynamic_dhcp"      ; }
elsif($ip_assignment_method == "3") { $ip_assignment_method = "static"; }
elsif($ip_assignment_method == "4") { $ip_assignment_method = "replicant"   ; }
}
### END IP Assignment Method ###

### BEGIN create a fresh $autoinstalldir/systemimager/$image.master ###
open (MASTER_SCRIPT, ">$master_script") || die "$program_name: Can't open $master_script for writing\n";

# add standard header stuff
print MASTER_SCRIPT << 'EOF';
#!/bin/sh

#
# "SystemImager" - Copyright (C) 1999-2001 Brian Elliott Finley <brian@systemimager.org>
#
#
EOF

print MASTER_SCRIPT "# This master autoinstall script was created with SystemImager v$version_number\n";
print MASTER_SCRIPT "\n";
print MASTER_SCRIPT "VERSION=$version_number\n";
print MASTER_SCRIPT "IMAGENAME=$image\n";

print MASTER_SCRIPT << 'EOF';
PATH=/sbin:/bin:/usr/bin:/usr/sbin:/tmp

shellout() {
  exec cat /etc/issue ; exit 1
}


### BEGIN Check to be sure this not run from a working machine ###

# test for mounted SCSI or IDE disks
mount | grep [hs]d[a-z][1-9] > /dev/null 2>&1
[ $? -eq 0 ] &&  echo Sorry.  Must not run on a working machine... && shellout

# test for mounted software RAID devices
mount | grep md[0-9] > /dev/null 2>&1
[ $? -eq 0 ] &&  echo Sorry.  Must not run on a working machine... && shellout

# test for mounted hardware RAID disks
mount | grep c[0-9]+d[0-9]+p > /dev/null 2>&1
[ $? -eq 0 ] &&  echo Sorry.  Must not run on a working machine... && shellout

### END Check to be sure this not run from a working machine ###


# Pull in variables left behind by the linuxrc script.
# This information is passed from the linuxrc script on the autoinstall media via /tmp/variables.txt
# Apparently the shell on the autoinstall media is not intelligent enough to take a "set -a" parameter
. /tmp/variables.txt || shellout

### BEGIN Stop RAID devices before partitioning begins ###
# Why did they get started in the first place?  So we can pull a local.cfg
# file off a root mounted RAID system.  We do this even if a system does not
# use RAID, in case you are using a disk that was previously part of a RAID
# array.

# find running raid devices
RAID_DEVICES=`cat /proc/mdstat | grep ^md | mawk '{print "/dev/" $1}'`

# get raidstop utility if any raid devices exist
if [ ! -z "${RAID_DEVICES}" ]
then
  rsync -av --numeric-ids $IMAGESERVER::tftpboot/systemimager/raidstop /tmp/ || shellout
fi

# raidstop will not run unless a raidtab file exists
touch /etc/raidtab || shellout

# turn dem pesky raid devices off!
for RAID_DEVICE in ${RAID_DEVICES}
do
  # we don't do a shellout here because, well I forgot why, but we don't.
  echo "raidstop ${RAID_DEVICE}" && raidstop ${RAID_DEVICE}
done
### END Stop RAID devices before partitioning begins ###

EOF


### BEGIN get list of disks to partition ###
# get list of hardware RAID devices
$partition_dir="$systemimagerdir/partitionschemes/rd";
if(-d "$imagedir$partition_dir") {
    opendir(PARTITIONSCHEMES, "$imagedir$partition_dir") || die "$program_name: Can't read the $imagedir$partition_dir directory";
        # Skip anything that begins with a "."
        push(my @hardware_raid_disks, grep( !/^\..*/, readdir(PARTITIONSCHEMES) ) );

        # add the rd/ bit to each device
        for (@hardware_raid_disks) {
          $_ =~ s/^/rd\//;
          push(@disks, $_);
        }
    close(PARTITIONSCHEMES);
}

# get list of IDE and SCSI devices
$partition_dir="$systemimagerdir/partitionschemes";
if(-d "$imagedir$partition_dir") {
    opendir(PARTITIONSCHEMES, "$imagedir$partition_dir") || die "$program_name: Can't read the $imagedir$partition_dir directory";
        # Skip anything that begins with a "." or an "rd"
        push(@disks, grep( !/^rd$/, grep( !/^\..*/, readdir(PARTITIONSCHEMES) ) ) );
    close(PARTITIONSCHEMES);
}
### END get list of disks to partition ###


### BEGIN get info on devices for software RAID, swap, and filesystems ###
%device_by_mount_point          = ();
%filesystem_type_by_mount_point = ();
%mount_options_by_mount_point   = ();
open (FSTAB, "<$imagedir/etc/fstab") || die "$program_name: Failed to open $imagedir/etc/fstab for reading\n";
while (<FSTAB>) {
    # Skip the line if it starts with a '#' or if it is for a floppy device
    if (m@(^\s*\#)|(/dev/fd)@) { next; }

    # turn all tabs into single spaces -- Note: <ctrl-v><tab>
    s/	/ /g;

    # Remove spaces from the beginning of the line
    s/^ +//;

    # Skip blank lines
    if (m@(^$)@) { next; }

    # split on space(s) and assign values to variables
    (my $device, my $mount_point, my $filesystem_type, my $mount_options) = split(/ +/);

    # Create hashes to be used in mounting and unmounting
    $device_by_mount_point{$mount_point}     = $device;
    $filesystem_type_by_mount_point{$mount_point} = $filesystem_type;
    $mount_options_by_mount_point{$mount_point}   = $mount_options;

    ### BEGIN create arrays of device files by device type ###
    # get software RAID devices that are not using LABEL= or UUID=
    if ($device =~ /\/dev\/md/) { push (@software_raid_devices, $device); }

    # swap
    if ($filesystem_type eq "swap") { push (@swap_devices, $device); }

    # ext2
    if ($filesystem_type eq "ext2") { 
      push (@ext2_devices, $device);
      push (@mount_points, $mount_point);
    }

    # ext3
    if ($filesystem_type eq "ext3") { 
      push (@ext3_devices, $device);
      push (@mount_points, $mount_point);
    }

    # reiserfs
    if ($filesystem_type eq "reiserfs") { 
      push (@reiserfs_devices, $device);
      push (@mount_points, $mount_point);
    }
    ### END create arrays of device files by device type ###
}
close FSTAB;
### END get info on devices for software RAID, swap, and filesystems ###

### BEGIN add proc to list of filesystems
#  The following allows a proc filesystem to be mounted in the fakeroot.
#  This provides /proc to programs which are called by SystemImager
#  (eg. System Configurator).

push (@mount_points, '/proc');
$device_by_mount_point{'/proc'} = 'proc';
$filesystem_type_by_mount_point{'proc'} = 'proc';
### END add proc to list of filesystems

### BEGIN compile hash of ext2 partitions to label ###
%devices_by_label = ();

$file="$imagedir/etc/systemimager/devices_by_label.txt";
if (-e $file) {
  open (LABELS, "<$file") || die "program_name: Failed to open $file for reading\n";
  while (<LABELS>) {
    # remove carriage returns
    chomp;

    # Skip the line if it starts with a '#'
    if (m@(^\s*\#)@) { next; }

    # turn all tabs into single spaces -- Note: <ctrl-v><tab>
    s/	/ /g;

    # Remove spaces from the beginning of the line
    s/^ +//;

    # Skip blank lines
    if (m@(^$)@) { next; }

    # split on space(s) and assign values to variables
    (my $label, my $device) = split(/ +/);

    # Create hash to be used in labelling
    $devices_by_label{$label} = $device;

    # get software RAID devices that are using LABEL=
    if ($device =~ /\/dev\/md/) { push (@software_raid_devices, $device); }
  }
  close (LABELS);
}
### END compile hash of ext2 partitions to label ###


### BEGIN stop RAID devices before partitioning ###
if (@software_raid_devices) {
  print MASTER_SCRIPT "# Pull /etc/raidtab over to autoinstall client\n";
  print MASTER_SCRIPT "rsync -av --numeric-ids \$IMAGESERVER::\$IMAGENAME/etc/raidtab /etc/raidtab || shellout\n";
  print MASTER_SCRIPT "\n";
  print MASTER_SCRIPT "# get software RAID utilities\n";
  print MASTER_SCRIPT "rsync -av --numeric-ids \$IMAGESERVER::tftpboot/systemimager/mkraid /tmp/ || shellout\n";
  print MASTER_SCRIPT "rsync -av --numeric-ids \$IMAGESERVER::tftpboot/systemimager/raidstart /tmp/ || shellout\n";
  print MASTER_SCRIPT "rsync -av --numeric-ids \$IMAGESERVER::tftpboot/systemimager/raidstop /tmp/ || shellout\n";
  print MASTER_SCRIPT "\n";

  print MASTER_SCRIPT << 'EOF';
# Stop RAID devices before partitioning begins
# Why did they get started in the first place?  So we can pull a local.cfg
# file off a root mounted RAID system.
RAID_DEVICES=`cat /proc/mdstat | grep ^md | mawk '{print "/dev/" $1}'`
for RAID_DEVICE in ${RAID_DEVICES}
do
  echo "raidstop ${RAID_DEVICE}" && raidstop ${RAID_DEVICE}
done

EOF
}
### END stop RAID devices before partitioning ###


### BEGIN give a custom partitioning example ###
print MASTER_SCRIPT << 'EOF';
# Partition the disk (see the sfdisk man page for customization details)
#
# Below is an example of how to customize a disk.  This can be useful if your clients
# have disks of differing sizes or geometries.  Here is a description of the sfdisk
# command presented in the example below:
#
# line 1 -- the sfdisk command and arguments (-uM means "units are MB)
# line 2 -- this is a comment
# line 3 -- start at the beginning of the disk 0, give 22M /dev/sda1 (/boot)
# line 4 -- start where the last partition left off, and add 512M /dev/sda2 for swap, partition type 82
# line 5 -- start where the last partition left off, and add 6000M /dev/sda3 (/)
# line 6 -- start where the last partition left off, and give the remaining space to /dev/sda4 (/var)
# line 7 -- the EOF statement indicating to sfdisk that we are finished giving it commands
#
# <<<< BEGIN EXAMPLE >>>>
#sfdisk -uM /dev/sda <<EOF
## partition    start_of_partition      size_in_megabytes       partition_type
#  /dev/sda1 :  start= 0,          	size= 22,               Id=83
#  /dev/sda2 :  start= ,                size= 512,              Id=82
#  /dev/sda3 :  start= ,                size= 6000,             Id=83
#  /dev/sda4 :  start= ,                size= ,                 Id=83
#EOF
# <<<< END EXAMPLE >>>>

EOF
### END give a custom partitioning example ###


### BEGIN foreach disk, gather up the partition info for that disk and prepare an sfdisk command ###
foreach $disk (@disks)  {
  ### BEGIN get partition information ###
  %id_by_device = ();
  %megabytes_by_device = ();
  $lowest_partition_start_point = "10000000";  # some random large number

  open (PARTITIONS, "<$imagedir$systemimagerdir/partitionschemes/$disk")
  || die "$program_name: Cannot open $imagedir$systemimagerdir/partitionschemes/$disk for reading\n";
    @partitions = <PARTITIONS>;
  close(PARTITIONS);

  # Determine whether we are using megabytes (the default) or sectors (prepareclient -explicit-geometry)
  if ( grep(/^Units = megabytes/, @partitions)) {
    for (@partitions) {
      if(/^\/dev/) {
        # get rid of newline
        chomp;

        # get rid of an asterisk that may be indicating a boot partition (Linux doesn't need this)
        $_ =~ s/\*//g;

        # get rid of + signs -- we're not going to worry about those...
        $_ =~ s/\+//g;

        # split on space(s) and assign values to variables
        (my $device, my $start, my $end, my $megabytes, my $blocks, my $id) = split(/ +/);

        # round down if there is a minus sign on the value
        if ($megabytes =~ /-/) {
          $megabytes =~ s/-//g;
          $megabytes--;
        }

        # figure out what the starting device is (probably partition 1)
        if (($megabytes != "0") and ($start < $lowest_partition_start_point)) { 
          $lowest_partition_start_point = $start; 
          $start_device = $device; 
        }

        # create the megabytes by device hash
        $megabytes_by_device{$device} = $megabytes;

        # create the Id by device hash
        $id_by_device{$device} = $id;
      }
    }

    # get number of partitions
    $number_of_partitions = (keys %id_by_device);
    ### END get partition information ###


    ### BEGIN format output for partitions 1-4 (must do these backwards) ###
    $sfdisk_command = "";
    my $has_a_non_null_partition_been_created = "no";
    foreach my $partition_number (4, 3, 2, 1) {

      my $device = "";
      if ( $disk =~ /c[0-9]+d[0-9]+/ )
      {
          $device = "/dev/$disk" . "p" . "$partition_number";
      }
      else
      {
          $device = "/dev/$disk" . "$partition_number";
      }

      my $megabytes = $megabytes_by_device{$device};
      my $id = $id_by_device{$device};
      if ($megabytes == "0") {
        $sfdisk_command = "$device : start= 0, size= 0, Id=0\n" . $sfdisk_command;
        next;
      } 
      if ($has_a_non_null_partition_been_created eq "no") { $megabytes = ""; }
      if ($device eq $start_device) {
        $sfdisk_command = "$device : start= $lowest_partition_start_point, size= $megabytes, Id=$id\n" . $sfdisk_command;
        $has_a_non_null_partition_been_created = "yes";
      } else {
        $sfdisk_command = "$device : start= , size= $megabytes, Id=$id\n" . $sfdisk_command;
        $has_a_non_null_partition_been_created = "yes";
      }
    }
    ### END format output for partitions 1-4 (must do these backwards) ###


    ### BEGIN format output for logical partitions 5+ ###
    my $partition_number = "5";
    if ($number_of_partitions > "4") {
      until ($partition_number == $number_of_partitions) {
        my $device = "/dev/$disk$partition_number";
        my $megabytes = $megabytes_by_device{$device};
        my $id = $id_by_device{$device};
        $sfdisk_command = $sfdisk_command . "$device : start= , size= $megabytes, Id=$id\n";
        $partition_number++;
      } 

      my $device = "";
      if ($disk =~ /c[0-9]+d[0-9]+/ )
          { $device = "/dev/$disk" . "p" . "$partition_number"; }
      else
          { $device = "/dev/$disk" . "$partition_number"; }

      my $id = $id_by_device{$device};
      $sfdisk_command = $sfdisk_command . "$device : start= , size= , Id=$id\n";
    }
    ### END format output for logical partitions 5+ ###

    # put final touch on sfdisk command
    $sfdisk_command = "sfdisk -L -uM /dev/$disk <<EOF || shellout\n" . $sfdisk_command . "EOF\n";

    # output disk partition section
    print MASTER_SCRIPT "# partition $disk\n";
    print MASTER_SCRIPT "echo partitioning $disk...\n";
    print MASTER_SCRIPT "sleep 1s\n";
    print MASTER_SCRIPT $sfdisk_command;
    print MASTER_SCRIPT "\n";

  } elsif ( grep(/^Units = sectors/, @partitions)) {

    ### BEGIN do stuff for disks partitioned in sectors (prepareclient -explicit-geometry)

      ### BEGIN partitioning output ###
      $sfdisk_command_part_one = "sfdisk -L -uS /dev/$disk <<EOF\n";
      $sfdisk_command_part_two = "";

      # gather up partition information
      open (PARTITIONS, "<$imagedir$systemimagerdir/partitionschemes/${disk}")
      || die "Cannot open $imagedir$systemimagerdir/partitionschemes/$disk for reading\n";
        @partitions = <PARTITIONS>;
      close(PARTITIONS);

      for (@partitions) {
        if(/^\/dev/) {
            # get rid of newline
            chomp;

            # get rid of an asterisk that may be indicating a boot partition (Linux doesn't need this)
            $_ =~ s/\*//g;

            # split on space(s) and assign values to variables
            (my $dev, my $start, my $end, my $sectors, my $id) = split(/ +/);

            # continue compiling sfdisk command
            $sfdisk_command_part_one = $sfdisk_command_part_one . "$dev : start= $start, size= $sectors, Id=$id\n";
        }
      }
      $sfdisk_command = $sfdisk_command_part_one . $sfdisk_command_part_two . "EOF\n";
      ### END partitioning output ###

      # output disk partition section
      print MASTER_SCRIPT "# partition $disk\n";
      print MASTER_SCRIPT "echo partitioning $disk...\n";
      print MASTER_SCRIPT "sleep 1s\n";
      print MASTER_SCRIPT $sfdisk_command;
      print MASTER_SCRIPT "\n";

    ### END do stuff for disks partitioned in sectors (prepareclient -explicit-geometry)
  }
}
### END foreach disk, gather up the partition info for that disk and prepare an sfdisk command ###


### BEGIN Write out software RAID device creation commands ###
if (@software_raid_devices) {
  print MASTER_SCRIPT "# create software RAID devices\n";
  foreach my $device (sort @software_raid_devices) {
    print MASTER_SCRIPT "mkraid --really-force $device || shellout\n";
  }
  print MASTER_SCRIPT "\n";
}
### END Write out software RAID device creation commands ###


### BEGIN Write out swap creation commands ###
if (@swap_devices) {
  print MASTER_SCRIPT "# initialize swap devices\n";
  foreach my $device (sort @swap_devices) {
    print MASTER_SCRIPT "mkswap -v1 $device || shellout\n";
    print MASTER_SCRIPT "swapon $device || shellout\n";
  }
  print MASTER_SCRIPT "\n";
}
### END Write out swap creation commands ###


### BEGIN Write out ext2 creation commands ###
if (@ext2_devices) {
  print MASTER_SCRIPT "# format ext2 devices\n";
  foreach my $device (sort @ext2_devices) {
    if ($device =~ /LABEL=/) {
      ### BEGIN this do for labelled devices
      foreach my $label (keys %devices_by_label) {
        if ($device eq $label) {
          # get device
          my $device = $devices_by_label{$label};
          # strip out LABEL= bit so that we're left with just the actual label
          $label =~ s/LABEL=//;
          print MASTER_SCRIPT "mke2fs -L $label $device || shellout\n";
        }
      }
      ### END this do for labelled devices
    } else {
      ### BEGIN this do for non-labelled devices
      print MASTER_SCRIPT "mke2fs $device || shellout\n";
      ### END this do for non-labelled devices
    }
  }
  print MASTER_SCRIPT "\n";
}
### END Write out ext2 creation commands ###


### BEGIN Write out ext3 creation commands ###
if (@ext3_devices) {
  print MASTER_SCRIPT "# format ext3 devices\n";
  print MASTER_SCRIPT "#   SystemImager will use the default parameters to create an appropriately\n";
  print MASTER_SCRIPT "#   sized journal (given the size of the filesystem) stored internally in the\n";
  print MASTER_SCRIPT "#   filesystem.\n";
  print MASTER_SCRIPT "#\n";
  print MASTER_SCRIPT "#   In the future, I hope to detect and re-create journals of an appropriate\n";
  print MASTER_SCRIPT "#   size.  Currently we don't deal with non-hidden journals or journals on a\n";
  print MASTER_SCRIPT "#   device other than the filesystem device itself.\n";
  print MASTER_SCRIPT "#\n";
  print MASTER_SCRIPT "#   If you require different journal options, simply make the changes here in\n";
  print MASTER_SCRIPT "#   this <image>.master script.\n";

  foreach my $device (sort @ext3_devices) {
    if ($device =~ /LABEL=/) {
      ### BEGIN this do for labelled devices
      foreach my $label (keys %devices_by_label) {
        if ($device eq $label) {
          # get device
          my $device = $devices_by_label{$label};
          # strip out LABEL= bit so that we're left with just the actual label
          $label =~ s/LABEL=//;
          print MASTER_SCRIPT "mke2fs -j -L $label $device || shellout\n";
        }
      }
      ### END this do for labelled devices
    } else {
      ### BEGIN this do for non-labelled devices
      print MASTER_SCRIPT "mke2fs -j $device || shellout\n";
      ### END this do for non-labelled devices
    }
  }

  print MASTER_SCRIPT "\n";
}
### END Write out ext3 creation commands ###


### BEGIN Write out reiserfs creation commands ###
if (@reiserfs_devices) {
  print MASTER_SCRIPT "# get mkreiserfs utility\n";
  print MASTER_SCRIPT "rsync -av --numeric-ids \$IMAGESERVER::tftpboot/systemimager/mkreiserfs /tmp/ || shellout\n";
  print MASTER_SCRIPT "\n";
  print MASTER_SCRIPT "# format reiserfs devices\n";
  foreach my $device (sort @reiserfs_devices) {
    print MASTER_SCRIPT "# rupasov is the default, but we are explicit here anyway\n";
    print MASTER_SCRIPT "echo \"y\" | mkreiserfs -h rupasov $device || shellout\n";
  }
  print MASTER_SCRIPT "\n";
}
### END Write out ext2 creation commands ###


### BEGIN Write out mkdir and mount commands ###
# be sure to pre-pend /a to each target directory being created
print MASTER_SCRIPT "# create mount points and mount filesystems\n";
foreach $mount_point (sort (@mount_points)) {
  my $device = $device_by_mount_point{$mount_point};
  print MASTER_SCRIPT "mkdir -p /a$mount_point || shellout\n";

  ### BEGIN this do for labelled devices
  if ($device =~ /LABEL=/) {
    foreach my $label (keys %devices_by_label) {
      if ($device eq $label) {
        # get device
        $device = $devices_by_label{$label};
        next;
      }
    }
  }
  ### END this do for labelled devices

  # Be sure to use proper mount options -- such as -notail for root mounted
  # reiserfs filesystems.  Thanks go to Matthew Marlowe <mmarlowe@jalan.com>
  # for finding this bug (root mounted reiserfs needing the -notail option).
  my $mount_options   = $mount_options_by_mount_point{$mount_point};

  my $filesystem_type = $filesystem_type_by_mount_point{$mount_point};

  # ext3 filesystems are mounted as ext2 for autoinstall purposes
  if($filesystem_type eq "ext3") { $filesystem_type = "ext2" }

  if ($mount_options) {
    # Deal with filesystems to be mounted read only (ro) after install.  We 
    # still need to write to them to install them. ;)
    $mount_options =~ s/^ro$/rw/;
    $mount_options =~ s/^ro,/rw,/;
    $mount_options =~ s/,ro$/,rw/;
    $mount_options =~ s/,ro,/,rw,/;

    # add commands to master script
    print MASTER_SCRIPT "mount $device /a$mount_point -t $filesystem_type -o $mount_options || shellout\n";
  } else {
    # add commands to master script
    print MASTER_SCRIPT "mount $device /a$mount_point -t $filesystem_type || shellout\n";
  }
  print MASTER_SCRIPT "\n";
}
### END Write out mkdir and mount commands ###


### BEGIN pull the image down ###
print MASTER_SCRIPT << 'EOF';
# Filler up!
#
# If we are installing over ssh, we must limit the bandwidth used by 
# rsync with the --bwlimit option.  This is because of a bug in ssh that
# causes a deadlock.  The only problem with --bwlimit is that it slows 
# down your autoinstall significantly.  We try to guess which one you need:
# o if you ran getimage with -ssh-user, we presume you need --bwlimit
# o if you ran getimage without -ssh-user, we presume you don't need 
#   --bwlimit and would rather have a faster autoinstall.
#
# Both options are here for your convenience.  We have done our best to 
# choose the one you need and have commented out the other.
#
EOF

if ($ssh_user) {
  # using ssh
  print MASTER_SCRIPT "rsync -av --bwlimit=10000 --numeric-ids \$IMAGESERVER::\$IMAGENAME/ /a/ || shellout\n\n";
  print MASTER_SCRIPT "#rsync -av --numeric-ids \$IMAGESERVER::\$IMAGENAME/ /a/ || shellout\n\n";
} else {
  # not using ssh
  print MASTER_SCRIPT "#rsync -av --bwlimit=10000 --numeric-ids \$IMAGESERVER::\$IMAGENAME/ /a/ || shellout\n\n";
  print MASTER_SCRIPT "rsync -av --numeric-ids \$IMAGESERVER::\$IMAGENAME/ /a/ || shellout\n\n";
}
### END pull the image down ###

### BEGIN graffiti ###
print MASTER_SCRIPT "# Leave notice of which image is installed on the client\n";
print MASTER_SCRIPT "echo \$IMAGENAME > /a/etc/systemimager/IMAGE_LAST_SYNCED_TO || shellout\n\n";
### END graffiti ###

### BEGIN System Configurator setup ###

if ($ip_assignment_method eq "static") { 

  print MASTER_SCRIPT <<'EOF';
chroot /a/ systemconfigurator --configsi --stdin <<EOL || shellout
[NETWORK]
HOSTNAME = $HOSTNAME
DOMAINNAME = $DOMAINNAME
GATEWAY = $GATEWAY
[INTERFACE0]
DEVICE = eth0
TYPE = static
IPADDR = $IPADDR
NETMASK = $NETMASK
EOL
EOF

} elsif ($ip_assignment_method eq "static_dhcp") {
  print MASTER_SCRIPT <<'EOF';
chroot /a/ systemconfigurator --configsi --stdin <<EOL || shellout
[INTERFACE0]
DEVICE = eth0
TYPE = dhcp
EOL
EOF

} elsif ($ip_assignment_method eq "replicant") {
  print MASTER_SCRIPT << 'EOF';
chroot /a/ systemconfigurator --runboot || shellout
EOF

} else { # aka elsif ($ip_assignment_method eq "dynamic_dhcp")
  print MASTER_SCRIPT <<'EOF';
chroot /a/ systemconfigurator --configsi --stdin <<EOL || shellout
[NETWORK]
HOSTNAME = $HOSTNAME
DOMAINNAME = $DOMAINNAME
[INTERFACE0]
DEVICE = eth0
TYPE = dhcp
EOL
EOF

}  ### END System Configurator setup ###

print MASTER_SCRIPT "# unmount the freshly filled filesystems\n";
foreach $mount_point (reverse sort @mount_points) {
    print MASTER_SCRIPT "echo -n umount /a$mount_point/ ... \n";
    print MASTER_SCRIPT "umount /a$mount_point/ && echo Done! || shellout\n";
}
print MASTER_SCRIPT "\n";

print MASTER_SCRIPT "# No need to manually stop software RAID devices -- the autodetect support\n";
print MASTER_SCRIPT "# in the kernel will do that for us.\n";
print MASTER_SCRIPT "\n";

print MASTER_SCRIPT "# Take network interface down\n";
print MASTER_SCRIPT "ifconfig eth0 down || shellout\n";
print MASTER_SCRIPT "\n";

if ($post_install eq "beep") {
print MASTER_SCRIPT << 'EOF';
# Cause the system to make noise and display an "I'm done." message
ralph="sick"
count="1"
while [ $ralph="sick" ]
do
  beep
  [ $count -lt 60 ] && echo "I've been done for $count seconds.  Reboot me already!"
  [ $(($count / 60 * 60)) = $count ] && echo "I've been done for $(($count / 60)) minutes now.  Reboot me already!"
  sleep 1
  count=$(($count + 1))
done

EOF
} elsif ($post_install eq "reboot") {
  #reboot stuff
  print MASTER_SCRIPT "# reboot the autoinstall client\n";
  print MASTER_SCRIPT "shutdown -r now\n";
  print MASTER_SCRIPT "\n";
} elsif ($post_install eq "shutdown") {
  #shutdown stuff
  print MASTER_SCRIPT "# shutdown the autoinstall client\n";
  print MASTER_SCRIPT "shutdown -h now\n";
  print MASTER_SCRIPT "\n";
}
### END end of autoinstall options ###

close(MASTER_SCRIPT);
### END create a fresh $autoinstalldir/systemimager/$image.master ###

# prompt to run makedhcpstatic after autoinstalling clients if using static_dhcp
if((!$quiet) and ($ip_assignment_method eq "static_dhcp")) {
    system("clear");
    print << 'EOF';
Static DHCP Instructions
------------------------

You have chosen to use "Static DHCP" for your IP addressing.  Be sure to
run "makedhcpstatic" after autoinstalling your client systems.  You will
need to autoinstall your client systems in the order that you want them
to be assigned their IP addresses.  When you run "makedhcpstatic", it 
will re-write the DHCP server configuration file to permanently assign
to each client the same IP address that client received during it's 
autoinstall process.

EOF

    # and then give 'em a chance to read the message
    print "\nPress <Enter> to continue...";
    <STDIN>;
    system("clear");
}

# prompt to run "addclients"
if (!$quiet) {
    print "Would you like to run the \"addclients\" utility now? (y/[n]): ";
    $continue = get_response('n');
    ($continue ne "n") or exit 0;
    exec("addclients");
}
