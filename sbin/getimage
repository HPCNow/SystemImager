#!/usr/bin/perl -w

#
# "SystemImager" - Copyright (C) 1999-2000 TheFinleys.com <brian@thefinleys.com> 
#
# This file is: getimage XXX: Should be getmaster????
#

$testing = 1;

### BEGIN Subroutines ###

sub get_response {
    my $garbage_out=$_[0];
    my $garbage_in=<STDIN>;
    chomp $garbage_in;
    unless($garbage_in eq "") { $garbage_out = $garbage_in; }
    return $garbage_out;
}

sub check_if_root{
    unless($< == 0) { die "Must be run as root!\n"; }
}


sub usage {
    print "Usage: $program_name [-q] master imagename\n";
    exit(1);
}

### END Subroutines ###

### BEGIN Program ###
check_if_root();

$0  =~ /(.*)\/+([^\/]*)$/;
$program_name = $2;

#Figure out where this script lives, so that we can find the templates.

if ($0 =~ /^\//) {
#If the path to this script starts with a slash, then just remove the
#part after the last slash to get the directory.
    $0 =~ /(.*)\/[^\/]*$/;
    $directory = $1;
} else {
#Otherwise, we concat the current working directory, a '/', and the
#name that was used to run this script minus anything after the final slash.
    $0  =~ /(.*)\/[^\/]*$/;
    $directory = $ENV{'PWD'} . "/" . $1;
}

if ($#ARGV < 1) {
    usage();
}
if ($ARGV[0] eq '-q')  {
    if ($#ARGV != 2) {
	usage();
    }
    $quiet = 1;
    $master =  $ARGV[1];
    $image = $ARGV[2];
} else {
    $master =  $ARGV[0];
    $image = $ARGV[1];
}


# set up some variables for use elsewhere

$RSYNC_CONF = '/etc/rsyncd.conf';
$imagedir_prefix =  '/var/spool/systemimager/images';
$imagedir = "$imagedir_prefix/$image";
$excludefile = "/tmp/.exclude.$image";
$masterscript = "/tftpboot/systemimager/$image.master";

if (!$quiet) {
    system("clear");
}

$warning =  <<"EOF";

This script will get the entire system image from \"$master\"
making the assumption that all filesystems considered part
of the system image are using ext2.

This script will not get /proc or network mounted filesystems.
It will only get ext2 formated file systems.

EOF

# give warning
if (!$quiet) {
    print $warning;
    print "Continue? ([y]/n): ";
    $continue = get_response('y');
    ($continue ne "n") or die "$program_name: No files were modified.\n";
}

if (! -d "$imagedir_prefix")  {
    die "Directory $imagedir_prefix doesn't exist.  " .
	"Please reinstall systemimager.\n";
}

if (-d "$imagedir") {
    if (!$quiet) {
	print "An image with the name \"$image\" is already on this server.\n" .
	    "Update exisiting image?  ([y]/n)";
	
	$continue = get_response('y');
	($continue ne "n") or die "$program_name: No files were modified.\n";
    }
} else  {
    mkdir("$imagedir", 0777) || 
	die "Can't make directory $imagedir\n";
}

# get /etc/mtab from master
print "Getting the mtab file from the master\n";
open(RSYNC, "rsync -azv ${master}::root/etc/mtab $imagedir|");
if (!$quiet) {
    print "----------- rsync output ------------\n";
    while (<RSYNC>) {
	print $_;
    }
    print "-------------------------------------\n";
}
close(RSYNC);

# $? is the return value from rsync
if ($?) {
    die "Failed to get /etc/mtab from the master.\n";
}

# create list of filesystems to *not* get
open (MTAB, "<$imagedir/mtab") || die ("Couldn't open $imagedir/mtab for reading\n");
@mtab = <MTAB>;
close MTAB;
open (EXCLUDE, ">$excludefile") || 
    die "Couldn't open $excludefile for writing\n";
@mtab = grep (!/\s+ext2\s+/, @mtab);
foreach (@mtab) {
    /\S+\s+(\S+)\s+/;
    print EXCLUDE "$1/*\n";
}
close EXCLUDE;

# Testing
if ($testing) {
    print "Adding to $excludefile\n";
    system("echo \"+ /etc/\" >> $excludefile");
    system("echo \"+ /etc/partitionschemes/\" >> $excludefile");
    system("echo \"+ /etc/partitionschemes/*\" >> $excludefile");
    system("echo \"/etc/*/*\" >> $excludefile");
    system("echo \"/+ /etc/*\" >> $excludefile");
    system("echo \"*\" >> $excludefile");
}

# Get the image from the master
print "Retrieving files from the master\n";
open (RSYNC, 
      "rsync -av --delete --exclude-from=$excludefile " .
      "${master}::root/ $imagedir |");
if (!$quiet) {
    print "----------- rsync output ------------\n";
    while (<RSYNC>) {
	print $_;
    }
    print "-------------------------------------\n";
}
close (RSYNC);
# $? is the return value from rsync
if ($?) {
    die "rsync call to get image from master failed.\n";
}

unlink $excludefile || 
    die "Removal of file $excludefile failed\n";

# Add entry to image server's rsyncd.conf if necessary
open (RSYNC_CONF, "<$RSYNC_CONF");
if (!grep(/\[$image\]/, <RSYNC_CONF>)) {
    open(RSYNC_CONF, ">>$RSYNC_CONF") || die 
	"Cannot open $RSYNC_CONF for writing";
    print RSYNC_CONF <<"EOF";
[$image]
    path = $imagedir
	    
EOF
};
close(RSYNC_CONF);

open (TEMPLATE1, "<$directory/image.master.1") || 
    die "Cannot open image.master.1\n";
open (TEMPLATE2, "<$directory/image.master.2") || 
    die "Cannot open image.master.2\n";
open (TEMPLATE3, "<$directory/image.master.3") || 
    die "Cannot open image.master.3\n";

# create a fresh /tftpboot/systemimager/$image.master
open (MASTER, ">$masterscript") || 
    die "Can't open $masterscript for writing\n";

# master.1 has no substitutions, so just dump it straight into the master.
while (<TEMPLATE1>) {
    print MASTER;
}

opendir(PARTITIONSCHEMES, "$imagedir/etc/partitionschemes/") || 
    die "Can't read $imagedir/etc/partitionschemes/ directory";

#Skip the . and .. entries
@disks = grep(!/^\.\.?$/, readdir(PARTITIONSCHEMES));

close(PARTITIONSCHEMES);

foreach $disk (@disks)  {

    # Foreach disk, look through the partition info for that disk and
    # note any swap and ext2 partions for later use.

    open (PARTITIONS, "<$imagedir/etc/partitionschemes/${disk}") ||
	die "Cannot open $imagedir/etc/partitionschemes/$disk for reading\n";
    @partitions =  <PARTITIONS>;
    close(PARTITIONS);
    $partitions = join('',@partitions);
    @swaps = grep(/Id=82/, @partitions);
    foreach $swapdev (@swaps) {
	push(@swapdevs, (split(':',$swapdev))[0]);
    }
    @ext2s = grep (/Id=83/, @partitions);
    foreach $ext2dev (@ext2s) {
	push(@ext2devs, (split(':',$ext2dev))[0]);
    }

    while (<TEMPLATE2>)  {
	if (/<SFDISK>/) {
	    print MASTER "sfdisk /dev/$disk <<EOF\n";
	    print MASTER $partitions;
	    print MASTER "EOF\n";
	} elsif (/<SWAP>/) {
	    foreach $swapdev (@swapdevs) {
		print MASTER "mkswap -v1 $swapdev\n";
	    }
	} elsif (/<EXT2>/) {
	    foreach $ext2dev (@ext2devs) {
		print MASTER "mke2fs -b 4096 -i 16384 -m 1 $ext2dev\n";
	    }
	} else {
	    print MASTER;
	}
    }
}

open (FSTAB, "<$imagedir/etc/fstab") || 
    die "Failed to open $imagedir/etc/fstab for reading\n";

while (<FSTAB>) {
    # Skip the line if it starts with a '#' or does not contain 'ext2'
    if (m@(^\s*\#)|(/dev/fd)@ || (! (/\s+ext2\s+/))) {
        next;
    }
    # Pull out the device file ($1) and the mount point ($2).
    if (/^\s*(\S+)\s+(\S+)\s/)  {
	$fstab{$1} = $2;
    }
}

close FSTAB;

# We substitute for <MOUNT>, <RSYNC>, and <UMOUNT> sections from the
# third part of the template.
while (<TEMPLATE3>)  {
    if (/<MOUNT>/) {
	while (($dev, $dir) = each %fstab) {
	    print MASTER "mkdir -p /a$dir/\n";
	    print MASTER "mount $dev /a$dir\n";
	}
    }
    elsif (/<RSYNC>/) {
	print MASTER "rsync -av \$DHCPSIADDR::$image /a/\n";
    }
    elsif (/<UMOUNT>/) {
	while (($dev, $dir) = each %fstab) {
	    print MASTER "umount /a$dir\n";
	}
    } else {
	print MASTER;
    }
}

close(TEMPLATE1);
close(TEMPLATE2);
close(TEMPLATE3);
close(MASTER);

if (!$quiet) {
    print "Would you like to add your client information now? ([y]/n): ";
    $continue = get_response('y');
    ($continue ne "n") or exit 0;
    exec("$directory/addclients");
}
