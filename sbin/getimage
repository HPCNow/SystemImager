#!/usr/bin/perl -w

#
# "SystemImager" - Copyright (C) 1999-2000 Brian Elliott Finley <brian@valinux.com>
#
#   Others who have contributed to this code:
#     Wesley Smith <wessmith@engr.sgi.com>
#
# This file is: getimage 
#

# set system path for system() calls
$ENV{PATH} = "/usr/sbin:/sbin:/usr/bin:/bin";

# miscellaneous variables and what not
# NIS domain name will be figured out automatically (if it exists)
$nisdomainname="";

# use the long options module to allow us to use, well, long options ;)
use Getopt::Long;

### BEGIN Subroutines ###

sub get_response {
    my $garbage_out=$_[0];
    my $garbage_in=<STDIN>;
    chomp $garbage_in;
    unless($garbage_in eq "") { $garbage_out = $garbage_in; }
    return $garbage_out;
}

sub check_if_root{
    unless($< == 0) { die "Must be run as root!\n"; }
}

### END Subroutines ###

### BEGIN Program ###

# figure out the program name
$0  =~ /(.*)\/+([^\/]*)$/;
$program_name = $2;
$version_number = "0.24beta3";

$version_info = <<"EOF";
$program_name (part of SystemImager) version $version_number

Copyright (C) 1999-2000 Brian Elliott Finley <brian\@valinux.com>
This is free software; see the source for copying conditions.  There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
EOF

$help_info = $version_info . <<"EOF";

Usage: $program_name [OPTION]...  --master-client HOSTNAME --image IMAGENAME

Options: (options can be presented in any order and may be abbreviated)
 --help                    Display this output.
 --version                 Display version and copyright information.
 --master-client HOSTNAME  Hostname or IP address of the \"master\" client.
 --image IMAGENAME         Where IMAGENAME is the name to assign to the 
                           image you are retrieving.  This can be either
                           the name of a new image if you want to create
                           a new image, or the name of an exisiting image
                           if you want to update an image.
 --quiet                   Don\'t ask any questions or print any output
                           (other than errors). In this mode, no warning
                           will be given if the image already exists on
                           the server.
 --ip-assignment METHOD    Where METHOD can be static_dhcp, dynamic_dhcp,
                           or static. (static_dhcp is recommended)
 --update-script [YES|NO]  Update the \$image.master script?
                           Defaults are:
                           - NO if --quiet
                           - Otherwise prompt for response if not
                             specified

Download from http://systemimager.org/
Report bugs or suggestions to <systemimager-bugs\@systemimager.org>
EOF
    

$master_client = "";
$ip_assignment_method = "";
$image = "";
$update_script = "";

GetOptions( 
    "master-client=s" => \$master_client,
    "image=s" => \$image,
    "ip-assignment=s" => \$ip_assignment_method,
    "update-script=s" => \$update_script,
    "help" => \$help,
    "version" => \$version,
    "quiet" => \$quiet
) || die "$help_info";

$ip_assignment_method = lc $ip_assignment_method;
$update_script = lc $update_script;

#if requested, print help information
if($help) { die "$help_info"; }

# if requested, print version and copyright information
if($version) { die "$version_info"; }

# both master_client and image must be set.
if($master_client eq "" || $image eq "") {
    die "$help_info";
}

# be sure $master_client name doesn't start with a hyphen
$_ = $master_client;
if(/^-/) { die qq(Master client name can't start with a hyphen.\n\n$help_info); }

# be sure $image doesn't start with a hyphen
$_ = $image;
if(/^-/) { die qq(Image name can't start with a hyphen.\n\n$help_info); }

# be sure $ip_assignment_method was passed a proper option
unless(
    ($ip_assignment_method eq "")
    or ($ip_assignment_method eq "static_dhcp")
    or ($ip_assignment_method eq "static")
    or ($ip_assignment_method eq "dynamic_dhcp")
) { die "$help_info"; }

# be sure program is run by root
check_if_root();

# set up some variables for use elsewhere
###FIX### at some point these should be set in /etc/systemimager.conf
$rsyncd_conf = '/etc/rsyncd.conf';
$imagedir_prefix =  '/var/spool/systemimager/images';
$imagedir = "$imagedir_prefix/$image";
$exclude_file = "/tmp/.exclude.$image";
$master_script = "/tftpboot/systemimager/$image.master";

$warning =  <<"EOF";

This program will get the entire system image from \"$master_client\"
making the assumption that all filesystems considered part
of the system image are using the ext2 format.

This program will not get /proc or network mounted filesystems.
It will only get ext2 formated file systems.

EOF

# give warning
if (!$quiet) {
    system("clear");
    print $warning;
    print "Continue? ([y]/n): ";
    $continue = get_response('y');
    ($continue ne "n") or die "$program_name: No files were modified.\n";
}

if (! -d "$imagedir_prefix")  {
    die "Directory $imagedir_prefix doesn't exist.  " .
	"Please reinstall SystemImager.\n";
}

if (-d "$imagedir") {
    if (!$quiet) {
	print "An image named \"$image\" already exists...\n\n" .
	    "Update exisiting image? ([y]/n): ";
	
	$continue = get_response('y');
	($continue ne "n") or die "$program_name: No files were modified.\n";
    }
} else  {
    mkdir("$imagedir", 0777) || 
	die "Can't make directory $imagedir\n";
}

# get /etc/mtab from $master_client
if (!$quiet) {
    print "\n\nRetrieving /etc/mtab from $master_client to check for mounted filesystems...\n";
    open(RSYNC, "rsync -av ${master_client}::root/etc/mtab $imagedir|");
    print "--------------------------- mtab RETRIEVAL PROGRESS ---------------------------------\n";
    while (<RSYNC>) {
        print;
    }
    print "--------------------------- mtab RETRIEVAL FINISHED ---------------------------------\n";
    close(RSYNC);
} else {
    $command = qq(rsync -a ${master_client}::root/etc/mtab $imagedir);
    system($command);
}

# $? is the return value from rsync
if ($?) {
    print "Failed to retrieve /etc/mtab from $master_client.\n";
    die "Have you run \"prepareclient\" on $master_client?\n";
}

# create list of filesystems to *not* get
open (MTAB, "<$imagedir/mtab") || die ("Couldn't open $imagedir/mtab for reading\n");
@mtab = <MTAB>;
close MTAB;
open (EXCLUDE, ">$exclude_file") ||
    die "Couldn't open $exclude_file for writing\n";
@mtab = grep (!/\s+ext2\s+/, @mtab);
foreach (@mtab) {
    /\S+\s+(\S+)\s+/;
    print EXCLUDE "$1/*\n";
}
close EXCLUDE;

# Get the image from the $master_client
if (!$quiet) {
    print "\n\nRetrieving system image from $master_client\n";
    open (RSYNC, "rsync -av --delete --exclude-from=$exclude_file " . "${master_client}::root/ $imagedir |");
    print "--------------------------- $image RETRIEVAL PROGRESS ---------------------------------\n";
    while (<RSYNC>) {
        print $_;
    }
    print "--------------------------- $image RETRIEVAL FINISHED ---------------------------------\n";
    close (RSYNC);
} else {
    $command = qq(rsync -a --delete --exclude-from=$exclude_file ${master_client}::root/ $imagedir);
    system($command);
}

# $? is the return value from rsync
if ($?) {
    die "Failed to retrieve system image from $master_client.\n";
}


if(!$quiet) {
    print "\nPress <Enter> to continue...";
    <STDIN>;
}

unlink $exclude_file || die "Removal of file $exclude_file failed\n";

# Add entry to image server's rsyncd.conf if necessary
open (RSYNCD_CONF, "<$rsyncd_conf");
if (!grep(/\[$image\]/, <RSYNCD_CONF>)) {
    open(RSYNCD_CONF, ">>$rsyncd_conf") || die "Cannot open $rsyncd_conf for writing";
    print RSYNCD_CONF <<"EOF";
[$image]
    path = $imagedir
	    
EOF
};
close(RSYNCD_CONF);


### BEGIN Overwrite $image.master? ###
if( (!$quiet) and (!$update_script) and (-e "/tftpboot/systemimager/$image.master") ) {
    system("clear");
    print "Update Autoinstall Script?\n";
    print "--------------------------\n\n";
    print "An autoinstall script for this image already exists.  It is recommended\n";
    print "that you update this autoinstall script, unless you have customized it.\n";
    print "(You will know if you have customized it.)\n\n";
    print "Would you like to update the autoinstall script for this image? ([y]/n): ";

    $update_script = get_response('yes');
}

# if we don't need to update the master script, then exit -- we're done
unless($update_script eq "yes") { exit 0; }

### END Overwrite $image.master? ###


### BEGIN Got NIS? ###
$file="$imagedir/etc/sysconfig/network";
open(NETWORK, "< $file") or die "Couldn't open $file for reading: $!\n";
while (<NETWORK>) {
  if(/^NISDOMAIN/) {
      chomp;
      # set $nisdomainname but dump $placeholder (figure out a better way to do this later)
      (my $placeholder, $nisdomainname) = split(/=/, $_);
  }
}
close(NETWORK);
### END Got NIS? ###


### BEGIN IP Assignment Method ###
if((!$quiet) and (!$ip_assignment_method)) {
    $satisfied="n";
    $ip_assignment_method="1";
    until($satisfied eq "y") {
        system("clear");
        print << 'EOF';
IP Address Assignment
---------------------

There are three ways to assign IP addresses to the client systems on an
ongoing basis:

1) Static IP addresses assigned by DHCP
   (recommended if you can continue to run the DHCP server
    on your imageserver -- use makedhcpstatic after autoinstalling
    your clients to make the addresses permanent)
2) Static IP addresses
   (recommended if you can not continue to run the DHCP server
    on your imageserver)
3) Dynamic IP addresses assigned by DHCP

EOF

        print "Which method do you prefer? [$ip_assignment_method]: ";
        $ip_assignment_method = get_response('1');
        print "You have chosen method $ip_assignment_method for assigning IP addresses.\n";
        print "\nAre you satisfied? ([y]/n): ";
        $satisfied=get_response('y');
    }
    if($ip_assignment_method eq "1") { $ip_assignment_method = "static_dhcp" ; }
    if($ip_assignment_method eq "2") { $ip_assignment_method = "static"      ; }
    if($ip_assignment_method eq "3") { $ip_assignment_method = "dynamic_dhcp"; }
}
### END IP Assignment Method ###

### BEGIN create a fresh /tftpboot/systemimager/$image.master ###
open (MASTER_SCRIPT, ">$master_script") || die "Can't open $master_script for writing\n";

# add standard header stuff
print MASTER_SCRIPT << 'EOF';
#!/bin/sh

#
# "SystemImager" - Copyright (C) 1999-2000 Brian Elliott Finley <brian@valinux.com>
#

PATH=/sbin:/bin:/usr/bin:/usr/sbin:/tmp1

# Check to be sure this not run from a working machine
mount | grep [hs]d[a-z][1-9] > /dev/null
[ $? -eq 0 ] &&  echo Sorry.  Must not run on a working machine... && exit 1

# Partition the disk (see the sfdisk man page for customization details)
#
# Below is an example of how to customize a disk.  This can be useful if your clients
# have disks of differing sizes or geometries.  Here is a description of the sfdisk
# command presented in the example below:
#
# line 1 -- the sfdisk command and arguments (-uM means "units are MB)
# line 2 -- this is a comment
# line 3 -- start at the beginning of the disk 0, give 22M /dev/sda1 (/boot)
# line 4 -- start where the last partition left off, and add 512M /dev/sda2 for swap, partition type 82
# line 5 -- start where the last partition left off, and add 6000M /dev/sda3 (/)
# line 6 -- start where the last partition left off, and give the remaining space to /dev/sda4 (/var)
# line 7 -- the EOF statement indicating to sfdisk that we are finished giving it commands
#
# <<<< BEGIN EXAMPLE >>>>
#sfdisk -uM /dev/sda <<EOF
## partition    start_of_partition      size_in_megabytes       partition_type
#  /dev/sda1 :  start= 0,          	size= 22,               Id=83
#  /dev/sda2 :  start= ,                size= 512,              Id=82
#  /dev/sda3 :  start= ,                size= 6000,             Id=83
#  /dev/sda4 :  start= ,                size= ,                 Id=83
#EOF
# <<<< END EXAMPLE >>>>
#
EOF


### BEGIN get list of disks to partition ###
# get list of hardware RAID devices
$partition_dir="/etc/partitionschemes/rd";
if(-d "$imagedir$partition_dir") {
    opendir(PARTITIONSCHEMES, "$imagedir$partition_dir") || die "Can't read the $imagedir$partition_dir directory";
        # Skip anything that begins with a "."
        push(my @hardware_raid_disks, grep( !/^\..*/, readdir(PARTITIONSCHEMES) ) );

        # add the rd/ bit to each device
        for (@hardware_raid_disks) {
          $_ =~ s/^/rd\//;
          push(@disks);
        }
    close(PARTITIONSCHEMES);
}

# get list of IDE and SCSI devices
$partition_dir="/etc/partitionschemes";
if(-d "$imagedir$partition_dir") {
    opendir(PARTITIONSCHEMES, "$imagedir$partition_dir") || die "Can't read the $imagedir$partition_dir directory";
        # Skip anything that begins with a "." or an "rd"
        push(@disks, grep( !/^rd$/, grep( !/^\..*/, readdir(PARTITIONSCHEMES) ) ) );
    close(PARTITIONSCHEMES);
}
### END get list of disks to partition ###


# Foreach disk, gather up the partition info for that disk and prepare an sfdisk command
foreach $disk (@disks)  {

    ### BEGIN partitioning output ###
    $sfdisk_command_part_one = "sfdisk -uS /dev/$disk <<EOF\n";
    $sfdisk_command_part_two = "";

    # gather up partition information
    open (PARTITIONS, "<$imagedir/etc/partitionschemes/${disk}") || die "Cannot open $imagedir/etc/partitionschemes/$disk for reading\n";
        @partitions = <PARTITIONS>;
    close(PARTITIONS);

    for (@partitions) {
        if(/^\/dev/) {
            # get rid of newline
            chomp;

            # get rid of an asterisk that may be indicating a boot partition (Linux doesn't need this)
            $_ =~ s/\*//g;

            # split on space(s) and assign values to variables
            (my $dev, my $start, my $end, my $sectors, my $id) = split(/ +/);

            # gather up swap partitions
            if($id eq "82") { push(@swaps, $dev); }

            # gather up ext2 partitions
            if($id eq "83") { push(@ext2s, $dev); }

            # continue compiling sfdisk command
            $sfdisk_command_part_one = $sfdisk_command_part_one . "$dev : start= $start, size= $sectors, Id=$id\n";
        }
    }

    $sfdisk_command = $sfdisk_command_part_one . $sfdisk_command_part_two . "EOF\n";
    ### END partitioning output ###

    # output disk partition section
    print MASTER_SCRIPT "\n# partition $disk\n";
    print MASTER_SCRIPT $sfdisk_command;

    # output swap creation section (sort order doesn't matter here)
    (@swaps) && print MASTER_SCRIPT "\n# create swap space(s) on $disk -- do a \"man mkswap\" for more info\n";
    foreach $swapdev (@swaps) {
        print MASTER_SCRIPT "mkswap -v1 $swapdev\n";
    }

    # output ext2 creation section (sort order doesn't matter here)
    (@ext2s) && print MASTER_SCRIPT "\n# create ext2 filesystem(s) on $disk -- do a \"man mke2fs\" for more info\n";
    foreach $ext2dev (@ext2s) {
        my $block_size = "4096";
        my $inodes_per_block = "16384";
        my $min_free = "1";
        print MASTER_SCRIPT "mke2fs -b $block_size -i $inodes_per_block -m $min_free $ext2dev\n";
    }
}


# initialize and void %fstab hash
%fstab = ();

# gather up mount point creation information
open (FSTAB, "<$imagedir/etc/fstab") || die "Failed to open $imagedir/etc/fstab for reading\n";
while (<FSTAB>) {
    # Skip the line if it starts with a '#' or does not contain 'ext2'
    if (m@(^\s*\#)|(/dev/fd)@ || (! (/\s+ext2\s+/))) {
        next;
    }
    # Pull out the device file ($1) and the mount point ($2).
    # mount point is key so we can easily sort for the mkdir section
    if (/^\s*(\S+)\s+(\S+)\s/)  {
	$fstab{$2} = $1;
    }
}
close FSTAB;

# these must be in proper order, so we'll employ sort()
print MASTER_SCRIPT "\n# mount the freshly formatted partitions\n";
foreach $dir (sort keys %fstab) {
    # pre-pend /a to the target directory and
    # in case directory doesn't already have one, add a trailing slash
    # (We could easily test to see if it does, but we've got to normalize multiple
    #  slashes into one down below anyway...  Same number of functions to execute.)
    my $target_dir = qq(/a$dir/);

    # turn multiple slashes "///" into a single slash "/"
    $target_dir =~ s/\/+/\//g;
    print MASTER_SCRIPT qq(mkdir -p $target_dir\n);
    print MASTER_SCRIPT qq(mount $fstab{$dir} $target_dir\n);
}

print MASTER_SCRIPT "\n# get imageserver, hostname, and other info by sourcing dhcp info file\n";
print MASTER_SCRIPT ". /etc/dhcpc/dhcpcd-eth0.info\n";

print MASTER_SCRIPT "\n# filler up!\n";
print MASTER_SCRIPT "rsync -av \$DHCPSIADDR::$image /a/\n\n";


print MASTER_SCRIPT << 'EOF';
# set host specific information
echo NETWORKING=yes > /a/etc/sysconfig/network
echo FORWARD_IPV4=false >> /a/etc/sysconfig/network

EOF


if($nisdomainname ne "") { 
    print MASTER_SCRIPT "# set NIS domainname and imply that we want to be an NIS client\n";
    print MASTER_SCRIPT "echo NISDOMAIN=$nisdomainname >> /a/etc/sysconfig/network\n\n";
}


if($ip_assignment_method eq "static") { print MASTER_SCRIPT << 'EOF';
# Stuff for static IP addressing
#
# /etc/sysconfig/network
echo HOSTNAME=$HOSTNAME >> /a/etc/sysconfig/network
echo DOMAINNAME=$DOMAIN >> /a/etc/sysconfig/network
echo GATEWAY=$GATEWAY >> /a/etc/sysconfig/network
echo GATEWAYDEV=eth0 >> /a/etc/sysconfig/network
#
# /etc/sysconfig/network-scripts/ifcfg-eth0
echo DEVICE=eth0 > /a/etc/sysconfig/network-scripts/ifcfg-eth0
echo IPADDR=$IPADDR >> /a/etc/sysconfig/network-scripts/ifcfg-eth0
echo NETWORK=$NETWORK >> /a/etc/sysconfig/network-scripts/ifcfg-eth0
echo NETMASK=$NETMASK >> /a/etc/sysconfig/network-scripts/ifcfg-eth0
echo BROADCAST=$BROADCAST >> /a/etc/sysconfig/network-scripts/ifcfg-eth0
echo ONBOOT=yes >> /a/etc/sysconfig/network-scripts/ifcfg-eth0
echo BOOTPROTO=none >> /a/etc/sysconfig/network-scripts/ifcfg-eth0

EOF

} elsif($ip_assignment_method eq "static_dhcp") { print MASTER_SCRIPT << 'EOF';
# Stuff for IP addressing with static DHCP.  Once makedhcpstatic is run,
# hostnames will be assigned by the dhcp server.  Until then, you will
# see "(none)" as the hostname.
#
# /etc/sysconfig/network
echo DEVICE=eth0 > /a/etc/sysconfig/network-scripts/ifcfg-eth0
echo ONBOOT=yes >> /a/etc/sysconfig/network-scripts/ifcfg-eth0
echo BOOTPROTO=dhcp >> /a/etc/sysconfig/network-scripts/ifcfg-eth0

EOF

} else { print MASTER_SCRIPT << 'EOF';
# Stuff for IP addressing via DHCP
#
# /etc/sysconfig/network
echo HOSTNAME=$HOSTNAME >> /a/etc/sysconfig/network
echo DEVICE=eth0 > /a/etc/sysconfig/network-scripts/ifcfg-eth0
echo ONBOOT=yes >> /a/etc/sysconfig/network-scripts/ifcfg-eth0
echo BOOTPROTO=dhcp >> /a/etc/sysconfig/network-scripts/ifcfg-eth0

EOF

}


print MASTER_SCRIPT << 'EOF';
# run lilo
# (no, we can not just do a lilo -r "/a/".
# we need to use the lilo that came with the distribution in case
# it has special modifications such as support for hardware or software RAID)
chroot /a/ /sbin/lilo

EOF


print MASTER_SCRIPT "# unmount the freshly filled filesystems\n";
foreach $dir (reverse sort keys %fstab) {
    print MASTER_SCRIPT "umount /a$dir\n";
}

print MASTER_SCRIPT << 'EOF';

# take the system down so it is safe to power off/reboot
# and so it will not respond to pings
shutdown -h now

EOF

close(MASTER_SCRIPT);
### END create a fresh /tftpboot/systemimager/$image.master ###

# prompt to run makedhcpstatic after autoinstalling clients if using static_dhcp
if((!$quiet) and ($ip_assignment_method eq "static_dhcp")) {
    system("clear");
    print << 'EOF';
Static DHCP Instructions
------------------------

You have chosen to use "Static DHCP" for your IP addressing.  Be sure to
run "makedhcpstatic" after autoinstalling your client systems.  You will
need to autoinstall your client systems in the order that you want them
to be assigned their IP addresses.  When you run "makedhcpstatic", it 
will re-write the DHCP server configuration file to permanently assign
to each client the same IP address that client received during it's 
autoinstall process.

EOF

    # and then give 'em a chance to read the message
    print "\nPress <Enter> to continue...";
    <STDIN>;
    system("clear");
}

# prompt to run "addclients"
if (!$quiet) {
    print "Would you like to add your client information now? ([y]/n): ";
    $continue = get_response('y');
    ($continue ne "n") or exit 0;
    exec("addclients");
}
