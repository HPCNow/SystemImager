#!/bin/sh
 
#
# "VA SystemImager" - Copyright (C) 1999-2000 Brian Elliott Finley <brian@valinux.com> 
#
# This file: prepareclient
#            (prepareclient is used to, well, prepare a client to have it's
#             image retrieved by an imageserver)
#

# set version
version_number="1.3.0"

# configuration directory
systemimagerdir="/etc/systemimager"

# set path
PATH=/bin:/usr/bin:/sbin:/usr/sbin

 
### BEGIN functions
#  (jump to ### END functions to see start of code)
#!/bin/sh
#
# functions	This file contains functions to be used by most or all
#		shell scripts in the /etc/init.d directory.
#
# Version:	@(#) /etc/init.d/functions 1.01 26-Oct-1993
#
# Author:	Miquel van Smoorenburg, <miquels@drinkel.nl.mugnet.org>
# Hacked by:    Greg Galloway and Marc Ewing
#
# Mercilessly hacked by: "Brian Finley" <brian@thefinleys.com> 1999.09.18
#                   for: VA SystemImager
#

# First set up a default search path.
export PATH="/sbin:/usr/sbin:/bin:/usr/bin:/usr/X11R6/bin"


[ -z "$COLUMNS" ] && COLUMNS=80

# Read in our configuration
if [ -z "$BOOTUP" ]; then
  if [ -f /etc/sysconfig/init ]; then
      . /etc/sysconfig/init
  else
    # This all seem confusing? Look in /etc/sysconfig/init,
    # or in /usr/doc/initscripts-*/sysconfig.txt
    BOOTUP=color
    RES_COL=60
    MOVE_TO_COL="echo -en \\033[300C\\033[$[${COLUMNS}-${RES_COL}]D"
    SETCOLOR_SUCCESS="echo -en \\033[0;39m"
    SETCOLOR_FAILURE="echo -en \\033[0;39m"
    SETCOLOR_WARNING="echo -en \\033[0;39m"
    SETCOLOR_NORMAL="echo -en \\033[0;39m"
    LOGLEVEL=1
  fi
fi

if [ "$BOOTUP" != "verbose" ]; then
   INITLOG_ARGS="-q"
else
   INITLOG_ARGS=
fi

# A function to start a program.
daemon() {
	# Test syntax.
	gotbase=
	case $1 in
	    '')    echo '$0: Usage: daemon [+/-nicelevel] {program}'
	           return 1;;
	    --check)
	           shift
		   base=$1
		   gotbase="yes"
		   shift
		   nicelevel=0
		   ;;
	          
	    -*|+*) nicelevel=$1
	           shift;;
	     *)    nicelevel=0;;
	esac

        # Save basename.
        [ -z $gotbase ] && base=`basename $1`

        # See if it's already running.
	pid=`pidofproc $base`
	[ -n "$pid" ] && ps h $pid >/dev/null 2>&1 && return

	# make sure it doesn't core dump anywhere; while this could mask
	# problems with the daemon, it also closes some security problems
	ulimit -c 0
	
	# Echo daemon
        [ "$BOOTUP" = "verbose" ] && echo -n " $base"

	# And start it up.
	nice -n $nicelevel initlog $INITLOG_ARGS -c "$*" && success "$base startup" || failure "$base startup"
}

# A function to stop a program.
killproc() {
	# Test syntax.
	if [ $# = 0 ]; then
		echo "Usage: killproc {program} [signal]"
		return 1
	fi

	notset=0
	# check for second arg to be kill level
	if [ "$2" != "" ] ; then
		killlevel=$2
	else
		notset=1
		killlevel="-9"
	fi

        # Save basename.
        base=`basename $1`

        # Find pid.
        pid=`pidofproc $base`

        # Kill it.
        if [ "$pid" != "" ] ; then
                [ $BOOTUP = "verbose" ] && echo -n "$base "
		if [ "$notset" = "1" ] ; then
		       if ps h $pid>/dev/null 2>&1; then
			   # TERM first, then KILL if not dead
			   kill -TERM $pid
			   usleep 100000
			   if ps h $pid >/dev/null 2>&1 ; then
				sleep 1
				if ps h $pid >/dev/null 2>&1 ; then
				        sleep 3
					if ps h $pid >/dev/null 2>&1 ; then
					   kill -KILL $pid
					fi
				fi
			   fi
		        fi
			ps h $pid >/dev/null 2>&1 && failure "$base shutdown" || success "$base shutdown"
		# use specified level only
		else
		        if ps h $pid >/dev/null 2>&1; then
	                	kill $killlevel $pid && success "$base $killlevel" || failure "$base $killlevel"
			fi
		fi
	else
	    failure "$base shutdown"
	fi

        # Remove pid file if any.
	if [ "$notset" = "1" ]; then
            rm -f /var/run/$base.pid
	fi
}

# A function to find the pid of a program.
pidofproc() {
	# Test syntax.
	if [ $# = 0 ] ; then
		echo "Usage: pidofproc {program}"
		return 1
	fi

	# First try "/var/run/*.pid" files
	if [ -f /var/run/$1.pid ] ; then
	        pid=`head -1 /var/run/$1.pid`
	        if [ "$pid" != "" ] ; then
	                echo $pid
	                return 0
	        fi
	fi

	# Next try "pidof"
	pid=`pidof $1`
	if [ "$pid" != "" ] ; then
	        echo $pid
	        return 0
	fi

	# Finally try to extract it from ps
	ps ax | awk 'BEGIN { prog=ARGV[1]; ARGC=1 } 
			   { if ((prog == $5) || (("(" prog ")") == $5) ||
			     (("[" prog "]") == $5) ||
			   ((prog ":") == $5)) { print $1 ; exit 0 } }' $1
}

status() {
	# Test syntax.
	if [ $# = 0 ] ; then
		echo "Usage: status {program}"
		return 1
	fi

	# First try "pidof"
	pid=`pidof $1`
	if [ "$pid" != "" ] ; then
	        echo "$1 (pid $pid) is running..."
	        return 0
        else
                pid=`ps ax | awk 'BEGIN { prog=ARGV[1]; ARGC=1 } 
			   { if ((prog == $5) || (("(" prog ")") == $5) ||
			     (("[" prog "]") == $5) ||
			   ((prog ":") == $5)) { print $1 ; exit 0 } }' $1`
                if [ "$pid" != "" ] ; then
                        echo "$1 (pid $pid) is running..."
                        return 0
                fi
	fi

	# Next try "/var/run/*.pid" files
	if [ -f /var/run/$1.pid ] ; then
	        pid=`head -1 /var/run/$1.pid`
	        if [ "$pid" != "" ] ; then
	                echo "$1 dead but pid file exists"
	                return 1
	        fi
	fi
	# See if /var/lock/subsys/$1 exists
	if [ -f /var/lock/subsys/$1 ]; then
		echo "$1 dead but subsys locked"
		return 2
	fi
	echo "$1 is stopped"
	return 3
}

echo_success() {
  [ "$BOOTUP" = "color" ] && $MOVE_TO_COL
  echo -n "[  "
  [ "$BOOTUP" = "color" ] && $SETCOLOR_SUCCESS
  echo -n "OK"
  [ "$BOOTUP" = "color" ] && $SETCOLOR_NORMAL
  echo -n "  ]"
  return 0
}

echo_failure() {
  [ "$BOOTUP" = "color" ] && $MOVE_TO_COL
  echo -n "["
  [ "$BOOTUP" = "color" ] && $SETCOLOR_FAILURE
  echo -n "FAILED"
  [ "$BOOTUP" = "color" ] && $SETCOLOR_NORMAL
  echo -n "]"
  return 1
}

echo_passed() {
  [ "$BOOTUP" = "color" ] && $MOVE_TO_COL
  echo -n "["
  [ "$BOOTUP" = "color" ] && $SETCOLOR_WARNING
  echo -n "PASSED"
  [ "$BOOTUP" = "color" ] && $SETCOLOR_NORMAL
  echo -n "]"
  return 1
}

# Log that something succeeded
success() {
  if [ -z "$IN_INITLOG" ]; then
     initlog -n $0 -s "$1" -e 1
  else
     echo "-n $0 -s \"$1\" -e 1" >&21
  fi
  [ "$BOOTUP" != "verbose" ] && echo_success
  return 0
}

# Log that something failed
failure() {
  rc=$?
  if [ -z "$IN_INITLOG" ]; then
     initlog -n $0 -s "$1" -e 2
  else
     echo "-n $0 -s \"$1\" -e 2" >&21
  fi
  [ "$BOOTUP" != "verbose" ] && echo_failure
  return $rc
}

# Log that something passed, but may have had errors. Useful for fsck
passed() {
  rc=$?
  if [ -z "$IN_INITLOG" ]; then
     initlog -n $0 -s "$1" -e 1
  else
     echo "-n $0 -s \"$1\" -e 1" >&21
  fi
  [ "$BOOTUP" != "verbose" ] && echo_passed
  return $rc
}  

# Run some action. Log its output.
action() {
  STRING=$1
  echo -n "$STRING "
  shift
  initlog $INITLOG_ARGS -c "$*" && success "$STRING" || failure "$STRING"
  rc=$?
  echo
  return $rc
}

# Confirm whether we really want to run this service
confirm() {
  echo -n "Start service $1 (Y)es/(N)o/(C)ontinue? [Y] "
  read answer
  case $answer in
    y|Y|"")
      return 0
    ;;
    c|C)
      return 2
    ;;
    n|N)
      return 1
    ;;
    *)
      confirm $1
      return $?
    ;;
    esac
}
############################################################################################

# VA SystemImager specific functions
create_rsyncd_conf() {
  echo '#'                                                      > $rsyncd_conf_file
  echo '# Copyright (C) 1999-2000 Brian Elliott Finley <brian@valinux.com>'    >> $rsyncd_conf_file
  echo '#'                                                      >> $rsyncd_conf_file
  echo '# This file: /tmp/rsyncd.conf'                          >> $rsyncd_conf_file
  echo '#'                                                      >> $rsyncd_conf_file
  echo ''                                                       >> $rsyncd_conf_file
  echo 'list = yes'                                             >> $rsyncd_conf_file
  echo 'timeout = 600'                                          >> $rsyncd_conf_file
  echo 'dont compress = *.gz *.tgz *.zip *.Z *.ZIP *.bz2 *.deb *.rpm *.dbf'  >> $rsyncd_conf_file
  echo 'uid = root'                                             >> $rsyncd_conf_file
  echo 'gid = root'                                             >> $rsyncd_conf_file
  echo ''                                                       >> $rsyncd_conf_file
  echo '[root]'                                                 >> $rsyncd_conf_file
  echo '    path = /'                                           >> $rsyncd_conf_file
  echo ''                                                       >> $rsyncd_conf_file
}

show_version() {
  echo "prepareclient (part of VA SystemImager) version $version_number"
  echo ""
  echo "Copyright (C) 1999-2000 Brian Elliott Finley <brian@valinux.com>"
  echo "This is free software; see the source for copying conditions.  There is NO"
  echo "warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE."
}

show_usage() {
  show_version
  echo ''
  echo 'Usage: prepareclient [OPTION]'
  echo ''
  echo 'Options: (only one option is taken)'
  echo ' -version                 Display version and copyright information.'
  echo ' -h, -help                Display this output.'
  echo ' -n, -no-rsyncd           Do not start the rsync daemon.'
  echo ' -q, -quiet               Run silently.  Return an exit status of 0 for'
  echo '                          success or a non-zero exit status for failure.'
  echo ' -r, -rpm-install         This is only used when building an RPM.'
  echo ''
  echo 'Download from http://systemimager.org/'
  echo 'Report bugs or suggestions to <systemimager-bugs@systemimager.org>'
}

### END functions
 

 
# default is an interactive install (nothing goes over the network any more)
QUIET="false"
HELP="false"
NO_RSYNCD="false"
SHOW_VERSION="false"

# if two or more options are given, die and show usage
if [ "x$2" != "x" ]; then
   show_usage
   exit 1
fi

# if only one option is given, verify it as a proper one
if [ "x$1" != "x" ]; then
   case $1 in
        -r | -rpm-install | --rpm-install          ) QUIET="true" ;;
        -q | -quiet | --quiet                      ) QUIET="true" ;;
        -h | -help | --help                        ) HELP="true" ;;
        -n | -no-rsyncd | --no-rsyncd              ) NO_RSYNCD="true" ;;
        -version | --version                       ) SHOW_VERSION="true" ;;
        *                                          ) show_usage && exit 1 ;;
   esac
fi

# show version if requested
if [ "$SHOW_VERSION" = "true" ]; then
    show_version
    exit 1
fi

# give help if requested
if [ "$HELP" = "true" ]; then
    show_usage
    exit 1
fi

# if not run as root, install will surely fail
[ "$QUIET" = "false" ] && [ `whoami` != "root" ] && echo "Must be run as root!" && exit 1
[ "$QUIET" = "true" ] && [ `whoami` != "root" ] && exit 1

 
# do introduction
if [ "$QUIET" = "false" ]; then
 clear
 cat << "EOF"
Welcome to the VA SystemImager prepareclient command.  This command
may modify the following files to prepare your client for having it's
image retrieved by the imageserver.  It will also create the 
/etc/systemimager directory and fill it with information about your 
master client, such as the disk partitioning scheme(s). 
 
 /etc/services    -- add rsync line if necessary
 /etc/inetd.conf  -- comment out rsync line if necessary
                     (rsync will run as a daemon until shutdown)
 /tmp/rsyncd.conf -- create a temporary rsyncd.conf file with a
                     [root] entry in it.
 
All modified files will be backed up with the .beforesystemimager 
extension.

EOF

 # you sure you want to install?
 echo -n "Prepare client for VA SystemImager? (y/[n]): "
 read REPLY
 case $REPLY in
  y|Y|Yes|yes|YES ) echo Ok.  Preparing client for VA SystemImager... ;;
  * ) echo Client preparation cancelled.  No files modified. && exit 1 ;;
 esac
 echo
 sleep 2
fi

# verify that rsync entry is in /etc/services
egrep -q ^rsync /etc/services
if [ $? != "0" ]; then
  if [ ! -f /etc/services.beforesystemimager ]; then
    [ "$QUIET" = "false" ] && echo "Backing up /etc/services to /etc/services.beforesystemimager ..."
    cp /etc/services /etc/services.beforesystemimager
  fi
  echo "rsync           873/tcp                         # rsync" >> /etc/services
  echo "rsync           873/udp                         # rsync" >> /etc/services
fi 

# comment out rsync entry in inetd.conf if it exists
RESTART_INETD="false"
egrep -q ^rsync /etc/inetd.conf > /dev/null 2>&1
if [ $? = "0" ]; then
  if [ ! -f /etc/inetd.conf.beforesystemimager ]; then
    [ "$QUIET" = "false" ] && echo "Backing up /etc/inetd.conf to /etc/inetd.conf.beforesystemimager ..."
    cp /etc/inetd.conf /etc/inetd.conf.beforesystemimager
  fi
  sed 's/^rsync/#rsync/' /etc/inetd.conf > /tmp/.systemimager
  cp /tmp/.systemimager /etc/inetd.conf
  rm /tmp/.systemimager
  RESTART_INETD="true"
fi 
# comment out rsync entry in inetd.conf if it exists


# location of rsyncd.conf file
rsyncd_conf_file="/tmp/rsyncd.conf"

# install SystemImager brand rsyncd.conf file ($rsyncd_conf_file)
[ "$QUIET" = "false" ] && [ "$NO_RSYNCD" = "false" ] && echo "Creating $rsyncd_conf_file ..."
[ "$NO_RSYNCD" = "false" ] && create_rsyncd_conf
# install SystemImager brand rsyncd.conf file


# signal inetd to re-read /etc/inetd.conf
if [ "$RESTART_INETD" = "true" ]; then
    if [ "$QUIET" = "false" ]; then
      echo -n "Signalling inetd to re-read /etc/inetd.conf: "
      killproc inetd -HUP
      echo
    else
      killall -HUP inetd
    fi
fi
# signal inetd to re-read /etc/inetd.conf

# test for hostname in hosts file -- this is necessary for rsyncd to run
HOSTNAME=`uname -n`
egrep -q $HOSTNAME /etc/hosts
if [ "$?" != "0" ]; then
   echo
   echo "******************************* WARNING *******************************"
   echo "This hosts name: \"$HOSTNAME\" must appear in the /etc/hosts file in"
   echo "order for me to crank up the rsyncd daemon.  rsync doesn't seem to be"
   echo "particular about the hostname being associated with an appropriate IP"
   echo "address, it just wants to see the hostname in there somewhere..."
   echo
   echo "Please add \"$HOSTNAME\" with the proper IP address to the /etc/hosts file"
   echo "and run \"prepareclient\" again."
   echo
   echo "-The Mgmt."
   echo "******************************* WARNING *******************************"
   echo
   exit 1
fi

# restart rsync as a daemon
killall rsync rsyncd > /dev/null 2>&1
[ "$QUIET" = "false" ] && [ "$NO_RSYNCD" = "false" ] && echo -n Starting or re-starting rsync as a daemon
for i in 1 2 3 4 5; do 
    [ "$QUIET" = "false" ] && [ "$NO_RSYNCD" = "false" ] && echo -n .
    [ "$NO_RSYNCD" = "false" ] && sleep 1s
done
[ "$QUIET" = "false" ] && [ "$NO_RSYNCD" = "false" ] && echo done!
[ "$NO_RSYNCD" = "false" ] && rsync --daemon --config=$rsyncd_conf_file
# restart rsync as a daemon


### BEGIN get list of IDE and SCSI disks ###
ide_and_scsi_disks=`

# extract SCSI and IDE disk device partitions
egrep [hs]d[a-z][0-9] /proc/partitions | awk '{print $4}' | \

# strip out partition numbers
sed -e 's/[0-9]//g' | \

# show each unique device only once
sort -u
`
### END get list of IDE and SCSI disks ###


### BEGIN get list of hardware RAID "disks" ###
hardware_raid_disks=`

# extract hardware RAID disk device partitions
egrep c[0-9]+d[0-9]+p /proc/partitions | awk '{print $4}' | \

# strip out partition numbers
sed -e 's/p[0-9][0-9]*//' | \

# show each unique device only once
sort -u
`
### END get list of hardware RAID "disks" ###


### BEGIN leave disk info behind for "getimage" script ###
# clean up after last "prepare"
rm -fr $systemimagerdir/partitionschemes/

# create receiving directory for SCSI and IDE disk info
[ "x$ide_and_scsi_disks" != "x" ] && mkdir -p $systemimagerdir/partitionschemes

# create receiving directory for Hardware RAID disk info
[ "x$hardware_raid_disks" != "x" ] && mkdir -p $systemimagerdir/partitionschemes/rd

# get sfdisk to report IDE and SCSI disk partition info
for disk in $ide_and_scsi_disks
do
 # Specify sectors explicitly -- this format may be used in the future
 # for partitioning with MB.
 sfdisk -l -uM /dev/$disk > $systemimagerdir/partitionschemes/$disk
done

# get sfdisk to report Hardware RAID disk info
for disk in $hardware_raid_disks
do
 # must do some funkification for sfdisk to report properly
 ln -s /dev/$disk /dev/$disk"p"

 # Specify sectors explicitly -- this format may be used in the future
 # for partitioning with MB.
 sfdisk -l -uM /dev/$disk"p" > $systemimagerdir/partitionschemes/$disk

 # get rid of the funkification
 rm -f /dev/$disk"p"
done
### END leave disk info behind for the getimage command ###

### BEGIN leave ext3 info behind for the autoinstall client ###
grep -qw ext3 /etc/fstab
if [ $? -eq 0 ]; then

  # what file are we working with?
  file="/etc/fstab"

  # let's start fresh, shall we?
  rm -f $systemimagerdir/put_new_ext3_journal_file_inodes_in_fstab.sh

  # get listing of ext3 mountpoints
  directories=`grep -v ^# $file | egrep -w ext3 | awk '{print $2}'`
  
  # create script to be run at the end of the autoinstall
  for directory in $directories; do

    # get current inode so we can find the file
    inode=`grep -v ^[[:blank:]]*# $file | grep -w $directory | awk '{print $4}' | sed 's/journal=//'`

    # get filename by looking it up by it's inode
    journalfile=`find $directory -inum $inode -print`

    # escape the slashes in the directory name for later sed commands
    echo $directory | sed 's/\//\\\//g' > /tmp/escaped_directory.$$
    escaped_directory=`cat /tmp/escaped_directory.$$`
    rm -f /tmp/escaped_directory.$$

    # create script to find new inodes on each freshly installed client
    echo "# set the immutable bit so that file doesn't float up into the filesystem buffer cache" \
          >> $systemimagerdir/put_new_ext3_journal_file_inodes_in_fstab.sh
    echo "chattr +i $journalfile" \
          >> $systemimagerdir/put_new_ext3_journal_file_inodes_in_fstab.sh
    echo \
          >> $systemimagerdir/put_new_ext3_journal_file_inodes_in_fstab.sh
    echo "# find the new inode number" \
          >> $systemimagerdir/put_new_ext3_journal_file_inodes_in_fstab.sh
    echo "newinode=\`ls -i $journalfile | awk '{print \$1}'\`" \
          >> $systemimagerdir/put_new_ext3_journal_file_inodes_in_fstab.sh
    echo \
          >> $systemimagerdir/put_new_ext3_journal_file_inodes_in_fstab.sh
    echo "# put the new inode number into the fstab file" \
          >> $systemimagerdir/put_new_ext3_journal_file_inodes_in_fstab.sh
    echo "sed \"/[[:blank:]]$escaped_directory[[:blank:]]/s/journal=[0-9]*/journal=\$newinode/\" /etc/fstab > /tmp/fstab.\$\$" \
          >> $systemimagerdir/put_new_ext3_journal_file_inodes_in_fstab.sh
    echo "cat /tmp/fstab.\$\$ > /etc/fstab" \
          >> $systemimagerdir/put_new_ext3_journal_file_inodes_in_fstab.sh
    echo "" \
          >> $systemimagerdir/put_new_ext3_journal_file_inodes_in_fstab.sh
  done
  
  # remove kruft
  echo "# remove kruft" \
        >> $systemimagerdir/put_new_ext3_journal_file_inodes_in_fstab.sh
  echo "rm -f /tmp/fstab.\$\$" \
        >> $systemimagerdir/put_new_ext3_journal_file_inodes_in_fstab.sh
fi
### END leave ext3 info behind for the autoinstall client ###

# wrap up
if [ "$QUIET" = "false" ] && [ "$NO_RSYNCD" = "false" ]; then
 echo
 echo "This client is ready to have it's image retrieved."
 echo "You must now run the \"getimage\" command on the imageserver."
fi

if [ "$QUIET" = "false" ] && [ "$NO_RSYNCD" = "true" ]; then
 echo
 echo "The rsync daemon was not started.  If this is an image on an"
 echo "imageserver, you can now update your master autoinstall script"
 echo "by running getimage with the -s option."
 echo
 echo "If this is a master client, you must run prepareclient again,"
 echo "without the -n option, before you can pull it's image to an"
 echo "imageserver."
 echo
fi
exit 0
